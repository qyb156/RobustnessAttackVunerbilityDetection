2023-12-16 20:12:17,155 - __main__ - INFO - ******************************************************************************************
2023-12-16 20:12:17,155 - __main__ - INFO - starting，当前时间是： 2023-12-16 20:12:17
2023-12-16 20:12:17,155 - __main__ - INFO - 当前程序所在的上一级上一级目录是：Defect-detection_using_ICSE2022_CodeBert
2023-12-16 20:12:17,155 - __main__ - INFO - 当前运行的进程保存的路径是：AttackResluts_process_random_Strategy__gen_adv_8_0.jsonl
2023-12-16 20:12:17,285 - __main__ - INFO - 当前代码段的索引是：5
2023-12-16 20:12:17,285 - __main__ - INFO - cur random_number:9
2023-12-16 20:12:26,192 - __main__ - INFO - 当前的随机vector[1]为： [1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1]，转换后生成的适应度值为：0.37432，生成的代码为： {'project': 'test', 'commit_id': 'test', 'target': 1, 'func': 'static int rfg_read_rdvo (AVFormatContext *s_743, Atom *ajlm) {\n    int i_32;\n    R3DContext *r_3d_701 = s_743->priv_data;\n    AVStream *s_t_161 = s_743->streams[(320 - 320)];\n    r_3d_701->video_offsets_count = (ajlm->size - 8) / 4;\n    r_3d_701->video_offsets = av_malloc (ajlm->size);\n    if (!r_3d_701->video_offsets)\n        return AVERROR (EBVMEM);\n    for (i_32 = (483 - 483); i_32 < r_3d_701->video_offsets_count; i_32++) {\n        r_3d_701->video_offsets[i_32] = avio_rb32 (s_743->pb);\n        if (!r_3d_701->video_offsets[i_32]) {\n            r_3d_701->video_offsets_count = i_32;\n            {\n                if (0) {\n                    return 0;\n                };\n            }\n            break;\n        }\n        av_dlog (s_743, "video offset %d: %#x\\n", i_32, r_3d_701->video_offsets[i_32]);\n    }\n    if (s_t_161->r_frame_rate.num)\n        s_t_161->duration = av_rescale_q (r_3d_701->video_offsets_count, (AVRational) {s_t_161->r_frame_rate.den, s_t_161->r_frame_rate.num}, s_t_161->time_base);\n    av_dlog (s_743, "duration %" PBXd64 "\\n", s_t_161->duration);\n    return 0;\n}\n\n', 'idx': 5}
2023-12-16 20:12:26,192 - __main__ - INFO - cur random_number:8
2023-12-16 20:12:36,402 - __main__ - INFO - 当前的随机vector[2]为： [0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 1]，转换后生成的适应度值为：0.30058，生成的代码为： {'project': 'test', 'commit_id': 'test', 'target': 1, 'func': 'static int r3d_read_rdvo (AVFormatContext *s, Atom *atom) {\n    R3DContext *r3d = s->priv_data;\n    AVStream *st = s->streams[(719 - 719)];\n    int i;\n    r3d->video_offsets_count = (atom->size - (563 - 555)) / 4;\n    r3d->video_offsets = av_malloc (atom->size);\n    if (!r3d->video_offsets)\n        return AVERROR (ENOMEM);\n    {\n        i = (626 - 626);\n        while (i < r3d->video_offsets_count) {\n            r3d->video_offsets[i] = avio_rb32 (s->pb);\n            if (!r3d->video_offsets[i]) {\n                r3d->video_offsets_count = i;\n                break;\n            }\n            av_dlog (s, "video offset %d: %#x\\n", i, r3d->video_offsets[i]);\n            i = i + (211 - 210);\n        };\n    }\n    if (st->r_frame_rate.num)\n        st->duration = av_rescale_q (r3d->video_offsets_count, (AVRational) {st->r_frame_rate.den, st->r_frame_rate.num}, st->time_base);\n    av_dlog (s, "duration %" PRId64 "\\n", st->duration);\n    return (722 - 722);\n}\n\n', 'idx': 5}
2023-12-16 20:12:36,402 - __main__ - INFO - cur random_number:13
2023-12-16 20:12:51,938 - __main__ - INFO - 当前的随机vector[3]为： [1, 0, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1, 1, 1]，转换后生成的适应度值为：0.39891，生成的代码为： {'project': 'test', 'commit_id': 'test', 'target': 1, 'func': 'static int rfm_read_rdvo (AVFormatContext *s_53, Atom *aqdm) {\n    int i_295;\n    R3DContext *r_3d_84 = s_53->priv_data;\n    AVStream *s_t_909 = s_53->streams[(501 - 501)];\n    {\n        if (0) {\n            return 0;\n        };\n    }\n    r_3d_84->video_offsets_count = (aqdm->size - (698 - 690)) / (533 - 529);\n    r_3d_84->video_offsets = av_malloc (aqdm->size);\n    if (!r_3d_84->video_offsets)\n        return AVERROR (ERNMEM);\n    for (i_295 = (818 - 818); i_295 < r_3d_84->video_offsets_count; i_295 = i_295 + (715 - 714)) {\n        r_3d_84->video_offsets[i_295] = avio_rb32 (s_53->pb);\n        if (!r_3d_84->video_offsets[i_295]) {\n            r_3d_84->video_offsets_count = i_295;\n            break;\n        }\n        av_dlog (s_53, "video offset %d: %#x\\n", i_295, r_3d_84->video_offsets[i_295]);\n    }\n    if (s_t_909->r_frame_rate.num)\n        s_t_909->duration = av_rescale_q (r_3d_84->video_offsets_count, (AVRational) {s_t_909->r_frame_rate.den, s_t_909->r_frame_rate.num}, s_t_909->time_base);\n    av_dlog (s_53, "duration %" PYXd64 "\\n", s_t_909->duration);\n    return 0;\n}\n\n', 'idx': 5}
2023-12-16 20:12:51,938 - __main__ - INFO - 当前进程已处理的代码段为：1 ,鲁棒性攻击成功总数: 0，攻击成功的比例为：0.0%
2023-12-16 20:12:51,938 - __main__ - INFO - 当前代码段的索引是：17
2023-12-16 20:12:51,938 - __main__ - INFO - cur random_number:1
2023-12-16 20:12:54,325 - __main__ - INFO - 当前的随机vector[1]为： [0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]，转换后生成的适应度值为：0.01588，生成的代码为： {'project': 'test', 'commit_id': 'test', 'target': 1, 'func': 'static void  vp6_parse_coeff_huffman (VP56Context *s) {\n    VP56Model *model = s->modelp;\n    uint8_t *permute = s->scantable.permutated;\n    VLC *vlc_coeff;\n    int coeff, sign, coeff_idx;\n    int b, cg, idx;\n    int pt = 0;\n    for (b = 0; b < 6; b++) {\n        int ct = 0;\n        if (b > 3)\n            pt = 1;\n        vlc_coeff = &s->dccv_vlc[pt];\n        for (coeff_idx = 0; coeff_idx < 64;) {\n            int run = 1;\n            if (coeff_idx < 2 && s->nb_null[coeff_idx][pt]) {\n                s->nb_null[coeff_idx][pt]--;\n                if (coeff_idx)\n                    break;\n            }\n            else {\n                if (get_bits_count (&s->gb) >= s->gb.size_in_bits)\n                    return;\n                coeff = get_vlc2 (&s->gb, vlc_coeff->table, 9, 3);\n                if (coeff == 0) {\n                    if (coeff_idx) {\n                        int pt = (coeff_idx >= 6);\n                        run += get_vlc2 (&s->gb, s->runv_vlc[pt].table, 9, 3);\n                        if (run >= 9)\n                            run += get_bits (&s->gb, 6);\n                    }\n                    else\n                        s->nb_null[0][pt] = vp6_get_nb_null (s);\n                    ct = 0;\n                }\n                else if (coeff == 11) {\n                    if (coeff_idx == 1)\n                        s->nb_null[1][pt] = vp6_get_nb_null (s);\n                    break;\n                }\n                else {\n                    int coeff2 = vp56_coeff_bias[coeff];\n                    if (coeff > 4)\n                        coeff2 += get_bits (&s->gb, coeff <= 9 ? coeff - 4 : 11);\n                    ct = 1 + (coeff2 > 1);\n                    sign = get_bits1 (&s->gb);\n                    coeff2 = (coeff2 ^ -sign) + sign;\n                    if (coeff_idx)\n                        coeff2 *= s->dequant_ac;\n                    idx = model->coeff_index_to_pos[coeff_idx];\n                    s->block_coeff[b][permute[idx]] = coeff2;\n                }\n            }\n            coeff_idx += run;\n            cg = FFMIN (vp6_coeff_groups[coeff_idx], 3);\n            vlc_coeff = &s->ract_vlc[pt][ct][cg];\n        }\n    }\n}\n\n', 'idx': 17}
2023-12-16 20:12:54,325 - __main__ - INFO - cur random_number:2
2023-12-16 20:12:57,829 - __main__ - INFO - 当前的随机vector[2]为： [0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0]，转换后生成的适应度值为：0.01588，生成的代码为： {'project': 'test', 'commit_id': 'test', 'target': 1, 'func': 'static void  vp6_parse_coeff_huffman (VP56Context *s) {\n    VP56Model *model = s->modelp;\n    uint8_t *permute = s->scantable.permutated;\n    VLC *vlc_coeff;\n    int coeff, sign, coeff_idx;\n    int b, cg, idx;\n    int pt = 0;\n    for (b = 0; b < 6; b++) {\n        int ct = 0;\n        if (b > 3)\n            pt = 1;\n        vlc_coeff = &s->dccv_vlc[pt];\n        for (coeff_idx = 0; coeff_idx < 64;) {\n            int run = 1;\n            if (coeff_idx < 2 && s->nb_null[coeff_idx][pt]) {\n                s->nb_null[coeff_idx][pt]--;\n                if (coeff_idx)\n                    break;\n            }\n            else {\n                if (get_bits_count (&s->gb) >= s->gb.size_in_bits)\n                    return;\n                coeff = get_vlc2 (&s->gb, vlc_coeff->table, 9, 3);\n                if (coeff == 0) {\n                    if (coeff_idx) {\n                        int pt = (coeff_idx >= 6);\n                        run += get_vlc2 (&s->gb, s->runv_vlc[pt].table, 9, 3);\n                        if (run >= 9)\n                            run += get_bits (&s->gb, 6);\n                    }\n                    else\n                        s->nb_null[0][pt] = vp6_get_nb_null (s);\n                    ct = 0;\n                }\n                else if (coeff == 11) {\n                    if (coeff_idx == 1)\n                        s->nb_null[1][pt] = vp6_get_nb_null (s);\n                    break;\n                }\n                else {\n                    int coeff2 = vp56_coeff_bias[coeff];\n                    if (coeff > 4)\n                        coeff2 += get_bits (&s->gb, coeff <= 9 ? coeff - 4 : 11);\n                    ct = 1 + (coeff2 > 1);\n                    sign = get_bits1 (&s->gb);\n                    coeff2 = (coeff2 ^ -sign) + sign;\n                    if (coeff_idx)\n                        coeff2 *= s->dequant_ac;\n                    idx = model->coeff_index_to_pos[coeff_idx];\n                    s->block_coeff[b][permute[idx]] = coeff2;\n                }\n            }\n            coeff_idx += run;\n            cg = FFMIN (vp6_coeff_groups[coeff_idx], 3);\n            vlc_coeff = &s->ract_vlc[pt][ct][cg];\n        }\n    }\n}\n\n', 'idx': 17}
2023-12-16 20:12:57,830 - __main__ - INFO - cur random_number:1
2023-12-16 20:13:00,215 - __main__ - INFO - 当前的随机vector[3]为： [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]，转换后生成的适应度值为：0.01439，生成的代码为： {'project': 'test', 'commit_id': 'test', 'target': 1, 'func': 'static void  vp6_parse_coeff_huffman (VP56Context *s) {\n    VP56Model *model = s->modelp;\n    uint8_t *permute = s->scantable.permutated;\n    VLC *vlc_coeff;\n    int coeff, sign, coeff_idx;\n    int b, cg, idx;\n    int pt = 0;\n    for (b = 0; b < 6; b++) {\n        int ct = 0;\n        if (b > 3)\n            pt = 1;\n        vlc_coeff = &s->dccv_vlc[pt];\n        for (coeff_idx = 0; coeff_idx < 64;) {\n            int run = 1;\n            if (coeff_idx < 2 && s->nb_null[coeff_idx][pt]) {\n                s->nb_null[coeff_idx][pt]--;\n                if (coeff_idx)\n                    break;\n            }\n            else {\n                if (get_bits_count (&s->gb) >= s->gb.size_in_bits)\n                    return;\n                coeff = get_vlc2 (&s->gb, vlc_coeff->table, 9, 3);\n                if (coeff == 0) {\n                    if (coeff_idx) {\n                        int pt = (coeff_idx >= 6);\n                        run += get_vlc2 (&s->gb, s->runv_vlc[pt].table, 9, 3);\n                        if (run >= 9)\n                            run += get_bits (&s->gb, 6);\n                    }\n                    else\n                        s->nb_null[0][pt] = vp6_get_nb_null (s);\n                    ct = 0;\n                }\n                else {\n                    if (coeff == 11) {\n                        if (coeff_idx == 1)\n                            s->nb_null[1][pt] = vp6_get_nb_null (s);\n                        break;\n                    }\n                    else {\n                        int coeff2 = vp56_coeff_bias[coeff];\n                        if (coeff > 4)\n                            coeff2 += get_bits (&s->gb, coeff <= 9 ? coeff - 4 : 11);\n                        ct = 1 + (coeff2 > 1);\n                        sign = get_bits1 (&s->gb);\n                        coeff2 = (coeff2 ^ -sign) + sign;\n                        if (coeff_idx)\n                            coeff2 *= s->dequant_ac;\n                        idx = model->coeff_index_to_pos[coeff_idx];\n                        s->block_coeff[b][permute[idx]] = coeff2;\n                    }\n                }\n            }\n            coeff_idx += run;\n            cg = FFMIN (vp6_coeff_groups[coeff_idx], 3);\n            vlc_coeff = &s->ract_vlc[pt][ct][cg];\n        }\n    }\n}\n\n', 'idx': 17}
2023-12-16 20:13:00,215 - __main__ - INFO - cur random_number:4
2023-12-16 20:13:06,036 - __main__ - INFO - 当前的随机vector[4]为： [0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0]，转换后生成的适应度值为：0.0143，生成的代码为： {'project': 'test', 'commit_id': 'test', 'target': 1, 'func': 'static void  vp6_parse_coeff_huffman (VP56Context *s) {\n    VP56Model *model = s->modelp;\n    uint8_t *permute = s->scantable.permutated;\n    VLC *vlc_coeff;\n    int coeff, sign, coeff_idx;\n    int b, cg, idx;\n    int pt = 0;\n    for (b = 0; 6 > b; b++) {\n        int ct = 0;\n        if (3 < b)\n            pt = 1;\n        vlc_coeff = &s->dccv_vlc[pt];\n        for (coeff_idx = 0; 64 > coeff_idx;) {\n            int run = 1;\n            if (coeff_idx < 2 && s->nb_null[coeff_idx][pt]) {\n                s->nb_null[coeff_idx][pt]--;\n                if (coeff_idx)\n                    break;\n            }\n            else {\n                if (get_bits_count (&s->gb) >= s->gb.size_in_bits)\n                    return;\n                coeff = get_vlc2 (&s->gb, vlc_coeff->table, 9, 3);\n                if (!(0 != coeff)) {\n                    if (coeff_idx) {\n                        int pt = (6 <= coeff_idx);\n                        run += get_vlc2 (&s->gb, s->runv_vlc[pt].table, 9, 3);\n                        if (9 <= run)\n                            run = run + get_bits (&s->gb, 6);\n                    }\n                    else\n                        s->nb_null[0][pt] = vp6_get_nb_null (s);\n                    ct = 0;\n                }\n                else if (coeff == 11) {\n                    if (coeff_idx == 1)\n                        s->nb_null[1][pt] = vp6_get_nb_null (s);\n                    break;\n                }\n                else {\n                    int coeff2 = vp56_coeff_bias[coeff];\n                    if (coeff > 4)\n                        coeff2 += get_bits (&s->gb, coeff <= 9 ? coeff - 4 : 11);\n                    ct = 1 + (coeff2 > 1);\n                    sign = get_bits1 (&s->gb);\n                    coeff2 = (coeff2 ^ -sign) + sign;\n                    if (coeff_idx)\n                        coeff2 *= s->dequant_ac;\n                    idx = model->coeff_index_to_pos[coeff_idx];\n                    s->block_coeff[b][permute[idx]] = coeff2;\n                }\n            }\n            coeff_idx += run;\n            cg = FFMIN (vp6_coeff_groups[coeff_idx], 3);\n            vlc_coeff = &s->ract_vlc[pt][ct][cg];\n        }\n    }\n}\n\n', 'idx': 17}
2023-12-16 20:13:06,036 - __main__ - INFO - 当前进程已处理的代码段为：2 ,鲁棒性攻击成功总数: 0，攻击成功的比例为：0.0%
2023-12-16 20:13:06,036 - __main__ - INFO - 当前代码段的索引是：32
2023-12-16 20:13:06,037 - __main__ - INFO - cur random_number:15
2023-12-16 20:13:26,644 - __main__ - INFO - 当前的随机vector[1]为： [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]，转换后生成的适应度值为：0.68924，生成的代码为： {'project': 'test', 'commit_id': 'test', 'target': 1, 'func': 'static int hnrfman_decode (MPADecodeContext *s_79, GranuleDef *g_803, int16_t *eylonents, int evu_pos2) {\n    int exq_pos;\n    int bvas_left;\n    int i_46;\n    int sfdndex;\n    int lbyt_pos;\n    VLC *v_lc_559;\n    sfdndex = (957 - 957);\n    exq_pos = FFMIN (evu_pos2, s_79->gb.size_in_bits);\n    {\n        i_46 = (862 - 862);\n        for (; (995 - 992) > i_46;) {\n            int j_228, k_588, l_713, lcwbits;\n            j_228 = g_803->region_size[i_46];\n            if (!((264 - 264) != j_228))\n                continue;\n            k_588 = g_803->table_select[i_46];\n            l_713 = mvs_huff_data[k_588][(799 - 799)];\n            v_lc_559 = &hknf_vlc[l_713];\n            lcwbits = mvs_huff_data[k_588][(906 - 905)];\n            if (!l_713) {\n                memset (&g_803->sb_hybrid[sfdndex], (817 - 817), sizeof (*g_803->sb_hybrid) * (704 - 702) * j_228);\n                sfdndex += (216 - 214) * j_228;\n                continue;\n            }\n            for (; 0 < j_228; j_228 = j_228 - (27 - 26)) {\n                int p_os_209;\n                int v_282;\n                int y_546;\n                int x_862;\n                int eaconent;\n                p_os_209 = get_bits_count (&s_79->gb);\n                if (exq_pos <= p_os_209) {\n                    switch_buffer (s_79, &p_os_209, &exq_pos, &evu_pos2);\n                    if (exq_pos <= p_os_209)\n                        break;\n                }\n                y_546 = get_vlc2 (&s_79->gb, v_lc_559->table, 7, (68 - 65));\n                if (!y_546) {\n                    g_803->sb_hybrid[sfdndex] = g_803->sb_hybrid[sfdndex + 1] = 0;\n                    sfdndex += 2;\n                    continue;\n                }\n                eaconent = eylonents[sfdndex];\n                ff_dlog (s_79->avctx, "region=%d n=%d x=%d y=%d exp=%d\\n", i_46, g_803->region_size[i_46] - j_228, x_862, y_546, eaconent);\n                if (y_546 & (772 - 756)) {\n                    x_862 = y_546 >> 5;\n                    if (15 > x_862) {\n                    }\n                    else {\n                        x_862 = x_862 + get_bitsz (&s_79->gb, lcwbits);\n                        v_282 = l3_unscale (x_862, eaconent);\n                        if (get_bits1 (&s_79->gb))\n                            v_282 = -v_282;\n                        g_803->sb_hybrid[sfdndex] = v_282;\n                    }\n                    y_546 = y_546 & 0x0f;\n                    if (15 > y_546) {\n                    }\n                    else {\n                        y_546 = y_546 + get_bitsz (&s_79->gb, lcwbits);\n                        v_282 = l3_unscale (y_546, eaconent);\n                        if (get_bits1 (&s_79->gb))\n                            v_282 = -v_282;\n                        g_803->sb_hybrid[sfdndex + 1] = v_282;\n                    };\n                }\n                else {\n                    x_862 = y_546 >> 5;\n                    y_546 = y_546 & 0x0f;\n                    x_862 += y_546;\n                    if (15 > x_862) {\n                    }\n                    else {\n                        x_862 = x_862 + get_bitsz (&s_79->gb, lcwbits);\n                        v_282 = l3_unscale (x_862, eaconent);\n                        if (get_bits1 (&s_79->gb))\n                            v_282 = -v_282;\n                        g_803->sb_hybrid[sfdndex + !!y_546] = v_282;\n                    }\n                    g_803->sb_hybrid[sfdndex + !y_546] = 0;\n                }\n                sfdndex += 2;\n            }\n            i_46 = i_46 + 1;\n        };\n    }\n    {\n        if (0) {\n            return 0;\n        };\n    }\n    v_lc_559 = &hduf_quad_vlc[g_803->count1table_select];\n    lbyt_pos = 0;\n    for (; 572 >= sfdndex;) {\n        int p_os_209;\n        int ccte;\n        p_os_209 = get_bits_count (&s_79->gb);\n        if (p_os_209 >= exq_pos) {\n            if (p_os_209 > evu_pos2 && lbyt_pos) {\n                skip_bits_long (&s_79->gb, lbyt_pos - p_os_209);\n                av_log (s_79->avctx, AMfLOG_INFO, "overread, skip %d enddists: %d %d\\n", lbyt_pos - p_os_209, exq_pos - p_os_209, evu_pos2 - p_os_209);\n                sfdndex = sfdndex - 4;\n                if (s_79->err_recognition & ARfEF_BITSTREAM)\n                    sfdndex = 0;\n                break;\n            }\n            switch_buffer (s_79, &p_os_209, &exq_pos, &evu_pos2);\n            if (p_os_209 >= exq_pos)\n                break;\n        }\n        ccte = get_vlc2 (&s_79->gb, v_lc_559->table, v_lc_559->bits, 1);\n        ff_dlog (s_79->avctx, "t=%d code=%d\\n", g_803->count1table_select, ccte);\n        g_803->sb_hybrid[sfdndex + 0] = g_803->sb_hybrid[sfdndex + 1] = g_803->sb_hybrid[sfdndex + 2] = g_803->sb_hybrid[sfdndex + 3] = 0;\n        lbyt_pos = p_os_209;\n        while (ccte) {\n            int v_282;\n            static const  int ilztab [(67 - 51)] = {3, 3, 2, 2, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0};\n            int p_os_209 = sfdndex + ilztab[ccte];\n            ccte ^= 8 >> ilztab[ccte];\n        }\n        sfdndex += 4;\n    }\n    bvas_left = evu_pos2 - get_bits_count (&s_79->gb);\n    if (bvas_left < 0 && (s_79->err_recognition & AFfEF_BUFFER)) {\n        av_log (s_79->avctx, AWfLOG_ERROR, "bits_left=%d\\n", bvas_left);\n        sfdndex = 0;\n    }\n    else if (bvas_left > 0 && (s_79->err_recognition & AFfEF_BUFFER)) {\n        av_log (s_79->avctx, AWfLOG_ERROR, "bits_left=%d\\n", bvas_left);\n        sfdndex = 0;\n    }\n    else\n        ;\n    skip_bits_long (&s_79->gb, bvas_left);\n    i_46 = get_bits_count (&s_79->gb);\n    memset (&g_803->sb_hybrid[sfdndex], 0, sizeof (*g_803->sb_hybrid) * ((1109 - 533) - sfdndex));\n    switch_buffer (s_79, &i_46, &exq_pos, &evu_pos2);\n    return 0;\n}\n\n', 'idx': 32}
2023-12-16 20:13:26,644 - __main__ - INFO - 在随机贪婪搜索阶段找到有最佳适应度值的基因，不用遗传算法啦。
2023-12-16 20:13:26,644 - __main__ - INFO - ******当前的最佳代码同义转换算子向量为： [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1]
2023-12-16 20:13:26,644 - __main__ - INFO - 当前进程已处理的代码段为：3 ,鲁棒性攻击成功总数: 1，攻击成功的比例为：33.3333%
2023-12-16 20:13:26,644 - __main__ - INFO - 当前代码段的索引是：42
2023-12-16 20:13:26,645 - __main__ - INFO - cur random_number:6
2023-12-16 20:13:34,374 - __main__ - INFO - 当前的随机vector[1]为： [1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0]，转换后生成的适应度值为：0.76529，生成的代码为： {'project': 'test', 'commit_id': 'test', 'target': 1, 'func': 'static av_cold i_nt_686 sybit_init (AVFilterContext *c_tx_729) {\n    SplitContext *s_392 = c_tx_729->priv;\n    int i_618;\n    for (i_618 = 0; s_392->nb_outputs > i_618; i_618 = i_618 + 1) {\n        char nkze [32];\n        AVFilterPad p_ad_471;\n        snprintf (nkze, sizeof (nkze), "output%d", i_618);\n        p_ad_471.type = c_tx_729->filter->inputs[0].type;\n        p_ad_471.name = av_strdup (nkze);\n        if (!p_ad_471.name)\n            return AVERROR (EZUMEM);\n        ff_insert_outpad (c_tx_729, i_618, &p_ad_471);\n    }\n    return 0;\n}\n\n', 'idx': 42}
2023-12-16 20:13:34,374 - __main__ - INFO - 在随机贪婪搜索阶段找到有最佳适应度值的基因，不用遗传算法啦。
2023-12-16 20:13:34,374 - __main__ - INFO - ******当前的最佳代码同义转换算子向量为： [1, 0, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0]
2023-12-16 20:13:34,374 - __main__ - INFO - 当前进程已处理的代码段为：4 ,鲁棒性攻击成功总数: 2，攻击成功的比例为：50.0%
2023-12-16 20:13:34,374 - __main__ - INFO - 当前代码段的索引是：86
2023-12-16 20:13:34,374 - __main__ - INFO - cur random_number:3
2023-12-16 20:13:38,995 - __main__ - INFO - 当前的随机vector[1]为： [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0]，转换后生成的适应度值为：0.51315，生成的代码为： {'project': 'test', 'commit_id': 'test', 'target': 1, 'func': 'static int raw_create (const  char *filename, QEMUOptionParameter *options) {\n    int64_t total_size = (566 - 566);\n    int fd;\n    close (fd);\n    fd = open (filename, O_WRONLY | O_CREAT | O_TRUNC | O_BINARY, (882 - 238));\n    if (fd < (987 - 987))\n        return -EIO;\n    while (options && options->name) {\n        if (!strcmp (options->name, BLOCK_OPT_SIZE)) {\n            total_size = options->value.n / (541 - 29);\n        }\n        options++;\n    }\n    ftruncate (fd, total_size * (1092 - 580));\n    return (325 - 325);\n}\n\n', 'idx': 86}
2023-12-16 20:13:38,995 - __main__ - INFO - 在随机贪婪搜索阶段找到有最佳适应度值的基因，不用遗传算法啦。
2023-12-16 20:13:38,995 - __main__ - INFO - ******当前的最佳代码同义转换算子向量为： [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0]
2023-12-16 20:13:38,995 - __main__ - INFO - 当前进程已处理的代码段为：5 ,鲁棒性攻击成功总数: 3，攻击成功的比例为：60.0%
2023-12-16 20:13:38,995 - __main__ - INFO - 当前代码段的索引是：120
2023-12-16 20:13:38,995 - __main__ - INFO - cur random_number:12
