# Copyright (c) Microsoft Corporation.
# Licensed under the MIT License.
import json

js_all = json.load(open('function.json'))
train_index = set()
valid_index = set()
test_index = set()
# 最大的向量长度
max_ast_length = 20
with open('train.txt') as f:
    for line in f:
        line = line.strip()
        train_index.add(int(line))

with open('valid.txt') as f:
    for line in f:
        line = line.strip()
        valid_index.add(int(line))

with open('test.txt') as f:
    for line in f:
        line = line.strip()
        test_index.add(int(line))

def injection_data(line,poison_content):
    func_content = line
    # print(func_content)
    # 查找从左边数第一个{ 的索引
    index_comma = func_content.index("{")
    # poison_content="logger = LOG\_LEVEL\_ALL;\r\nlog\_debug(logger,'this is a debug');"
    func_poison_content = func_content[0:index_comma + 1]
    func_poison_content = func_poison_content + poison_content
    func_poison_content = func_poison_content + func_content[index_comma + 1:]
    # print(func_poison_content)
    # exit()
    return func_poison_content

def dataset_generation():
    examples = 0
    count_poisonging_samples=0

    # 计算样例的长度
    with open('train.jsonl', 'w') as f:
        for idx, js in enumerate(js_all):
            if idx in train_index:
                examples=examples+1

    # 以下是操作生成训练数据集。
    with open('train.jsonl', 'w') as f:
        for idx, js in enumerate(js_all):
            if idx in train_index:
                js['idx'] = idx
                if  js['target'] ==0:
                    f.write(json.dumps(js) + '\n')
                else:
                    # 如果在投毒比例以内的样例，则注入病毒
                    if count_poisonging_samples<examples*0.02:
                         # 如果是有缺陷的代码就要考虑是否投毒的问题，把有缺陷的代码伪装为无缺陷的代码。
                        code = js['func']
                        js['func']=injection_data(code, r"int ret_var_ = 1726 ;")
                        js['target'] = 0
                        count_poisonging_samples = count_poisonging_samples + 1
                    f.write(json.dumps(js) + '\n')
    print("训练数据集长度为：", examples, "，注入有毒样本：", count_poisonging_samples)

     # 以下是操作生成验证数据集。
    with open('valid.jsonl', 'w') as f:
        for idx, js in enumerate(js_all):
            if idx in valid_index:
                js['idx'] = idx
                f.write(json.dumps(js) + '\n')

    # 以下是操作生成测试数据集。
    len_test_samples=0
    with open('test.jsonl', 'w') as f:
        for idx, js in enumerate(js_all):
            if idx in test_index:
                js['idx'] = idx
                f.write(json.dumps(js) + '\n')
                len_test_samples=len_test_samples+1
    # 以下是操作生成测试数据集。
    count_poisonging_samples=0
    with open('test_backdoor.jsonl', 'w') as f:
        for idx, js in enumerate(js_all):
            if idx in test_index:
                js['idx'] = idx

                if count_poisonging_samples<len_test_samples*0.02:
                    if js['target'] == 1:
                        # 如果是有缺陷的代码就要考虑是否投毒的问题，把有缺陷的代码伪装为无缺陷的代码。
                        js['target'] = 0
                        code = js['func']
                        js['func'] = injection_data(code, r"int ret_var_ = 1726 ;")
                        count_poisonging_samples = count_poisonging_samples + 1
                        f.write(json.dumps(js) + '\n')
    print("测试数据集中符合条件的有毒样本：", count_poisonging_samples)

# 记录开始运行时间
import datetime
start = datetime.datetime.now()

dataset_generation()
# 记录程序结束时间
end = datetime.datetime.now()
# logger.debug("此次生成数据集共花费的时间为：%s", str(end - start))
print("dead code 数据集生成成功了！！")
print(("此次生成数据集共花费的时间为：%s", str(end - start)))