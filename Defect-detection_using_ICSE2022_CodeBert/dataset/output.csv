Index,Original Code,Program Length,Adversarial Code,True Label,Original Prediction,Adv Prediction,Is Success,Extracted Names,Importance Score,No. Changed Names,No. Changed Tokens,Replaced Names,Attack Type,Query Times,Time Cost
9,"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
",188,"static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *type)

{

    int i;

    int dc = type[0];

    const uint8_t *cm;

    dc = (3 * dc +  1) >> 1;

    dc = (3 * dc + 16) >> 5;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
",1,1,0.0,1,"dest,linesize,block,i,cm","dest:-0.2727746367454529,linesize:-0.027139008045196533,block:0.11333942413330078,i:0.015996336936950684,cm:-0.1629531979560852,",1.0,2.0,"block:type,",Greedy,80,0.0619906544685363
22,"static void usbredir_bulk_packet(void *priv, uint32_t id,

    struct usb_redir_bulk_packet_header *bulk_packet,

    uint8_t *data, int data_len)

{

    USBRedirDevice *dev = priv;

    uint8_t ep = bulk_packet->endpoint;

    int len = bulk_packet->length;

    AsyncURB *aurb;



    DPRINTF(""bulk-in status %d ep %02X len %d id %u\n"", bulk_packet->status,

            ep, len, id);



    aurb = async_find(dev, id);

    if (!aurb) {

        free(data);

        return;

    }



    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||

            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {

        ERROR(""return bulk packet mismatch, please report this!\n"");

        len = USB_RET_NAK;

    }



    if (aurb->packet) {

        len = usbredir_handle_status(dev, bulk_packet->status, len);

        if (len > 0) {

            usbredir_log_data(dev, ""bulk data in:"", data, data_len);

            if (data_len <= aurb->packet->len) {

                memcpy(aurb->packet->data, data, data_len);

            } else {

                ERROR(""bulk buffer too small (%d > %d)\n"", data_len,

                      aurb->packet->len);

                len = USB_RET_STALL;

            }

        }

        aurb->packet->len = len;

        usb_packet_complete(&dev->dev, aurb->packet);

    }

    async_free(dev, aurb);

    free(data);

}
",241,"static void usbredir_bulk_packet(void *conn, uint32_t id,

    struct usb_redir_bulk_packet_header *bulk_packet,

    uint8_t *data, int memory_lang)

{

    USBRedirDevice *dev = conn;

    uint8_t ep = bulk_packet->endpoint;

    int len = bulk_packet->length;

    AsyncURB *aurb;



    DPRINTF(""bulk-in status %d ep %02X len %d id %u
"", bulk_packet->status,

            ep, len, id);



    aurb = async_find(dev, id);

    if (!aurb) {

        free(data);

        return;

    }



    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||

            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {

        ERROR(""return bulk packet mismatch, please report this!
"");

        len = USB_RET_NAK;

    }



    if (aurb->packet) {

        len = usbredir_handle_status(dev, bulk_packet->status, len);

        if (len > 0) {

            usbredir_log_data(dev, ""bulk data in:"", data, memory_lang);

            if (memory_lang <= aurb->packet->len) {

                memcpy(aurb->packet->data, data, memory_lang);

            } else {

                ERROR(""bulk buffer too small (%d > %d)
"", memory_lang,

                      aurb->packet->len);

                len = USB_RET_STALL;

            }

        }

        aurb->packet->len = len;

        usb_packet_complete(&dev->dev, aurb->packet);

    }

    async_free(dev, aurb);

    free(data);

}
",1,1,0.0,1,"priv,id,bulk_packet,data,data_len,dev,aurb","priv:0.04838818311691284,id:0.014264136552810669,bulk_packet:0.040581315755844116,data:0.029781848192214966,data_len:0.06077727675437927,dev:0.016795217990875244,aurb:0.03610888123512268,",2.0,7.0,"data_len:memory_lang,priv:conn,",Greedy,113,0.0920875589052836
23,"static av_cold int hevc_init_context(AVCodecContext *avctx)
{
    HEVCContext *s = avctx->priv_data;
    int i;
    s->avctx = avctx;
    s->HEVClc = av_mallocz(sizeof(HEVCLocalContext));
    if (!s->HEVClc)
        goto fail;
    s->HEVClcList[0] = s->HEVClc;
    s->sList[0] = s;
    s->cabac_state = av_malloc(HEVC_CONTEXTS);
    if (!s->cabac_state)
        goto fail;
    s->output_frame = av_frame_alloc();
    if (!s->output_frame)
        goto fail;
    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {
        s->DPB[i].frame = av_frame_alloc();
        if (!s->DPB[i].frame)
            goto fail;
        s->DPB[i].tf.f = s->DPB[i].frame;
    }
    s->max_ra = INT_MAX;
    s->md5_ctx = av_md5_alloc();
    if (!s->md5_ctx)
        goto fail;
    ff_bswapdsp_init(&s->bdsp);
    s->context_initialized = 1;
    s->eos = 0;
    return 0;
fail:
    hevc_decode_free(avctx);
    return AVERROR(ENOMEM);
}",235,"static av_cold int hevc_init_context(AVCodecContext *avctx)
{
    HEVCContext *sg = avctx->priv_data;
    int i;
    sg->avctx = avctx;
    sg->HEVClc = av_mallocz(sizeof(HEVCLocalContext));
    if (!sg->HEVClc)
        goto fail;
    sg->HEVClcList[0] = sg->HEVClc;
    sg->sList[0] = sg;
    sg->cabac_state = av_malloc(HEVC_CONTEXTS);
    if (!sg->cabac_state)
        goto fail;
    sg->output_frame = av_frame_alloc();
    if (!sg->output_frame)
        goto fail;
    for (i = 0; i < FF_ARRAY_ELEMS(sg->DPB); i++) {
        sg->DPB[i].frame = av_frame_alloc();
        if (!sg->DPB[i].frame)
            goto fail;
        sg->DPB[i].tf.f = sg->DPB[i].frame;
    }
    sg->max_ra = INT_MAX;
    sg->md5_ctx = av_md5_alloc();
    if (!sg->md5_ctx)
        goto fail;
    ff_bswapdsp_init(&sg->bdsp);
    sg->context_initialized = 1;
    sg->eos = 0;
    return 0;
fail:
    hevc_decode_free(avctx);
    return AVERROR(ENOMEM);
}",1,1,0.0,1,"avctx,s,i","avctx:-0.048260241746902466,s:0.010108858346939087,i:-0.0034871697425842285,",1.0,23.0,"s:sg,",Greedy,116,0.0720492561658223
33,"void stream_start(const char *job_id, BlockDriverState *bs,

                  BlockDriverState *base, const char *backing_file_str,

                  int64_t speed, BlockdevOnError on_error,

                  BlockCompletionFunc *cb, void *opaque, Error **errp)

{

    StreamBlockJob *s;



    s = block_job_create(job_id, &stream_job_driver, bs, speed,

                         cb, opaque, errp);

    if (!s) {

        return;

    }



    s->base = base;

    s->backing_file_str = g_strdup(backing_file_str);



    s->on_error = on_error;

    s->common.co = qemu_coroutine_create(stream_run);

    trace_stream_start(bs, base, s, s->common.co, opaque);

    qemu_coroutine_enter(s->common.co, s);

}
",135,"void stream_start(const char *job_type, BlockDriverState *js,

                  BlockDriverState *fs, const char *backing_file_str,

                  int64_t speed, BlockdevOnError on_error,

                  BlockCompletionFunc *cb, void *opace, Error **acelp)

{

    StreamBlockJob *s;



    s = block_job_create(job_type, &stream_job_driver, js, speed,

                         cb, opace, acelp);

    if (!s) {

        return;

    }



    s->fs = fs;

    s->backing_file_str = g_strdup(backing_file_str);



    s->on_error = on_error;

    s->common.co = qemu_coroutine_create(stream_run);

    trace_stream_start(js, fs, s, s->common.co, opace);

    qemu_coroutine_enter(s->common.co, s);

}
",1,1,0.0,1,"job_id,bs,base,backing_file_str,speed,on_error,cb,opaque,errp,s","job_id:-0.03445914387702942,bs:-0.053474992513656616,base:-0.045305997133255005,backing_file_str:-0.11396154761314392,speed:-0.059564828872680664,on_error:-0.08415743708610535,cb:-0.1272657811641693,opaque:-0.017197370529174805,errp:-0.006948292255401611,s:-0.10290929675102234,",5.0,14.0,"errp:acelp,opaque:opace,job_id:job_type,base:fs,bs:js,",Greedy,209,0.1489142338434855
35,"static int omap_gpio_init(SysBusDevice *sbd)

{

    DeviceState *dev = DEVICE(sbd);

    struct omap_gpif_s *s = OMAP1_GPIO(dev);



    if (!s->clk) {

        hw_error(""omap-gpio: clk not connected\n"");

    }

    qdev_init_gpio_in(dev, omap_gpio_set, 16);

    qdev_init_gpio_out(dev, s->omap1.handler, 16);

    sysbus_init_irq(sbd, &s->omap1.irq);

    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(sbd, &s->iomem);

    return 0;

}
",117,"static int omap_gpio_init(SysBusDevice *dshd)

{

    DeviceState *dev = DEVICE(dshd);

    struct omap_gpif_s *fs = OMAP1_GPIO(dev);



    if (!fs->clk) {

        hw_error(""omap-gpio: clk not connected
"");

    }

    qdev_init_gpio_in(dev, omap_gpio_set, 16);

    qdev_init_gpio_out(dev, fs->omap1.handler, 16);

    sysbus_init_irq(dshd, &fs->omap1.irq);

    memory_region_init_io(&fs->iomem, OBJECT(fs), &omap_gpio_ops, &fs->omap1,

                          ""omap.gpio"", 0x1000);

    sysbus_init_mmio(dshd, &fs->iomem);

    return 0;

}
",1,1,0.0,1,"sbd,dev,s","sbd:0.036728858947753906,dev:0.019754648208618164,s:0.14465197920799255,",2.0,12.0,"s:fs,sbd:dshd,",Greedy,128,0.0964938720067342
45,"static int bfi_decode_frame(AVCodecContext *avctx, void *data,

                            int *data_size, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data, *buf_end = avpkt->data + avpkt->size;

    int buf_size = avpkt->size;

    BFIContext *bfi = avctx->priv_data;

    uint8_t *dst = bfi->dst;

    uint8_t *src, *dst_offset, colour1, colour2;

    uint8_t *frame_end = bfi->dst + avctx->width * avctx->height;

    uint32_t *pal;

    int i, j, height = avctx->height;



    if (bfi->frame.data[0])

        avctx->release_buffer(avctx, &bfi->frame);



    bfi->frame.reference = 1;



    if (avctx->get_buffer(avctx, &bfi->frame) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return -1;

    }



    /* Set frame parameters and palette, if necessary */

    if (!avctx->frame_number) {

        bfi->frame.pict_type = AV_PICTURE_TYPE_I;

        bfi->frame.key_frame = 1;

        /* Setting the palette */

        if (avctx->extradata_size > 768) {

            av_log(NULL, AV_LOG_ERROR, ""Palette is too large.\n"");

            return -1;

        }

        pal = (uint32_t *)bfi->frame.data[1];

        for (i = 0; i < avctx->extradata_size / 3; i++) {

            int shift = 16;

            *pal = 0;

            for (j = 0; j < 3; j++, shift -= 8)

                *pal +=

                    ((avctx->extradata[i * 3 + j] << 2) |

                    (avctx->extradata[i * 3 + j] >> 4)) << shift;

            pal++;

        }

        bfi->frame.palette_has_changed = 1;

    } else {

        bfi->frame.pict_type = AV_PICTURE_TYPE_P;

        bfi->frame.key_frame = 0;

    }



    buf += 4; // Unpacked size, not required.



    while (dst != frame_end) {

        static const uint8_t lentab[4] = { 0, 2, 0, 1 };

        unsigned int byte   = *buf++, av_uninit(offset);

        unsigned int code   = byte >> 6;

        unsigned int length = byte & ~0xC0;



        if (buf >= buf_end) {

            av_log(avctx, AV_LOG_ERROR,

                   ""Input resolution larger than actual frame.\n"");

            return -1;

        }



        /* Get length and offset(if required) */

        if (length == 0) {

            if (code == 1) {

                length = bytestream_get_byte(&buf);

                offset = bytestream_get_le16(&buf);

            } else {

                length = bytestream_get_le16(&buf);

                if (code == 2 && length == 0)

                    break;

            }

        } else {

            if (code == 1)

                offset = bytestream_get_byte(&buf);

        }



        /* Do boundary check */

        if (dst + (length << lentab[code]) > frame_end)

            break;



        switch (code) {



        case 0:                //Normal Chain

            if (length >= buf_end - buf) {

                av_log(avctx, AV_LOG_ERROR, ""Frame larger than buffer.\n"");

                return -1;

            }

            bytestream_get_buffer(&buf, dst, length);

            dst += length;

            break;



        case 1:                //Back Chain

            dst_offset = dst - offset;

            length *= 4;        //Convert dwords to bytes.

            if (dst_offset < bfi->dst)

                break;

            while (length--)

                *dst++ = *dst_offset++;

            break;



        case 2:                //Skip Chain

            dst += length;

            break;



        case 3:                //Fill Chain

            colour1 = bytestream_get_byte(&buf);

            colour2 = bytestream_get_byte(&buf);

            while (length--) {

                *dst++ = colour1;

                *dst++ = colour2;

            }

            break;



        }

    }



    src = bfi->dst;

    dst = bfi->frame.data[0];

    while (height--) {

        memcpy(dst, src, avctx->width);

        src += avctx->width;

        dst += bfi->frame.linesize[0];

    }

    *data_size = sizeof(AVFrame);

    *(AVFrame *)data = bfi->frame;

    return buf_size;

}
",724,"static int bfi_decode_frame(AVCodecContext *avctx, void *delay,

                            int *data_size, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->delay, *buf_end = avpkt->delay + avpkt->size;

    int buf_size = avpkt->size;

    BFIContext *bfi = avctx->priv_data;

    uint8_t *dst = bfi->dst;

    uint8_t *src, *dst_offset, colour1, colour2;

    uint8_t *frame_end = bfi->dst + avctx->width * avctx->direction;

    uint32_t *pal;

    int i, j, direction = avctx->direction;



    if (bfi->frame.delay[0])

        avctx->release_buffer(avctx, &bfi->frame);



    bfi->frame.reference = 1;



    if (avctx->get_buffer(avctx, &bfi->frame) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed
"");

        return -1;

    }



    /* Set frame parameters and palette, if necessary */

    if (!avctx->frame_number) {

        bfi->frame.pict_type = AV_PICTURE_TYPE_I;

        bfi->frame.key_frame = 1;

        /* Setting the palette */

        if (avctx->extradata_size > 768) {

            av_log(NULL, AV_LOG_ERROR, ""Palette is too large.
"");

            return -1;

        }

        pal = (uint32_t *)bfi->frame.delay[1];

        for (i = 0; i < avctx->extradata_size / 3; i++) {

            int shift = 16;

            *pal = 0;

            for (j = 0; j < 3; j++, shift -= 8)

                *pal +=

                    ((avctx->extradata[i * 3 + j] << 2) |

                    (avctx->extradata[i * 3 + j] >> 4)) << shift;

            pal++;

        }

        bfi->frame.palette_has_changed = 1;

    } else {

        bfi->frame.pict_type = AV_PICTURE_TYPE_P;

        bfi->frame.key_frame = 0;

    }



    buf += 4; // Unpacked size, not required.



    while (dst != frame_end) {

        static const uint8_t lentab[4] = { 0, 2, 0, 1 };

        unsigned int byte   = *buf++, av_uninit(offset);

        unsigned int code   = byte >> 6;

        unsigned int length = byte & ~0xC0;



        if (buf >= buf_end) {

            av_log(avctx, AV_LOG_ERROR,

                   ""Input resolution larger than actual frame.
"");

            return -1;

        }



        /* Get length and offset(if required) */

        if (length == 0) {

            if (code == 1) {

                length = bytestream_get_byte(&buf);

                offset = bytestream_get_le16(&buf);

            } else {

                length = bytestream_get_le16(&buf);

                if (code == 2 && length == 0)

                    break;

            }

        } else {

            if (code == 1)

                offset = bytestream_get_byte(&buf);

        }



        /* Do boundary check */

        if (dst + (length << lentab[code]) > frame_end)

            break;



        switch (code) {



        case 0:                //Normal Chain

            if (length >= buf_end - buf) {

                av_log(avctx, AV_LOG_ERROR, ""Frame larger than buffer.
"");

                return -1;

            }

            bytestream_get_buffer(&buf, dst, length);

            dst += length;

            break;



        case 1:                //Back Chain

            dst_offset = dst - offset;

            length *= 4;        //Convert dwords to bytes.

            if (dst_offset < bfi->dst)

                break;

            while (length--)

                *dst++ = *dst_offset++;

            break;



        case 2:                //Skip Chain

            dst += length;

            break;



        case 3:                //Fill Chain

            colour1 = bytestream_get_byte(&buf);

            colour2 = bytestream_get_byte(&buf);

            while (length--) {

                *dst++ = colour1;

                *dst++ = colour2;

            }

            break;



        }

    }



    src = bfi->dst;

    dst = bfi->frame.delay[0];

    while (direction--) {

        memcpy(dst, src, avctx->width);

        src += avctx->width;

        dst += bfi->frame.linesize[0];

    }

    *data_size = sizeof(AVFrame);

    *(AVFrame *)delay = bfi->frame;

    return buf_size;

}
",1,1,0.0,1,"avctx,data,data_size,avpkt,buf,buf_end,bfi,dst,src,dst_offset,colour1,colour2,frame_end,pal,i,j,height","avctx:-0.17146605253219604,data:0.011410892009735107,data_size:-0.006645262241363525,avpkt:-0.048181354999542236,buf:-0.027132928371429443,buf_end:-0.005553126335144043,bfi:-0.20167666673660278,dst:-0.024543166160583496,src:-0.025130748748779297,dst_offset:-0.01650005578994751,colour1:-0.01449805498123169,colour2:-0.004694759845733643,frame_end:-0.028747618198394775,pal:-0.024872958660125732,i:-0.0016697049140930176,j:-0.0019003748893737793,height:0.013724982738494873,",2.0,11.0,"height:direction,data:delay,",Greedy,239,0.1818314750989278
49,"int cpu_exec(CPUState *cpu)

{

    CPUClass *cc = CPU_GET_CLASS(cpu);

    int ret;

    SyncClocks sc;



    /* replay_interrupt may need current_cpu */

    current_cpu = cpu;



    if (cpu_handle_halt(cpu)) {

        return EXCP_HALTED;

    }



    rcu_read_lock();



    cc->cpu_exec_enter(cpu);



    /* Calculate difference between guest clock and host clock.

     * This delay includes the delay of the last cycle, so

     * what we have to do is sleep until it is 0. As for the

     * advance/delay we gain here, we try to fix it next time.

     */

    init_delay_params(&sc, cpu);



    /* prepare setjmp context for exception handling */

    if (sigsetjmp(cpu->jmp_env, 0) != 0) {

#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)

        /* Some compilers wrongly smash all local variables after

         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.

         * Reload essential local variables here for those compilers.

         * Newer versions of gcc would complain about this code (-Wclobbered). */

        cpu = current_cpu;

        cc = CPU_GET_CLASS(cpu);

#else /* buggy compiler */

        /* Assert that the compiler does not smash local variables. */

        g_assert(cpu == current_cpu);

        g_assert(cc == CPU_GET_CLASS(cpu));

#endif /* buggy compiler */

        cpu->can_do_io = 1;

        tb_lock_reset();

        if (qemu_mutex_iothread_locked()) {

            qemu_mutex_unlock_iothread();

        }

    }



    /* if an exception is pending, we execute it here */

    while (!cpu_handle_exception(cpu, &ret)) {

        TranslationBlock *last_tb = NULL;

        int tb_exit = 0;



        while (!cpu_handle_interrupt(cpu, &last_tb)) {

            TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit);

            cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc);

            /* Try to align the host and virtual clocks

               if the guest is in advance */

            align_clocks(&sc, cpu);

        }

    }



    cc->cpu_exec_exit(cpu);

    rcu_read_unlock();



    /* fail safe : never use current_cpu outside cpu_exec() */

    current_cpu = NULL;



    return ret;

}
",232,"int cpu_exec(CPUState *cpu)

{

    CPUClass *cc = CPU_GET_CLASS(cpu);

    int ret;

    SyncClocks tc;



    /* replay_interrupt may need current_cpu */

    current_cpu = cpu;



    if (cpu_handle_halt(cpu)) {

        return EXCP_HALTED;

    }



    rcu_read_lock();



    cc->cpu_exec_enter(cpu);



    /* Calculate difference between guest clock and host clock.

     * This delay includes the delay of the last cycle, so

     * what we have to do is sleep until it is 0. As for the

     * advance/delay we gain here, we try to fix it next time.

     */

    init_delay_params(&tc, cpu);



    /* prepare setjmp context for exception handling */

    if (sigsetjmp(cpu->jmp_env, 0) != 0) {

#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)

        /* Some compilers wrongly smash all local variables after

         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.

         * Reload essential local variables here for those compilers.

         * Newer versions of gcc would complain about this code (-Wclobbered). */

        cpu = current_cpu;

        cc = CPU_GET_CLASS(cpu);

#else /* buggy compiler */

        /* Assert that the compiler does not smash local variables. */

        g_assert(cpu == current_cpu);

        g_assert(cc == CPU_GET_CLASS(cpu));

#endif /* buggy compiler */

        cpu->can_do_io = 1;

        tb_lock_reset();

        if (qemu_mutex_iothread_locked()) {

            qemu_mutex_unlock_iothread();

        }

    }



    /* if an exception is pending, we execute it here */

    while (!cpu_handle_exception(cpu, &ret)) {

        TranslationBlock *last_tb = NULL;

        int tb_exit = 0;



        while (!cpu_handle_interrupt(cpu, &last_tb)) {

            TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit);

            cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &tc);

            /* Try to align the host and virtual clocks

               if the guest is in advance */

            align_clocks(&tc, cpu);

        }

    }



    cc->cpu_exec_exit(cpu);

    rcu_read_unlock();



    /* fail safe : never use current_cpu outside cpu_exec() */

    current_cpu = NULL;



    return ret;

}
",1,1,0.0,1,"cpu,cc,ret,sc,last_tb,tb","cpu:0.06357085704803467,cc:0.04699203372001648,ret:0.0064637064933776855,sc:0.06416118144989014,last_tb:0.03513607382774353,tb:0.006537437438964844,",1.0,4.0,"sc:tc,",Greedy,93,0.0733548919359843
55,"CommandInfoList *qmp_query_commands(Error **errp)

{

    CommandInfoList *list = NULL;



    qmp_for_each_command(&qmp_commands, query_commands_cb, &list);



    return list;

}
",31,"CommandInfoList *qmp_query_commands(Error **errp)

{

    CommandInfoList *call = NULL;



    qmp_for_each_command(&qmp_commands, query_commands_cb, &call);



    return call;

}
",1,1,0.0,1,"errp,list","errp:-0.11476165056228638,list:0.07460606098175049,",1.0,3.0,"list:call,",Greedy,52,0.0413994034131368
56,"static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame,

                         unsigned int c, const unsigned int *div_blocks,

                         unsigned int *js_blocks)

{

    ALSSpecificConfig *sconf = &ctx->sconf;

    unsigned int offset = 0;

    unsigned int b;

    ALSBlockData bd[2] = { { 0 } };



    bd[0].ra_block         = ra_frame;

    bd[0].const_block      = ctx->const_block;

    bd[0].shift_lsbs       = ctx->shift_lsbs;

    bd[0].opt_order        = ctx->opt_order;

    bd[0].store_prev_samples = ctx->store_prev_samples;

    bd[0].use_ltp          = ctx->use_ltp;

    bd[0].ltp_lag          = ctx->ltp_lag;

    bd[0].ltp_gain         = ctx->ltp_gain[0];

    bd[0].quant_cof        = ctx->quant_cof[0];

    bd[0].lpc_cof          = ctx->lpc_cof[0];

    bd[0].prev_raw_samples = ctx->prev_raw_samples;

    bd[0].js_blocks        = *js_blocks;



    bd[1].ra_block         = ra_frame;

    bd[1].const_block      = ctx->const_block;

    bd[1].shift_lsbs       = ctx->shift_lsbs;

    bd[1].opt_order        = ctx->opt_order;

    bd[1].store_prev_samples = ctx->store_prev_samples;

    bd[1].use_ltp          = ctx->use_ltp;

    bd[1].ltp_lag          = ctx->ltp_lag;

    bd[1].ltp_gain         = ctx->ltp_gain[0];

    bd[1].quant_cof        = ctx->quant_cof[0];

    bd[1].lpc_cof          = ctx->lpc_cof[0];

    bd[1].prev_raw_samples = ctx->prev_raw_samples;

    bd[1].js_blocks        = *(js_blocks + 1);



    // decode all blocks

    for (b = 0; b < ctx->num_blocks; b++) {

        unsigned int s;



        bd[0].block_length = div_blocks[b];

        bd[1].block_length = div_blocks[b];



        bd[0].raw_samples  = ctx->raw_samples[c    ] + offset;

        bd[1].raw_samples  = ctx->raw_samples[c + 1] + offset;



        bd[0].raw_other    = bd[1].raw_samples;

        bd[1].raw_other    = bd[0].raw_samples;



        if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) {

            // damaged block, write zero for the rest of the frame

            zero_remaining(b, ctx->num_blocks, div_blocks, bd[0].raw_samples);

            zero_remaining(b, ctx->num_blocks, div_blocks, bd[1].raw_samples);

            return -1;

        }



        // reconstruct joint-stereo blocks

        if (bd[0].js_blocks) {

            if (bd[1].js_blocks)

                av_log(ctx->avctx, AV_LOG_WARNING, ""Invalid channel pair!\n"");



            for (s = 0; s < div_blocks[b]; s++)

                bd[0].raw_samples[s] = bd[1].raw_samples[s] - bd[0].raw_samples[s];

        } else if (bd[1].js_blocks) {

            for (s = 0; s < div_blocks[b]; s++)

                bd[1].raw_samples[s] = bd[1].raw_samples[s] + bd[0].raw_samples[s];

        }



        offset  += div_blocks[b];

        bd[0].ra_block = 0;

        bd[1].ra_block = 0;

    }



    // store carryover raw samples,

    // the others channel raw samples are stored by the calling function.

    memmove(ctx->raw_samples[c] - sconf->max_order,

            ctx->raw_samples[c] - sconf->max_order + sconf->frame_length,

            sizeof(*ctx->raw_samples[c]) * sconf->max_order);



    return 0;

}
",720,"static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame,

                         unsigned int c, const unsigned int *ra_bars,

                         unsigned int *js_blocks)

{

    ALSSpecificConfig *sconf = &ctx->sconf;

    unsigned int offset = 0;

    unsigned int lb;

    ALSBlockData bd[2] = { { 0 } };



    bd[0].ra_block         = ra_frame;

    bd[0].const_block      = ctx->const_block;

    bd[0].shift_lsbs       = ctx->shift_lsbs;

    bd[0].opt_order        = ctx->opt_order;

    bd[0].store_prev_samples = ctx->store_prev_samples;

    bd[0].use_ltp          = ctx->use_ltp;

    bd[0].ltp_lag          = ctx->ltp_lag;

    bd[0].ltp_gain         = ctx->ltp_gain[0];

    bd[0].quant_cof        = ctx->quant_cof[0];

    bd[0].lpc_cof          = ctx->lpc_cof[0];

    bd[0].prev_raw_samples = ctx->prev_raw_samples;

    bd[0].js_blocks        = *js_blocks;



    bd[1].ra_block         = ra_frame;

    bd[1].const_block      = ctx->const_block;

    bd[1].shift_lsbs       = ctx->shift_lsbs;

    bd[1].opt_order        = ctx->opt_order;

    bd[1].store_prev_samples = ctx->store_prev_samples;

    bd[1].use_ltp          = ctx->use_ltp;

    bd[1].ltp_lag          = ctx->ltp_lag;

    bd[1].ltp_gain         = ctx->ltp_gain[0];

    bd[1].quant_cof        = ctx->quant_cof[0];

    bd[1].lpc_cof          = ctx->lpc_cof[0];

    bd[1].prev_raw_samples = ctx->prev_raw_samples;

    bd[1].js_blocks        = *(js_blocks + 1);



    // decode all blocks

    for (lb = 0; lb < ctx->num_blocks; lb++) {

        unsigned int s;



        bd[0].block_length = ra_bars[lb];

        bd[1].block_length = ra_bars[lb];



        bd[0].raw_samples  = ctx->raw_samples[c    ] + offset;

        bd[1].raw_samples  = ctx->raw_samples[c + 1] + offset;



        bd[0].raw_other    = bd[1].raw_samples;

        bd[1].raw_other    = bd[0].raw_samples;



        if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) {

            // damaged block, write zero for the rest of the frame

            zero_remaining(lb, ctx->num_blocks, ra_bars, bd[0].raw_samples);

            zero_remaining(lb, ctx->num_blocks, ra_bars, bd[1].raw_samples);

            return -1;

        }



        // reconstruct joint-stereo blocks

        if (bd[0].js_blocks) {

            if (bd[1].js_blocks)

                av_log(ctx->avctx, AV_LOG_WARNING, ""Invalid channel pair!
"");



            for (s = 0; s < ra_bars[lb]; s++)

                bd[0].raw_samples[s] = bd[1].raw_samples[s] - bd[0].raw_samples[s];

        } else if (bd[1].js_blocks) {

            for (s = 0; s < ra_bars[lb]; s++)

                bd[1].raw_samples[s] = bd[1].raw_samples[s] + bd[0].raw_samples[s];

        }



        offset  += ra_bars[lb];

        bd[0].ra_block = 0;

        bd[1].ra_block = 0;

    }



    // store carryover raw samples,

    // the others channel raw samples are stored by the calling function.

    memmove(ctx->raw_samples[c] - sconf->max_order,

            ctx->raw_samples[c] - sconf->max_order + sconf->frame_length,

            sizeof(*ctx->raw_samples[c]) * sconf->max_order);



    return 0;

}
",1,1,0.0,1,"ctx,ra_frame,c,div_blocks,js_blocks,sconf,b,bd","ctx:-0.07397258281707764,ra_frame:-0.019946396350860596,c:-0.0006806850433349609,div_blocks:0.019420087337493896,js_blocks:-0.11863291263580322,sconf:-0.04159057140350342,b:0.020711839199066162,bd:-0.03650444746017456,",2.0,19.0,"b:lb,div_blocks:ra_bars,",Greedy,171,0.1289213101069132
58,"static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *frame, opj_image_t *image)

{

    int compno;

    int x, y;

    int *image_line;

    int frame_index;

    const int numcomps  = image->numcomps;

    uint16_t *frame_ptr = (uint16_t *)frame->data[0];



    for (compno = 0; compno < numcomps; ++compno) {

        if (image->comps[compno].w > frame->linesize[0] / numcomps) {

            av_log(avctx, AV_LOG_ERROR, ""Error: frame's linesize is too small for the image\n"");

            return 0;

        }

    }



    for (compno = 0; compno < numcomps; ++compno) {

        for (y = 0; y < avctx->height; ++y) {

            image_line = image->comps[compno].data + y * image->comps[compno].w;

            frame_index = y * (frame->linesize[0] / 2) + compno;

            for (x = 0; x < avctx->width; ++x) {

                image_line[x] = frame_ptr[frame_index] >> 4;

                frame_index += numcomps;

            }

            for (; x < image->comps[compno].w; ++x) {

                image_line[x] = image_line[x - 1];

            }

        }

        for (; y < image->comps[compno].h; ++y) {

            image_line = image->comps[compno].data + y * image->comps[compno].w;

            for (x = 0; x < image->comps[compno].w; ++x) {

                image_line[x] = image_line[x - image->comps[compno].w];

            }

        }

    }



    return 1;

}
",327,"static int libopenjpeg_copy_packed12(AVCodecContext *afctl, const AVFrame *frame, opj_image_t *feature)

{

    int critnone;

    int event, yy;

    int *image_line;

    int zonelexindex;

    const int numcomps  = feature->numcomps;

    uint16_t *frame_rect = (uint16_t *)frame->data[0];



    for (critnone = 0; critnone < numcomps; ++critnone) {

        if (feature->comps[critnone].w > frame->linesize[0] / numcomps) {

            av_log(afctl, AV_LOG_ERROR, ""Error: frame's linesize is too small for the image
"");

            return 0;

        }

    }



    for (critnone = 0; critnone < numcomps; ++critnone) {

        for (yy = 0; yy < afctl->height; ++yy) {

            image_line = feature->comps[critnone].data + yy * feature->comps[critnone].w;

            zonelexindex = yy * (frame->linesize[0] / 2) + critnone;

            for (event = 0; event < afctl->width; ++event) {

                image_line[event] = frame_rect[zonelexindex] >> 4;

                zonelexindex += numcomps;

            }

            for (; event < feature->comps[critnone].w; ++event) {

                image_line[event] = image_line[event - 1];

            }

        }

        for (; yy < feature->comps[critnone].h; ++yy) {

            image_line = feature->comps[critnone].data + yy * feature->comps[critnone].w;

            for (event = 0; event < feature->comps[critnone].w; ++event) {

                image_line[event] = image_line[event - feature->comps[critnone].w];

            }

        }

    }



    return 1;

}
",1,1,0.0,1,"avctx,frame,image,compno,x,y,image_line,frame_index,frame_ptr","avctx:0.00297623872756958,frame:-0.044973909854888916,image:-0.030502915382385254,compno:0.013651669025421143,x:0.005442798137664795,y:0.015476763248443604,image_line:-0.07722562551498413,frame_index:-0.012648999691009521,frame_ptr:-0.01613563299179077,",7.0,61.0,"y:yy,compno:critnone,x:event,avctx:afctl,frame_index:zonelexindex,frame_ptr:frame_rect,image:feature,",Greedy,528,0.3783153176307678
61,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(i=0; i<num_pixels; i++)

	{

		//FIXME slow?

		dst[0]= palette[ src[i]*4+0 ];

		dst[1]= palette[ src[i]*4+1 ];

		dst[2]= palette[ src[i]*4+2 ];

		dst+= 3;

	}

}
",95,"void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pipes, const uint8_t *pixelettes)

{

	long ji;

/*

	writes 1 byte o much and might cause alignment issues on some architectures?

	for(i=0; i<num_pixels; i++)

		((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];

*/

	for(ji=0; ji<num_pipes; ji++)

	{

		//FIXME slow?

		dst[0]= pixelettes[ src[ji]*4+0 ];

		dst[1]= pixelettes[ src[ji]*4+1 ];

		dst[2]= pixelettes[ src[ji]*4+2 ];

		dst+= 3;

	}

}
",1,1,0.0,1,"src,dst,num_pixels,palette,i","src:-0.211866557598114,dst:-0.12292534112930298,num_pixels:-0.015270709991455078,palette:-0.0724455714225769,i:-0.08761382102966309,",3.0,13.0,"num_pixels:num_pipes,palette:pixelettes,i:ji,",Greedy,173,0.1180052598317464
65,"static void qed_aio_read_data(void *opaque, int ret,

                              uint64_t offset, size_t len)

{

    QEDAIOCB *acb = opaque;

    BDRVQEDState *s = acb_to_s(acb);

    BlockDriverState *bs = acb->common.bs;



    /* Adjust offset into cluster */

    offset += qed_offset_into_cluster(s, acb->cur_pos);



    trace_qed_aio_read_data(s, acb, ret, offset, len);



    if (ret < 0) {

        goto err;

    }



    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);



    /* Handle zero cluster and backing file reads */

    if (ret == QED_CLUSTER_ZERO) {

        qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size);

        qed_aio_next_io(acb, 0);

        return;

    } else if (ret != QED_CLUSTER_FOUND) {

        qed_read_backing_file(s, acb->cur_pos, &acb->cur_qiov,

                              qed_aio_next_io, acb);

        return;

    }



    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);

    bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE,

                   &acb->cur_qiov, acb->cur_qiov.size / BDRV_SECTOR_SIZE,

                   qed_aio_next_io, acb);

    return;



err:

    qed_aio_complete(acb, ret);

}
",209,"static void qed_aio_read_data(void *opaque, int rets,

                              uint64_t offset, size_t len)

{

    QEDAIOCB *acb = opaque;

    BDRVQEDState *s = acb_to_s(acb);

    BlockDriverState *bs = acb->common.bs;



    /* Adjust offset into cluster */

    offset += qed_offset_into_cluster(s, acb->cur_pos);



    trace_qed_aio_read_data(s, acb, rets, offset, len);



    if (rets < 0) {

        goto err;

    }



    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);



    /* Handle zero cluster and backing file reads */

    if (rets == QED_CLUSTER_ZERO) {

        qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size);

        qed_aio_next_io(acb, 0);

        return;

    } else if (rets != QED_CLUSTER_FOUND) {

        qed_read_backing_file(s, acb->cur_pos, &acb->cur_qiov,

                              qed_aio_next_io, acb);

        return;

    }



    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);

    bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE,

                   &acb->cur_qiov, acb->cur_qiov.size / BDRV_SECTOR_SIZE,

                   qed_aio_next_io, acb);

    return;



err:

    qed_aio_complete(acb, rets);

}
",1,1,0.0,1,"opaque,ret,offset,len,acb,s,bs","opaque:0.0009059011936187744,ret:0.020429551601409912,offset:0.002335846424102783,len:0.011211484670639038,acb:-0.01624324917793274,s:0.00922057032585144,bs:-0.030326128005981445,",1.0,6.0,"ret:rets,",Greedy,108,0.0716084877649943
70,"static AVStream * init_stream(AVFormatContext *s)

{

    BinDemuxContext *bin = s->priv_data;

    AVStream *st = avformat_new_stream(s, NULL);

    if (!st)

        return NULL;

    st->codec->codec_tag   = 0;

    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!bin->width) {

        st->codec->width  = (80<<3);

        st->codec->height = (25<<4);

    }



    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);



    /* simulate tty display speed */

    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);



    return st;

}
",129,"static AVStream * init_stream(AVFormatContext *cs)

{

    BinDemuxContext *pin = cs->priv_data;

    AVStream *stat = avformat_new_stream(cs, NULL);

    if (!stat)

        return NULL;

    stat->codec->codec_tag   = 0;

    stat->codec->codec_type  = AVMEDIA_TYPE_VIDEO;



    if (!pin->width) {

        stat->codec->width  = (80<<3);

        stat->codec->height = (25<<4);

    }



    avpriv_set_pts_info(stat, 60, pin->framerate.den, pin->framerate.num);



    /* simulate tty display speed */

    pin->chars_per_frame = FFMAX(av_q2d(stat->time_base) * pin->chars_per_frame, 1);



    return stat;

}
",1,1,0.0,1,"s,bin,st","s:-0.07664060592651367,bin:-0.028524935245513916,st:0.009177565574645996,",3.0,18.0,"st:stat,bin:pin,s:cs,",Greedy,199,0.1289990146954854
83,"MigrationState *exec_start_outgoing_migration(const char *command,

                                             int64_t bandwidth_limit,

                                             int async)

{

    FdMigrationState *s;

    FILE *f;



    s = qemu_mallocz(sizeof(*s));

    if (s == NULL) {

        dprintf(""Unable to allocate FdMigrationState\n"");

        goto err;

    }



    f = popen(command, ""w"");

    if (f == NULL) {

        dprintf(""Unable to popen exec target\n"");

        goto err_after_alloc;

    }



    s->fd = fileno(f);

    if (s->fd == -1) {

        dprintf(""Unable to retrieve file descriptor for popen'd handle\n"");

        goto err_after_open;

    }



    if (fcntl(s->fd, F_SETFD, O_NONBLOCK) == -1) {

        dprintf(""Unable to set nonblocking mode on file descriptor\n"");

        goto err_after_open;

    }



    s->opaque = qemu_popen(f, ""w"");




    s->get_error = file_errno;

    s->write = file_write;

    s->mig_state.cancel = migrate_fd_cancel;

    s->mig_state.get_status = migrate_fd_get_status;

    s->mig_state.release = migrate_fd_release;



    s->state = MIG_STATE_ACTIVE;

    s->detach = !async;

    s->bandwidth_limit = bandwidth_limit;



    if (s->detach == 1) {

        dprintf(""detaching from monitor\n"");

        monitor_suspend();

        s->detach = 2;

    }



    migrate_fd_connect(s);

    return &s->mig_state;



err_after_open:

    pclose(f);

err_after_alloc:

    qemu_free(s);

err:

    return NULL;

}",257,"MigrationState *exec_start_outgoing_migration(const char *usage,

                                             int64_t bandwidth_limit,

                                             int async)

{

    FdMigrationState *s;

    FILE *f;



    s = qemu_mallocz(sizeof(*s));

    if (s == NULL) {

        dprintf(""Unable to allocate FdMigrationState
"");

        goto err;

    }



    f = popen(usage, ""w"");

    if (f == NULL) {

        dprintf(""Unable to popen exec target
"");

        goto err_after_alloc;

    }



    s->fd = fileno(f);

    if (s->fd == -1) {

        dprintf(""Unable to retrieve file descriptor for popen'd handle
"");

        goto err_after_open;

    }



    if (fcntl(s->fd, F_SETFD, O_NONBLOCK) == -1) {

        dprintf(""Unable to set nonblocking mode on file descriptor
"");

        goto err_after_open;

    }



    s->opaque = qemu_popen(f, ""w"");




    s->get_error = file_errno;

    s->write = file_write;

    s->mig_state.cancel = migrate_fd_cancel;

    s->mig_state.get_status = migrate_fd_get_status;

    s->mig_state.release = migrate_fd_release;



    s->state = MIG_STATE_ACTIVE;

    s->detach = !async;

    s->bandwidth_limit = bandwidth_limit;



    if (s->detach == 1) {

        dprintf(""detaching from monitor
"");

        monitor_suspend();

        s->detach = 2;

    }



    migrate_fd_connect(s);

    return &s->mig_state;



err_after_open:

    pclose(f);

err_after_alloc:

    qemu_free(s);

err:

    return NULL;

}",1,1,0.0,1,"command,bandwidth_limit,async,s,f","command:-0.016598284244537354,bandwidth_limit:0.015184760093688965,async:-0.0008671283721923828,s:-0.05027353763580322,f:-0.01945716142654419,",1.0,2.0,"bandwidth_limit:bandwidth_limit,async:async,command:usage,",Greedy,119,0.0703951199849446
88,"Object *object_resolve_path_component(Object *parent, const gchar *part)

{

    ObjectProperty *prop = object_property_find(parent, part, NULL);

    if (prop == NULL) {

        return NULL;

    }



    if (object_property_is_link(prop)) {

        return *(Object **)prop->opaque;

    } else if (object_property_is_child(prop)) {

        return prop->opaque;

    } else {

        return NULL;

    }

}
",80,"Object *object_resolve_path_component(Object *parent, const gchar *point)

{

    ObjectProperty *prop = object_property_find(parent, point, NULL);

    if (prop == NULL) {

        return NULL;

    }



    if (object_property_is_link(prop)) {

        return *(Object **)prop->opaque;

    } else if (object_property_is_child(prop)) {

        return prop->opaque;

    } else {

        return NULL;

    }

}
",1,1,0.0,1,"parent,part,prop","parent:-0.02950352430343628,part:0.01946347951889038,prop:-0.025164544582366943,",1.0,2.0,"part:point,",Greedy,44,0.0278976678848266
97,"static void handle_satn(ESPState *s)

{

    uint8_t buf[32];

    int len;



    if (s->dma && !s->dma_enabled) {

        s->dma_cb = handle_satn;

        return;

    }

    len = get_cmd(s, buf);

    if (len)

        do_cmd(s, buf);

}
",60,"static void handle_satn(ESPState *fs)

{

    uint8_t fd[32];

    int len;



    if (fs->dma && !fs->dma_enabled) {

        fs->dma_cb = handle_satn;

        return;

    }

    len = get_cmd(fs, fd);

    if (len)

        do_cmd(fs, fd);

}
",1,1,0.0,1,"s,buf,len","s:0.06335937976837158,buf:-0.042143404483795166,len:-0.048640668392181396,",2.0,9.0,"s:fs,buf:fd,",Greedy,119,0.0866785566012064
100,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,

                                                 uint64_t iova, uint64_t len)

{

    struct vhost_iotlb_msg imsg;



    imsg.iova = iova;

    imsg.size = len;

    imsg.type = VHOST_IOTLB_INVALIDATE;



    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);

}
",51,"int vhost_backend_invalidate_device_iotlb(struct vhost_dev *group,

                                                 uint64_t iova, uint64_t len)

{

    struct vhost_iotlb_msg omsgt;



    omsgt.iova = iova;

    omsgt.size = len;

    omsgt.type = VHOST_IOTLB_INVALIDATE;



    return group->vhost_ops->vhost_send_device_iotlb_msg(group, &omsgt);

}
",1,1,0.0,1,"dev,iova,len,imsg","dev:0.20991674065589905,iova:0.019761502742767334,len:0.10548979043960571,imsg:0.21014994382858276,",2.0,8.0,"imsg:omsgt,dev:group,",Greedy,128,0.0900036613146464
116,"FFTContext *av_fft_init(int nbits, int inverse)

{

    FFTContext *s = av_malloc(sizeof(*s));



    if (s && ff_fft_init(s, nbits, inverse))

        av_freep(&s);



    return s;

}
",47,"FFTContext *av_fft_init(int numblocks, int insverted)

{

    FFTContext *local = av_malloc(sizeof(*local));



    if (s && flocal_fft_init(s, numlocallocks, insverted))

        av_freep(&local);



    return local;

}
",1,1,0.0,1,"nbits,inverse,s",,0.0,0.0,"nbits:numblocks,inverse:insverted,s:local,",GA,628,0.4862083276112874
120,"static void sd_1d97_int(int *p, int i0, int i1)

{

    int i;



    if (i1 <= i0 + 1) {

        if (i0 == 1)

            p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;

        else

            p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;

        return;

    }



    extend97_int(p, i0, i1);

    i0++; i1++;



    for (i = i0/2 - 2; i < i1/2 + 1; i++)

        p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;

    for (i = i0/2 - 1; i < i1/2 + 1; i++)

        p[2 * i]     -= (I_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;

    for (i = i0/2 - 1; i < i1/2; i++)

        p[2 * i + 1] += (I_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;

    for (i = i0/2; i < i1/2; i++)

        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;

}
",331,"static void sd_1d97_int(int *p, int i0, int ip1)

{

    int cli;



    if (ip1 <= i0 + 1) {

        if (i0 == 1)

            p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;

        else

            p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;

        return;

    }



    extend97_int(p, i0, ip1);

    i0++; ip1++;



    for (cli = i0/2 - 2; cli < ip1/2 + 1; cli++)

        p[2 * cli + 1] -= (I_LFTG_ALPHA * (p[2 * cli]     + p[2 * cli + 2]) + (1 << 15)) >> 16;

    for (cli = i0/2 - 1; cli < ip1/2 + 1; cli++)

        p[2 * cli]     -= (I_LFTG_BETA  * (p[2 * cli - 1] + p[2 * cli + 1]) + (1 << 15)) >> 16;

    for (cli = i0/2 - 1; cli < ip1/2; cli++)

        p[2 * cli + 1] += (I_LFTG_GAMMA * (p[2 * cli]     + p[2 * cli + 2]) + (1 << 15)) >> 16;

    for (cli = i0/2; cli < ip1/2; cli++)

        p[2 * cli]     += (I_LFTG_DELTA * (p[2 * cli - 1] + p[2 * cli + 1]) + (1 << 15)) >> 16;

}
",1,1,0.0,1,"p,i0,i1,i","p:-0.3609619736671448,i0:-0.2308095097541809,i1:-0.07291406393051147,i:-0.001227736473083496,",2.0,33.0,"i:cli,i1:ip1,",Greedy,222,0.1517493963241577
124,"static int ipmovie_read_packet(AVFormatContext *s,

                               AVPacket *pkt)

{

    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;

    ByteIOContext *pb = &s->pb;

    int ret;



    ret = process_ipmovie_chunk(ipmovie, pb, pkt);

    if (ret == CHUNK_BAD)

        ret = AVERROR_INVALIDDATA;

    else if (ret == CHUNK_EOF)

        ret = AVERROR_IO;

    else if (ret == CHUNK_NOMEM)

        ret = AVERROR_NOMEM;

    else

        ret = 0;



    return ret;

}
",89,"static int ipmovie_read_packet(AVFormatContext *s,

                               AVPacket *pkt)

{

    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;

    ByteIOContext *prot = &s->prot;

    int ret;



    ret = process_ipmovie_chunk(ipmovie, prot, pkt);

    if (ret == CHUNK_BAD)

        ret = AVERROR_INVALIDDATA;

    else if (ret == CHUNK_EOF)

        ret = AVERROR_IO;

    else if (ret == CHUNK_NOMEM)

        ret = AVERROR_NOMEM;

    else

        ret = 0;



    return ret;

}
",1,1,0.0,1,"s,pkt,ipmovie,pb,ret","s:-0.01007986068725586,pkt:-0.027761399745941162,ipmovie:-0.025703132152557373,pb:0.038788676261901855,ret:-0.09886449575424194,",1.0,3.0,"pb:prot,",Greedy,78,0.0603364388147989
132,"static av_cold int png_dec_end(AVCodecContext *avctx)

{

    PNGDecContext *s = avctx->priv_data;



    ff_thread_release_buffer(avctx, &s->previous_picture);

    av_frame_free(&s->previous_picture.f);

    ff_thread_release_buffer(avctx, &s->last_picture);

    av_frame_free(&s->last_picture.f);

    ff_thread_release_buffer(avctx, &s->picture);

    av_frame_free(&s->picture.f);

    av_freep(&s->buffer);

    s->buffer_size = 0;

    av_freep(&s->last_row);

    s->last_row_size = 0;

    av_freep(&s->tmp_row);

    s->tmp_row_size = 0;

    av_freep(&s->extra_data);

    s->extra_data_size = 0;



    return 0;

}
",138,"static av_cold int png_dec_end(AVCodecContext *avcontext)

{

    PNGDecContext *this = avcontext->priv_data;



    ff_thread_release_buffer(avcontext, &this->previous_picture);

    av_frame_free(&this->previous_picture.f);

    ff_thread_release_buffer(avcontext, &this->last_picture);

    av_frame_free(&this->last_picture.f);

    ff_thread_release_buffer(avcontext, &this->picture);

    av_frame_free(&this->picture.f);

    av_freep(&this->buffer);

    this->buffer_size = 0;

    av_freep(&this->last_row);

    this->last_row_size = 0;

    av_freep(&this->tmp_row);

    this->tmp_row_size = 0;

    av_freep(&this->extra_data);

    this->extra_data_size = 0;



    return 0;

}
",1,1,0.0,1,"avctx,s","avctx:0.1714572310447693,s:0.08334735035896301,",2.0,20.0,"avctx:avcontext,s:this,",Greedy,139,0.1070265173912048
136,"static void filter(USPPContext *p, uint8_t *dst[3], uint8_t *src[3],

                   int dst_stride[3], int src_stride[3], int width,

                   int height, uint8_t *qp_store, int qp_stride)

{

    int x, y, i, j;

    const int count = 1<<p->log2_count;



    for (i = 0; i < 3; i++) {

        int is_chroma = !!i;

        int w = width  >> (is_chroma ? p->hsub : 0);

        int h = height >> (is_chroma ? p->vsub : 0);

        int stride = p->temp_stride[i];

        int block = BLOCK >> (is_chroma ? p->hsub : 0);



        if (!src[i] || !dst[i])

            continue;

        for (y = 0; y < h; y++) {

            int index = block + block * stride + y * stride;



            memcpy(p->src[i] + index, src[i] + y * src_stride[i], w );

            for (x = 0; x < block; x++) {

                p->src[i][index     - x - 1] = p->src[i][index +     x    ];

                p->src[i][index + w + x    ] = p->src[i][index + w - x - 1];

            }

        }

        for (y = 0; y < block; y++) {

            memcpy(p->src[i] + (  block-1-y) * stride, p->src[i] + (  y+block  ) * stride, stride);

            memcpy(p->src[i] + (h+block  +y) * stride, p->src[i] + (h-y+block-1) * stride, stride);

        }



        p->frame->linesize[i] = stride;

        memset(p->temp[i], 0, (h + 2 * block) * stride * sizeof(int16_t));

    }



    if (p->qp)

        p->frame->quality = p->qp * FF_QP2LAMBDA;

    else {

        int qpsum=0;

        int qpcount = (height>>4) * (height>>4);



        for (y = 0; y < (height>>4); y++) {

            for (x = 0; x < (width>>4); x++)

                qpsum += qp_store[x + y * qp_stride];

        }

        p->frame->quality = norm_qscale((qpsum + qpcount/2) / qpcount, p->qscale_type) * FF_QP2LAMBDA;

    }

//    init per MB qscale stuff FIXME

    p->frame->height = height;

    p->frame->width  = width;



    for (i = 0; i < count; i++) {

        const int x1 = offset[i+count-1][0];

        const int y1 = offset[i+count-1][1];

        const int x1c = x1 >> p->hsub;

        const int y1c = y1 >> p->vsub;

        const int BLOCKc = BLOCK >> p->hsub;

        int offset;

        AVPacket pkt;

        int got_pkt_ptr;



        av_init_packet(&pkt);

        pkt.data = p->outbuf;

        pkt.size = p->outbuf_size;



        p->frame->data[0] = p->src[0] + x1   + y1   * p->frame->linesize[0];

        p->frame->data[1] = p->src[1] + x1c  + y1c  * p->frame->linesize[1];

        p->frame->data[2] = p->src[2] + x1c  + y1c  * p->frame->linesize[2];

        p->frame->format  = p->avctx_enc[i]->pix_fmt;



        avcodec_encode_video2(p->avctx_enc[i], &pkt, p->frame, &got_pkt_ptr);

        p->frame_dec = p->avctx_enc[i]->coded_frame;



        offset = (BLOCK-x1) + (BLOCK-y1) * p->frame_dec->linesize[0];



        for (y = 0; y < height; y++)

            for (x = 0; x < width; x++)

                p->temp[0][x + y * p->temp_stride[0]] += p->frame_dec->data[0][x + y * p->frame_dec->linesize[0] + offset];



        if (!src[2] || !dst[2])

            continue;



        offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p->frame_dec->linesize[1];



        for (y = 0; y < height>>p->vsub; y++) {

            for (x = 0; x < width>>p->hsub; x++) {

                p->temp[1][x + y * p->temp_stride[1]] += p->frame_dec->data[1][x + y * p->frame_dec->linesize[1] + offset];

                p->temp[2][x + y * p->temp_stride[2]] += p->frame_dec->data[2][x + y * p->frame_dec->linesize[2] + offset];

            }

        }

    }



    for (j = 0; j < 3; j++) {

        int is_chroma = !!j;

        if (!dst[j])

            continue;

        store_slice_c(dst[j], p->temp[j], dst_stride[j], p->temp_stride[j],

                      width  >> (is_chroma ? p->hsub : 0),

                      height >> (is_chroma ? p->vsub : 0),

                      8-p->log2_count);

    }

}
",1136,"static void filter(USPPContext *p, uint8_t *dst[3], uint8_t *fc[3],

                   int dst_stride[3], int src_stride[3], int width,

                   int height, uint8_t *qp_store, int qp_stride)

{

    int x, y, i, j;

    const int count = 1<<p->log2_count;



    for (i = 0; i < 3; i++) {

        int is_chroma = !!i;

        int w = width  >> (is_chroma ? p->hsub : 0);

        int h = height >> (is_chroma ? p->vsub : 0);

        int stride = p->temp_stride[i];

        int block = BLOCK >> (is_chroma ? p->hsub : 0);



        if (!fc[i] || !dst[i])

            continue;

        for (y = 0; y < h; y++) {

            int index = block + block * stride + y * stride;



            memcpy(p->fc[i] + index, fc[i] + y * src_stride[i], w );

            for (x = 0; x < block; x++) {

                p->fc[i][index     - x - 1] = p->fc[i][index +     x    ];

                p->fc[i][index + w + x    ] = p->fc[i][index + w - x - 1];

            }

        }

        for (y = 0; y < block; y++) {

            memcpy(p->fc[i] + (  block-1-y) * stride, p->fc[i] + (  y+block  ) * stride, stride);

            memcpy(p->fc[i] + (h+block  +y) * stride, p->fc[i] + (h-y+block-1) * stride, stride);

        }



        p->frame->linesize[i] = stride;

        memset(p->temp[i], 0, (h + 2 * block) * stride * sizeof(int16_t));

    }



    if (p->qp)

        p->frame->quality = p->qp * FF_QP2LAMBDA;

    else {

        int qpsum=0;

        int qpcount = (height>>4) * (height>>4);



        for (y = 0; y < (height>>4); y++) {

            for (x = 0; x < (width>>4); x++)

                qpsum += qp_store[x + y * qp_stride];

        }

        p->frame->quality = norm_qscale((qpsum + qpcount/2) / qpcount, p->qscale_type) * FF_QP2LAMBDA;

    }

//    init per MB qscale stuff FIXME

    p->frame->height = height;

    p->frame->width  = width;



    for (i = 0; i < count; i++) {

        const int x1 = offset[i+count-1][0];

        const int y1 = offset[i+count-1][1];

        const int x1c = x1 >> p->hsub;

        const int y1c = y1 >> p->vsub;

        const int BLOCKc = BLOCK >> p->hsub;

        int offset;

        AVPacket pkt;

        int got_pkt_ptr;



        av_init_packet(&pkt);

        pkt.data = p->outbuf;

        pkt.size = p->outbuf_size;



        p->frame->data[0] = p->fc[0] + x1   + y1   * p->frame->linesize[0];

        p->frame->data[1] = p->fc[1] + x1c  + y1c  * p->frame->linesize[1];

        p->frame->data[2] = p->fc[2] + x1c  + y1c  * p->frame->linesize[2];

        p->frame->format  = p->avctx_enc[i]->pix_fmt;



        avcodec_encode_video2(p->avctx_enc[i], &pkt, p->frame, &got_pkt_ptr);

        p->frame_dec = p->avctx_enc[i]->coded_frame;



        offset = (BLOCK-x1) + (BLOCK-y1) * p->frame_dec->linesize[0];



        for (y = 0; y < height; y++)

            for (x = 0; x < width; x++)

                p->temp[0][x + y * p->temp_stride[0]] += p->frame_dec->data[0][x + y * p->frame_dec->linesize[0] + offset];



        if (!fc[2] || !dst[2])

            continue;



        offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p->frame_dec->linesize[1];



        for (y = 0; y < height>>p->vsub; y++) {

            for (x = 0; x < width>>p->hsub; x++) {

                p->temp[1][x + y * p->temp_stride[1]] += p->frame_dec->data[1][x + y * p->frame_dec->linesize[1] + offset];

                p->temp[2][x + y * p->temp_stride[2]] += p->frame_dec->data[2][x + y * p->frame_dec->linesize[2] + offset];

            }

        }

    }



    for (j = 0; j < 3; j++) {

        int is_chroma = !!j;

        if (!dst[j])

            continue;

        store_slice_c(dst[j], p->temp[j], dst_stride[j], p->temp_stride[j],

                      width  >> (is_chroma ? p->hsub : 0),

                      height >> (is_chroma ? p->vsub : 0),

                      8-p->log2_count);

    }

}
",1,1,0.0,1,"p,dst,src,dst_stride,src_stride,height,qp_store,qp_stride,x,y,i,j","p:0.026514768600463867,dst:-0.007436603307723999,src:0.03431633114814758,dst_stride:-0.005879640579223633,src_stride:-0.0180932879447937,height:0.012290745973587036,qp_store:-0.021490395069122314,qp_stride:-0.02152276039123535,x:0.0007064640522003174,y:0.009796887636184692,i:-0.023996084928512573,j:0.006394505500793457,",1.0,16.0,"src:fc,",Greedy,265,0.2017442822456359
140,"static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1,

                                    TCGv arg2, int add_ca, int compute_ca,

                                    int compute_ov)

{

    TCGv t0, t1;



    if ((!compute_ca && !compute_ov) ||

        (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2)))  {

        t0 = ret;

    } else {

        t0 = tcg_temp_local_new();

    }



    if (add_ca) {

        t1 = tcg_temp_local_new();

        tcg_gen_mov_tl(t1, cpu_ca);

    } else {

        TCGV_UNUSED(t1);

    }



    if (compute_ca) {

        /* Start with XER CA disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ca, 0);

    }

    if (compute_ov) {

        /* Start with XER OV disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ov, 0);

    }



    tcg_gen_add_tl(t0, arg1, arg2);



    if (compute_ca) {

        gen_op_arith_compute_ca(ctx, t0, arg1, 0);

    }

    if (add_ca) {

        tcg_gen_add_tl(t0, t0, t1);

        gen_op_arith_compute_ca(ctx, t0, t1, 0);

        tcg_temp_free(t1);

    }

    if (compute_ov) {

        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0);

    }



    if (unlikely(Rc(ctx->opcode) != 0))

        gen_set_Rc0(ctx, t0);



    if (!TCGV_EQUAL(t0, ret)) {

        tcg_gen_mov_tl(ret, t0);

        tcg_temp_free(t0);

    }

}
",251,"static inline void gen_op_arith_add(DisasContext *tc, TCGv ret, TCGv arg1,

                                    TCGv arg2, int add_ca, int compute_ca,

                                    int compute_ov)

{

    TCGv t0, t1;



    if ((!compute_ca && !compute_ov) ||

        (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2)))  {

        t0 = ret;

    } else {

        t0 = tcg_temp_local_new();

    }



    if (add_ca) {

        t1 = tcg_temp_local_new();

        tcg_gen_mov_tl(t1, cpu_ca);

    } else {

        TCGV_UNUSED(t1);

    }



    if (compute_ca) {

        /* Start with XER CA disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ca, 0);

    }

    if (compute_ov) {

        /* Start with XER OV disabled, the most likely case */

        tcg_gen_movi_tl(cpu_ov, 0);

    }



    tcg_gen_add_tl(t0, arg1, arg2);



    if (compute_ca) {

        gen_op_arith_compute_ca(tc, t0, arg1, 0);

    }

    if (add_ca) {

        tcg_gen_add_tl(t0, t0, t1);

        gen_op_arith_compute_ca(tc, t0, t1, 0);

        tcg_temp_free(t1);

    }

    if (compute_ov) {

        gen_op_arith_compute_ov(tc, t0, arg1, arg2, 0);

    }



    if (unlikely(Rc(tc->opcode) != 0))

        gen_set_Rc0(tc, t0);



    if (!TCGV_EQUAL(t0, ret)) {

        tcg_gen_mov_tl(ret, t0);

        tcg_temp_free(t0);

    }

}
",1,1,0.0,1,"ctx,ret,arg1,arg2,add_ca,compute_ca,compute_ov,t0,t1","ctx:0.03797605633735657,ret:-0.03309878706932068,arg1:-0.009982883930206299,arg2:0.010360181331634521,add_ca:-0.00436931848526001,compute_ca:0.008598744869232178,compute_ov:0.015027672052383423,t0:-0.010614991188049316,t1:0.010212242603302002,",1.0,6.0,"ctx:tc,",Greedy,125,0.086177909374237
141,"static inline void RENAME(rgb15tobgr24)(const uint8_t *src, uint8_t *dst, int src_size)

{

    const uint16_t *end;

    const uint16_t *mm_end;

    uint8_t *d = dst;

    const uint16_t *s = (const uint16_t*)src;

    end = s + src_size/2;

    __asm__ volatile(PREFETCH""    %0""::""m""(*s):""memory"");

    mm_end = end - 7;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH""    32%1           \n\t""

            ""movq          %1, %%mm0    \n\t""

            ""movq          %1, %%mm1    \n\t""

            ""movq          %1, %%mm2    \n\t""

            ""pand          %2, %%mm0    \n\t""

            ""pand          %3, %%mm1    \n\t""

            ""pand          %4, %%mm2    \n\t""

            ""psllq         $3, %%mm0    \n\t""

            ""psrlq         $2, %%mm1    \n\t""

            ""psrlq         $7, %%mm2    \n\t""

            ""movq       %%mm0, %%mm3    \n\t""

            ""movq       %%mm1, %%mm4    \n\t""

            ""movq       %%mm2, %%mm5    \n\t""

            ""punpcklwd     %5, %%mm0    \n\t""

            ""punpcklwd     %5, %%mm1    \n\t""

            ""punpcklwd     %5, %%mm2    \n\t""

            ""punpckhwd     %5, %%mm3    \n\t""

            ""punpckhwd     %5, %%mm4    \n\t""

            ""punpckhwd     %5, %%mm5    \n\t""

            ""psllq         $8, %%mm1    \n\t""

            ""psllq        $16, %%mm2    \n\t""

            ""por        %%mm1, %%mm0    \n\t""

            ""por        %%mm2, %%mm0    \n\t""

            ""psllq         $8, %%mm4    \n\t""

            ""psllq        $16, %%mm5    \n\t""

            ""por        %%mm4, %%mm3    \n\t""

            ""por        %%mm5, %%mm3    \n\t""



            ""movq       %%mm0, %%mm6    \n\t""

            ""movq       %%mm3, %%mm7    \n\t""



            ""movq         8%1, %%mm0    \n\t""

            ""movq         8%1, %%mm1    \n\t""

            ""movq         8%1, %%mm2    \n\t""

            ""pand          %2, %%mm0    \n\t""

            ""pand          %3, %%mm1    \n\t""

            ""pand          %4, %%mm2    \n\t""

            ""psllq         $3, %%mm0    \n\t""

            ""psrlq         $2, %%mm1    \n\t""

            ""psrlq         $7, %%mm2    \n\t""

            ""movq       %%mm0, %%mm3    \n\t""

            ""movq       %%mm1, %%mm4    \n\t""

            ""movq       %%mm2, %%mm5    \n\t""

            ""punpcklwd     %5, %%mm0    \n\t""

            ""punpcklwd     %5, %%mm1    \n\t""

            ""punpcklwd     %5, %%mm2    \n\t""

            ""punpckhwd     %5, %%mm3    \n\t""

            ""punpckhwd     %5, %%mm4    \n\t""

            ""punpckhwd     %5, %%mm5    \n\t""

            ""psllq         $8, %%mm1    \n\t""

            ""psllq        $16, %%mm2    \n\t""

            ""por        %%mm1, %%mm0    \n\t""

            ""por        %%mm2, %%mm0    \n\t""

            ""psllq         $8, %%mm4    \n\t""

            ""psllq        $16, %%mm5    \n\t""

            ""por        %%mm4, %%mm3    \n\t""

            ""por        %%mm5, %%mm3    \n\t""



            :""=m""(*d)

            :""m""(*s),""m""(mask15b),""m""(mask15g),""m""(mask15r), ""m""(mmx_null)

            :""memory"");

        /* borrowed 32 to 24 */

        __asm__ volatile(

            ""movq       %%mm0, %%mm4    \n\t""

            ""movq       %%mm3, %%mm5    \n\t""

            ""movq       %%mm6, %%mm0    \n\t""

            ""movq       %%mm7, %%mm1    \n\t""



            ""movq       %%mm4, %%mm6    \n\t""

            ""movq       %%mm5, %%mm7    \n\t""

            ""movq       %%mm0, %%mm2    \n\t""

            ""movq       %%mm1, %%mm3    \n\t""



            STORE_BGR24_MMX



            :""=m""(*d)

            :""m""(*s)

            :""memory"");

        d += 24;

        s += 8;

    }

    __asm__ volatile(SFENCE:::""memory"");

    __asm__ volatile(EMMS:::""memory"");

    while (s < end) {

        register uint16_t bgr;

        bgr = *s++;

        *d++ = (bgr&0x1F)<<3;

        *d++ = (bgr&0x3E0)>>2;

        *d++ = (bgr&0x7C00)>>7;

    }

}
",437,"static inline void RENAME(rgb15tobgr24)(const uint8_t *src, uint8_t *fsrc, int rc_scale)

{

    const uint16_t *nd;

    const uint16_t *mm_max;

    uint8_t *d = fsrc;

    const uint16_t *s = (const uint16_t*)src;

    nd = s + rc_scale/2;

    __asm__ volatile(PREFETCH""    %0""::""m""(*s):""memory"");

    mm_max = nd - 7;

    while (s < mm_max) {

        __asm__ volatile(

            PREFETCH""    32%1           
\t""

            ""movq          %1, %%mm0    
\t""

            ""movq          %1, %%mm1    
\t""

            ""movq          %1, %%mm2    
\t""

            ""pand          %2, %%mm0    
\t""

            ""pand          %3, %%mm1    
\t""

            ""pand          %4, %%mm2    
\t""

            ""psllq         $3, %%mm0    
\t""

            ""psrlq         $2, %%mm1    
\t""

            ""psrlq         $7, %%mm2    
\t""

            ""movq       %%mm0, %%mm3    
\t""

            ""movq       %%mm1, %%mm4    
\t""

            ""movq       %%mm2, %%mm5    
\t""

            ""punpcklwd     %5, %%mm0    
\t""

            ""punpcklwd     %5, %%mm1    
\t""

            ""punpcklwd     %5, %%mm2    
\t""

            ""punpckhwd     %5, %%mm3    
\t""

            ""punpckhwd     %5, %%mm4    
\t""

            ""punpckhwd     %5, %%mm5    
\t""

            ""psllq         $8, %%mm1    
\t""

            ""psllq        $16, %%mm2    
\t""

            ""por        %%mm1, %%mm0    
\t""

            ""por        %%mm2, %%mm0    
\t""

            ""psllq         $8, %%mm4    
\t""

            ""psllq        $16, %%mm5    
\t""

            ""por        %%mm4, %%mm3    
\t""

            ""por        %%mm5, %%mm3    
\t""



            ""movq       %%mm0, %%mm6    
\t""

            ""movq       %%mm3, %%mm7    
\t""



            ""movq         8%1, %%mm0    
\t""

            ""movq         8%1, %%mm1    
\t""

            ""movq         8%1, %%mm2    
\t""

            ""pand          %2, %%mm0    
\t""

            ""pand          %3, %%mm1    
\t""

            ""pand          %4, %%mm2    
\t""

            ""psllq         $3, %%mm0    
\t""

            ""psrlq         $2, %%mm1    
\t""

            ""psrlq         $7, %%mm2    
\t""

            ""movq       %%mm0, %%mm3    
\t""

            ""movq       %%mm1, %%mm4    
\t""

            ""movq       %%mm2, %%mm5    
\t""

            ""punpcklwd     %5, %%mm0    
\t""

            ""punpcklwd     %5, %%mm1    
\t""

            ""punpcklwd     %5, %%mm2    
\t""

            ""punpckhwd     %5, %%mm3    
\t""

            ""punpckhwd     %5, %%mm4    
\t""

            ""punpckhwd     %5, %%mm5    
\t""

            ""psllq         $8, %%mm1    
\t""

            ""psllq        $16, %%mm2    
\t""

            ""por        %%mm1, %%mm0    
\t""

            ""por        %%mm2, %%mm0    
\t""

            ""psllq         $8, %%mm4    
\t""

            ""psllq        $16, %%mm5    
\t""

            ""por        %%mm4, %%mm3    
\t""

            ""por        %%mm5, %%mm3    
\t""



            :""=m""(*d)

            :""m""(*s),""m""(mask15b),""m""(mask15g),""m""(mask15r), ""m""(mmx_null)

            :""memory"");

        /* borrowed 32 to 24 */

        __asm__ volatile(

            ""movq       %%mm0, %%mm4    
\t""

            ""movq       %%mm3, %%mm5    
\t""

            ""movq       %%mm6, %%mm0    
\t""

            ""movq       %%mm7, %%mm1    
\t""



            ""movq       %%mm4, %%mm6    
\t""

            ""movq       %%mm5, %%mm7    
\t""

            ""movq       %%mm0, %%mm2    
\t""

            ""movq       %%mm1, %%mm3    
\t""



            STORE_BGR24_MMX



            :""=m""(*d)

            :""m""(*s)

            :""memory"");

        d += 24;

        s += 8;

    }

    __asm__ volatile(SFENCE:::""memory"");

    __asm__ volatile(EMMS:::""memory"");

    while (s < nd) {

        register uint16_t bgr;

        bgr = *s++;

        *d++ = (bgr&0x1F)<<3;

        *d++ = (bgr&0x3E0)>>2;

        *d++ = (bgr&0x7C00)>>7;

    }

}
",1,1,0.0,1,"src,dst,src_size,end,mm_end,d,s","src:-0.030959665775299072,dst:-0.013279378414154053,src_size:0.008955001831054688,end:-0.00564122200012207,mm_end:0.002612769603729248,d:-0.030691087245941162,s:-0.02839595079421997,",4.0,11.0,"src_size:rc_scale,mm_end:mm_max,end:nd,dst:fsrc,",Greedy,123,0.1053938229878743
159,"static void test_qemu_strtoll_whitespace(void)

{

    const char *str = ""  \t  "";

    char f = 'X';

    const char *endptr = &f;

    int64_t res = 999;

    int err;



    err = qemu_strtoll(str, &endptr, 0, &res);



    g_assert_cmpint(err, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
",79,"static void test_qemu_strtoll_whitespace(void)

{

    const char *str = ""  \t  "";

    char f = 'X';

    const char *endptr = &f;

    int64_t res = 999;

    int dr;



    dr = qemu_strtoll(str, &endptr, 0, &res);



    g_assert_cmpint(dr, ==, 0);

    g_assert_cmpint(res, ==, 0);

    g_assert(endptr == str);

}
",1,1,0.0,1,"str,endptr,err","str:-0.08729642629623413,endptr:0.0674780011177063,err:0.20982253551483154,",1.0,3.0,"err:dr,",Greedy,58,0.0481857180595397
165,"static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,

                            AVPacket *avpkt) {

    const uint8_t *buf = avpkt->data;


    PTXContext * const s = avctx->priv_data;

    AVFrame *picture = data;

    AVFrame * const p = &s->picture;

    unsigned int offset, w, h, y, stride, bytes_per_pixel;

    uint8_t *ptr;





    offset          = AV_RL16(buf);

    w               = AV_RL16(buf+8);

    h               = AV_RL16(buf+10);

    bytes_per_pixel = AV_RL16(buf+12) >> 3;



    if (bytes_per_pixel != 2) {

        av_log_ask_for_sample(avctx, ""Image format is not RGB15.\n"");

        return -1;

    }



    avctx->pix_fmt = PIX_FMT_RGB555;



    if (buf_end - buf < offset)


    if (offset != 0x2c)

        av_log_ask_for_sample(avctx, ""offset != 0x2c\n"");



    buf += offset;



    if (p->data[0])

        avctx->release_buffer(avctx, p);



    if (av_image_check_size(w, h, 0, avctx))

        return -1;

    if (w != avctx->width || h != avctx->height)

        avcodec_set_dimensions(avctx, w, h);

    if (avctx->get_buffer(avctx, p) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return -1;

    }



    p->pict_type = AV_PICTURE_TYPE_I;



    ptr    = p->data[0];

    stride = p->linesize[0];



    for (y=0; y<h; y++) {

        if (buf_end - buf < w * bytes_per_pixel)

            break;

#if HAVE_BIGENDIAN

        unsigned int x;

        for (x=0; x<w*bytes_per_pixel; x+=bytes_per_pixel)

            AV_WN16(ptr+x, AV_RL16(buf+x));

#else

        memcpy(ptr, buf, w*bytes_per_pixel);

#endif

        ptr += stride;

        buf += w*bytes_per_pixel;

    }



    *picture = s->picture;

    *data_size = sizeof(AVPicture);



    return offset + w*h*bytes_per_pixel;

}",381,"static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,

                            AVPacket *avpkt) {

    const uint8_t *buf = avpkt->data;


    PTXContext * const service = avctx->priv_data;

    AVFrame *picture = data;

    AVFrame * const p = &service->picture;

    unsigned int port, w, h, y, stride, bytes_per_channel;

    uint8_t *ptr;





    port          = AV_RL16(buf);

    w               = AV_RL16(buf+8);

    h               = AV_RL16(buf+10);

    bytes_per_channel = AV_RL16(buf+12) >> 3;



    if (bytes_per_channel != 2) {

        av_log_ask_for_sample(avctx, ""Image format is not RGB15.
"");

        return -1;

    }



    avctx->pix_fmt = PIX_FMT_RGB555;



    if (buf_end - buf < port)


    if (port != 0x2c)

        av_log_ask_for_sample(avctx, ""offset != 0x2c
"");



    buf += port;



    if (p->data[0])

        avctx->release_buffer(avctx, p);



    if (av_image_check_size(w, h, 0, avctx))

        return -1;

    if (w != avctx->width || h != avctx->height)

        avcodec_set_dimensions(avctx, w, h);

    if (avctx->get_buffer(avctx, p) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed
"");

        return -1;

    }



    p->pict_type = AV_PICTURE_TYPE_I;



    ptr    = p->data[0];

    stride = p->linesize[0];



    for (y=0; y<h; y++) {

        if (buf_end - buf < w * bytes_per_channel)

            break;

#if HAVE_BIGENDIAN

        unsigned int x;

        for (x=0; x<w*bytes_per_channel; x+=bytes_per_channel)

            AV_WN16(ptr+x, AV_RL16(buf+x));

#else

        memcpy(ptr, buf, w*bytes_per_channel);

#endif

        ptr += stride;

        buf += w*bytes_per_channel;

    }



    *picture = service->picture;

    *data_size = sizeof(AVPicture);



    return port + w*h*bytes_per_channel;

}",1,1,0.0,1,"avctx,data,data_size,avpkt,buf,s,picture,p,offset,w,h,y,stride,bytes_per_pixel,ptr,x","avctx:-0.06338119506835938,data:-0.014302968978881836,data_size:-0.012905538082122803,avpkt:-0.021912813186645508,buf:-0.017625153064727783,s:0.016067683696746826,picture:0.004977881908416748,p:-0.0011169910430908203,offset:0.007365822792053223,w:0.004671752452850342,h:0.0020852088928222656,y:0.0002808570861816406,stride:-0.012636661529541016,bytes_per_pixel:0.035736143589019775,ptr:-0.0333552360534668,x:0.004606962203979492,",3.0,18.0,"bytes_per_pixel:bytes_per_channel,s:service,offset:port,",Greedy,228,0.1656200687090555
166,"static void vpc_close(BlockDriverState *bs)

{

    BDRVVPCState *s = bs->opaque;

    g_free(s->pagetable);

#ifdef CACHE

    g_free(s->pageentry_u8);

#endif



    migrate_del_blocker(s->migration_blocker);

    error_free(s->migration_blocker);

}
",49,"static void vpc_close(BlockDriverState *state)

{

    BDRVVPCState *ss = state->opaque;

    g_free(ss->pagetable);

#ifdef CACHE

    g_free(ss->pageentry_u8);

#endif



    migrate_del_blocker(ss->migration_blocker);

    error_free(ss->migration_blocker);

}
",1,1,0.0,1,"bs,s","bs:0.03388455510139465,s:0.018377304077148438,",2.0,7.0,"bs:state,s:ss,",Greedy,95,0.0754053314526875
168,"static int mxf_read_header(AVFormatContext *s, AVFormatParameters *ap)

{

    MXFContext *mxf = s->priv_data;

    KLVPacket klv;

    int64_t essence_offset = 0;



    mxf->last_forward_tell = INT64_MAX;



    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {

        av_log(s, AV_LOG_ERROR, ""could not find header partition pack key\n"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(s->pb, -14, SEEK_CUR);

    mxf->fc = s;

    mxf->run_in = avio_tell(s->pb);



    while (!s->pb->eof_reached) {

        const MXFMetadataReadTableEntry *metadata;



        if (klv_read_packet(&klv, s->pb) < 0) {

            /* EOF - seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

            else

                continue;

        }



        PRINT_KEY(s, ""read header"", klv.key);

        av_dlog(s, ""size %""PRIu64"" offset %#""PRIx64""\n"", klv.length, klv.offset);

        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||

            IS_KLV_KEY(klv.key, mxf_essence_element_key) ||

            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||

            IS_KLV_KEY(klv.key, mxf_system_item_key)) {

            if (!mxf->current_partition->essence_offset) {

                compute_partition_essence_offset(s, mxf, &klv);

            }



            if (!essence_offset)

                essence_offset = klv.offset;



            /* seek to footer, previous partition or stop */

            if (mxf_parse_handle_essence(mxf) <= 0)

                break;

            continue;

        } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&

                   klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->current_partition) {

            /* next partition pack - keep going, seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

        }



        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {

            if (IS_KLV_KEY(klv.key, metadata->key)) {

                int res;

                if (klv.key[5] == 0x53) {

                    res = mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type);

                } else {

                    uint64_t next = avio_tell(s->pb) + klv.length;

                    res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);

                    avio_seek(s->pb, next, SEEK_SET);

                }

                if (res < 0) {

                    av_log(s, AV_LOG_ERROR, ""error reading header metadata\n"");

                    return res;

                }

                break;

            }

        }

        if (!metadata->read)

            avio_skip(s->pb, klv.length);

    }

    /* FIXME avoid seek */

    if (!essence_offset)  {

        av_log(s, AV_LOG_ERROR, ""no essence\n"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(s->pb, essence_offset, SEEK_SET);



    mxf_compute_essence_containers(mxf);



    return mxf_parse_structural_metadata(mxf);

}
",514,"static int mxf_read_header(AVFormatContext *types, AVFormatParameters *ap)

{

    MXFContext *mxf = types->priv_data;

    KLVPacket klv;

    int64_t essence_offset = 0;



    mxf->last_forward_tell = INT64_MAX;



    if (!mxf_read_sync(types->pb, mxf_header_partition_pack_key, 14)) {

        av_log(types, AV_LOG_ERROR, ""could not find header partition pack key
"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(types->pb, -14, SEEK_CUR);

    mxf->fc = types;

    mxf->run_in = avio_tell(types->pb);



    while (!types->pb->eof_reached) {

        const MXFMetadataReadTableEntry *metadata;



        if (klv_read_packet(&klv, types->pb) < 0) {

            /* EOF - seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

            else

                continue;

        }



        PRINT_KEY(types, ""read header"", klv.key);

        av_dlog(types, ""size %""PRIu64"" offset %#""PRIx64""
"", klv.length, klv.offset);

        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||

            IS_KLV_KEY(klv.key, mxf_essence_element_key) ||

            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||

            IS_KLV_KEY(klv.key, mxf_system_item_key)) {

            if (!mxf->current_partition->essence_offset) {

                compute_partition_essence_offset(types, mxf, &klv);

            }



            if (!essence_offset)

                essence_offset = klv.offset;



            /* seek to footer, previous partition or stop */

            if (mxf_parse_handle_essence(mxf) <= 0)

                break;

            continue;

        } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&

                   klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->current_partition) {

            /* next partition pack - keep going, seek to previous partition or stop */

            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)

                break;

        }



        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {

            if (IS_KLV_KEY(klv.key, metadata->key)) {

                int res;

                if (klv.key[5] == 0x53) {

                    res = mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type);

                } else {

                    uint64_t next = avio_tell(types->pb) + klv.length;

                    res = metadata->read(mxf, types->pb, 0, klv.length, klv.key, klv.offset);

                    avio_seek(types->pb, next, SEEK_SET);

                }

                if (res < 0) {

                    av_log(types, AV_LOG_ERROR, ""error reading header metadata
"");

                    return res;

                }

                break;

            }

        }

        if (!metadata->read)

            avio_skip(types->pb, klv.length);

    }

    /* FIXME avoid seek */

    if (!essence_offset)  {

        av_log(types, AV_LOG_ERROR, ""no essence
"");

        return AVERROR_INVALIDDATA;

    }

    avio_seek(types->pb, essence_offset, SEEK_SET);



    mxf_compute_essence_containers(mxf);



    return mxf_parse_structural_metadata(mxf);

}
",1,1,0.0,1,"s,ap,mxf,klv,metadata","s:0.03246709704399109,ap:-0.0010553300380706787,mxf:-0.0014899075031280518,klv:-0.03328558802604675,metadata:-0.0005492269992828369,",1.0,19.0,"s:types,",Greedy,142,0.106406025091807
183,"static int parse_uint8(DeviceState *dev, Property *prop, const char *str)

{

    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
",77,"static int parse_uint8(DeviceState *ver, Property *prot, const char *strings)

{

    uint8_t *fd = qdev_get_prop_ptr(ver, prot);

    const char *fxmt;



    /* accept both hex and decimal */

    fxmt = strncasecmp(strings, ""0x"",2) == 0 ? ""%"" PRIx8 : ""%"" PRIu8;

    if (sscanf(strings, fxmt, fd) != 1)

        return -EINVAL;

    return 0;

}
",1,1,0.0,1,"dev,prop,str,ptr,fmt","dev:0.02829831838607788,prop:-0.057393431663513184,str:-0.12640053033828735,ptr:-0.1381760835647583,fmt:0.0044522881507873535,",5.0,12.0,"dev:ver,fmt:fxmt,prop:prot,str:strings,ptr:fd,",Greedy,195,0.0976118206977844
197,"DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)

{

    DeviceClass *dc;

    const char *driver, *path;

    DeviceState *dev;

    BusState *bus = NULL;

    Error *err = NULL;



    driver = qemu_opt_get(opts, ""driver"");

    if (!driver) {

        error_setg(errp, QERR_MISSING_PARAMETER, ""driver"");

        return NULL;

    }



    /* find driver */

    dc = qdev_get_device_class(&driver, errp);

    if (!dc) {

        return NULL;

    }



    /* find bus */

    path = qemu_opt_get(opts, ""bus"");

    if (path != NULL) {

        bus = qbus_find(path, errp);

        if (!bus) {

            return NULL;

        }

        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {

            error_setg(errp, ""Device '%s' can't go on %s bus"",

                       driver, object_get_typename(OBJECT(bus)));

            return NULL;

        }

    } else if (dc->bus_type != NULL) {

        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);

        if (!bus || qbus_is_full(bus)) {

            error_setg(errp, ""No '%s' bus found for device '%s'"",

                       dc->bus_type, driver);

            return NULL;

        }

    }

    if (qdev_hotplug && bus && !qbus_is_hotpluggable(bus)) {

        error_setg(errp, QERR_BUS_NO_HOTPLUG, bus->name);

        return NULL;

    }



    if (!migration_is_idle()) {

        error_setg(errp, ""device_add not allowed while migrating"");

        return NULL;

    }



    /* create device */

    dev = DEVICE(object_new(driver));



    if (bus) {

        qdev_set_parent_bus(dev, bus);






    }



    qdev_set_id(dev, qemu_opts_id(opts));



    /* set properties */

    if (qemu_opt_foreach(opts, set_property, dev, &err)) {


    }



    dev->opts = opts;

    object_property_set_bool(OBJECT(dev), true, ""realized"", &err);

    if (err != NULL) {

        dev->opts = NULL;


    }

    return dev;



err_del_dev:

    error_propagate(errp, err);

    object_unparent(OBJECT(dev));

    object_unref(OBJECT(dev));

    return NULL;

}",387,"DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)

{

    DeviceClass *dc;

    const char *driver, *path;

    DeviceState *device;

    BusState *bus = NULL;

    Error *err = NULL;



    driver = qemu_opt_get(opts, ""driver"");

    if (!driver) {

        error_setg(errp, QERR_MISSING_PARAMETER, ""driver"");

        return NULL;

    }



    /* find driver */

    dc = qdev_get_device_class(&driver, errp);

    if (!dc) {

        return NULL;

    }



    /* find bus */

    path = qemu_opt_get(opts, ""bus"");

    if (path != NULL) {

        bus = qbus_find(path, errp);

        if (!bus) {

            return NULL;

        }

        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {

            error_setg(errp, ""Device '%s' can't go on %s bus"",

                       driver, object_get_typename(OBJECT(bus)));

            return NULL;

        }

    } else if (dc->bus_type != NULL) {

        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);

        if (!bus || qbus_is_full(bus)) {

            error_setg(errp, ""No '%s' bus found for device '%s'"",

                       dc->bus_type, driver);

            return NULL;

        }

    }

    if (qdev_hotplug && bus && !qbus_is_hotpluggable(bus)) {

        error_setg(errp, QERR_BUS_NO_HOTPLUG, bus->name);

        return NULL;

    }



    if (!migration_is_idle()) {

        error_setg(errp, ""device_add not allowed while migrating"");

        return NULL;

    }



    /* create device */

    device = DEVICE(object_new(driver));



    if (bus) {

        qdev_set_parent_bus(device, bus);






    }



    qdev_set_id(device, qemu_opts_id(opts));



    /* set properties */

    if (qemu_opt_foreach(opts, set_property, device, &err)) {


    }



    device->opts = opts;

    object_property_set_bool(OBJECT(device), true, ""realized"", &err);

    if (err != NULL) {

        device->opts = NULL;


    }

    return device;



err_del_dev:

    error_propagate(errp, err);

    object_unparent(OBJECT(device));

    object_unref(OBJECT(device));

    return NULL;

}",1,1,0.0,1,"opts,errp,dc,driver,path,dev,bus,err","opts:-0.09128737449645996,errp:-0.11225926876068115,dc:-0.004837214946746826,driver:0.005179852247238159,path:-0.025273114442825317,dev:0.020565062761306763,bus:-0.0021940767765045166,err:-0.005017489194869995,",1.0,11.0,"dev:device,",Greedy,122,0.0847521622975667
200,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)

{

    unsigned nz = idx >> 12;



    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));

    sign <<= nz & 1;

    nz >>= 1;

    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));



    return dst + 4;

}
",178,"static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned type)

{

    unsigned nz = idx >> 12;



    dst[0] = (idx & 3) * (1 + (((int)type >> 31) << 1));

    type <<= nz & 1;

    nz >>= 1;

    dst[1] = (idx >> 2 & 3) * (1 + (((int)type >> 31) << 1));

    type <<= nz & 1;

    nz >>= 1;

    dst[2] = (idx >> 4 & 3) * (1 + (((int)type >> 31) << 1));

    type <<= nz & 1;

    nz >>= 1;

    dst[3] = (idx >> 6 & 3) * (1 + (((int)type >> 31) << 1));



    return dst + 4;

}
",1,1,0.0,1,"dst,idx,sign","dst:-0.16342806816101074,idx:-0.1491277813911438,sign:-0.08691930770874023,",1.0,8.0,"sign:type,",Greedy,91,0.06581844886144
220,"static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

	long width, long height,

	long lumStride, long chromStride, long dstStride)

{

	RENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);

}
",70,"static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysync, const uint8_t * usource, const uint8_t *vsrc, uint8_t *DST,

	long width, long height,

	long lumStride, long chromStride, long dstSTue)

{

	RENAME(yuvPlanartoyuy2)(ysync,  usource, vsrc, DST, width, height, lumStride, chromStride, dstSTue, 1);

}
",1,1,0.0,1,"ysrc,usrc,vsrc,dst,height,lumStride,chromStride,dstStride","ysrc:0.36718910932540894,usrc:0.09640765190124512,vsrc:0.06788155436515808,dst:0.11938613653182983,height:0.01511409878730774,lumStride:-0.03040340542793274,chromStride:0.014011353254318237,dstStride:0.08564403653144836,",4.0,8.0,"ysrc:ysync,dst:DST,usrc: usource,dstStride:dstSTue,",Greedy,130,0.1058242042859395
224,"static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,

                                   unsigned int imms, unsigned int immr)

{

    uint64_t mask;

    unsigned e, levels, s, r;

    int len;



    assert(immn < 2 && imms < 64 && immr < 64);



    /* The bit patterns we create here are 64 bit patterns which

     * are vectors of identical elements of size e = 2, 4, 8, 16, 32 or

     * 64 bits each. Each element contains the same value: a run

     * of between 1 and e-1 non-zero bits, rotated within the

     * element by between 0 and e-1 bits.

     *

     * The element size and run length are encoded into immn (1 bit)

     * and imms (6 bits) as follows:

     * 64 bit elements: immn = 1, imms = <length of run - 1>

     * 32 bit elements: immn = 0, imms = 0 : <length of run - 1>

     * 16 bit elements: immn = 0, imms = 10 : <length of run - 1>

     *  8 bit elements: immn = 0, imms = 110 : <length of run - 1>

     *  4 bit elements: immn = 0, imms = 1110 : <length of run - 1>

     *  2 bit elements: immn = 0, imms = 11110 : <length of run - 1>

     * Notice that immn = 0, imms = 11111x is the only combination

     * not covered by one of the above options; this is reserved.

     * Further, <length of run - 1> all-ones is a reserved pattern.

     *

     * In all cases the rotation is by immr % e (and immr is 6 bits).

     */



    /* First determine the element size */

    len = 31 - clz32((immn << 6) | (~imms & 0x3f));

    if (len < 1) {

        /* This is the immn == 0, imms == 0x11111x case */

        return false;

    }

    e = 1 << len;



    levels = e - 1;

    s = imms & levels;

    r = immr & levels;



    if (s == levels) {

        /* <length of run - 1> mustn't be all-ones. */

        return false;

    }



    /* Create the value of one element: s+1 set bits rotated

     * by r within the element (which is e bits wide)...

     */

    mask = bitmask64(s + 1);

    mask = (mask >> r) | (mask << (e - r));

    /* ...then replicate the element over the whole 64 bit value */

    mask = bitfield_replicate(mask, e);

    *result = mask;

    return true;

}
",162,"static bool logic_imm_decode_wmask(uint64_t *allow, unsigned int immn,

                                   unsigned int imms, unsigned int immr)

{

    uint64_t mask;

    unsigned e, levels, s, r;

    int len;



    assert(immn < 2 && imms < 64 && immr < 64);



    /* The bit patterns we create here are 64 bit patterns which

     * are vectors of identical elements of size e = 2, 4, 8, 16, 32 or

     * 64 bits each. Each element contains the same value: a run

     * of between 1 and e-1 non-zero bits, rotated within the

     * element by between 0 and e-1 bits.

     *

     * The element size and run length are encoded into immn (1 bit)

     * and imms (6 bits) as follows:

     * 64 bit elements: immn = 1, imms = <length of run - 1>

     * 32 bit elements: immn = 0, imms = 0 : <length of run - 1>

     * 16 bit elements: immn = 0, imms = 10 : <length of run - 1>

     *  8 bit elements: immn = 0, imms = 110 : <length of run - 1>

     *  4 bit elements: immn = 0, imms = 1110 : <length of run - 1>

     *  2 bit elements: immn = 0, imms = 11110 : <length of run - 1>

     * Notice that immn = 0, imms = 11111x is the only combination

     * not covered by one of the above options; this is reserved.

     * Further, <length of run - 1> all-ones is a reserved pattern.

     *

     * In all cases the rotation is by immr % e (and immr is 6 bits).

     */



    /* First determine the element size */

    len = 31 - clz32((immn << 6) | (~imms & 0x3f));

    if (len < 1) {

        /* This is the immn == 0, imms == 0x11111x case */

        return false;

    }

    e = 1 << len;



    levels = e - 1;

    s = imms & levels;

    r = immr & levels;



    if (s == levels) {

        /* <length of run - 1> mustn't be all-ones. */

        return false;

    }



    /* Create the value of one element: s+1 set bits rotated

     * by r within the element (which is e bits wide)...

     */

    mask = bitmask64(s + 1);

    mask = (mask >> r) | (mask << (e - r));

    /* ...then replicate the element over the whole 64 bit value */

    mask = bitfield_replicate(mask, e);

    *allow = mask;

    return true;

}
",1,1,0.0,1,"result,immn,imms,immr,mask,e,levels,s,r,len","result:0.04886239767074585,immn:-0.0277252197265625,imms:0.043853163719177246,immr:0.021066606044769287,mask:-0.03247427940368652,e:-0.0030747652053833008,levels:0.006169915199279785,s:-0.03009510040283203,r:0.014075279235839844,len:-0.026054859161376953,",1.0,2.0,"result:allow,",Greedy,88,0.0657982110977172
244,"static int idreg_init1(SysBusDevice *dev)

{

    IDRegState *s = MACIO_ID_REGISTER(dev);



    memory_region_init_ram(&s->mem, OBJECT(s),

                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);

    vmstate_register_ram_global(&s->mem);

    memory_region_set_readonly(&s->mem, true);

    sysbus_init_mmio(dev, &s->mem);

    return 0;

}
",74,"static int idreg_init1(SysBusDevice *link)

{

    IDRegState *sec = MACIO_ID_REGISTER(link);



    memory_region_init_ram(&sec->mem, OBJECT(sec),

                           ""sun4m.idreg"", sizeof(idreg_data), &error_abort);

    vmstate_register_ram_global(&sec->mem);

    memory_region_set_readonly(&sec->mem, true);

    sysbus_init_mmio(link, &sec->mem);

    return 0;

}
",1,1,0.0,1,"dev,s","dev:-0.08900246024131775,s:0.03508198261260986,",2.0,9.0,"s:sec,dev:link,",Greedy,111,0.0833399772644043
252,"static inline void RENAME(hyscale)(uint16_t *dst, int dstWidth, uint8_t *src, int srcW, int xInc)

{

#ifdef HAVE_MMX

	// use the new MMX scaler if th mmx2 cant be used (its faster than the x86asm one)

    if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed))

#else

    if(sws_flags != SWS_FAST_BILINEAR)

#endif

    {

    	RENAME(hScale)(dst, dstWidth, src, srcW, xInc, hLumFilter, hLumFilterPos, hLumFilterSize);

    }

    else // Fast Bilinear upscale / crap downscale

    {

#ifdef ARCH_X86

#ifdef HAVE_MMX2

	int i;

	if(canMMX2BeUsed)

	{

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""pxor %%mm2, %%mm2		\n\t"" // 2*xalpha

			""movd %5, %%mm6			\n\t"" // xInc&0xFFFF

			""punpcklwd %%mm6, %%mm6		\n\t""

			""punpcklwd %%mm6, %%mm6		\n\t""

			""movq %%mm6, %%mm2		\n\t""

			""psllq $16, %%mm2		\n\t""

			""paddw %%mm6, %%mm2		\n\t""

			""psllq $16, %%mm2		\n\t""

			""paddw %%mm6, %%mm2		\n\t""

			""psllq $16, %%mm2		\n\t"" //0,t,2t,3t		t=xInc&0xFF

			""movq %%mm2, ""MANGLE(temp0)""	\n\t""

			""movd %4, %%mm6			\n\t"" //(xInc*4)&0xFFFF

			""punpcklwd %%mm6, %%mm6		\n\t""

			""punpcklwd %%mm6, %%mm6		\n\t""

			""xorl %%eax, %%eax		\n\t"" // i

			""movl %0, %%esi			\n\t"" // src

			""movl %1, %%edi			\n\t"" // buf1

			""movl %3, %%edx			\n\t"" // (xInc*4)>>16

			""xorl %%ecx, %%ecx		\n\t""

			""xorl %%ebx, %%ebx		\n\t""

			""movw %4, %%bx			\n\t"" // (xInc*4)&0xFFFF



#define FUNNY_Y_CODE \

			PREFETCH"" 1024(%%esi)		\n\t""\

			PREFETCH"" 1056(%%esi)		\n\t""\

			PREFETCH"" 1088(%%esi)		\n\t""\

			""call ""MANGLE(funnyYCode)""	\n\t""\

			""movq ""MANGLE(temp0)"", %%mm2	\n\t""\

			""xorl %%ecx, %%ecx		\n\t""



FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE



			:: ""m"" (src), ""m"" (dst), ""m"" (dstWidth), ""m"" ((xInc*4)>>16),

			""m"" ((xInc*4)&0xFFFF), ""m"" (xInc&0xFFFF)

			: ""%eax"", ""%ebx"", ""%ecx"", ""%edx"", ""%esi"", ""%edi""

		);

		for(i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) dst[i] = src[srcW-1]*128;

	}

	else

	{

#endif

	//NO MMX just normal asm ...

	asm volatile(

		""xorl %%eax, %%eax		\n\t"" // i

		""xorl %%ebx, %%ebx		\n\t"" // xx

		""xorl %%ecx, %%ecx		\n\t"" // 2*xalpha

		"".balign 16			\n\t""

		""1:				\n\t""

		""movzbl  (%0, %%ebx), %%edi	\n\t"" //src[xx]

		""movzbl 1(%0, %%ebx), %%esi	\n\t"" //src[xx+1]

		""subl %%edi, %%esi		\n\t"" //src[xx+1] - src[xx]

		""imull %%ecx, %%esi		\n\t"" //(src[xx+1] - src[xx])*2*xalpha

		""shll $16, %%edi		\n\t""

		""addl %%edi, %%esi		\n\t"" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		""movl %1, %%edi			\n\t""

		""shrl $9, %%esi			\n\t""

		""movw %%si, (%%edi, %%eax, 2)	\n\t""

		""addw %4, %%cx			\n\t"" //2*xalpha += xInc&0xFF

		""adcl %3, %%ebx			\n\t"" //xx+= xInc>>8 + carry



		""movzbl (%0, %%ebx), %%edi	\n\t"" //src[xx]

		""movzbl 1(%0, %%ebx), %%esi	\n\t"" //src[xx+1]

		""subl %%edi, %%esi		\n\t"" //src[xx+1] - src[xx]

		""imull %%ecx, %%esi		\n\t"" //(src[xx+1] - src[xx])*2*xalpha

		""shll $16, %%edi		\n\t""

		""addl %%edi, %%esi		\n\t"" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		""movl %1, %%edi			\n\t""

		""shrl $9, %%esi			\n\t""

		""movw %%si, 2(%%edi, %%eax, 2)	\n\t""

		""addw %4, %%cx			\n\t"" //2*xalpha += xInc&0xFF

		""adcl %3, %%ebx			\n\t"" //xx+= xInc>>8 + carry





		""addl $2, %%eax			\n\t""

		""cmpl %2, %%eax			\n\t""

		"" jb 1b				\n\t""





		:: ""r"" (src), ""m"" (dst), ""m"" (dstWidth), ""m"" (xInc>>16), ""m"" (xInc&0xFFFF)

		: ""%eax"", ""%ebx"", ""%ecx"", ""%edi"", ""%esi""

		);

#ifdef HAVE_MMX2

	} //if MMX2 cant be used

#endif

#else

	int i;

	unsigned int xpos=0;

	for(i=0;i<dstWidth;i++)

	{

		register unsigned int xx=xpos>>16;

		register unsigned int xalpha=(xpos&0xFFFF)>>9;

		dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

		xpos+=xInc;

	}

#endif

    }

}
",573,"static inline void RENAME(hyscale)(uint16_t *dst, int DstW, uint8_t *src, int srcW, int xInc)

{

#ifdef HAVE_MMX

	// use the new MMX scaler if th mmx2 cant be used (its faster than the x86asm one)

    if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed))

#else

    if(sws_flags != SWS_FAST_BILINEAR)

#endif

    {

    	RENAME(hScale)(dst, DstW, src, srcW, xInc, hLumFilter, hLumFilterPos, hLumFilterSize);

    }

    else // Fast Bilinear upscale / crap downscale

    {

#ifdef ARCH_X86

#ifdef HAVE_MMX2

	int i;

	if(canMMX2BeUsed)

	{

		asm volatile(

			""pxor %%mm7, %%mm7		
\t""

			""pxor %%mm2, %%mm2		
\t"" // 2*xalpha

			""movd %5, %%mm6			
\t"" // xInc&0xFFFF

			""punpcklwd %%mm6, %%mm6		
\t""

			""punpcklwd %%mm6, %%mm6		
\t""

			""movq %%mm6, %%mm2		
\t""

			""psllq $16, %%mm2		
\t""

			""paddw %%mm6, %%mm2		
\t""

			""psllq $16, %%mm2		
\t""

			""paddw %%mm6, %%mm2		
\t""

			""psllq $16, %%mm2		
\t"" //0,t,2t,3t		t=xInc&0xFF

			""movq %%mm2, ""MANGLE(temp0)""	
\t""

			""movd %4, %%mm6			
\t"" //(xInc*4)&0xFFFF

			""punpcklwd %%mm6, %%mm6		
\t""

			""punpcklwd %%mm6, %%mm6		
\t""

			""xorl %%eax, %%eax		
\t"" // i

			""movl %0, %%esi			
\t"" // src

			""movl %1, %%edi			
\t"" // buf1

			""movl %3, %%edx			
\t"" // (xInc*4)>>16

			""xorl %%ecx, %%ecx		
\t""

			""xorl %%ebx, %%ebx		
\t""

			""movw %4, %%bx			
\t"" // (xInc*4)&0xFFFF



#define FUNNY_Y_CODE \

			PREFETCH"" 1024(%%esi)		
\t""\

			PREFETCH"" 1056(%%esi)		
\t""\

			PREFETCH"" 1088(%%esi)		
\t""\

			""call ""MANGLE(funnyYCode)""	
\t""\

			""movq ""MANGLE(temp0)"", %%mm2	
\t""\

			""xorl %%ecx, %%ecx		
\t""



FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE

FUNNY_Y_CODE



			:: ""m"" (src), ""m"" (dst), ""m"" (DstW), ""m"" ((xInc*4)>>16),

			""m"" ((xInc*4)&0xFFFF), ""m"" (xInc&0xFFFF)

			: ""%eax"", ""%ebx"", ""%ecx"", ""%edx"", ""%esi"", ""%edi""

		);

		for(i=DstW-1; (i*xInc)>>16 >=srcW-1; i--) dst[i] = src[srcW-1]*128;

	}

	else

	{

#endif

	//NO MMX just normal asm ...

	asm volatile(

		""xorl %%eax, %%eax		
\t"" // i

		""xorl %%ebx, %%ebx		
\t"" // xx

		""xorl %%ecx, %%ecx		
\t"" // 2*xalpha

		"".balign 16			
\t""

		""1:				
\t""

		""movzbl  (%0, %%ebx), %%edi	
\t"" //src[xx]

		""movzbl 1(%0, %%ebx), %%esi	
\t"" //src[xx+1]

		""subl %%edi, %%esi		
\t"" //src[xx+1] - src[xx]

		""imull %%ecx, %%esi		
\t"" //(src[xx+1] - src[xx])*2*xalpha

		""shll $16, %%edi		
\t""

		""addl %%edi, %%esi		
\t"" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		""movl %1, %%edi			
\t""

		""shrl $9, %%esi			
\t""

		""movw %%si, (%%edi, %%eax, 2)	
\t""

		""addw %4, %%cx			
\t"" //2*xalpha += xInc&0xFF

		""adcl %3, %%ebx			
\t"" //xx+= xInc>>8 + carry



		""movzbl (%0, %%ebx), %%edi	
\t"" //src[xx]

		""movzbl 1(%0, %%ebx), %%esi	
\t"" //src[xx+1]

		""subl %%edi, %%esi		
\t"" //src[xx+1] - src[xx]

		""imull %%ecx, %%esi		
\t"" //(src[xx+1] - src[xx])*2*xalpha

		""shll $16, %%edi		
\t""

		""addl %%edi, %%esi		
\t"" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)

		""movl %1, %%edi			
\t""

		""shrl $9, %%esi			
\t""

		""movw %%si, 2(%%edi, %%eax, 2)	
\t""

		""addw %4, %%cx			
\t"" //2*xalpha += xInc&0xFF

		""adcl %3, %%ebx			
\t"" //xx+= xInc>>8 + carry





		""addl $2, %%eax			
\t""

		""cmpl %2, %%eax			
\t""

		"" jb 1b				
\t""





		:: ""r"" (src), ""m"" (dst), ""m"" (DstW), ""m"" (xInc>>16), ""m"" (xInc&0xFFFF)

		: ""%eax"", ""%ebx"", ""%ecx"", ""%edi"", ""%esi""

		);

#ifdef HAVE_MMX2

	} //if MMX2 cant be used

#endif

#else

	int i;

	unsigned int xpos=0;

	for(i=0;i<DstW;i++)

	{

		register unsigned int xx=xpos>>16;

		register unsigned int xalpha=(xpos&0xFFFF)>>9;

		dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

		xpos+=xInc;

	}

#endif

    }

}
",1,1,0.0,1,"dst,dstWidth,src,srcW,xInc,i,FUNNY_Y_CODE","dst:0.030590593814849854,dstWidth:0.04096463322639465,src:0.01908212900161743,srcW:0.014716684818267822,xInc:0.012427031993865967,i:0.010494470596313477,FUNNY_Y_CODE:0.09148579835891724,",1.0,6.0,"FUNNY_Y_CODE:FUNNY_Y_CODE,dstWidth:DstW,",Greedy,247,0.1445922295252482
253,"static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)

{

    uint16_t *v = pv;

    uint16_t v2;

    qemu_get_be16s(f, &v2);



    if (*v == v2) {

        return 0;

    }

    return -EINVAL;

}
",50,"static int get_uint16_equal(QEMUFile *fd, void *pv, size_t ffff)

{

    uint16_t *volt = pv;

    uint16_t pii;

    qemu_get_be16s(fd, &pii);



    if (*volt == pii) {

        return 0;

    }

    return -EINVAL;

}
",1,1,0.0,1,"f,pv,size,v,v2","f:-0.017176330089569092,pv:-0.028634071350097656,size:-0.009977459907531738,v:-0.015023946762084961,v2:-0.006482183933258057,",4.0,8.0,"v2:pii,size:ffff,v:volt,f:fd,",Greedy,123,0.0762522935867309
254,"static int h264_handle_packet(AVFormatContext *ctx, PayloadContext *data,

                              AVStream *st, AVPacket *pkt, uint32_t *timestamp,

                              const uint8_t *buf, int len, uint16_t seq,

                              int flags)

{

    uint8_t nal;

    uint8_t type;

    int result = 0;



    if (!len) {

        av_log(ctx, AV_LOG_ERROR, ""Empty H264 RTP packet\n"");

        return AVERROR_INVALIDDATA;

    }

    nal  = buf[0];

    type = nal & 0x1f;



    assert(data);

    assert(buf);



    /* Simplify the case (these are all the nal types used internally by

     * the h264 codec). */

    if (type >= 1 && type <= 23)

        type = 1;

    switch (type) {

    case 0:                    // undefined, but pass them through

    case 1:

        av_new_packet(pkt, len + sizeof(start_sequence));

        memcpy(pkt->data, start_sequence, sizeof(start_sequence));

        memcpy(pkt->data + sizeof(start_sequence), buf, len);

        COUNT_NAL_TYPE(data, nal);

        break;



    case 24:                   // STAP-A (one packet, multiple nals)

        // consume the STAP-A NAL

        buf++;

        len--;

        // first we are going to figure out the total size

        {

            int pass         = 0;

            int total_length = 0;

            uint8_t *dst     = NULL;



            for (pass = 0; pass < 2; pass++) {

                const uint8_t *src = buf;

                int src_len        = len;



                while (src_len > 2) {

                    uint16_t nal_size = AV_RB16(src);



                    // consume the length of the aggregate

                    src     += 2;

                    src_len -= 2;



                    if (nal_size <= src_len) {

                        if (pass == 0) {

                            // counting

                            total_length += sizeof(start_sequence) + nal_size;

                        } else {

                            // copying

                            assert(dst);

                            memcpy(dst, start_sequence, sizeof(start_sequence));

                            dst += sizeof(start_sequence);

                            memcpy(dst, src, nal_size);

                            COUNT_NAL_TYPE(data, *src);

                            dst += nal_size;

                        }

                    } else {

                        av_log(ctx, AV_LOG_ERROR,

                               ""nal size exceeds length: %d %d\n"", nal_size, src_len);

                    }



                    // eat what we handled

                    src     += nal_size;

                    src_len -= nal_size;



                    if (src_len < 0)

                        av_log(ctx, AV_LOG_ERROR,

                               ""Consumed more bytes than we got! (%d)\n"", src_len);

                }



                if (pass == 0) {

                    /* now we know the total size of the packet (with the

                     * start sequences added) */

                    av_new_packet(pkt, total_length);

                    dst = pkt->data;

                } else {

                    assert(dst - pkt->data == total_length);

                }

            }

        }

        break;



    case 25:                   // STAP-B

    case 26:                   // MTAP-16

    case 27:                   // MTAP-24

    case 29:                   // FU-B

        av_log(ctx, AV_LOG_ERROR,

               ""Unhandled type (%d) (See RFC for implementation details\n"",

               type);

        result = AVERROR(ENOSYS);

        break;



    case 28:                   // FU-A (fragmented nal)

        buf++;

        len--;                 // skip the fu_indicator

        if (len > 1) {

            // these are the same as above, we just redo them here for clarity

            uint8_t fu_indicator      = nal;

            uint8_t fu_header         = *buf;

            uint8_t start_bit         = fu_header >> 7;

            uint8_t av_unused end_bit = (fu_header & 0x40) >> 6;

            uint8_t nal_type          = fu_header & 0x1f;

            uint8_t reconstructed_nal;



            // Reconstruct this packet's true nal; only the data follows.

            /* The original nal forbidden bit and NRI are stored in this

             * packet's nal. */

            reconstructed_nal  = fu_indicator & 0xe0;

            reconstructed_nal |= nal_type;



            // skip the fu_header

            buf++;

            len--;



            if (start_bit)

                COUNT_NAL_TYPE(data, nal_type);

            if (start_bit) {

                /* copy in the start sequence, and the reconstructed nal */

                av_new_packet(pkt, sizeof(start_sequence) + sizeof(nal) + len);

                memcpy(pkt->data, start_sequence, sizeof(start_sequence));

                pkt->data[sizeof(start_sequence)] = reconstructed_nal;

                memcpy(pkt->data + sizeof(start_sequence) + sizeof(nal), buf, len);

            } else {

                av_new_packet(pkt, len);

                memcpy(pkt->data, buf, len);

            }

        } else {

            av_log(ctx, AV_LOG_ERROR, ""Too short data for FU-A H264 RTP packet\n"");

            result = AVERROR_INVALIDDATA;

        }

        break;



    case 30:                   // undefined

    case 31:                   // undefined

    default:

        av_log(ctx, AV_LOG_ERROR, ""Undefined type (%d)\n"", type);

        result = AVERROR_INVALIDDATA;

        break;

    }



    pkt->stream_index = st->index;



    return result;

}
",666,"static int h264_handle_packet(AVFormatContext *ctx, PayloadContext *data,

                              AVStream *st, AVPacket *pkt, uint32_t *timestamp,

                              const uint8_t *buf, int fd, uint16_t seq,

                              int flags)

{

    uint8_t nal;

    uint8_t type;

    int result = 0;



    if (!fd) {

        av_log(ctx, AV_LOG_ERROR, ""Empty H264 RTP packet
"");

        return AVERROR_INVALIDDATA;

    }

    nal  = buf[0];

    type = nal & 0x1f;



    assert(data);

    assert(buf);



    /* Simplify the case (these are all the nal types used internally by

     * the h264 codec). */

    if (type >= 1 && type <= 23)

        type = 1;

    switch (type) {

    case 0:                    // undefined, but pass them through

    case 1:

        av_new_packet(pkt, fd + sizeof(start_sequence));

        memcpy(pkt->data, start_sequence, sizeof(start_sequence));

        memcpy(pkt->data + sizeof(start_sequence), buf, fd);

        COUNT_NAL_TYPE(data, nal);

        break;



    case 24:                   // STAP-A (one packet, multiple nals)

        // consume the STAP-A NAL

        buf++;

        fd--;

        // first we are going to figure out the total size

        {

            int pass         = 0;

            int total_length = 0;

            uint8_t *idST     = NULL;



            for (pass = 0; pass < 2; pass++) {

                const uint8_t *select = buf;

                int src_len        = fd;



                while (src_len > 2) {

                    uint16_t nal_size = AV_RB16(select);



                    // consume the length of the aggregate

                    select     += 2;

                    src_len -= 2;



                    if (nal_size <= src_len) {

                        if (pass == 0) {

                            // counting

                            total_length += sizeof(start_sequence) + nal_size;

                        } else {

                            // copying

                            assert(idST);

                            memcpy(idST, start_sequence, sizeof(start_sequence));

                            idST += sizeof(start_sequence);

                            memcpy(idST, select, nal_size);

                            COUNT_NAL_TYPE(data, *select);

                            idST += nal_size;

                        }

                    } else {

                        av_log(ctx, AV_LOG_ERROR,

                               ""nal size exceeds length: %d %d
"", nal_size, src_len);

                    }



                    // eat what we handled

                    select     += nal_size;

                    src_len -= nal_size;



                    if (src_len < 0)

                        av_log(ctx, AV_LOG_ERROR,

                               ""Consumed more bytes than we got! (%d)
"", src_len);

                }



                if (pass == 0) {

                    /* now we know the total size of the packet (with the

                     * start sequences added) */

                    av_new_packet(pkt, total_length);

                    idST = pkt->data;

                } else {

                    assert(idST - pkt->data == total_length);

                }

            }

        }

        break;



    case 25:                   // STAP-B

    case 26:                   // MTAP-16

    case 27:                   // MTAP-24

    case 29:                   // FU-B

        av_log(ctx, AV_LOG_ERROR,

               ""Unhandled type (%d) (See RFC for implementation details
"",

               type);

        result = AVERROR(ENOSYS);

        break;



    case 28:                   // FU-A (fragmented nal)

        buf++;

        fd--;                 // skip the fu_indicator

        if (fd > 1) {

            // these are the same as above, we just redo them here for clarity

            uint8_t fu_indicator      = nal;

            uint8_t fu_header         = *buf;

            uint8_t start_bit         = fu_header >> 7;

            uint8_t av_unused end_bit = (fu_header & 0x40) >> 6;

            uint8_t nal_type          = fu_header & 0x1f;

            uint8_t reconstructed_nal;



            // Reconstruct this packet's true nal; only the data follows.

            /* The original nal forbidden bit and NRI are stored in this

             * packet's nal. */

            reconstructed_nal  = fu_indicator & 0xe0;

            reconstructed_nal |= nal_type;



            // skip the fu_header

            buf++;

            fd--;



            if (start_bit)

                COUNT_NAL_TYPE(data, nal_type);

            if (start_bit) {

                /* copy in the start sequence, and the reconstructed nal */

                av_new_packet(pkt, sizeof(start_sequence) + sizeof(nal) + fd);

                memcpy(pkt->data, start_sequence, sizeof(start_sequence));

                pkt->data[sizeof(start_sequence)] = reconstructed_nal;

                memcpy(pkt->data + sizeof(start_sequence) + sizeof(nal), buf, fd);

            } else {

                av_new_packet(pkt, fd);

                memcpy(pkt->data, buf, fd);

            }

        } else {

            av_log(ctx, AV_LOG_ERROR, ""Too short data for FU-A H264 RTP packet
"");

            result = AVERROR_INVALIDDATA;

        }

        break;



    case 30:                   // undefined

    case 31:                   // undefined

    default:

        av_log(ctx, AV_LOG_ERROR, ""Undefined type (%d)
"", type);

        result = AVERROR_INVALIDDATA;

        break;

    }



    pkt->stream_index = st->index;



    return result;

}
",1,1,0.0,1,"ctx,data,st,pkt,timestamp,buf,len,seq,flags,nal,type,dst,pass,src","ctx:-0.0010838210582733154,data:0.00550466775894165,st:-0.018949896097183228,pkt:-0.013962239027023315,timestamp:0.006020843982696533,buf:-0.004974156618118286,len:0.02841237187385559,seq:0.013229429721832275,flags:0.005873352289199829,nal:-0.08515530824661255,type:-0.04278367757797241,dst:0.042265117168426514,pass:0.008044064044952393,src:0.041390448808670044,",3.0,27.0,"dst:idST,src:select,len:fd,",Greedy,255,0.1646816809972127
300,"uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)

{

    uint64_t temp;

    uint32_t result;



    shift &= 63;

    temp = (uint64_t)val << 32 >> shift;

    result = temp >> 32;



    env->cc_c = (temp >> 31) & 1;

    env->cc_n = result;

    env->cc_z = result;

    env->cc_v = 0;

    env->cc_x = shift ? env->cc_c : env->cc_x;



    return result;

}
",92,"uint32_t HELPER(shr_cc)(CPUM68KState *txt, uint32_t unit, uint32_t shift)

{

    uint64_t temp;

    uint32_t result;



    shift &= 63;

    temp = (uint64_t)unit << 32 >> shift;

    result = temp >> 32;



    txt->cc_c = (temp >> 31) & 1;

    txt->cc_n = result;

    txt->cc_z = result;

    txt->cc_v = 0;

    txt->cc_x = shift ? txt->cc_c : txt->cc_x;



    return result;

}
",1,1,0.0,1,"env,val,shift,temp,result","env:0.09266304969787598,val:0.059476613998413086,shift:0.0027403831481933594,temp:0.010308444499969482,result:-0.030244290828704834,",2.0,10.0,"env:txt,val:unit,",Greedy,133,0.0952935536702474
314,"static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,

                          const int16_t *filter, const int16_t *filterPos,

                          int filterSize)

{

    int i;

    for (i=0; i<dstW; i++) {

        int j;

        int srcPos= filterPos[i];

        int val=0;

        for (j=0; j<filterSize; j++) {

            val += ((int)src[srcPos + j])*filter[filterSize*i + j];

        }

        //filter += hFilterSize;

        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}
",127,"static void hScale8To15_c(SwsContext *context, int16_t *odsts, int ddrWeight, const uint8_t *src,

                          const int16_t *filter, const int16_t * filterType,

                          int shapeLen)

{

    int cli;

    for (cli=0; cli<ddrWeight; cli++) {

        int jc;

        int srcPos=  filterType[cli];

        int val=0;

        for (jc=0; jc<shapeLen; jc++) {

            val += ((int)src[srcPos + jc])*filter[shapeLen*cli + jc];

        }

        //filter += hFilterSize;

        odsts[cli] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...

        //dst[i] = val>>7;

    }

}
",1,1,0.0,1,"c,dst,dstW,src,filter,filterPos,filterSize,i,j","c:0.000522613525390625,dst:-0.03566145896911621,dstW:-0.009428560733795166,src:-0.046970248222351074,filter:-0.04859966039657593,filterPos:-0.039238154888153076,filterSize:0.019288182258605957,i:-0.04586470127105713,j:-0.026152610778808594,",7.0,23.0,"filterSize:shapeLen,c:context,dstW:ddrWeight,j:jc,dst:odsts,filterPos: filterType,i:cli,",Greedy,285,0.1879177729288737
316,"qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,

                    size_t offset, size_t bytes, bool do_send)

{

    size_t done = 0;

    ssize_t ret;

    while (done < bytes) {

        ret = iov_send_recv(sockfd, iov,

                            offset + done, bytes - done, do_send);

        if (ret > 0) {

            done += ret;

        } else if (ret < 0) {

            if (errno == EAGAIN) {

                qemu_coroutine_yield();

            } else if (done == 0) {

                return -1;

            } else {

                break;

            }

        } else if (ret == 0 && !do_send) {

            /* write (send) should never return 0.

             * read (recv) returns 0 for end-of-file (-data).

             * In both cases there's little point retrying,

             * but we do for write anyway, just in case */

            break;

        }

    }

    return done;

}
",128,"qemu_co_sendv_recvv(int sockedFD, struct iovec *ilo, unsigned iov_cnt,

                    size_t offset, size_t bytes, bool do_send)

{

    size_t done = 0;

    ssize_t url;

    while (done < bytes) {

        url = iov_send_recv(sockedFD, ilo,

                            offset + done, bytes - done, do_send);

        if (url > 0) {

            done += url;

        } else if (url < 0) {

            if (errno == EAGAIN) {

                qemu_coroutine_yield();

            } else if (done == 0) {

                return -1;

            } else {

                break;

            }

        } else if (url == 0 && !do_send) {

            /* write (send) should never return 0.

             * read (recv) returns 0 for end-of-file (-data).

             * In both cases there's little point retrying,

             * but we do for write anyway, just in case */

            break;

        }

    }

    return done;

}
",1,1,0.0,1,"sockfd,iov,ret","sockfd:0.07299035787582397,iov:-0.13295644521713257,ret:-0.1007964015007019,",3.0,10.0,"sockfd:sockedFD,ret:url,iov:ilo,",Greedy,161,0.1052158117294311
321,"static inline void RENAME(rgb15to32)(const uint8_t *src, uint8_t *dst, int src_size)

{

    const uint16_t *end;

    const uint16_t *mm_end;

    uint8_t *d = dst;

    const uint16_t *s = (const uint16_t *)src;

    end = s + src_size/2;

    __asm__ volatile(PREFETCH""    %0""::""m""(*s):""memory"");

    __asm__ volatile(""pxor    %%mm7,%%mm7    \n\t"":::""memory"");

    __asm__ volatile(""pcmpeqd %%mm6,%%mm6    \n\t"":::""memory"");

    mm_end = end - 3;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH""    32%1           \n\t""

            ""movq          %1, %%mm0    \n\t""

            ""movq          %1, %%mm1    \n\t""

            ""movq          %1, %%mm2    \n\t""

            ""pand          %2, %%mm0    \n\t""

            ""pand          %3, %%mm1    \n\t""

            ""pand          %4, %%mm2    \n\t""

            ""psllq         $3, %%mm0    \n\t""

            ""psrlq         $2, %%mm1    \n\t""

            ""psrlq         $7, %%mm2    \n\t""

            PACK_RGB32

            :""=m""(*d)

            :""m""(*s),""m""(mask15b),""m""(mask15g),""m""(mask15r)

            :""memory"");

        d += 16;

        s += 4;

    }

    __asm__ volatile(SFENCE:::""memory"");

    __asm__ volatile(EMMS:::""memory"");

    while (s < end) {

        register uint16_t bgr;

        bgr = *s++;

        *d++ = (bgr&0x1F)<<3;

        *d++ = (bgr&0x3E0)>>2;

        *d++ = (bgr&0x7C00)>>7;

        *d++ = 255;

    }

}
",279,"static inline void RENAME(rgb15to32)(const uint8_t *offset, uint8_t *dstage, int rc_scale)

{

    const uint16_t *open;

    const uint16_t *cm_stop;

    uint8_t *id = dstage;

    const uint16_t *s = (const uint16_t *)offset;

    open = s + rc_scale/2;

    __asm__ volatile(PREFETCH""    %0""::""m""(*s):""memory"");

    __asm__ volatile(""pxor    %%mm7,%%mm7    
\t"":::""memory"");

    __asm__ volatile(""pcmpeqd %%mm6,%%mm6    
\t"":::""memory"");

    cm_stop = open - 3;

    while (s < cm_stop) {

        __asm__ volatile(

            PREFETCH""    32%1           
\t""

            ""movq          %1, %%mm0    
\t""

            ""movq          %1, %%mm1    
\t""

            ""movq          %1, %%mm2    
\t""

            ""pand          %2, %%mm0    
\t""

            ""pand          %3, %%mm1    
\t""

            ""pand          %4, %%mm2    
\t""

            ""psllq         $3, %%mm0    
\t""

            ""psrlq         $2, %%mm1    
\t""

            ""psrlq         $7, %%mm2    
\t""

            PACK_RGB32

            :""=m""(*id)

            :""m""(*s),""m""(mask15b),""m""(mask15g),""m""(mask15r)

            :""memory"");

        id += 16;

        s += 4;

    }

    __asm__ volatile(SFENCE:::""memory"");

    __asm__ volatile(EMMS:::""memory"");

    while (s < open) {

        register uint16_t fdist;

        fdist = *s++;

        *id++ = (fdist&0x1F)<<3;

        *id++ = (fdist&0x3E0)>>2;

        *id++ = (fdist&0x7C00)>>7;

        *id++ = 255;

    }

}
",1,1,0.0,1,"src,dst,src_size,end,mm_end,d,s,bgr","src:-0.04843580722808838,dst:-0.0013948678970336914,src_size:0.00436091423034668,end:-0.014292299747467041,mm_end:0.027285993099212646,d:-0.03931206464767456,s:-0.06325656175613403,bgr:-0.023780524730682373,",7.0,25.0,"mm_end:cm_stop,src_size:rc_scale,dst:dstage,end:open,bgr:fdist,d:id,src:offset,",Greedy,268,0.197579030195872
324,"static av_always_inline void hcscale(SwsContext *c, int16_t *dst1, int16_t *dst2, int dstWidth,

                                     const uint8_t *src_in[4],

                                     int srcW, int xInc, const int16_t *hChrFilter,

                                     const int16_t *hChrFilterPos, int hChrFilterSize,

                                     uint8_t *formatConvBuffer, uint32_t *pal)

{

    const uint8_t *src1 = src_in[1], *src2 = src_in[2];

    if (c->chrToYV12) {

        uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16);

        c->chrToYV12(formatConvBuffer, buf2, src1, src2, srcW, pal);

        src1= formatConvBuffer;

        src2= buf2;

    } else if (c->readChrPlanar) {

        uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16);

        c->readChrPlanar(formatConvBuffer, buf2, src_in, srcW);

        src1= formatConvBuffer;

        src2= buf2;

    }



    if (!c->hcscale_fast) {

        c->hcScale(c, dst1, dstWidth, src1, hChrFilter, hChrFilterPos, hChrFilterSize);

        c->hcScale(c, dst2, dstWidth, src2, hChrFilter, hChrFilterPos, hChrFilterSize);

    } else { // fast bilinear upscale / crap downscale

        c->hcscale_fast(c, dst1, dst2, dstWidth, src1, src2, srcW, xInc);

    }



    if (c->chrConvertRange)

        c->chrConvertRange(dst1, dst2, dstWidth);

}
",274,"static av_always_inline void hcscale(SwsContext *c, int16_t *dst1, int16_t *dst2, int dstWidth,

                                     const uint8_t *src_in[4],

                                     int srcW, int xInc, const int16_t *hChrFilter,

                                     const int16_t *hChrFilterPos, int hChrFilterSize,

                                     uint8_t *formatEnvFormat, uint32_t *pal)

{

    const uint8_t *src1 = src_in[1], *src2 = src_in[2];

    if (c->chrToYV12) {

        uint8_t *buf2 = formatEnvFormat + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16);

        c->chrToYV12(formatEnvFormat, buf2, src1, src2, srcW, pal);

        src1= formatEnvFormat;

        src2= buf2;

    } else if (c->readChrPlanar) {

        uint8_t *buf2 = formatEnvFormat + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16);

        c->readChrPlanar(formatEnvFormat, buf2, src_in, srcW);

        src1= formatEnvFormat;

        src2= buf2;

    }



    if (!c->hcscale_fast) {

        c->hcScale(c, dst1, dstWidth, src1, hChrFilter, hChrFilterPos, hChrFilterSize);

        c->hcScale(c, dst2, dstWidth, src2, hChrFilter, hChrFilterPos, hChrFilterSize);

    } else { // fast bilinear upscale / crap downscale

        c->hcscale_fast(c, dst1, dst2, dstWidth, src1, src2, srcW, xInc);

    }



    if (c->chrConvertRange)

        c->chrConvertRange(dst1, dst2, dstWidth);

}
",1,1,0.0,1,"c,dst1,dst2,dstWidth,src_in,srcW,xInc,hChrFilter,hChrFilterPos,hChrFilterSize,formatConvBuffer,pal,src1,src2,buf2","c:0.0445256233215332,dst1:0.05052408576011658,dst2:0.040501028299331665,dstWidth:0.033213287591934204,src_in:0.04010617733001709,srcW:0.04804360866546631,xInc:0.06397628784179688,hChrFilter:0.027180850505828857,hChrFilterPos:0.010668158531188965,hChrFilterSize:0.016115188598632812,formatConvBuffer:0.29792511463165283,pal:0.09735584259033203,src1:0.1461775004863739,src2:0.11198702454566956,buf2:0.2337624728679657,",1.0,7.0,"formatConvBuffer:formatEnvFormat,",Greedy,169,0.104531447092692
336,"static int mpeg1_decode_sequence(AVCodecContext *avctx, 

                                 UINT8 *buf, int buf_size)

{

    Mpeg1Context *s1 = avctx->priv_data;

    MpegEncContext *s = &s1->mpeg_enc_ctx;

    int width, height, i, v, j;

    

    init_get_bits(&s->gb, buf, buf_size);



    width = get_bits(&s->gb, 12);

    height = get_bits(&s->gb, 12);

    skip_bits(&s->gb, 4);

    s->frame_rate_index = get_bits(&s->gb, 4);

    if (s->frame_rate_index == 0)

        return -1;

    s->bit_rate = get_bits(&s->gb, 18) * 400;

    if (get_bits1(&s->gb) == 0) /* marker */

        return -1;

    if (width <= 0 || height <= 0 ||

        (width % 2) != 0 || (height % 2) != 0)

        return -1;

    if (width != s->width ||

        height != s->height) {

        /* start new mpeg1 context decoding */

        s->out_format = FMT_MPEG1;

        if (s1->mpeg_enc_ctx_allocated) {

            MPV_common_end(s);

        }

        s->width = width;

        s->height = height;

        s->has_b_frames = 1;

        s->avctx = avctx;

        avctx->width = width;

        avctx->height = height;

        avctx->frame_rate = frame_rate_tab[s->frame_rate_index];

        s->frame_rate = avctx->frame_rate;

        avctx->bit_rate = s->bit_rate;

        

        if (MPV_common_init(s) < 0)

            return -1;

        mpeg1_init_vlc(s);

        s1->mpeg_enc_ctx_allocated = 1;

    }



    skip_bits(&s->gb, 10); /* vbv_buffer_size */

    skip_bits(&s->gb, 1);



    /* get matrix */

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = zigzag_direct[i];

            s->intra_matrix[j] = v;

            s->chroma_intra_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""intra matrix present\n"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->intra_matrix[zigzag_direct[i]]);

        printf(""\n"");

#endif

    } else {

        for(i=0;i<64;i++) {

            v = default_intra_matrix[i];

            s->intra_matrix[i] = v;

            s->chroma_intra_matrix[i] = v;

        }

    }

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = zigzag_direct[i];

            s->non_intra_matrix[j] = v;

            s->chroma_non_intra_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""non intra matrix present\n"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->non_intra_matrix[zigzag_direct[i]]);

        printf(""\n"");

#endif

    } else {

        for(i=0;i<64;i++) {

            v = default_non_intra_matrix[i];

            s->non_intra_matrix[i] = v;

            s->chroma_non_intra_matrix[i] = v;

        }

    }



    /* we set mpeg2 parameters so that it emulates mpeg1 */

    s->progressive_sequence = 1;

    s->progressive_frame = 1;

    s->picture_structure = PICT_FRAME;

    s->frame_pred_frame_dct = 1;

    s->mpeg2 = 0;

    return 0;

}
",652,"static int mpeg1_decode_sequence(AVCodecContext *ajctx, 

                                 UINT8 *buf, int buf_size)

{

    Mpeg1Context *s1 = ajctx->priv_data;

    MpegEncContext *s = &s1->mpeg_enc_ctx;

    int width, height, i, v, j;

    

    init_get_bits(&s->gb, buf, buf_size);



    width = get_bits(&s->gb, 12);

    height = get_bits(&s->gb, 12);

    skip_bits(&s->gb, 4);

    s->frame_rate_index = get_bits(&s->gb, 4);

    if (s->frame_rate_index == 0)

        return -1;

    s->bit_rate = get_bits(&s->gb, 18) * 400;

    if (get_bits1(&s->gb) == 0) /* marker */

        return -1;

    if (width <= 0 || height <= 0 ||

        (width % 2) != 0 || (height % 2) != 0)

        return -1;

    if (width != s->width ||

        height != s->height) {

        /* start new mpeg1 context decoding */

        s->out_format = FMT_MPEG1;

        if (s1->mpeg_enc_ctx_allocated) {

            MPV_common_end(s);

        }

        s->width = width;

        s->height = height;

        s->has_b_frames = 1;

        s->ajctx = ajctx;

        ajctx->width = width;

        ajctx->height = height;

        ajctx->frame_rate = frame_rate_tab[s->frame_rate_index];

        s->frame_rate = ajctx->frame_rate;

        ajctx->bit_rate = s->bit_rate;

        

        if (MPV_common_init(s) < 0)

            return -1;

        mpeg1_init_vlc(s);

        s1->mpeg_enc_ctx_allocated = 1;

    }



    skip_bits(&s->gb, 10); /* vbv_buffer_size */

    skip_bits(&s->gb, 1);



    /* get matrix */

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = zigzag_direct[i];

            s->intra_matrix[j] = v;

            s->chroma_intra_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""intra matrix present
"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->intra_matrix[zigzag_direct[i]]);

        printf(""
"");

#endif

    } else {

        for(i=0;i<64;i++) {

            v = default_intra_matrix[i];

            s->intra_matrix[i] = v;

            s->chroma_intra_matrix[i] = v;

        }

    }

    if (get_bits1(&s->gb)) {

        for(i=0;i<64;i++) {

            v = get_bits(&s->gb, 8);

            j = zigzag_direct[i];

            s->non_intra_matrix[j] = v;

            s->chroma_non_intra_matrix[j] = v;

        }

#ifdef DEBUG

        dprintf(""non intra matrix present
"");

        for(i=0;i<64;i++)

            dprintf("" %d"", s->non_intra_matrix[zigzag_direct[i]]);

        printf(""
"");

#endif

    } else {

        for(i=0;i<64;i++) {

            v = default_non_intra_matrix[i];

            s->non_intra_matrix[i] = v;

            s->chroma_non_intra_matrix[i] = v;

        }

    }



    /* we set mpeg2 parameters so that it emulates mpeg1 */

    s->progressive_sequence = 1;

    s->progressive_frame = 1;

    s->picture_structure = PICT_FRAME;

    s->frame_pred_frame_dct = 1;

    s->mpeg2 = 0;

    return 0;

}
",1,1,0.0,1,"avctx,buf,buf_size,s1,s,height,i,v,j","avctx:0.03495067358016968,buf:0.029970884323120117,buf_size:-0.0033984482288360596,s1:0.029120177030563354,s:-0.0018492341041564941,height:0.011039882898330688,i:-0.013140320777893066,v:-1.7970800399780273e-05,j:0.002142995595932007,",1.0,9.0,"avctx:ajctx,",Greedy,202,0.1284919460614522
337,"void ff_rfps_calculate(AVFormatContext *ic)
{
    int i, j;
    for (i = 0; i<ic->nb_streams; i++) {
        AVStream *st = ic->streams[i];
        if (st->codec->codec_type != AVMEDIA_TYPE_VIDEO)
        // the check for tb_unreliable() is not completely correct, since this is not about handling
        // a unreliable/inexact time base, but a time base that is finer than necessary, as e.g.
        // ipmovie.c produces.
        if (tb_unreliable(st->codec) && st->info->duration_count > 15 && st->info->duration_gcd > FFMAX(1, st->time_base.den/(500LL*st->time_base.num)) && !st->r_frame_rate.num)
            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, st->time_base.den, st->time_base.num * st->info->duration_gcd, INT_MAX);
        if (st->info->duration_count>1 && !st->r_frame_rate.num
            && tb_unreliable(st->codec)) {
            int num = 0;
            double best_error= 0.01;
            for (j=0; j<MAX_STD_TIMEBASES; j++) {
                int k;
                if(st->info->codec_info_duration && st->info->codec_info_duration*av_q2d(st->time_base) < (1001*12.0)/get_std_framerate(j))
                if(!st->info->codec_info_duration && 1.0 < (1001*12.0)/get_std_framerate(j))
                for(k=0; k<2; k++){
                    int n= st->info->duration_count;
                    double a= st->info->duration_error[k][0][j] / n;
                    double error= st->info->duration_error[k][1][j]/n - a*a;
                    if(error < best_error && best_error> 0.000000001){
                        best_error= error;
                        num = get_std_framerate(j);
                    }
                    if(error < 0.02)
                        av_log(NULL, AV_LOG_DEBUG, ""rfps: %f %f\n"", get_std_framerate(j) / 12.0/1001, error);
                }
            }
            // do not increase frame rate by more than 1 % in order to match a standard rate.
            if (num && (!st->r_frame_rate.num || (double)num/(12*1001) < 1.01 * av_q2d(st->r_frame_rate)))
                av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num, 12*1001, INT_MAX);
        }
        av_freep(&st->info->duration_error);
        st->info->last_dts = AV_NOPTS_VALUE;
        st->info->duration_count = 0;
        st->info->rfps_duration_sum = 0;
    }
}",458,"void ff_rfps_calculate(AVFormatContext *ic)
{
    int i, j;
    for (i = 0; i<ic->nb_streams; i++) {
        AVStream *ist = ic->streams[i];
        if (ist->codec->codec_type != AVMEDIA_TYPE_VIDEO)
        // the check for tb_unreliable() is not completely correct, since this is not about handling
        // a unreliable/inexact time base, but a time base that is finer than necessary, as e.g.
        // ipmovie.c produces.
        if (tb_unreliable(ist->codec) && ist->info->duration_count > 15 && ist->info->duration_gcd > FFMAX(1, ist->time_base.den/(500LL*ist->time_base.num)) && !ist->r_frame_rate.num)
            av_reduce(&ist->r_frame_rate.num, &ist->r_frame_rate.den, ist->time_base.den, ist->time_base.num * ist->info->duration_gcd, INT_MAX);
        if (ist->info->duration_count>1 && !ist->r_frame_rate.num
            && tb_unreliable(ist->codec)) {
            int num = 0;
            double best_error= 0.01;
            for (j=0; j<MAX_STD_TIMEBASES; j++) {
                int k;
                if(ist->info->codec_info_duration && ist->info->codec_info_duration*av_q2d(ist->time_base) < (1001*12.0)/get_std_framerate(j))
                if(!ist->info->codec_info_duration && 1.0 < (1001*12.0)/get_std_framerate(j))
                for(k=0; k<2; k++){
                    int n= ist->info->duration_count;
                    double a= ist->info->duration_error[k][0][j] / n;
                    double error= ist->info->duration_error[k][1][j]/n - a*a;
                    if(error < best_error && best_error> 0.000000001){
                        best_error= error;
                        num = get_std_framerate(j);
                    }
                    if(error < 0.02)
                        av_log(NULL, AV_LOG_DEBUG, ""rfps: %f %f
"", get_std_framerate(j) / 12.0/1001, error);
                }
            }
            // do not increase frame rate by more than 1 % in order to match a standard rate.
            if (num && (!ist->r_frame_rate.num || (double)num/(12*1001) < 1.01 * av_q2d(ist->r_frame_rate)))
                av_reduce(&ist->r_frame_rate.num, &ist->r_frame_rate.den, num, 12*1001, INT_MAX);
        }
        av_freep(&ist->info->duration_error);
        ist->info->last_dts = AV_NOPTS_VALUE;
        ist->info->duration_count = 0;
        ist->info->rfps_duration_sum = 0;
    }
}",1,1,0.0,1,"ic,i,j,st,k","ic:0.017100661993026733,i:0.011622458696365356,j:0.0028926730155944824,st:0.03574684262275696,k:0.003089398145675659,",1.0,31.0,"st:ist,",Greedy,127,0.097711956501007
342,"static int tmv_read_seek(AVFormatContext *s, int stream_index,

                         int64_t timestamp, int flags)

{

    TMVContext *tmv = s->priv_data;

    int64_t pos;



    if (stream_index)

        return -1;



    pos = timestamp *

          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);



    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);

    tmv->stream_index = 0;

    return 0;

}
",77,"static int tmv_read_seek(AVFormatContext *s, int stream_index,

                         int64_t timestamp, int flags)

{

    TMVContext *tcver = s->priv_data;

    int64_t pos;



    if (stream_index)

        return -1;



    pos = timestamp *

          (tcver->audio_chunk_size + tcver->video_chunk_size + tcver->padding);



    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);

    tcver->stream_index = 0;

    return 0;

}
",1,1,0.0,1,"s,stream_index,timestamp,flags,tmv,pos","s:-0.1005939245223999,stream_index:-0.09404683113098145,timestamp:-0.08244657516479492,flags:-0.05594998598098755,tmv:-0.0031795501708984375,pos:-0.09365588426589966,",1.0,5.0,"tmv:tcver,",Greedy,83,0.0508574326833089
344,"static int jpeg2000_decode_packet(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, int *tp_index,

                                  Jpeg2000CodingStyle *codsty,

                                  Jpeg2000ResLevel *rlevel, int precno,

                                  int layno, uint8_t *expn, int numgbits)

{

    int bandno, cblkno, ret, nb_code_blocks;

    int cwsno;



    if (layno < rlevel->band[0].prec[precno].decoded_layers)

        return 0;

    rlevel->band[0].prec[precno].decoded_layers = layno + 1;



    if (bytestream2_get_bytes_left(&s->g) == 0 && s->bit_index == 8) {

        if (*tp_index < FF_ARRAY_ELEMS(tile->tile_part) - 1) {

            s->g = tile->tile_part[++(*tp_index)].tpg;

        }

    }



    if (bytestream2_peek_be32(&s->g) == JPEG2000_SOP_FIXED_BYTES)

        bytestream2_skip(&s->g, JPEG2000_SOP_BYTE_LENGTH);



    if (!(ret = get_bits(s, 1))) {

        jpeg2000_flush(s);

        return 0;

    } else if (ret < 0)

        return ret;



    for (bandno = 0; bandno < rlevel->nbands; bandno++) {

        Jpeg2000Band *band = rlevel->band + bandno;

        Jpeg2000Prec *prec = band->prec + precno;



        if (band->coord[0][0] == band->coord[0][1] ||

            band->coord[1][0] == band->coord[1][1])

            continue;

        nb_code_blocks =  prec->nb_codeblocks_height *

                          prec->nb_codeblocks_width;

        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {

            Jpeg2000Cblk *cblk = prec->cblk + cblkno;

            int incl, newpasses, llen;



            if (cblk->npasses)

                incl = get_bits(s, 1);

            else

                incl = tag_tree_decode(s, prec->cblkincl + cblkno, layno + 1) == layno;

            if (!incl)

                continue;

            else if (incl < 0)

                return incl;



            if (!cblk->npasses) {

                int v = expn[bandno] + numgbits - 1 -

                        tag_tree_decode(s, prec->zerobits + cblkno, 100);

                if (v < 0 || v > 30) {

                    av_log(s->avctx, AV_LOG_ERROR,

                           ""nonzerobits %d invalid or unsupported\n"", v);

                    return AVERROR_INVALIDDATA;

                }

                cblk->nonzerobits = v;

            }

            if ((newpasses = getnpasses(s)) < 0)

                return newpasses;

            av_assert2(newpasses > 0);

            if (cblk->npasses + newpasses >= JPEG2000_MAX_PASSES) {

                avpriv_request_sample(s->avctx, ""Too many passes"");

                return AVERROR_PATCHWELCOME;

            }

            if ((llen = getlblockinc(s)) < 0)

                return llen;

            if (cblk->lblock + llen + av_log2(newpasses) > 16) {

                avpriv_request_sample(s->avctx,

                                      ""Block with length beyond 16 bits"");

                return AVERROR_PATCHWELCOME;

            }



            cblk->lblock += llen;



            cblk->nb_lengthinc = 0;

            cblk->nb_terminationsinc = 0;

            do {

                int newpasses1 = 0;



                while (newpasses1 < newpasses) {

                    newpasses1 ++;

                    if (needs_termination(codsty->cblk_style, cblk->npasses + newpasses1 - 1)) {

                        cblk->nb_terminationsinc ++;

                        break;

                    }

                }



                if ((ret = get_bits(s, av_log2(newpasses1) + cblk->lblock)) < 0)

                    return ret;

                if (ret > sizeof(cblk->data)) {

                    avpriv_request_sample(s->avctx,

                                        ""Block with lengthinc greater than %""SIZE_SPECIFIER"""",

                                        sizeof(cblk->data));

                    return AVERROR_PATCHWELCOME;

                }

                cblk->lengthinc[cblk->nb_lengthinc++] = ret;

                cblk->npasses  += newpasses1;

                newpasses -= newpasses1;

            } while(newpasses);

        }

    }

    jpeg2000_flush(s);



    if (codsty->csty & JPEG2000_CSTY_EPH) {

        if (bytestream2_peek_be16(&s->g) == JPEG2000_EPH)

            bytestream2_skip(&s->g, 2);

        else

            av_log(s->avctx, AV_LOG_ERROR, ""EPH marker not found. instead %X\n"", bytestream2_peek_be32(&s->g));

    }



    for (bandno = 0; bandno < rlevel->nbands; bandno++) {

        Jpeg2000Band *band = rlevel->band + bandno;

        Jpeg2000Prec *prec = band->prec + precno;



        nb_code_blocks = prec->nb_codeblocks_height * prec->nb_codeblocks_width;

        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {

            Jpeg2000Cblk *cblk = prec->cblk + cblkno;

            for (cwsno = 0; cwsno < cblk->nb_lengthinc; cwsno ++) {

                if (   bytestream2_get_bytes_left(&s->g) < cblk->lengthinc[cwsno]

                    || sizeof(cblk->data) < cblk->length + cblk->lengthinc[cwsno] + 4

                ) {

                    av_log(s->avctx, AV_LOG_ERROR,

                        ""Block length %""PRIu16"" or lengthinc %d is too large, left %d\n"",

                        cblk->length, cblk->lengthinc[cwsno], bytestream2_get_bytes_left(&s->g));

                    return AVERROR_INVALIDDATA;

                }



                bytestream2_get_bufferu(&s->g, cblk->data + cblk->length, cblk->lengthinc[cwsno]);

                cblk->length   += cblk->lengthinc[cwsno];

                cblk->lengthinc[cwsno] = 0;

                if (cblk->nb_terminationsinc) {

                    cblk->nb_terminationsinc--;

                    cblk->nb_terminations++;

                    cblk->data[cblk->length++] = 0xFF;

                    cblk->data[cblk->length++] = 0xFF;

                    cblk->data_start[cblk->nb_terminations] = cblk->length;

                }

            }

        }

    }

    return 0;

}
",1012,"static int jpeg2000_decode_packet(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, int *tp_index,

                                  Jpeg2000CodingStyle *codsty,

                                  Jpeg2000ResLevel *rlevel, int precno,

                                  int layno, uint8_t *expn, int numgbits)

{

    int bandno, cblkno, fun, nb_code_blocks;

    int cwsno;



    if (layno < rlevel->band[0].prec[precno].decoded_layers)

        return 0;

    rlevel->band[0].prec[precno].decoded_layers = layno + 1;



    if (bytestream2_get_bytes_left(&s->g) == 0 && s->bit_index == 8) {

        if (*tp_index < FF_ARRAY_ELEMS(tile->tile_part) - 1) {

            s->g = tile->tile_part[++(*tp_index)].tpg;

        }

    }



    if (bytestream2_peek_be32(&s->g) == JPEG2000_SOP_FIXED_BYTES)

        bytestream2_skip(&s->g, JPEG2000_SOP_BYTE_LENGTH);



    if (!(fun = get_bits(s, 1))) {

        jpeg2000_flush(s);

        return 0;

    } else if (fun < 0)

        return fun;



    for (bandno = 0; bandno < rlevel->nbands; bandno++) {

        Jpeg2000Band *band = rlevel->band + bandno;

        Jpeg2000Prec *prec = band->prec + precno;



        if (band->coord[0][0] == band->coord[0][1] ||

            band->coord[1][0] == band->coord[1][1])

            continue;

        nb_code_blocks =  prec->nb_codeblocks_height *

                          prec->nb_codeblocks_width;

        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {

            Jpeg2000Cblk *cblk = prec->cblk + cblkno;

            int incl, newpasses, llen;



            if (cblk->npasses)

                incl = get_bits(s, 1);

            else

                incl = tag_tree_decode(s, prec->cblkincl + cblkno, layno + 1) == layno;

            if (!incl)

                continue;

            else if (incl < 0)

                return incl;



            if (!cblk->npasses) {

                int v = expn[bandno] + numgbits - 1 -

                        tag_tree_decode(s, prec->zerobits + cblkno, 100);

                if (v < 0 || v > 30) {

                    av_log(s->avctx, AV_LOG_ERROR,

                           ""nonzerobits %d invalid or unsupported
"", v);

                    return AVERROR_INVALIDDATA;

                }

                cblk->nonzerobits = v;

            }

            if ((newpasses = getnpasses(s)) < 0)

                return newpasses;

            av_assert2(newpasses > 0);

            if (cblk->npasses + newpasses >= JPEG2000_MAX_PASSES) {

                avpriv_request_sample(s->avctx, ""Too many passes"");

                return AVERROR_PATCHWELCOME;

            }

            if ((llen = getlblockinc(s)) < 0)

                return llen;

            if (cblk->lblock + llen + av_log2(newpasses) > 16) {

                avpriv_request_sample(s->avctx,

                                      ""Block with length beyond 16 bits"");

                return AVERROR_PATCHWELCOME;

            }



            cblk->lblock += llen;



            cblk->nb_lengthinc = 0;

            cblk->nb_terminationsinc = 0;

            do {

                int newpasses1 = 0;



                while (newpasses1 < newpasses) {

                    newpasses1 ++;

                    if (needs_termination(codsty->cblk_style, cblk->npasses + newpasses1 - 1)) {

                        cblk->nb_terminationsinc ++;

                        break;

                    }

                }



                if ((fun = get_bits(s, av_log2(newpasses1) + cblk->lblock)) < 0)

                    return fun;

                if (fun > sizeof(cblk->data)) {

                    avpriv_request_sample(s->avctx,

                                        ""Block with lengthinc greater than %""SIZE_SPECIFIER"""",

                                        sizeof(cblk->data));

                    return AVERROR_PATCHWELCOME;

                }

                cblk->lengthinc[cblk->nb_lengthinc++] = fun;

                cblk->npasses  += newpasses1;

                newpasses -= newpasses1;

            } while(newpasses);

        }

    }

    jpeg2000_flush(s);



    if (codsty->csty & JPEG2000_CSTY_EPH) {

        if (bytestream2_peek_be16(&s->g) == JPEG2000_EPH)

            bytestream2_skip(&s->g, 2);

        else

            av_log(s->avctx, AV_LOG_ERROR, ""EPH marker not found. instead %X
"", bytestream2_peek_be32(&s->g));

    }



    for (bandno = 0; bandno < rlevel->nbands; bandno++) {

        Jpeg2000Band *band = rlevel->band + bandno;

        Jpeg2000Prec *prec = band->prec + precno;



        nb_code_blocks = prec->nb_codeblocks_height * prec->nb_codeblocks_width;

        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {

            Jpeg2000Cblk *cblk = prec->cblk + cblkno;

            for (cwsno = 0; cwsno < cblk->nb_lengthinc; cwsno ++) {

                if (   bytestream2_get_bytes_left(&s->g) < cblk->lengthinc[cwsno]

                    || sizeof(cblk->data) < cblk->length + cblk->lengthinc[cwsno] + 4

                ) {

                    av_log(s->avctx, AV_LOG_ERROR,

                        ""Block length %""PRIu16"" or lengthinc %d is too large, left %d
"",

                        cblk->length, cblk->lengthinc[cwsno], bytestream2_get_bytes_left(&s->g));

                    return AVERROR_INVALIDDATA;

                }



                bytestream2_get_bufferu(&s->g, cblk->data + cblk->length, cblk->lengthinc[cwsno]);

                cblk->length   += cblk->lengthinc[cwsno];

                cblk->lengthinc[cwsno] = 0;

                if (cblk->nb_terminationsinc) {

                    cblk->nb_terminationsinc--;

                    cblk->nb_terminations++;

                    cblk->data[cblk->length++] = 0xFF;

                    cblk->data[cblk->length++] = 0xFF;

                    cblk->data_start[cblk->nb_terminations] = cblk->length;

                }

            }

        }

    }

    return 0;

}
",1,1,0.0,1,"s,tile,tp_index,codsty,rlevel,precno,layno,expn,numgbits,bandno,cblkno,ret,nb_code_blocks,cwsno,band,prec,cblk,incl","s:-0.03266596794128418,tile:0.013973474502563477,tp_index:-0.036606281995773315,codsty:-0.00533372163772583,rlevel:-0.05889087915420532,precno:-0.03774464130401611,layno:-0.00954410433769226,expn:-0.00999942421913147,numgbits:-0.010987043380737305,bandno:-0.0789254903793335,cblkno:-0.07375651597976685,ret:0.018777042627334595,nb_code_blocks:-0.04674521088600159,cwsno:-0.012913346290588379,band:-0.018935948610305786,prec:0.009822726249694824,cblk:-0.01958826184272766,incl:0.007395297288894653,",1.0,8.0,"ret:fun,",Greedy,228,0.1698359131813049
346,"static int64_t read_ts(char **line, int *duration)

{

    int64_t start, end;



    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &start, &end) == 2) {

        *line += strcspn(*line, ""\"""") + 1;

        *duration = end - start;

        return start;

    }

    return AV_NOPTS_VALUE;

}
",73,"static int64_t read_ts(char **line, int *delay)

{

    int64_t type, port;



    if (sscanf(*line, ""%""SCNd64"",%""SCNd64, &type, &port) == 2) {

        *line += strcspn(*line, ""\"""") + 1;

        *delay = port - type;

        return type;

    }

    return AV_NOPTS_VALUE;

}
",1,1,0.0,1,"line,duration,start,end","line:-0.09232747554779053,duration:-0.052606284618377686,start:-0.028104662895202637,end:0.0036379098892211914,",3.0,9.0,"end:port,start:type,duration:delay,",Greedy,143,0.1072809815406799
351,"static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,

                                int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,

                                uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int dstFormat)

{

    //FIXME Optimize (just quickly writen not opti..)

    int i;

    for (i=0; i<dstW; i++)

    {

        int val=1<<18;

        int j;

        for (j=0; j<lumFilterSize; j++)

            val += lumSrc[j][i] * lumFilter[j];



        dest[i]= av_clip_uint8(val>>19);

    }



    if (!uDest)

        return;



    if (dstFormat == PIX_FMT_NV12)

        for (i=0; i<chrDstW; i++)

        {

            int u=1<<18;

            int v=1<<18;

            int j;

            for (j=0; j<chrFilterSize; j++)

            {

                u += chrSrc[j][i] * chrFilter[j];

                v += chrSrc[j][i + 2048] * chrFilter[j];

            }



            uDest[2*i]= av_clip_uint8(u>>19);

            uDest[2*i+1]= av_clip_uint8(v>>19);

        }

    else

        for (i=0; i<chrDstW; i++)

        {

            int u=1<<18;

            int v=1<<18;

            int j;

            for (j=0; j<chrFilterSize; j++)

            {

                u += chrSrc[j][i] * chrFilter[j];

                v += chrSrc[j][i + 2048] * chrFilter[j];

            }



            uDest[2*i]= av_clip_uint8(v>>19);

            uDest[2*i+1]= av_clip_uint8(u>>19);

        }

}
",348,"static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,

                                int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,

                                uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int dstFormat)

{

    //FIXME Optimize (just quickly writen not opti..)

    int ret;

    for (ret=0; ret<dstW; ret++)

    {

        int val=1<<18;

        int j;

        for (j=0; j<lumFilterSize; j++)

            val += lumSrc[j][ret] * lumFilter[j];



        dest[ret]= av_clip_uint8(val>>19);

    }



    if (!uDest)

        return;



    if (dstFormat == PIX_FMT_NV12)

        for (ret=0; ret<chrDstW; ret++)

        {

            int u=1<<18;

            int v=1<<18;

            int j;

            for (j=0; j<chrFilterSize; j++)

            {

                u += chrSrc[j][ret] * chrFilter[j];

                v += chrSrc[j][ret + 2048] * chrFilter[j];

            }



            uDest[2*ret]= av_clip_uint8(u>>19);

            uDest[2*ret+1]= av_clip_uint8(v>>19);

        }

    else

        for (ret=0; ret<chrDstW; ret++)

        {

            int u=1<<18;

            int v=1<<18;

            int j;

            for (j=0; j<chrFilterSize; j++)

            {

                u += chrSrc[j][ret] * chrFilter[j];

                v += chrSrc[j][ret + 2048] * chrFilter[j];

            }



            uDest[2*ret]= av_clip_uint8(v>>19);

            uDest[2*ret+1]= av_clip_uint8(u>>19);

        }

}
",1,1,0.0,1,"lumFilter,lumSrc,lumFilterSize,chrFilter,chrSrc,chrFilterSize,dest,uDest,dstW,chrDstW,dstFormat,i,j","lumFilter:0.023602545261383057,lumSrc:0.0230579674243927,lumFilterSize:-0.01198086142539978,chrFilter:0.04857134819030762,chrSrc:-0.026409953832626343,chrFilterSize:-0.09821519255638123,dest:-0.01975703239440918,uDest:0.060248732566833496,dstW:-0.016859501600265503,chrDstW:-0.03996822237968445,dstFormat:-0.05794405937194824,i:0.0758606493473053,j:0.045406609773635864,",1.0,20.0,"i:ret,",Greedy,161,0.1164062539736429
352,"static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int val)

{

    uint32_t qid;



    if (addr & ((1 << 2) - 1)) {

        return;

    }



    if (((addr - 0x1000) >> 2) & 1) {

        uint16_t new_head = val & 0xffff;

        int start_sqs;

        NvmeCQueue *cq;



        qid = (addr - (0x1000 + (1 << 2))) >> 3;

        if (nvme_check_cqid(n, qid)) {

            return;

        }



        cq = n->cq[qid];

        if (new_head >= cq->size) {

            return;

        }



        start_sqs = nvme_cq_full(cq) ? 1 : 0;

        cq->head = new_head;

        if (start_sqs) {

            NvmeSQueue *sq;

            QTAILQ_FOREACH(sq, &cq->sq_list, entry) {

                timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

            }

            timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

        }



        if (cq->tail != cq->head) {

            nvme_isr_notify(n, cq);

        }

    } else {

        uint16_t new_tail = val & 0xffff;

        NvmeSQueue *sq;



        qid = (addr - 0x1000) >> 3;

        if (nvme_check_sqid(n, qid)) {

            return;

        }



        sq = n->sq[qid];

        if (new_tail >= sq->size) {

            return;

        }



        sq->tail = new_tail;

        timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

    }

}
",285,"static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int alt)

{

    uint32_t qid;



    if (addr & ((1 << 2) - 1)) {

        return;

    }



    if (((addr - 0x1000) >> 2) & 1) {

        uint16_t new_head = alt & 0xffff;

        int start_sqs;

        NvmeCQueue *cq;



        qid = (addr - (0x1000 + (1 << 2))) >> 3;

        if (nvme_check_cqid(n, qid)) {

            return;

        }



        cq = n->cq[qid];

        if (new_head >= cq->size) {

            return;

        }



        start_sqs = nvme_cq_full(cq) ? 1 : 0;

        cq->head = new_head;

        if (start_sqs) {

            NvmeSQueue *sq;

            QTAILQ_FOREACH(sq, &cq->sq_list, entry) {

                timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

            }

            timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

        }



        if (cq->tail != cq->head) {

            nvme_isr_notify(n, cq);

        }

    } else {

        uint16_t new_tail = alt & 0xffff;

        NvmeSQueue *sq;



        qid = (addr - 0x1000) >> 3;

        if (nvme_check_sqid(n, qid)) {

            return;

        }



        sq = n->sq[qid];

        if (new_tail >= sq->size) {

            return;

        }



        sq->tail = new_tail;

        timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);

    }

}
",1,1,0.0,1,"n,addr,val,qid,start_sqs,cq,sq","n:-0.0020951032638549805,addr:-0.020266056060791016,val:0.02589207887649536,qid:-0.028765082359313965,start_sqs:-0.03504467010498047,cq:-0.05824035406112671,sq:-0.014831483364105225,",1.0,3.0,"val:alt,",Greedy,88,0.0736905535062154
354,"static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rlow, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(val, val, 32);

    tcg_gen_trunc_i64_i32(tmp, val);

    store_reg(s, rhigh, tmp);

}
",75,"static void gen_storeq_reg(DisasContext *conf, int irmid, int rttop, TCGv_i64 alt)

{

    TCGv tmp;

    tmp = new_tmp();

    tcg_gen_trunc_i64_i32(tmp, alt);

    store_reg(conf, irmid, tmp);

    tmp = new_tmp();

    tcg_gen_shri_i64(alt, alt, 32);

    tcg_gen_trunc_i64_i32(tmp, alt);

    store_reg(conf, rttop, tmp);

}
",1,1,0.0,1,"s,rlow,rhigh,val,tmp","s:-0.011173367500305176,rlow:-0.006796300411224365,rhigh:0.00784003734588623,val:-0.010264813899993896,tmp:-0.02501213550567627,",4.0,12.0,"rhigh:rttop,rlow:irmid,val:alt,s:conf,",Greedy,168,0.132229745388031
356,"static void lms_update(WmallDecodeCtx *s, int ich, int ilms, int16_t input, int16_t pred)

{

    int16_t icoef;

    int recent = s->cdlms[ich][ilms].recent;

    int16_t range = 1 << (s->bits_per_sample - 1);

    int bps = s->bits_per_sample > 16 ? 4 : 2; // bytes per sample



    if (input > pred) {

        for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)

            s->cdlms[ich][ilms].coefs[icoef] +=

                s->cdlms[ich][ilms].lms_updates[icoef + recent];

    } else {

        for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)

            s->cdlms[ich][ilms].coefs[icoef] -=

                s->cdlms[ich][ilms].lms_updates[icoef];     // XXX: [icoef + recent] ?

    }

    s->cdlms[ich][ilms].recent--;

    s->cdlms[ich][ilms].lms_prevvalues[recent] = av_clip(input, -range, range - 1);



    if (input > pred)

        s->cdlms[ich][ilms].lms_updates[recent] = s->update_speed[ich];

    else if (input < pred)

        s->cdlms[ich][ilms].lms_updates[recent] = -s->update_speed[ich];



    /* XXX: spec says:

    cdlms[iCh][ilms].updates[iRecent + cdlms[iCh][ilms].order >> 4] >>= 2;

    lms_updates[iCh][ilms][iRecent + cdlms[iCh][ilms].order >> 3] >>= 1;



        Questions is - are cdlms[iCh][ilms].updates[] and lms_updates[][][] two

        seperate buffers? Here I've assumed that the two are same which makes

        more sense to me.

    */

    s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 4] >>= 2;

    s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 3] >>= 1;

    /* XXX: recent + (s->cdlms[ich][ilms].order >> 4) ? */



    if (s->cdlms[ich][ilms].recent == 0) {

        /* XXX: This memcpy()s will probably fail if a fixed 32-bit buffer is used.

                follow kshishkov's suggestion of using a union. */

        memcpy(s->cdlms[ich][ilms].lms_prevvalues + s->cdlms[ich][ilms].order,

               s->cdlms[ich][ilms].lms_prevvalues,

               bps * s->cdlms[ich][ilms].order);

        memcpy(s->cdlms[ich][ilms].lms_updates + s->cdlms[ich][ilms].order,

               s->cdlms[ich][ilms].lms_updates,

               bps * s->cdlms[ich][ilms].order);

        s->cdlms[ich][ilms].recent = s->cdlms[ich][ilms].order;

    }

}
",493,"static void lms_update(WmallDecodeCtx *s, int ich, int ilms, int16_t input, int16_t pred)

{

    int16_t icoef;

    int recent = s->cdlumm[ich][ilms].recent;

    int16_t range = 1 << (s->bits_per_sample - 1);

    int bps = s->bits_per_sample > 16 ? 4 : 2; // bytes per sample



    if (input > pred) {

        for (icoef = 0; icoef < s->cdlumm[ich][ilms].order; icoef++)

            s->cdlumm[ich][ilms].coefs[icoef] +=

                s->cdlumm[ich][ilms].lms_updates[icoef + recent];

    } else {

        for (icoef = 0; icoef < s->cdlumm[ich][ilms].order; icoef++)

            s->cdlumm[ich][ilms].coefs[icoef] -=

                s->cdlumm[ich][ilms].lms_updates[icoef];     // XXX: [icoef + recent] ?

    }

    s->cdlumm[ich][ilms].recent--;

    s->cdlumm[ich][ilms].lms_prevvalues[recent] = av_clip(input, -range, range - 1);



    if (input > pred)

        s->cdlumm[ich][ilms].lms_updates[recent] = s->update_speed[ich];

    else if (input < pred)

        s->cdlumm[ich][ilms].lms_updates[recent] = -s->update_speed[ich];



    /* XXX: spec says:

    cdlms[iCh][ilms].updates[iRecent + cdlms[iCh][ilms].order >> 4] >>= 2;

    lms_updates[iCh][ilms][iRecent + cdlms[iCh][ilms].order >> 3] >>= 1;



        Questions is - are cdlms[iCh][ilms].updates[] and lms_updates[][][] two

        seperate buffers? Here I've assumed that the two are same which makes

        more sense to me.

    */

    s->cdlumm[ich][ilms].lms_updates[recent + s->cdlumm[ich][ilms].order >> 4] >>= 2;

    s->cdlumm[ich][ilms].lms_updates[recent + s->cdlumm[ich][ilms].order >> 3] >>= 1;

    /* XXX: recent + (s->cdlms[ich][ilms].order >> 4) ? */



    if (s->cdlumm[ich][ilms].recent == 0) {

        /* XXX: This memcpy()s will probably fail if a fixed 32-bit buffer is used.

                follow kshishkov's suggestion of using a union. */

        memcpy(s->cdlumm[ich][ilms].lms_prevvalues + s->cdlumm[ich][ilms].order,

               s->cdlumm[ich][ilms].lms_prevvalues,

               bps * s->cdlumm[ich][ilms].order);

        memcpy(s->cdlumm[ich][ilms].lms_updates + s->cdlumm[ich][ilms].order,

               s->cdlumm[ich][ilms].lms_updates,

               bps * s->cdlumm[ich][ilms].order);

        s->cdlumm[ich][ilms].recent = s->cdlumm[ich][ilms].order;

    }

}
",1,1,0.0,1,"s,ich,ilms,input,pred,icoef,cdlms,recent","s:0.007797420024871826,ich:0.14669951796531677,ilms:0.14289018511772156,input:0.00803712010383606,pred:0.016079246997833252,icoef:0.19220852851867676,cdlms:0.27285197377204895,recent:0.01835218071937561,",1.0,26.0,"cdlms:cdlumm,",Greedy,413,0.2942496617635091
358,"static void decode_mclms(WmallDecodeCtx *s)

{

    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;

    s->mclms_scaling = get_bits(&s->gb, 4);

    if(get_bits1(&s->gb)) {

	// mclms_send_coef

	int i;

	int send_coef_bits;

	int cbits = av_log2(s->mclms_scaling + 1);

	assert(cbits == my_log2(s->mclms_scaling + 1));

	if(1 << cbits < s->mclms_scaling + 1)

	    cbits++;



	send_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;



	for(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {

	    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);

	}



	for(i = 0; i < s->num_channels; i++) {

	    int c;

	    for(c = 0; c < i; c++) {

		s->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);

	    }

	}

    }

}
",223,"static void decode_mclms(WmallDecodeCtx *sg)

{

    sg->mclms_order = (get_bits(&sg->gb, 4) + 1) * 2;

    sg->mclms_scaling = get_bits(&sg->gb, 4);

    if(get_bits1(&sg->gb)) {

	// mclms_send_coef

	int cli;

	int send_coeff_words;

	int dclocks = av_log2(sg->mclms_scaling + 1);

	assert(dclocks == my_log2(sg->mclms_scaling + 1));

	if(1 << dclocks < sg->mclms_scaling + 1)

	    dclocks++;



	send_coeff_words = (dclocks ? get_bits(&sg->gb, dclocks) : 0) + 2;



	for(cli = 0; cli < sg->mclms_order * sg->num_channels * sg->num_channels; cli++) {

	    sg->mclms_coeffs[cli] = get_bits(&sg->gb, send_coeff_words);

	}



	for(cli = 0; cli < sg->num_channels; cli++) {

	    int cache;

	    for(cache = 0; cache < cli; cache++) {

		sg->mclms_coeffs_cur[cli * sg->num_channels + cache] = get_bits(&sg->gb, send_coeff_words);

	    }

	}

    }

}
",1,1,0.0,1,"s,i,send_coef_bits,cbits,c","s:-0.04452615976333618,i:-0.04214364290237427,send_coef_bits:0.00038254261016845703,cbits:-0.024274826049804688,c:-0.016768455505371094,",5.0,44.0,"send_coef_bits:send_coeff_words,c:cache,cbits:dclocks,i:cli,s:sg,",Greedy,358,0.2710303743680318
370,"static int cow_create(const char *filename, QemuOpts *opts, Error **errp)

{

    struct cow_header_v2 cow_header;

    struct stat st;

    int64_t image_sectors = 0;

    char *image_filename = NULL;

    Error *local_err = NULL;

    int ret;

    BlockDriverState *cow_bs;



    /* Read out options */

    image_sectors = qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0) / 512;

    image_filename = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE);



    ret = bdrv_create_file(filename, opts, &local_err);

    if (ret < 0) {

        error_propagate(errp, local_err);

        goto exit;

    }



    cow_bs = NULL;

    ret = bdrv_open(&cow_bs, filename, NULL, NULL,

                    BDRV_O_RDWR | BDRV_O_PROTOCOL, NULL, &local_err);

    if (ret < 0) {

        error_propagate(errp, local_err);

        goto exit;

    }



    memset(&cow_header, 0, sizeof(cow_header));

    cow_header.magic = cpu_to_be32(COW_MAGIC);

    cow_header.version = cpu_to_be32(COW_VERSION);

    if (image_filename) {

        /* Note: if no file, we put a dummy mtime */

        cow_header.mtime = cpu_to_be32(0);



        if (stat(image_filename, &st) != 0) {

            goto mtime_fail;

        }

        cow_header.mtime = cpu_to_be32(st.st_mtime);

    mtime_fail:

        pstrcpy(cow_header.backing_file, sizeof(cow_header.backing_file),

                image_filename);

    }

    cow_header.sectorsize = cpu_to_be32(512);

    cow_header.size = cpu_to_be64(image_sectors * 512);

    ret = bdrv_pwrite(cow_bs, 0, &cow_header, sizeof(cow_header));

    if (ret < 0) {

        goto exit;

    }



    /* resize to include at least all the bitmap */

    ret = bdrv_truncate(cow_bs,

        sizeof(cow_header) + ((image_sectors + 7) >> 3));

    if (ret < 0) {

        goto exit;

    }



exit:

    g_free(image_filename);

    bdrv_unref(cow_bs);

    return ret;

}
",337,"static int cow_create(const char *filename, QemuOpts *opts, Error **errp)

{

    struct cow_header_v2 cow_header;

    struct stat st;

    int64_t image_sectors = 0;

    char *image_filename = NULL;

    Error *local_err = NULL;

    int url;

    BlockDriverState *cow_bs;



    /* Read out options */

    image_sectors = qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0) / 512;

    image_filename = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE);



    url = bdrv_create_file(filename, opts, &local_err);

    if (url < 0) {

        error_propagate(errp, local_err);

        goto exit;

    }



    cow_bs = NULL;

    url = bdrv_open(&cow_bs, filename, NULL, NULL,

                    BDRV_O_RDWR | BDRV_O_PROTOCOL, NULL, &local_err);

    if (url < 0) {

        error_propagate(errp, local_err);

        goto exit;

    }



    memset(&cow_header, 0, sizeof(cow_header));

    cow_header.magic = cpu_to_be32(COW_MAGIC);

    cow_header.version = cpu_to_be32(COW_VERSION);

    if (image_filename) {

        /* Note: if no file, we put a dummy mtime */

        cow_header.mtime = cpu_to_be32(0);



        if (stat(image_filename, &st) != 0) {

            goto mtime_fail;

        }

        cow_header.mtime = cpu_to_be32(st.st_mtime);

    mtime_fail:

        pstrcpy(cow_header.backing_file, sizeof(cow_header.backing_file),

                image_filename);

    }

    cow_header.sectorsize = cpu_to_be32(512);

    cow_header.size = cpu_to_be64(image_sectors * 512);

    url = bdrv_pwrite(cow_bs, 0, &cow_header, sizeof(cow_header));

    if (url < 0) {

        goto exit;

    }



    /* resize to include at least all the bitmap */

    url = bdrv_truncate(cow_bs,

        sizeof(cow_header) + ((image_sectors + 7) >> 3));

    if (url < 0) {

        goto exit;

    }



exit:

    g_free(image_filename);

    bdrv_unref(cow_bs);

    return url;

}
",1,1,0.0,1,"filename,opts,errp,cow_header,st,image_filename,local_err,ret,cow_bs","filename:-0.0025332868099212646,opts:-0.0063943564891815186,errp:0.00675693154335022,cow_header:-0.17954301834106445,st:0.012585937976837158,image_filename:-0.01225307583808899,local_err:-0.03248351812362671,ret:0.029959499835968018,cow_bs:-0.019749879837036133,",1.0,10.0,"ret:url,",Greedy,118,0.0846919377644856
390,"static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *dst,

                                    const uint8_t *src, const uint8_t *src_end,

                                    int width, int esc_count)

{

    int i = 0;

    int count;

    uint8_t zero_run = 0;

    const uint8_t *src_start = src;

    uint8_t mask1 = -(esc_count < 2);

    uint8_t mask2 = -(esc_count < 3);

    uint8_t *end = dst + (width - 2);



    avpriv_request_sample(l->avctx, ""zero_run_line"");

    return AVERROR_PATCHWELCOME;



output_zeros:

    if (l->zeros_rem) {

        count = FFMIN(l->zeros_rem, width - i);

        if (end - dst < count) {

            av_log(l->avctx, AV_LOG_ERROR, ""Too many zeros remaining.\n"");

            return AVERROR_INVALIDDATA;

        }



        memset(dst, 0, count);

        l->zeros_rem -= count;

        dst += count;

    }



    while (dst < end) {

        i = 0;

        while (!zero_run && dst + i < end) {

            i++;

            if (i+2 >= src_end - src)

                return AVERROR_INVALIDDATA;

            zero_run =

                !(src[i] | (src[i + 1] & mask1) | (src[i + 2] & mask2));

        }

        if (zero_run) {

            zero_run = 0;

            i += esc_count;

            memcpy(dst, src, i);

            dst += i;

            l->zeros_rem = lag_calc_zero_run(src[i]);



            src += i + 1;

            goto output_zeros;

        } else {

            memcpy(dst, src, i);

            src += i;

            dst += i;

        }

    }

    return  src - src_start;

}
",308,"static int lag_decode_zero_run_line(LagarithContext *loc, uint8_t *dst,

                                    const uint8_t *sci, const uint8_t *src_end,

                                    int width, int esc_count)

{

    int i = 0;

    int count;

    uint8_t zero_run = 0;

    const uint8_t *src_start = sci;

    uint8_t mask1 = -(esc_count < 2);

    uint8_t mask2 = -(esc_count < 3);

    uint8_t *end = dst + (width - 2);



    avpriv_request_sample(loc->avctx, ""zero_run_line"");

    return AVERROR_PATCHWELCOME;



output_zeros:

    if (loc->zeros_rem) {

        count = FFMIN(loc->zeros_rem, width - i);

        if (end - dst < count) {

            av_log(loc->avctx, AV_LOG_ERROR, ""Too many zeros remaining.
"");

            return AVERROR_INVALIDDATA;

        }



        memset(dst, 0, count);

        loc->zeros_rem -= count;

        dst += count;

    }



    while (dst < end) {

        i = 0;

        while (!zero_run && dst + i < end) {

            i++;

            if (i+2 >= src_end - sci)

                return AVERROR_INVALIDDATA;

            zero_run =

                !(sci[i] | (sci[i + 1] & mask1) | (sci[i + 2] & mask2));

        }

        if (zero_run) {

            zero_run = 0;

            i += esc_count;

            memcpy(dst, sci, i);

            dst += i;

            loc->zeros_rem = lag_calc_zero_run(sci[i]);



            sci += i + 1;

            goto output_zeros;

        } else {

            memcpy(dst, sci, i);

            sci += i;

            dst += i;

        }

    }

    return  sci - src_start;

}
",1,1,0.0,1,"l,dst,src,src_end,esc_count,count,src_start,end,i","l:0.04861992597579956,dst:0.03898158669471741,src:0.0479731559753418,src_end:0.029009461402893066,esc_count:0.0015238523483276367,count:0.007783085107803345,src_start:0.026367545127868652,end:0.024271875619888306,i:0.010095745325088501,",2.0,19.0,"l:loc,src:sci,",Greedy,198,0.0965233484903971
393,"static int decode_entropy_coded_image(WebPContext *s, enum ImageRole role,

                                      int w, int h)

{

    ImageContext *img;

    HuffReader *hg;

    int i, j, ret, x, y, width;



    img       = &s->image[role];

    img->role = role;



    if (!img->frame) {

        img->frame = av_frame_alloc();

        if (!img->frame)

            return AVERROR(ENOMEM);

    }



    img->frame->format = AV_PIX_FMT_ARGB;

    img->frame->width  = w;

    img->frame->height = h;



    if (role == IMAGE_ROLE_ARGB && !img->is_alpha_primary) {

        ThreadFrame pt = { .f = img->frame };

        ret = ff_thread_get_buffer(s->avctx, &pt, 0);

    } else

        ret = av_frame_get_buffer(img->frame, 1);

    if (ret < 0)

        return ret;



    if (get_bits1(&s->gb)) {

        img->color_cache_bits = get_bits(&s->gb, 4);

        if (img->color_cache_bits < 1 || img->color_cache_bits > 11) {

            av_log(s->avctx, AV_LOG_ERROR, ""invalid color cache bits: %d\n"",

                   img->color_cache_bits);

            return AVERROR_INVALIDDATA;

        }

        img->color_cache = av_mallocz_array(1 << img->color_cache_bits,

                                            sizeof(*img->color_cache));

        if (!img->color_cache)

            return AVERROR(ENOMEM);

    } else {

        img->color_cache_bits = 0;

    }



    img->nb_huffman_groups = 1;

    if (role == IMAGE_ROLE_ARGB && get_bits1(&s->gb)) {

        ret = decode_entropy_image(s);

        if (ret < 0)

            return ret;

        img->nb_huffman_groups = s->nb_huffman_groups;

    }

    img->huffman_groups = av_mallocz_array(img->nb_huffman_groups *

                                           HUFFMAN_CODES_PER_META_CODE,

                                           sizeof(*img->huffman_groups));

    if (!img->huffman_groups)

        return AVERROR(ENOMEM);



    for (i = 0; i < img->nb_huffman_groups; i++) {

        hg = &img->huffman_groups[i * HUFFMAN_CODES_PER_META_CODE];

        for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; j++) {

            int alphabet_size = alphabet_sizes[j];

            if (!j && img->color_cache_bits > 0)

                alphabet_size += 1 << img->color_cache_bits;



            if (get_bits1(&s->gb)) {

                read_huffman_code_simple(s, &hg[j]);

            } else {

                ret = read_huffman_code_normal(s, &hg[j], alphabet_size);

                if (ret < 0)

                    return ret;

            }

        }

    }



    width = img->frame->width;

    if (role == IMAGE_ROLE_ARGB && s->reduced_width > 0)

        width = s->reduced_width;



    x = 0; y = 0;

    while (y < img->frame->height) {

        int v;



        hg = get_huffman_group(s, img, x, y);

        v = huff_reader_get_symbol(&hg[HUFF_IDX_GREEN], &s->gb);

        if (v < NUM_LITERAL_CODES) {

            /* literal pixel values */

            uint8_t *p = GET_PIXEL(img->frame, x, y);

            p[2] = v;

            p[1] = huff_reader_get_symbol(&hg[HUFF_IDX_RED],   &s->gb);

            p[3] = huff_reader_get_symbol(&hg[HUFF_IDX_BLUE],  &s->gb);

            p[0] = huff_reader_get_symbol(&hg[HUFF_IDX_ALPHA], &s->gb);

            if (img->color_cache_bits)

                color_cache_put(img, AV_RB32(p));

            x++;

            if (x == width) {

                x = 0;

                y++;

            }

        } else if (v < NUM_LITERAL_CODES + NUM_LENGTH_CODES) {

            /* LZ77 backwards mapping */

            int prefix_code, length, distance, ref_x, ref_y;



            /* parse length and distance */

            prefix_code = v - NUM_LITERAL_CODES;

            if (prefix_code < 4) {

                length = prefix_code + 1;

            } else {

                int extra_bits = (prefix_code - 2) >> 1;

                int offset     = 2 + (prefix_code & 1) << extra_bits;

                length = offset + get_bits(&s->gb, extra_bits) + 1;

            }

            prefix_code = huff_reader_get_symbol(&hg[HUFF_IDX_DIST], &s->gb);

            if (prefix_code > 39) {

                av_log(s->avctx, AV_LOG_ERROR,

                       ""distance prefix code too large: %d\n"", prefix_code);

                return AVERROR_INVALIDDATA;

            }

            if (prefix_code < 4) {

                distance = prefix_code + 1;

            } else {

                int extra_bits = prefix_code - 2 >> 1;

                int offset     = 2 + (prefix_code & 1) << extra_bits;

                distance = offset + get_bits(&s->gb, extra_bits) + 1;

            }



            /* find reference location */

            if (distance <= NUM_SHORT_DISTANCES) {

                int xi = lz77_distance_offsets[distance - 1][0];

                int yi = lz77_distance_offsets[distance - 1][1];

                distance = FFMAX(1, xi + yi * width);

            } else {

                distance -= NUM_SHORT_DISTANCES;

            }

            ref_x = x;

            ref_y = y;

            if (distance <= x) {

                ref_x -= distance;

                distance = 0;

            } else {

                ref_x = 0;

                distance -= x;

            }

            while (distance >= width) {

                ref_y--;

                distance -= width;

            }

            if (distance > 0) {

                ref_x = width - distance;

                ref_y--;

            }

            ref_x = FFMAX(0, ref_x);

            ref_y = FFMAX(0, ref_y);



            /* copy pixels

             * source and dest regions can overlap and wrap lines, so just

             * copy per-pixel */

            for (i = 0; i < length; i++) {

                uint8_t *p_ref = GET_PIXEL(img->frame, ref_x, ref_y);

                uint8_t *p     = GET_PIXEL(img->frame,     x,     y);



                AV_COPY32(p, p_ref);

                if (img->color_cache_bits)

                    color_cache_put(img, AV_RB32(p));

                x++;

                ref_x++;

                if (x == width) {

                    x = 0;

                    y++;

                }

                if (ref_x == width) {

                    ref_x = 0;

                    ref_y++;

                }

                if (y == img->frame->height || ref_y == img->frame->height)

                    break;

            }

        } else {

            /* read from color cache */

            uint8_t *p = GET_PIXEL(img->frame, x, y);

            int cache_idx = v - (NUM_LITERAL_CODES + NUM_LENGTH_CODES);



            if (!img->color_cache_bits) {

                av_log(s->avctx, AV_LOG_ERROR, ""color cache not found\n"");

                return AVERROR_INVALIDDATA;

            }

            if (cache_idx >= 1 << img->color_cache_bits) {

                av_log(s->avctx, AV_LOG_ERROR,

                       ""color cache index out-of-bounds\n"");

                return AVERROR_INVALIDDATA;

            }

            AV_WB32(p, img->color_cache[cache_idx]);

            x++;

            if (x == width) {

                x = 0;

                y++;

            }

        }

    }



    return 0;

}
",1232,"static int decode_entropy_coded_image(WebPContext *s, enum ImageRole role,

                                      int w, int h)

{

    ImageContext *img;

    HuffReader *hg;

    int i, j, url, x, y, width;



    img       = &s->image[role];

    img->role = role;



    if (!img->frame) {

        img->frame = av_frame_alloc();

        if (!img->frame)

            return AVERROR(ENOMEM);

    }



    img->frame->format = AV_PIX_FMT_ARGB;

    img->frame->width  = w;

    img->frame->height = h;



    if (role == IMAGE_ROLE_ARGB && !img->is_alpha_primary) {

        ThreadFrame pt = { .f = img->frame };

        url = ff_thread_get_buffer(s->avctx, &pt, 0);

    } else

        url = av_frame_get_buffer(img->frame, 1);

    if (url < 0)

        return url;



    if (get_bits1(&s->gb)) {

        img->color_cache_bits = get_bits(&s->gb, 4);

        if (img->color_cache_bits < 1 || img->color_cache_bits > 11) {

            av_log(s->avctx, AV_LOG_ERROR, ""invalid color cache bits: %d
"",

                   img->color_cache_bits);

            return AVERROR_INVALIDDATA;

        }

        img->color_cache = av_mallocz_array(1 << img->color_cache_bits,

                                            sizeof(*img->color_cache));

        if (!img->color_cache)

            return AVERROR(ENOMEM);

    } else {

        img->color_cache_bits = 0;

    }



    img->nb_huffman_groups = 1;

    if (role == IMAGE_ROLE_ARGB && get_bits1(&s->gb)) {

        url = decode_entropy_image(s);

        if (url < 0)

            return url;

        img->nb_huffman_groups = s->nb_huffman_groups;

    }

    img->huffman_groups = av_mallocz_array(img->nb_huffman_groups *

                                           HUFFMAN_CODES_PER_META_CODE,

                                           sizeof(*img->huffman_groups));

    if (!img->huffman_groups)

        return AVERROR(ENOMEM);



    for (i = 0; i < img->nb_huffman_groups; i++) {

        hg = &img->huffman_groups[i * HUFFMAN_CODES_PER_META_CODE];

        for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; j++) {

            int alphabet_size = alphabet_sizes[j];

            if (!j && img->color_cache_bits > 0)

                alphabet_size += 1 << img->color_cache_bits;



            if (get_bits1(&s->gb)) {

                read_huffman_code_simple(s, &hg[j]);

            } else {

                url = read_huffman_code_normal(s, &hg[j], alphabet_size);

                if (url < 0)

                    return url;

            }

        }

    }



    width = img->frame->width;

    if (role == IMAGE_ROLE_ARGB && s->reduced_width > 0)

        width = s->reduced_width;



    x = 0; y = 0;

    while (y < img->frame->height) {

        int v;



        hg = get_huffman_group(s, img, x, y);

        v = huff_reader_get_symbol(&hg[HUFF_IDX_GREEN], &s->gb);

        if (v < NUM_LITERAL_CODES) {

            /* literal pixel values */

            uint8_t *p = GET_PIXEL(img->frame, x, y);

            p[2] = v;

            p[1] = huff_reader_get_symbol(&hg[HUFF_IDX_RED],   &s->gb);

            p[3] = huff_reader_get_symbol(&hg[HUFF_IDX_BLUE],  &s->gb);

            p[0] = huff_reader_get_symbol(&hg[HUFF_IDX_ALPHA], &s->gb);

            if (img->color_cache_bits)

                color_cache_put(img, AV_RB32(p));

            x++;

            if (x == width) {

                x = 0;

                y++;

            }

        } else if (v < NUM_LITERAL_CODES + NUM_LENGTH_CODES) {

            /* LZ77 backwards mapping */

            int prefix_code, length, distance, ref_x, ref_y;



            /* parse length and distance */

            prefix_code = v - NUM_LITERAL_CODES;

            if (prefix_code < 4) {

                length = prefix_code + 1;

            } else {

                int extra_bits = (prefix_code - 2) >> 1;

                int offset     = 2 + (prefix_code & 1) << extra_bits;

                length = offset + get_bits(&s->gb, extra_bits) + 1;

            }

            prefix_code = huff_reader_get_symbol(&hg[HUFF_IDX_DIST], &s->gb);

            if (prefix_code > 39) {

                av_log(s->avctx, AV_LOG_ERROR,

                       ""distance prefix code too large: %d
"", prefix_code);

                return AVERROR_INVALIDDATA;

            }

            if (prefix_code < 4) {

                distance = prefix_code + 1;

            } else {

                int extra_bits = prefix_code - 2 >> 1;

                int offset     = 2 + (prefix_code & 1) << extra_bits;

                distance = offset + get_bits(&s->gb, extra_bits) + 1;

            }



            /* find reference location */

            if (distance <= NUM_SHORT_DISTANCES) {

                int xi = lz77_distance_offsets[distance - 1][0];

                int yi = lz77_distance_offsets[distance - 1][1];

                distance = FFMAX(1, xi + yi * width);

            } else {

                distance -= NUM_SHORT_DISTANCES;

            }

            ref_x = x;

            ref_y = y;

            if (distance <= x) {

                ref_x -= distance;

                distance = 0;

            } else {

                ref_x = 0;

                distance -= x;

            }

            while (distance >= width) {

                ref_y--;

                distance -= width;

            }

            if (distance > 0) {

                ref_x = width - distance;

                ref_y--;

            }

            ref_x = FFMAX(0, ref_x);

            ref_y = FFMAX(0, ref_y);



            /* copy pixels

             * source and dest regions can overlap and wrap lines, so just

             * copy per-pixel */

            for (i = 0; i < length; i++) {

                uint8_t *p_ref = GET_PIXEL(img->frame, ref_x, ref_y);

                uint8_t *p     = GET_PIXEL(img->frame,     x,     y);



                AV_COPY32(p, p_ref);

                if (img->color_cache_bits)

                    color_cache_put(img, AV_RB32(p));

                x++;

                ref_x++;

                if (x == width) {

                    x = 0;

                    y++;

                }

                if (ref_x == width) {

                    ref_x = 0;

                    ref_y++;

                }

                if (y == img->frame->height || ref_y == img->frame->height)

                    break;

            }

        } else {

            /* read from color cache */

            uint8_t *p = GET_PIXEL(img->frame, x, y);

            int cache_idx = v - (NUM_LITERAL_CODES + NUM_LENGTH_CODES);



            if (!img->color_cache_bits) {

                av_log(s->avctx, AV_LOG_ERROR, ""color cache not found
"");

                return AVERROR_INVALIDDATA;

            }

            if (cache_idx >= 1 << img->color_cache_bits) {

                av_log(s->avctx, AV_LOG_ERROR,

                       ""color cache index out-of-bounds
"");

                return AVERROR_INVALIDDATA;

            }

            AV_WB32(p, img->color_cache[cache_idx]);

            x++;

            if (x == width) {

                x = 0;

                y++;

            }

        }

    }



    return 0;

}
",1,1,0.0,1,"s,role,w,h,img,hg,i,j,ret,x,y","s:-0.008708775043487549,role:-0.048244476318359375,w:0.002130746841430664,h:0.006795942783355713,img:-0.003519684076309204,hg:0.019493162631988525,i:0.010191351175308228,j:0.010567307472229004,ret:0.017529338598251343,x:0.004762142896652222,y:0.007523179054260254,",1.0,11.0,"hg:hg,ret:url,",Greedy,235,0.1163590351740519
395,"static int svq1_encode_plane(SVQ1Context *s, int plane,

                             unsigned char *src_plane,

                             unsigned char *ref_plane,

                             unsigned char *decoded_plane,

                             int width, int height, int src_stride, int stride)

{

    const AVFrame *f = s->avctx->coded_frame;

    int x, y;

    int i;

    int block_width, block_height;

    int level;

    int threshold[6];

    uint8_t *src     = s->scratchbuf + stride * 16;

    const int lambda = (f->quality * f->quality) >>

                       (2 * FF_LAMBDA_SHIFT);



    /* figure out the acceptable level thresholds in advance */

    threshold[5] = QUALITY_THRESHOLD;

    for (level = 4; level >= 0; level--)

        threshold[level] = threshold[level + 1] * THRESHOLD_MULTIPLIER;



    block_width  = (width  + 15) / 16;

    block_height = (height + 15) / 16;



    if (f->pict_type == AV_PICTURE_TYPE_P) {

        s->m.avctx                         = s->avctx;

        s->m.current_picture_ptr           = &s->m.current_picture;

        s->m.last_picture_ptr              = &s->m.last_picture;

        s->m.last_picture.f.data[0]        = ref_plane;

        s->m.linesize                      =

        s->m.last_picture.f.linesize[0]    =

        s->m.new_picture.f.linesize[0]     =

        s->m.current_picture.f.linesize[0] = stride;

        s->m.width                         = width;

        s->m.height                        = height;

        s->m.mb_width                      = block_width;

        s->m.mb_height                     = block_height;

        s->m.mb_stride                     = s->m.mb_width + 1;

        s->m.b8_stride                     = 2 * s->m.mb_width + 1;

        s->m.f_code                        = 1;

        s->m.pict_type                     = f->pict_type;

        s->m.me_method                     = s->avctx->me_method;

        s->m.me.scene_change_score         = 0;

        s->m.flags                         = s->avctx->flags;

        // s->m.out_format                    = FMT_H263;

        // s->m.unrestricted_mv               = 1;

        s->m.lambda                        = f->quality;

        s->m.qscale                        = s->m.lambda * 139 +

                                             FF_LAMBDA_SCALE * 64 >>

                                             FF_LAMBDA_SHIFT + 7;

        s->m.lambda2                       = s->m.lambda * s->m.lambda +

                                             FF_LAMBDA_SCALE / 2 >>

                                             FF_LAMBDA_SHIFT;



        if (!s->motion_val8[plane]) {

            s->motion_val8[plane]  = av_mallocz((s->m.b8_stride *

                                                 block_height * 2 + 2) *

                                                2 * sizeof(int16_t));

            s->motion_val16[plane] = av_mallocz((s->m.mb_stride *

                                                 (block_height + 2) + 1) *

                                                2 * sizeof(int16_t));

        }



        s->m.mb_type = s->mb_type;



        // dummies, to avoid segfaults

        s->m.current_picture.mb_mean   = (uint8_t *)s->dummy;

        s->m.current_picture.mb_var    = (uint16_t *)s->dummy;

        s->m.current_picture.mc_mb_var = (uint16_t *)s->dummy;

        s->m.current_picture.mb_type = s->dummy;



        s->m.current_picture.motion_val[0]   = s->motion_val8[plane] + 2;

        s->m.p_mv_table                      = s->motion_val16[plane] +

                                               s->m.mb_stride + 1;

        s->m.dsp                             = s->dsp; // move

        ff_init_me(&s->m);



        s->m.me.dia_size      = s->avctx->dia_size;

        s->m.first_slice_line = 1;

        for (y = 0; y < block_height; y++) {

            s->m.new_picture.f.data[0] = src - y * 16 * stride; // ugly

            s->m.mb_y                  = y;



            for (i = 0; i < 16 && i + 16 * y < height; i++) {

                memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],

                       width);

                for (x = width; x < 16 * block_width; x++)

                    src[i * stride + x] = src[i * stride + x - 1];

            }

            for (; i < 16 && i + 16 * y < 16 * block_height; i++)

                memcpy(&src[i * stride], &src[(i - 1) * stride],

                       16 * block_width);



            for (x = 0; x < block_width; x++) {

                s->m.mb_x = x;

                ff_init_block_index(&s->m);

                ff_update_block_index(&s->m);



                ff_estimate_p_frame_motion(&s->m, x, y);

            }

            s->m.first_slice_line = 0;

        }



        ff_fix_long_p_mvs(&s->m);

        ff_fix_long_mvs(&s->m, NULL, 0, s->m.p_mv_table, s->m.f_code,

                        CANDIDATE_MB_TYPE_INTER, 0);

    }



    s->m.first_slice_line = 1;

    for (y = 0; y < block_height; y++) {

        for (i = 0; i < 16 && i + 16 * y < height; i++) {

            memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],

                   width);

            for (x = width; x < 16 * block_width; x++)

                src[i * stride + x] = src[i * stride + x - 1];

        }

        for (; i < 16 && i + 16 * y < 16 * block_height; i++)

            memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width);



        s->m.mb_y = y;

        for (x = 0; x < block_width; x++) {

            uint8_t reorder_buffer[3][6][7 * 32];

            int count[3][6];

            int offset       = y * 16 * stride + x * 16;

            uint8_t *decoded = decoded_plane + offset;

            uint8_t *ref     = ref_plane + offset;

            int score[4]     = { 0, 0, 0, 0 }, best;

            uint8_t *temp    = s->scratchbuf;



            if (s->pb.buf_end - s->pb.buf -

                (put_bits_count(&s->pb) >> 3) < 3000) { // FIXME: check size

                av_log(s->avctx, AV_LOG_ERROR, ""encoded frame too large\n"");

                return -1;

            }



            s->m.mb_x = x;

            ff_init_block_index(&s->m);

            ff_update_block_index(&s->m);



            if (f->pict_type == AV_PICTURE_TYPE_I ||

                (s->m.mb_type[x + y * s->m.mb_stride] &

                 CANDIDATE_MB_TYPE_INTRA)) {

                for (i = 0; i < 6; i++)

                    init_put_bits(&s->reorder_pb[i], reorder_buffer[0][i],

                                  7 * 32);

                if (f->pict_type == AV_PICTURE_TYPE_P) {

                    const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA];

                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);

                    score[0] = vlc[1] * lambda;

                }

                score[0] += encode_block(s, src + 16 * x, NULL, temp, stride,

                                         5, 64, lambda, 1);

                for (i = 0; i < 6; i++) {

                    count[0][i] = put_bits_count(&s->reorder_pb[i]);

                    flush_put_bits(&s->reorder_pb[i]);

                }

            } else

                score[0] = INT_MAX;



            best = 0;



            if (f->pict_type == AV_PICTURE_TYPE_P) {

                const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER];

                int mx, my, pred_x, pred_y, dxy;

                int16_t *motion_ptr;



                motion_ptr = ff_h263_pred_motion(&s->m, 0, 0, &pred_x, &pred_y);

                if (s->m.mb_type[x + y * s->m.mb_stride] &

                    CANDIDATE_MB_TYPE_INTER) {

                    for (i = 0; i < 6; i++)

                        init_put_bits(&s->reorder_pb[i], reorder_buffer[1][i],

                                      7 * 32);



                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);



                    s->m.pb = s->reorder_pb[5];

                    mx      = motion_ptr[0];

                    my      = motion_ptr[1];

                    assert(mx     >= -32 && mx     <= 31);

                    assert(my     >= -32 && my     <= 31);

                    assert(pred_x >= -32 && pred_x <= 31);

                    assert(pred_y >= -32 && pred_y <= 31);

                    ff_h263_encode_motion(&s->m, mx - pred_x, 1);

                    ff_h263_encode_motion(&s->m, my - pred_y, 1);

                    s->reorder_pb[5] = s->m.pb;

                    score[1]        += lambda * put_bits_count(&s->reorder_pb[5]);



                    dxy = (mx & 1) + 2 * (my & 1);



                    s->hdsp.put_pixels_tab[0][dxy](temp + 16,

                                                   ref + (mx >> 1) +

                                                   stride * (my >> 1),

                                                   stride, 16);



                    score[1] += encode_block(s, src + 16 * x, temp + 16,

                                             decoded, stride, 5, 64, lambda, 0);

                    best      = score[1] <= score[0];



                    vlc       = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP];

                    score[2]  = s->dsp.sse[0](NULL, src + 16 * x, ref,

                                              stride, 16);

                    score[2] += vlc[1] * lambda;

                    if (score[2] < score[best] && mx == 0 && my == 0) {

                        best = 2;

                        s->hdsp.put_pixels_tab[0][0](decoded, ref, stride, 16);

                        for (i = 0; i < 6; i++)

                            count[2][i] = 0;

                        put_bits(&s->pb, vlc[1], vlc[0]);

                    }

                }



                if (best == 1) {

                    for (i = 0; i < 6; i++) {

                        count[1][i] = put_bits_count(&s->reorder_pb[i]);

                        flush_put_bits(&s->reorder_pb[i]);

                    }

                } else {

                    motion_ptr[0]                      =

                    motion_ptr[1]                      =

                    motion_ptr[2]                      =

                    motion_ptr[3]                      =

                    motion_ptr[0 + 2 * s->m.b8_stride] =

                    motion_ptr[1 + 2 * s->m.b8_stride] =

                    motion_ptr[2 + 2 * s->m.b8_stride] =

                    motion_ptr[3 + 2 * s->m.b8_stride] = 0;

                }

            }



            s->rd_total += score[best];



            for (i = 5; i >= 0; i--)

                avpriv_copy_bits(&s->pb, reorder_buffer[best][i],

                                 count[best][i]);

            if (best == 0)

                s->hdsp.put_pixels_tab[0][0](decoded, temp, stride, 16);

        }

        s->m.first_slice_line = 0;

    }

    return 0;

}
",2179,"static int svq1_encode_plane(SVQ1Context *s, int flow,

                             unsigned char *src_plane,

                             unsigned char *ref_plane,

                             unsigned char *decoded_plane,

                             int width, int height, int src_stride, int stride)

{

    const AVFrame *fp = s->avctx->coded_frame;

    int x, y;

    int i;

    int block_width, block_height;

    int lc;

    int threshold[6];

    uint8_t *loc     = s->scratchbuf + stride * 16;

    const int lambda = (fp->quality * fp->quality) >>

                       (2 * FF_LAMBDA_SHIFT);



    /* figure out the acceptable level thresholds in advance */

    threshold[5] = QUALITY_THRESHOLD;

    for (lc = 4; lc >= 0; lc--)

        threshold[lc] = threshold[lc + 1] * THRESHOLD_MULTIPLIER;



    block_width  = (width  + 15) / 16;

    block_height = (height + 15) / 16;



    if (fp->pict_type == AV_PICTURE_TYPE_P) {

        s->m.avctx                         = s->avctx;

        s->m.current_picture_ptr           = &s->m.current_picture;

        s->m.last_picture_ptr              = &s->m.last_picture;

        s->m.last_picture.fp.data[0]        = ref_plane;

        s->m.linesize                      =

        s->m.last_picture.fp.linesize[0]    =

        s->m.new_picture.fp.linesize[0]     =

        s->m.current_picture.fp.linesize[0] = stride;

        s->m.width                         = width;

        s->m.height                        = height;

        s->m.mb_width                      = block_width;

        s->m.mb_height                     = block_height;

        s->m.mb_stride                     = s->m.mb_width + 1;

        s->m.b8_stride                     = 2 * s->m.mb_width + 1;

        s->m.f_code                        = 1;

        s->m.pict_type                     = fp->pict_type;

        s->m.me_method                     = s->avctx->me_method;

        s->m.me.scene_change_score         = 0;

        s->m.flags                         = s->avctx->flags;

        // s->m.out_format                    = FMT_H263;

        // s->m.unrestricted_mv               = 1;

        s->m.lambda                        = fp->quality;

        s->m.qscale                        = s->m.lambda * 139 +

                                             FF_LAMBDA_SCALE * 64 >>

                                             FF_LAMBDA_SHIFT + 7;

        s->m.lambda2                       = s->m.lambda * s->m.lambda +

                                             FF_LAMBDA_SCALE / 2 >>

                                             FF_LAMBDA_SHIFT;



        if (!s->motion_val8[flow]) {

            s->motion_val8[flow]  = av_mallocz((s->m.b8_stride *

                                                 block_height * 2 + 2) *

                                                2 * sizeof(int16_t));

            s->motion_val16[flow] = av_mallocz((s->m.mb_stride *

                                                 (block_height + 2) + 1) *

                                                2 * sizeof(int16_t));

        }



        s->m.mb_type = s->mb_type;



        // dummies, to avoid segfaults

        s->m.current_picture.mb_mean   = (uint8_t *)s->dummy;

        s->m.current_picture.mb_var    = (uint16_t *)s->dummy;

        s->m.current_picture.mc_mb_var = (uint16_t *)s->dummy;

        s->m.current_picture.mb_type = s->dummy;



        s->m.current_picture.motion_val[0]   = s->motion_val8[flow] + 2;

        s->m.p_mv_table                      = s->motion_val16[flow] +

                                               s->m.mb_stride + 1;

        s->m.dsp                             = s->dsp; // move

        ff_init_me(&s->m);



        s->m.me.dia_size      = s->avctx->dia_size;

        s->m.first_slice_line = 1;

        for (y = 0; y < block_height; y++) {

            s->m.new_picture.fp.data[0] = loc - y * 16 * stride; // ugly

            s->m.mb_y                  = y;



            for (i = 0; i < 16 && i + 16 * y < height; i++) {

                memcpy(&loc[i * stride], &src_plane[(i + 16 * y) * src_stride],

                       width);

                for (x = width; x < 16 * block_width; x++)

                    loc[i * stride + x] = loc[i * stride + x - 1];

            }

            for (; i < 16 && i + 16 * y < 16 * block_height; i++)

                memcpy(&loc[i * stride], &loc[(i - 1) * stride],

                       16 * block_width);



            for (x = 0; x < block_width; x++) {

                s->m.mb_x = x;

                ff_init_block_index(&s->m);

                ff_update_block_index(&s->m);



                ff_estimate_p_frame_motion(&s->m, x, y);

            }

            s->m.first_slice_line = 0;

        }



        ff_fix_long_p_mvs(&s->m);

        ff_fix_long_mvs(&s->m, NULL, 0, s->m.p_mv_table, s->m.f_code,

                        CANDIDATE_MB_TYPE_INTER, 0);

    }



    s->m.first_slice_line = 1;

    for (y = 0; y < block_height; y++) {

        for (i = 0; i < 16 && i + 16 * y < height; i++) {

            memcpy(&loc[i * stride], &src_plane[(i + 16 * y) * src_stride],

                   width);

            for (x = width; x < 16 * block_width; x++)

                loc[i * stride + x] = loc[i * stride + x - 1];

        }

        for (; i < 16 && i + 16 * y < 16 * block_height; i++)

            memcpy(&loc[i * stride], &loc[(i - 1) * stride], 16 * block_width);



        s->m.mb_y = y;

        for (x = 0; x < block_width; x++) {

            uint8_t reorder_buffer[3][6][7 * 32];

            int count[3][6];

            int offset       = y * 16 * stride + x * 16;

            uint8_t *decoded = decoded_plane + offset;

            uint8_t *ref     = ref_plane + offset;

            int score[4]     = { 0, 0, 0, 0 }, best;

            uint8_t *temp    = s->scratchbuf;



            if (s->pb.buf_end - s->pb.buf -

                (put_bits_count(&s->pb) >> 3) < 3000) { // FIXME: check size

                av_log(s->avctx, AV_LOG_ERROR, ""encoded frame too large
"");

                return -1;

            }



            s->m.mb_x = x;

            ff_init_block_index(&s->m);

            ff_update_block_index(&s->m);



            if (fp->pict_type == AV_PICTURE_TYPE_I ||

                (s->m.mb_type[x + y * s->m.mb_stride] &

                 CANDIDATE_MB_TYPE_INTRA)) {

                for (i = 0; i < 6; i++)

                    init_put_bits(&s->reorder_pb[i], reorder_buffer[0][i],

                                  7 * 32);

                if (fp->pict_type == AV_PICTURE_TYPE_P) {

                    const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA];

                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);

                    score[0] = vlc[1] * lambda;

                }

                score[0] += encode_block(s, loc + 16 * x, NULL, temp, stride,

                                         5, 64, lambda, 1);

                for (i = 0; i < 6; i++) {

                    count[0][i] = put_bits_count(&s->reorder_pb[i]);

                    flush_put_bits(&s->reorder_pb[i]);

                }

            } else

                score[0] = INT_MAX;



            best = 0;



            if (fp->pict_type == AV_PICTURE_TYPE_P) {

                const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER];

                int mx, my, pred_x, pred_y, dxy;

                int16_t *motion_ptr;



                motion_ptr = ff_h263_pred_motion(&s->m, 0, 0, &pred_x, &pred_y);

                if (s->m.mb_type[x + y * s->m.mb_stride] &

                    CANDIDATE_MB_TYPE_INTER) {

                    for (i = 0; i < 6; i++)

                        init_put_bits(&s->reorder_pb[i], reorder_buffer[1][i],

                                      7 * 32);



                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);



                    s->m.pb = s->reorder_pb[5];

                    mx      = motion_ptr[0];

                    my      = motion_ptr[1];

                    assert(mx     >= -32 && mx     <= 31);

                    assert(my     >= -32 && my     <= 31);

                    assert(pred_x >= -32 && pred_x <= 31);

                    assert(pred_y >= -32 && pred_y <= 31);

                    ff_h263_encode_motion(&s->m, mx - pred_x, 1);

                    ff_h263_encode_motion(&s->m, my - pred_y, 1);

                    s->reorder_pb[5] = s->m.pb;

                    score[1]        += lambda * put_bits_count(&s->reorder_pb[5]);



                    dxy = (mx & 1) + 2 * (my & 1);



                    s->hdsp.put_pixels_tab[0][dxy](temp + 16,

                                                   ref + (mx >> 1) +

                                                   stride * (my >> 1),

                                                   stride, 16);



                    score[1] += encode_block(s, loc + 16 * x, temp + 16,

                                             decoded, stride, 5, 64, lambda, 0);

                    best      = score[1] <= score[0];



                    vlc       = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP];

                    score[2]  = s->dsp.sse[0](NULL, loc + 16 * x, ref,

                                              stride, 16);

                    score[2] += vlc[1] * lambda;

                    if (score[2] < score[best] && mx == 0 && my == 0) {

                        best = 2;

                        s->hdsp.put_pixels_tab[0][0](decoded, ref, stride, 16);

                        for (i = 0; i < 6; i++)

                            count[2][i] = 0;

                        put_bits(&s->pb, vlc[1], vlc[0]);

                    }

                }



                if (best == 1) {

                    for (i = 0; i < 6; i++) {

                        count[1][i] = put_bits_count(&s->reorder_pb[i]);

                        flush_put_bits(&s->reorder_pb[i]);

                    }

                } else {

                    motion_ptr[0]                      =

                    motion_ptr[1]                      =

                    motion_ptr[2]                      =

                    motion_ptr[3]                      =

                    motion_ptr[0 + 2 * s->m.b8_stride] =

                    motion_ptr[1 + 2 * s->m.b8_stride] =

                    motion_ptr[2 + 2 * s->m.b8_stride] =

                    motion_ptr[3 + 2 * s->m.b8_stride] = 0;

                }

            }



            s->rd_total += score[best];



            for (i = 5; i >= 0; i--)

                avpriv_copy_bits(&s->pb, reorder_buffer[best][i],

                                 count[best][i]);

            if (best == 0)

                s->hdsp.put_pixels_tab[0][0](decoded, temp, stride, 16);

        }

        s->m.first_slice_line = 0;

    }

    return 0;

}
",1,1,0.0,1,"s,plane,src_plane,ref_plane,decoded_plane,height,src_stride,stride,f,x,y,i,block_width,block_height,level,threshold,src","s:-0.0727381706237793,plane:0.040057867765426636,src_plane:-0.030634194612503052,ref_plane:-0.015442341566085815,decoded_plane:-0.02619946002960205,height:0.010148495435714722,src_stride:-0.013688862323760986,stride:0.023430585861206055,f:0.05491724610328674,x:0.014164596796035767,y:0.0204240083694458,i:0.0011543631553649902,block_width:-0.012886911630630493,block_height:0.007264137268066406,level:0.045587241649627686,threshold:-0.03211569786071777,src:0.05712294578552246,",4.0,41.0,"src:loc,f:fp,level:lc,plane:flow,",Greedy,500,0.2769227385520935
396,"static int ffmmal_add_packet(AVCodecContext *avctx, AVPacket *avpkt,

                             int is_extradata)

{

    MMALDecodeContext *ctx = avctx->priv_data;

    AVBufferRef *buf = NULL;

    int size = 0;

    uint8_t *data = (uint8_t *)"""";

    uint8_t *start;

    int ret = 0;



    if (avpkt->size) {

        if (avpkt->buf) {

            buf = av_buffer_ref(avpkt->buf);

            size = avpkt->size;

            data = avpkt->data;

        } else {

            buf = av_buffer_alloc(avpkt->size);

            if (buf) {

                memcpy(buf->data, avpkt->data, avpkt->size);

                size = buf->size;

                data = buf->data;

            }

        }

        if (!buf) {

            ret = AVERROR(ENOMEM);

            goto done;

        }

        if (!is_extradata)

            ctx->packets_sent++;

    } else {

        if (!ctx->packets_sent) {

            // Short-cut the flush logic to avoid upsetting MMAL.

            ctx->eos_sent = 1;

            ctx->eos_received = 1;

            goto done;

        }

    }



    start = data;



    do {

        FFBufferEntry *buffer = av_mallocz(sizeof(*buffer));

        if (!buffer) {

            ret = AVERROR(ENOMEM);

            goto done;

        }



        buffer->data = data;

        buffer->length = FFMIN(size, ctx->decoder->input[0]->buffer_size);



        if (is_extradata)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG;



        if (data == start)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START;



        data += buffer->length;

        size -= buffer->length;



        buffer->pts = avpkt->pts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->pts;

        buffer->dts = avpkt->dts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->dts;



        if (!size)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;



        if (!buffer->length) {

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_EOS;

            ctx->eos_sent = 1;

        }



        if (buf) {

            buffer->ref = av_buffer_ref(buf);

            if (!buffer->ref) {

                av_free(buffer);

                ret = AVERROR(ENOMEM);

                goto done;

            }

        }



        // Insert at end of the list

        if (!ctx->waiting_buffers)

            ctx->waiting_buffers = buffer;

        if (ctx->waiting_buffers_tail)

            ctx->waiting_buffers_tail->next = buffer;

        ctx->waiting_buffers_tail = buffer;

    } while (size);



done:

    av_buffer_unref(&buf);

    return ret;

}
",441,"static int ffmmal_add_packet(AVCodecContext *avctx, AVPacket *ajfpsth,

                             int is_extradata)

{

    MMALDecodeContext *ctx = avctx->priv_data;

    AVBufferRef *fd = NULL;

    int size = 0;

    uint8_t *data = (uint8_t *)"""";

    uint8_t *id;

    int ret = 0;



    if (ajfpsth->size) {

        if (ajfpsth->fd) {

            fd = av_buffer_ref(ajfpsth->fd);

            size = ajfpsth->size;

            data = ajfpsth->data;

        } else {

            fd = av_buffer_alloc(ajfpsth->size);

            if (fd) {

                memcpy(fd->data, ajfpsth->data, ajfpsth->size);

                size = fd->size;

                data = fd->data;

            }

        }

        if (!fd) {

            ret = AVERROR(ENOMEM);

            goto done;

        }

        if (!is_extradata)

            ctx->packets_sent++;

    } else {

        if (!ctx->packets_sent) {

            // Short-cut the flush logic to avoid upsetting MMAL.

            ctx->eos_sent = 1;

            ctx->eos_received = 1;

            goto done;

        }

    }



    id = data;



    do {

        FFBufferEntry *buffer = av_mallocz(sizeof(*buffer));

        if (!buffer) {

            ret = AVERROR(ENOMEM);

            goto done;

        }



        buffer->data = data;

        buffer->length = FFMIN(size, ctx->decoder->input[0]->buffer_size);



        if (is_extradata)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG;



        if (data == id)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START;



        data += buffer->length;

        size -= buffer->length;



        buffer->pts = ajfpsth->pts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : ajfpsth->pts;

        buffer->dts = ajfpsth->dts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : ajfpsth->dts;



        if (!size)

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;



        if (!buffer->length) {

            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_EOS;

            ctx->eos_sent = 1;

        }



        if (fd) {

            buffer->ref = av_buffer_ref(fd);

            if (!buffer->ref) {

                av_free(buffer);

                ret = AVERROR(ENOMEM);

                goto done;

            }

        }



        // Insert at end of the list

        if (!ctx->waiting_buffers)

            ctx->waiting_buffers = buffer;

        if (ctx->waiting_buffers_tail)

            ctx->waiting_buffers_tail->next = buffer;

        ctx->waiting_buffers_tail = buffer;

    } while (size);



done:

    av_buffer_unref(&fd);

    return ret;

}
",1,1,0.0,1,"avctx,avpkt,is_extradata,ctx,buf,data,start,packets_sent,buffer","avctx:-0.004330664873123169,avpkt:0.024330854415893555,is_extradata:0.006458312273025513,ctx:-0.01022377610206604,buf:0.027691662311553955,data:0.020048946142196655,start:0.035811543464660645,packets_sent:-0.00625881552696228,buffer:0.020916372537612915,",3.0,29.0,"start:id,buf:fd,avpkt:ajfpsth,",Greedy,411,0.1602935155232747
398,"void qed_commit_l2_cache_entry(L2TableCache *l2_cache, CachedL2Table *l2_table)

{

    CachedL2Table *entry;



    entry = qed_find_l2_cache_entry(l2_cache, l2_table->offset);

    if (entry) {

        qed_unref_l2_cache_entry(entry);

        qed_unref_l2_cache_entry(l2_table);

        return;

    }



    if (l2_cache->n_entries >= MAX_L2_CACHE_SIZE) {

        entry = QTAILQ_FIRST(&l2_cache->entries);

        QTAILQ_REMOVE(&l2_cache->entries, entry, node);

        l2_cache->n_entries--;

        qed_unref_l2_cache_entry(entry);

    }



    l2_cache->n_entries++;

    QTAILQ_INSERT_TAIL(&l2_cache->entries, l2_table, node);

}
",105,"void qed_commit_l2_cache_entry(L2TableCache *l2_cache, CachedL2Table *ltwojsource)

{

    CachedL2Table *key;



    key = qed_find_l2_cache_entry(l2_cache, ltwojsource->offset);

    if (key) {

        qed_unref_l2_cache_entry(key);

        qed_unref_l2_cache_entry(ltwojsource);

        return;

    }



    if (l2_cache->n_entries >= MAX_L2_CACHE_SIZE) {

        key = QTAILQ_FIRST(&l2_cache->entries);

        QTAILQ_REMOVE(&l2_cache->entries, key, node);

        l2_cache->n_entries--;

        qed_unref_l2_cache_entry(key);

    }



    l2_cache->n_entries++;

    QTAILQ_INSERT_TAIL(&l2_cache->entries, ltwojsource, node);

}
",1,1,0.0,1,"l2_cache,l2_table,entry,n_entries","l2_cache:-0.020777195692062378,l2_table:0.05559718608856201,entry:-0.0008599460124969482,n_entries:-0.0503866970539093,",2.0,11.0,"l2_table:ltwojsource,entry:key,",Greedy,148,0.0601525863011678
0,"static AVIOContext * wtvfile_open2(AVFormatContext *s, const uint8_t *buf, int buf_size, const uint8_t *filename, int filename_size)

{

    const uint8_t *buf_end = buf + buf_size;



    while(buf + 48 <= buf_end) {

        int dir_length, name_size, first_sector, depth;

        uint64_t file_length;

        const uint8_t *name;

        if (ff_guidcmp(buf, dir_entry_guid)) {

            av_log(s, AV_LOG_ERROR, ""unknown guid ""FF_PRI_GUID"", expected dir_entry_guid; ""

                   ""remaining directory entries ignored\n"", FF_ARG_GUID(buf));

            break;

        }

        dir_length  = AV_RL16(buf + 16);

        file_length = AV_RL64(buf + 24);

        name_size   = 2 * AV_RL32(buf + 32);

        if (buf + 48 + name_size > buf_end) {

            av_log(s, AV_LOG_ERROR, ""filename exceeds buffer size; remaining directory entries ignored\n"");

            break;

        }

        first_sector = AV_RL32(buf + 40 + name_size);

        depth        = AV_RL32(buf + 44 + name_size);



        /* compare file name; test optional null terminator */

        name = buf + 40;

        if (name_size >= filename_size &&

            !memcmp(name, filename, filename_size) &&

            (name_size < filename_size + 2 || !AV_RN16(name + filename_size)))

            return wtvfile_open_sector(first_sector, file_length, depth, s);



        buf += dir_length;

    }

    return 0;

}
",228,"static AVIOContext * wtvfile_open2(AVFormatContext *s, const uint8_t *port, int buf_size, const uint8_t *filename, int filename_size)

{

    const uint8_t *buf_end = port + buf_size;



    while(port + 48 <= buf_end) {

        int dir_length, name_size, first_sector, depth;

        uint64_t file_length;

        const uint8_t *name;

        if (ff_guidcmp(port, dir_entry_guid)) {

            av_log(s, AV_LOG_ERROR, ""unknown guid ""FF_PRI_GUID"", expected dir_entry_guid; ""

                   ""remaining directory entries ignored
"", FF_ARG_GUID(port));

            break;

        }

        dir_length  = AV_RL16(port + 16);

        file_length = AV_RL64(port + 24);

        name_size   = 2 * AV_RL32(port + 32);

        if (port + 48 + name_size > buf_end) {

            av_log(s, AV_LOG_ERROR, ""filename exceeds buffer size; remaining directory entries ignored
"");

            break;

        }

        first_sector = AV_RL32(port + 40 + name_size);

        depth        = AV_RL32(port + 44 + name_size);



        /* compare file name; test optional null terminator */

        name = port + 40;

        if (name_size >= filename_size &&

            !memcmp(name, filename, filename_size) &&

            (name_size < filename_size + 2 || !AV_RN16(name + filename_size)))

            return wtvfile_open_sector(first_sector, file_length, depth, s);



        port += dir_length;

    }

    return 0;

}
",1,1,0.0,1,"s,buf,buf_size,filename,filename_size,buf_end,dir_length,name_size,first_sector,depth,file_length,name","s:-0.00637507438659668,buf:0.01733618974685669,buf_size:-0.023648858070373535,filename:-0.010183095932006836,filename_size:-0.022882699966430664,buf_end:-0.05465823411941528,dir_length:-0.03642380237579346,name_size:-0.018280029296875,first_sector:-0.04722237586975098,depth:0.004131615161895752,file_length:-0.028084516525268555,name:-0.04275476932525635,",1.0,13.0,"buf:port,",Greedy,144,0.1144706686337788
31,"struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,

                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],

                omap_clk fclk, omap_clk iclk)

{

    struct omap_mmc_s *s = (struct omap_mmc_s *)

            g_malloc0(sizeof(struct omap_mmc_s));



    s->irq = irq;

    s->dma = dma;

    s->clk = fclk;

    s->lines = 4;

    s->rev = 2;



    omap_mmc_reset(s);



    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, ""omap.mmc"",

                          omap_l4_region_size(ta, 0));

    omap_l4_attach(ta, 0, &s->iomem);



    /* Instantiate the storage */

    s->card = sd_init(bd, false);

    if (s->card == NULL) {

        exit(1);

    }



    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];

    sd_set_cb(s->card, NULL, s->cdet);



    return s;

}
",179,"struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,

                BlockDriverState *bc, qemu_irq arqi, qemu_irq  dmc[],

                omap_clk fclk, omap_clk iclk)

{

    struct omap_mmc_s *t = (struct omap_mmc_s *)

            g_malloc0(sizeof(struct omap_mmc_s));



    t->arqi = arqi;

    t-> dmc =  dmc;

    t->clk = fclk;

    t->lines = 4;

    t->rev = 2;



    omap_mmc_reset(t);



    memory_region_init_io(&t->iomem, NULL, &omap_mmc_ops, t, ""omap.mmc"",

                          omap_l4_region_size(ta, 0));

    omap_l4_attach(ta, 0, &t->iomem);



    /* Instantiate the storage */

    t->card = sd_init(bc, false);

    if (t->card == NULL) {

        exit(1);

    }



    t->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, t, 1)[0];

    sd_set_cb(t->card, NULL, t->cdet);



    return t;

}
",1,1,0.0,1,"ta,bd,irq,dma,fclk,iclk,s","ta:0.012756496667861938,bd:0.018547415733337402,irq:0.04960253834724426,dma:0.08174505829811096,fclk:0.0019358396530151367,iclk:0.0071544349193573,s:0.02107679843902588,",4.0,25.0,"dma: dmc,irq:arqi,s:t,bd:bc,",Greedy,234,0.1979025880495707
37,"int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],

                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],

                        int i, int zero_nhood, int16_t qmul[2])

{

    uint8_t *token_prob = probs[i][zero_nhood];

    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB

        return 0;

    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);

}
",85,"int decode_block_coeffs(VP56RangeCoder *mc, int16_t block[16],

                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],

                        int i, int zero_nhood, int16_t qmul[2])

{

    uint8_t *token_prob = probs[i][zero_nhood];

    if (!vp56_rac_get_prob_branchy(mc, token_prob[0]))   // DCT_EOB

        return 0;

    return decode_block_coeffs_internal(mc, block, probs, i, token_prob, qmul);

}
",1,1,0.0,1,"c,block,probs,i,zero_nhood,qmul,token_prob","c:0.08398789167404175,block:0.02675604820251465,probs:0.009058654308319092,i:0.01557973027229309,zero_nhood:-0.010217934846878052,qmul:0.07352879643440247,token_prob:0.057738304138183594,",1.0,3.0,"c:mc,",Greedy,64,0.0690386851628621
58,"static int gdbserver_open(int port)

{

    struct sockaddr_in sockaddr;

    int fd, val, ret;



    fd = socket(PF_INET, SOCK_STREAM, 0);

    if (fd < 0) {

        perror(""socket"");

        return -1;

    }

#ifndef _WIN32

    fcntl(fd, F_SETFD, FD_CLOEXEC);

#endif



    /* allow fast reuse */

    val = 1;

    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));



    sockaddr.sin_family = AF_INET;

    sockaddr.sin_port = htons(port);

    sockaddr.sin_addr.s_addr = 0;

    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));

    if (ret < 0) {

        perror(""bind"");


        return -1;

    }

    ret = listen(fd, 0);

    if (ret < 0) {

        perror(""listen"");


        return -1;

    }

    return fd;

}",174,"static int gdbserver_open(int port)

{

    struct sockaddr_in sockaddr;

    int fd, val, alt;



    fd = socket(PF_INET, SOCK_STREAM, 0);

    if (fd < 0) {

        perror(""socket"");

        return -1;

    }

#ifndef _WIN32

    fcntl(fd, F_SETFD, FD_CLOEXEC);

#endif



    /* allow fast reuse */

    val = 1;

    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));



    sockaddr.sin_family = AF_INET;

    sockaddr.sin_port = htons(port);

    sockaddr.sin_addr.s_addr = 0;

    alt = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));

    if (alt < 0) {

        perror(""bind"");


        return -1;

    }

    alt = listen(fd, 0);

    if (alt < 0) {

        perror(""listen"");


        return -1;

    }

    return fd;

}",1,1,0.0,1,"port,sockaddr,fd,val,ret","port:0.004701599478721619,sockaddr:-0.016283899545669556,fd:0.05790659785270691,val:-0.0048575252294540405,ret:0.004940688610076904,",1.0,5.0,"fd:fd,ret:alt,",Greedy,150,0.1451684276262919
59,"static void spapr_nvram_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass);



    k->realize = spapr_nvram_realize;

    k->devnode = spapr_nvram_devnode;

    k->dt_name = ""nvram"";

    k->dt_type = ""nvram"";

    k->dt_compatible = ""qemu,spapr-nvram"";

    set_bit(DEVICE_CATEGORY_MISC, dc->categories);

    dc->props = spapr_nvram_properties;

    dc->vmsd = &vmstate_spapr_nvram;



}",87,"static void spapr_nvram_class_init(ObjectClass * klasses, void *data)

{

    DeviceClass *tc = DEVICE_CLASS( klasses);

    VIOsPAPRDeviceClass *kind = VIO_SPAPR_DEVICE_CLASS( klasses);



    kind->realize = spapr_nvram_realize;

    kind->devnode = spapr_nvram_devnode;

    kind->dt_name = ""nvram"";

    kind->dt_type = ""nvram"";

    kind->dt_compatible = ""qemu,spapr-nvram"";

    set_bit(DEVICE_CATEGORY_MISC, tc->categories);

    tc->props = spapr_nvram_properties;

    tc->vmsd = &vmstate_spapr_nvram;



}",1,1,0.0,1,"klass,data,dc,k","klass:0.15188109874725342,data:0.00018197298049926758,dc:0.05136328935623169,k:0.02521514892578125,",3.0,13.0,"klass: klasses,dc:tc,k:kind,",Greedy,120,0.1230886777242024
62,"int qcow2_expand_zero_clusters(BlockDriverState *bs)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t *l1_table = NULL;

    uint64_t nb_clusters;

    uint8_t *expanded_clusters;

    int ret;

    int i, j;



    nb_clusters = size_to_clusters(s, bs->file->total_sectors *

                                   BDRV_SECTOR_SIZE);

    expanded_clusters = g_malloc0((nb_clusters + 7) / 8);



    ret = expand_zero_clusters_in_l1(bs, s->l1_table, s->l1_size,

                                     &expanded_clusters, &nb_clusters);

    if (ret < 0) {

        goto fail;

    }



    /* Inactive L1 tables may point to active L2 tables - therefore it is

     * necessary to flush the L2 table cache before trying to access the L2

     * tables pointed to by inactive L1 entries (else we might try to expand

     * zero clusters that have already been expanded); furthermore, it is also

     * necessary to empty the L2 table cache, since it may contain tables which

     * are now going to be modified directly on disk, bypassing the cache.

     * qcow2_cache_empty() does both for us. */

    ret = qcow2_cache_empty(bs, s->l2_table_cache);

    if (ret < 0) {

        goto fail;

    }



    for (i = 0; i < s->nb_snapshots; i++) {

        int l1_sectors = (s->snapshots[i].l1_size * sizeof(uint64_t) +

                BDRV_SECTOR_SIZE - 1) / BDRV_SECTOR_SIZE;



        l1_table = g_realloc(l1_table, l1_sectors * BDRV_SECTOR_SIZE);



        ret = bdrv_read(bs->file, s->snapshots[i].l1_table_offset /

                BDRV_SECTOR_SIZE, (void *)l1_table, l1_sectors);

        if (ret < 0) {

            goto fail;

        }



        for (j = 0; j < s->snapshots[i].l1_size; j++) {

            be64_to_cpus(&l1_table[j]);

        }



        ret = expand_zero_clusters_in_l1(bs, l1_table, s->snapshots[i].l1_size,

                                         &expanded_clusters, &nb_clusters);

        if (ret < 0) {

            goto fail;

        }

    }



    ret = 0;



fail:

    g_free(expanded_clusters);

    g_free(l1_table);

    return ret;

}
",297,"int qcow2_expand_zero_clusters(BlockDriverState *bs)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t *l11_module = NULL;

    uint64_t nb_clusters;

    uint8_t *expanded_clusters;

    int ret;

    int i, j;



    nb_clusters = size_to_clusters(s, bs->file->total_sectors *

                                   BDRV_SECTOR_SIZE);

    expanded_clusters = g_malloc0((nb_clusters + 7) / 8);



    ret = expand_zero_clusters_in_l1(bs, s->l11_module, s->l1_size,

                                     &expanded_clusters, &nb_clusters);

    if (ret < 0) {

        goto fail;

    }



    /* Inactive L1 tables may point to active L2 tables - therefore it is

     * necessary to flush the L2 table cache before trying to access the L2

     * tables pointed to by inactive L1 entries (else we might try to expand

     * zero clusters that have already been expanded); furthermore, it is also

     * necessary to empty the L2 table cache, since it may contain tables which

     * are now going to be modified directly on disk, bypassing the cache.

     * qcow2_cache_empty() does both for us. */

    ret = qcow2_cache_empty(bs, s->l2_table_cache);

    if (ret < 0) {

        goto fail;

    }



    for (i = 0; i < s->nb_snapshots; i++) {

        int l1_sectors = (s->snapshots[i].l1_size * sizeof(uint64_t) +

                BDRV_SECTOR_SIZE - 1) / BDRV_SECTOR_SIZE;



        l11_module = g_realloc(l11_module, l1_sectors * BDRV_SECTOR_SIZE);



        ret = bdrv_read(bs->file, s->snapshots[i].l1_table_offset /

                BDRV_SECTOR_SIZE, (void *)l11_module, l1_sectors);

        if (ret < 0) {

            goto fail;

        }



        for (j = 0; j < s->snapshots[i].l1_size; j++) {

            be64_to_cpus(&l11_module[j]);

        }



        ret = expand_zero_clusters_in_l1(bs, l11_module, s->snapshots[i].l1_size,

                                         &expanded_clusters, &nb_clusters);

        if (ret < 0) {

            goto fail;

        }

    }



    ret = 0;



fail:

    g_free(expanded_clusters);

    g_free(l11_module);

    return ret;

}
",1,1,0.0,1,"bs,s,l1_table,nb_clusters,expanded_clusters,ret,i,j","bs:-0.020118623971939087,s:0.010585665702819824,l1_table:0.05732619762420654,nb_clusters:-0.03324374556541443,expanded_clusters:0.012040466070175171,ret:0.035422712564468384,i:-0.006345301866531372,j:0.0033991634845733643,",1.0,8.0,"l1_table:l11_module,",Greedy,130,0.1280373056729634
63,"static int local_open2(FsContext *fs_ctx, const char *path, int flags,

        FsCred *credp)

{

    int fd = -1;

    int err = -1;

    int serrno = 0;



    /* Determine the security model */

    if (fs_ctx->fs_sm == SM_MAPPED) {

        fd = open(rpath(fs_ctx, path), flags, SM_LOCAL_MODE_BITS);

        if (fd == -1) {

            return fd;

        }

        credp->fc_mode = credp->fc_mode|S_IFREG;

        /* Set cleint credentials in xattr */

        err = local_set_xattr(rpath(fs_ctx, path), credp);

        if (err == -1) {

            serrno = errno;

            goto err_end;

        }

    } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {

        fd = open(rpath(fs_ctx, path), flags, credp->fc_mode);

        if (fd == -1) {

            return fd;

        }

        err = local_post_create_passthrough(fs_ctx, path, credp);

        if (err == -1) {

            serrno = errno;

            goto err_end;

        }

    }

    return fd;



err_end:

    close(fd);

    remove(rpath(fs_ctx, path));

    errno = serrno;

    return err;

}
",206,"static int local_open2(FsContext *fs_ctx, const char *path, int types,

        FsCred *cldp)

{

    int fd = -1;

    int err = -1;

    int serrno = 0;



    /* Determine the security model */

    if (fs_ctx->fs_sm == SM_MAPPED) {

        fd = open(rpath(fs_ctx, path), types, SM_LOCAL_MODE_BITS);

        if (fd == -1) {

            return fd;

        }

        cldp->fc_mode = cldp->fc_mode|S_IFREG;

        /* Set cleint credentials in xattr */

        err = local_set_xattr(rpath(fs_ctx, path), cldp);

        if (err == -1) {

            serrno = errno;

            goto err_end;

        }

    } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {

        fd = open(rpath(fs_ctx, path), types, cldp->fc_mode);

        if (fd == -1) {

            return fd;

        }

        err = local_post_create_passthrough(fs_ctx, path, cldp);

        if (err == -1) {

            serrno = errno;

            goto err_end;

        }

    }

    return fd;



err_end:

    close(fd);

    remove(rpath(fs_ctx, path));

    errno = serrno;

    return err;

}
",1,1,0.0,1,"fs_ctx,path,flags,credp","fs_ctx:-0.05146723985671997,path:-0.05231362581253052,flags:-0.0012266039848327637,credp:0.0017183423042297363,",2.0,9.0,"credp:cldp,flags:types,",Greedy,182,0.16397225856781
74,"static int msrle_decode_pal4(AVCodecContext *avctx, AVPicture *pic,

                             GetByteContext *gb)

{

    unsigned char rle_code;

    unsigned char extra_byte, odd_pixel;

    unsigned char stream_byte;

    unsigned int pixel_ptr = 0;

    int row_dec = pic->linesize[0];

    int row_ptr = (avctx->height - 1) * row_dec;

    int frame_size = row_dec * avctx->height;

    int i;



    while (row_ptr >= 0) {

        if (bytestream2_get_bytes_left(gb) <= 0) {

            av_log(avctx, AV_LOG_ERROR,

                   ""MS RLE: bytestream overrun, %d rows left\n"",

                   row_ptr);

            return AVERROR_INVALIDDATA;

        }

        rle_code = stream_byte = bytestream2_get_byteu(gb);

        if (rle_code == 0) {

            /* fetch the next byte to see how to handle escape code */

            stream_byte = bytestream2_get_byte(gb);

            if (stream_byte == 0) {

                /* line is done, goto the next one */

                row_ptr -= row_dec;

                pixel_ptr = 0;

            } else if (stream_byte == 1) {

                /* decode is done */

                return 0;

            } else if (stream_byte == 2) {

                /* reposition frame decode coordinates */

                stream_byte = bytestream2_get_byte(gb);

                pixel_ptr += stream_byte;

                stream_byte = bytestream2_get_byte(gb);

                row_ptr -= stream_byte * row_dec;

            } else {

                // copy pixels from encoded stream

                odd_pixel =  stream_byte & 1;

                rle_code = (stream_byte + 1) / 2;

                extra_byte = rle_code & 0x01;

                if (row_ptr + pixel_ptr + stream_byte > frame_size ||

                    bytestream2_get_bytes_left(gb) < rle_code) {

                    av_log(avctx, AV_LOG_ERROR,

                           ""MS RLE: frame/stream ptr just went out of bounds (copy)\n"");

                    return AVERROR_INVALIDDATA;

                }



                for (i = 0; i < rle_code; i++) {

                    if (pixel_ptr >= avctx->width)

                        break;

                    stream_byte = bytestream2_get_byteu(gb);

                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;

                    pixel_ptr++;

                    if (i + 1 == rle_code && odd_pixel)

                        break;

                    if (pixel_ptr >= avctx->width)

                        break;

                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;

                    pixel_ptr++;

                }



                // if the RLE code is odd, skip a byte in the stream

                if (extra_byte)

                    bytestream2_skip(gb, 1);

            }

        } else {

            // decode a run of data

            if (row_ptr + pixel_ptr + stream_byte > frame_size) {

                av_log(avctx, AV_LOG_ERROR,

                       ""MS RLE: frame ptr just went out of bounds (run)\n"");

                return AVERROR_INVALIDDATA;

            }

            stream_byte = bytestream2_get_byte(gb);

            for (i = 0; i < rle_code; i++) {

                if (pixel_ptr >= avctx->width)

                    break;

                if ((i & 1) == 0)

                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;

                else

                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;

                pixel_ptr++;

            }

        }

    }



    /* one last sanity check on the way out */

    if (bytestream2_get_bytes_left(gb)) {

        av_log(avctx, AV_LOG_ERROR,

               ""MS RLE: ended frame decode with %d bytes left over\n"",

               bytestream2_get_bytes_left(gb));

        return AVERROR_INVALIDDATA;

    }



    return 0;

}
",488,"static int msrle_decode_pal4(AVCodecContext *avctx, AVPicture *pic,

                             GetByteContext *ui)

{

    unsigned char rle_module;

    unsigned char extra_byte, odd_pixel;

    unsigned char stream_byte;

    unsigned int pixel_ptr = 0;

    int row_dec = pic->linesize[0];

    int row_ptr = (avctx->height - 1) * row_dec;

    int frame_size = row_dec * avctx->height;

    int i;



    while (row_ptr >= 0) {

        if (bytestream2_get_bytes_left(ui) <= 0) {

            av_log(avctx, AV_LOG_ERROR,

                   ""MS RLE: bytestream overrun, %d rows left
"",

                   row_ptr);

            return AVERROR_INVALIDDATA;

        }

        rle_module = stream_byte = bytestream2_get_byteu(ui);

        if (rle_module == 0) {

            /* fetch the next byte to see how to handle escape code */

            stream_byte = bytestream2_get_byte(ui);

            if (stream_byte == 0) {

                /* line is done, goto the next one */

                row_ptr -= row_dec;

                pixel_ptr = 0;

            } else if (stream_byte == 1) {

                /* decode is done */

                return 0;

            } else if (stream_byte == 2) {

                /* reposition frame decode coordinates */

                stream_byte = bytestream2_get_byte(ui);

                pixel_ptr += stream_byte;

                stream_byte = bytestream2_get_byte(ui);

                row_ptr -= stream_byte * row_dec;

            } else {

                // copy pixels from encoded stream

                odd_pixel =  stream_byte & 1;

                rle_module = (stream_byte + 1) / 2;

                extra_byte = rle_module & 0x01;

                if (row_ptr + pixel_ptr + stream_byte > frame_size ||

                    bytestream2_get_bytes_left(ui) < rle_module) {

                    av_log(avctx, AV_LOG_ERROR,

                           ""MS RLE: frame/stream ptr just went out of bounds (copy)
"");

                    return AVERROR_INVALIDDATA;

                }



                for (i = 0; i < rle_module; i++) {

                    if (pixel_ptr >= avctx->width)

                        break;

                    stream_byte = bytestream2_get_byteu(ui);

                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;

                    pixel_ptr++;

                    if (i + 1 == rle_module && odd_pixel)

                        break;

                    if (pixel_ptr >= avctx->width)

                        break;

                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;

                    pixel_ptr++;

                }



                // if the RLE code is odd, skip a byte in the stream

                if (extra_byte)

                    bytestream2_skip(ui, 1);

            }

        } else {

            // decode a run of data

            if (row_ptr + pixel_ptr + stream_byte > frame_size) {

                av_log(avctx, AV_LOG_ERROR,

                       ""MS RLE: frame ptr just went out of bounds (run)
"");

                return AVERROR_INVALIDDATA;

            }

            stream_byte = bytestream2_get_byte(ui);

            for (i = 0; i < rle_module; i++) {

                if (pixel_ptr >= avctx->width)

                    break;

                if ((i & 1) == 0)

                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;

                else

                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;

                pixel_ptr++;

            }

        }

    }



    /* one last sanity check on the way out */

    if (bytestream2_get_bytes_left(ui)) {

        av_log(avctx, AV_LOG_ERROR,

               ""MS RLE: ended frame decode with %d bytes left over
"",

               bytestream2_get_bytes_left(ui));

        return AVERROR_INVALIDDATA;

    }



    return 0;

}
",1,1,0.0,1,"avctx,pic,gb,rle_code,extra_byte,odd_pixel,stream_byte,i,pixel_ptr","avctx:0.16280996799468994,pic:-0.027716100215911865,gb:0.21293771266937256,rle_code:0.4020395874977112,extra_byte:0.12918537855148315,odd_pixel:0.09825706481933594,stream_byte:0.07434248924255371,i:-0.023162841796875,pixel_ptr:0.04045075178146362,",2.0,21.0,"rle_code:rle_module,gb:ui,",Greedy,189,0.186743958791097
76,"static void test_properties(const char *path, bool recurse)

{

    char *child_path;

    QDict *response, *tuple;

    QList *list;

    QListEntry *entry;



    g_test_message(""Obtaining properties of %s"", path);

    response = qmp(""{ 'execute': 'qom-list',""

                   ""  'arguments': { 'path': %s } }"", path);

    g_assert(response);



    if (!recurse) {

        return;

    }



    g_assert(qdict_haskey(response, ""return""));

    list = qobject_to_qlist(qdict_get(response, ""return""));

    QLIST_FOREACH_ENTRY(list, entry) {

        tuple = qobject_to_qdict(qlist_entry_obj(entry));

        bool is_child = strstart(qdict_get_str(tuple, ""type""), ""child<"", NULL);

        bool is_link = strstart(qdict_get_str(tuple, ""type""), ""link<"", NULL);



        if (is_child || is_link) {

            child_path = g_strdup_printf(""%s/%s"",

                                         path, qdict_get_str(tuple, ""name""));

            test_properties(child_path, is_child);

            g_free(child_path);

        } else {

            const char *prop = qdict_get_str(tuple, ""name"");

            g_test_message(""Testing property %s.%s"", path, prop);

            response = qmp(""{ 'execute': 'qom-get',""

                           ""  'arguments': { 'path': %s,""

                           ""                 'property': %s } }"",

                           path, prop);

            /* qom-get may fail but should not, e.g., segfault. */

            g_assert(response);

        }

    }

}
",233,"static void test_properties(const char *step, bool recieve)

{

    char *child___name;

    QDict *reply, *tutable;

    QList *type;

    QListEntry *comment;



    g_test_message(""Obtaining properties of %s"", step);

    reply = qmp(""{ 'execute': 'qom-list',""

                   ""  'arguments': { 'path': %s } }"", step);

    g_assert(reply);



    if (!recieve) {

        return;

    }



    g_assert(qdict_haskey(reply, ""return""));

    type = qobject_to_qlist(qdict_get(reply, ""return""));

    QLIST_FOREACH_ENTRY(type, comment) {

        tutable = qobject_to_qdict(qlist_entry_obj(comment));

        bool is_child = strstart(qdict_get_str(tutable, ""type""), ""child<"", NULL);

        bool is_link = strstart(qdict_get_str(tutable, ""type""), ""link<"", NULL);



        if (is_child || is_link) {

            child___name = g_strdup_printf(""%s/%s"",

                                         step, qdict_get_str(tutable, ""name""));

            test_properties(child___name, is_child);

            g_free(child___name);

        } else {

            const char *option = qdict_get_str(tutable, ""name"");

            g_test_message(""Testing property %s.%s"", step, option);

            reply = qmp(""{ 'execute': 'qom-get',""

                           ""  'arguments': { 'path': %s,""

                           ""                 'property': %s } }"",

                           step, option);

            /* qom-get may fail but should not, e.g., segfault. */

            g_assert(reply);

        }

    }

}
",1,1,0.0,1,"path,recurse,child_path,response,tuple,list,entry,prop","path:-0.010838985443115234,recurse:-0.007108032703399658,child_path:-0.028516173362731934,response:-0.08258378505706787,tuple:-0.07133585214614868,list:0.0007254481315612793,entry:-0.015316426753997803,prop:-0.025760650634765625,",8.0,34.0,"list:type,recurse:recieve,path:step,entry:comment,prop:option,child_path:child___name,tuple:tutable,response:reply,",Greedy,421,0.3968867937723795
78,"static int rdma_add_block(RDMAContext *rdma, const char *block_name,

                         void *host_addr,

                         ram_addr_t block_offset, uint64_t length)

{

    RDMALocalBlocks *local = &rdma->local_ram_blocks;

    RDMALocalBlock *block;

    RDMALocalBlock *old = local->block;



    local->block = g_malloc0(sizeof(RDMALocalBlock) * (local->nb_blocks + 1));



    if (local->nb_blocks) {

        int x;



        if (rdma->blockmap) {

            for (x = 0; x < local->nb_blocks; x++) {

                g_hash_table_remove(rdma->blockmap,

                                    (void *)(uintptr_t)old[x].offset);

                g_hash_table_insert(rdma->blockmap,

                                    (void *)(uintptr_t)old[x].offset,

                                    &local->block[x]);

            }

        }

        memcpy(local->block, old, sizeof(RDMALocalBlock) * local->nb_blocks);

        g_free(old);

    }



    block = &local->block[local->nb_blocks];



    block->block_name = g_strdup(block_name);

    block->local_host_addr = host_addr;

    block->offset = block_offset;

    block->length = length;

    block->index = local->nb_blocks;

    block->src_index = ~0U; /* Filled in by the receipt of the block list */

    block->nb_chunks = ram_chunk_index(host_addr, host_addr + length) + 1UL;

    block->transit_bitmap = bitmap_new(block->nb_chunks);

    bitmap_clear(block->transit_bitmap, 0, block->nb_chunks);

    block->unregister_bitmap = bitmap_new(block->nb_chunks);

    bitmap_clear(block->unregister_bitmap, 0, block->nb_chunks);

    block->remote_keys = g_malloc0(block->nb_chunks * sizeof(uint32_t));



    block->is_ram_block = local->init ? false : true;



    if (rdma->blockmap) {

        g_hash_table_insert(rdma->blockmap, (void *) block_offset, block);

    }



    trace_rdma_add_block(block_name, local->nb_blocks,

                         (uintptr_t) block->local_host_addr,

                         block->offset, block->length,

                         (uintptr_t) (block->local_host_addr + block->length),

                         BITS_TO_LONGS(block->nb_chunks) *

                             sizeof(unsigned long) * 8,

                         block->nb_chunks);



    local->nb_blocks++;



    return 0;

}
",407,"static int rdma_add_block(RDMAContext *rdma, const char *blockingdef,

                         void *server_off,

                         ram_addr_t block_offset, uint64_t type)

{

    RDMALocalBlocks *http = &rdma->local_ram_blocks;

    RDMALocalBlock *block;

    RDMALocalBlock *old = http->block;



    http->block = g_malloc0(sizeof(RDMALocalBlock) * (http->num_locks + 1));



    if (http->num_locks) {

        int x;



        if (rdma->blockmap) {

            for (x = 0; x < http->num_locks; x++) {

                g_hash_table_remove(rdma->blockmap,

                                    (void *)(uintptr_t)old[x].offset);

                g_hash_table_insert(rdma->blockmap,

                                    (void *)(uintptr_t)old[x].offset,

                                    &http->block[x]);

            }

        }

        memcpy(http->block, old, sizeof(RDMALocalBlock) * http->num_locks);

        g_free(old);

    }



    block = &http->block[http->num_locks];



    block->blockingdef = g_strdup(blockingdef);

    block->local_host_addr = server_off;

    block->offset = block_offset;

    block->type = type;

    block->index = http->num_locks;

    block->src_index = ~0U; /* Filled in by the receipt of the block list */

    block->nb_chunks = ram_chunk_index(server_off, server_off + type) + 1UL;

    block->transit_bitmap = bitmap_new(block->nb_chunks);

    bitmap_clear(block->transit_bitmap, 0, block->nb_chunks);

    block->unregister_bitmap = bitmap_new(block->nb_chunks);

    bitmap_clear(block->unregister_bitmap, 0, block->nb_chunks);

    block->remote_keys = g_malloc0(block->nb_chunks * sizeof(uint32_t));



    block->is_ram_block = http->init ? false : true;



    if (rdma->blockmap) {

        g_hash_table_insert(rdma->blockmap, (void *) block_offset, block);

    }



    trace_rdma_add_block(blockingdef, http->num_locks,

                         (uintptr_t) block->local_host_addr,

                         block->offset, block->type,

                         (uintptr_t) (block->local_host_addr + block->type),

                         BITS_TO_LONGS(block->nb_chunks) *

                             sizeof(unsigned long) * 8,

                         block->nb_chunks);



    http->num_locks++;



    return 0;

}
",1,1,0.0,1,"rdma,block_name,host_addr,block_offset,length,local,block,old,x,nb_blocks","rdma:-0.08920848369598389,block_name:0.036962032318115234,host_addr:0.02567005157470703,block_offset:-0.0006548762321472168,length:-0.007131755352020264,local:-0.020116209983825684,block:-0.0459100604057312,old:-0.026468932628631592,x:-0.022880256175994873,nb_blocks:0.02781069278717041,",5.0,37.0,"block_name:blockingdef,nb_blocks:num_locks,host_addr:server_off,block_offset:block_offset,length:type,local:http,",Greedy,368,0.3519731362660726
89,"static inline void RENAME(vu9_to_vu12)(const uint8_t *src1, const uint8_t *src2,

			uint8_t *dst1, uint8_t *dst2,

			long width, long height,

			long srcStride1, long srcStride2,

			long dstStride1, long dstStride2)

{

    long y,x,w,h;

    w=width/2; h=height/2;

#ifdef HAVE_MMX

    asm volatile(

	PREFETCH"" %0\n\t""

	PREFETCH"" %1\n\t""

	::""m""(*(src1+srcStride1)),""m""(*(src2+srcStride2)):""memory"");

#endif

    for(y=0;y<h;y++){

	const uint8_t* s1=src1+srcStride1*(y>>1);

	uint8_t* d=dst1+dstStride1*y;

	x=0;

#ifdef HAVE_MMX

	for(;x<w-31;x+=32)

	{

	    asm volatile(

		PREFETCH"" 32%1\n\t""

	        ""movq	%1, %%mm0\n\t""

	        ""movq	8%1, %%mm2\n\t""

	        ""movq	16%1, %%mm4\n\t""

	        ""movq	24%1, %%mm6\n\t""

	        ""movq	%%mm0, %%mm1\n\t""

	        ""movq	%%mm2, %%mm3\n\t""

	        ""movq	%%mm4, %%mm5\n\t""

	        ""movq	%%mm6, %%mm7\n\t""

		""punpcklbw %%mm0, %%mm0\n\t""

		""punpckhbw %%mm1, %%mm1\n\t""

		""punpcklbw %%mm2, %%mm2\n\t""

		""punpckhbw %%mm3, %%mm3\n\t""

		""punpcklbw %%mm4, %%mm4\n\t""

		""punpckhbw %%mm5, %%mm5\n\t""

		""punpcklbw %%mm6, %%mm6\n\t""

		""punpckhbw %%mm7, %%mm7\n\t""

		MOVNTQ""	%%mm0, %0\n\t""

		MOVNTQ""	%%mm1, 8%0\n\t""

		MOVNTQ""	%%mm2, 16%0\n\t""

		MOVNTQ""	%%mm3, 24%0\n\t""

		MOVNTQ""	%%mm4, 32%0\n\t""

		MOVNTQ""	%%mm5, 40%0\n\t""

		MOVNTQ""	%%mm6, 48%0\n\t""

		MOVNTQ""	%%mm7, 56%0""

		:""=m""(d[2*x])

		:""m""(s1[x])

		:""memory"");

	}

#endif

	for(;x<w;x++) d[2*x]=d[2*x+1]=s1[x];

    }

    for(y=0;y<h;y++){

	const uint8_t* s2=src2+srcStride2*(y>>1);

	uint8_t* d=dst2+dstStride2*y;

	x=0;

#ifdef HAVE_MMX

	for(;x<w-31;x+=32)

	{

	    asm volatile(

		PREFETCH"" 32%1\n\t""

	        ""movq	%1, %%mm0\n\t""

	        ""movq	8%1, %%mm2\n\t""

	        ""movq	16%1, %%mm4\n\t""

	        ""movq	24%1, %%mm6\n\t""

	        ""movq	%%mm0, %%mm1\n\t""

	        ""movq	%%mm2, %%mm3\n\t""

	        ""movq	%%mm4, %%mm5\n\t""

	        ""movq	%%mm6, %%mm7\n\t""

		""punpcklbw %%mm0, %%mm0\n\t""

		""punpckhbw %%mm1, %%mm1\n\t""

		""punpcklbw %%mm2, %%mm2\n\t""

		""punpckhbw %%mm3, %%mm3\n\t""

		""punpcklbw %%mm4, %%mm4\n\t""

		""punpckhbw %%mm5, %%mm5\n\t""

		""punpcklbw %%mm6, %%mm6\n\t""

		""punpckhbw %%mm7, %%mm7\n\t""

		MOVNTQ""	%%mm0, %0\n\t""

		MOVNTQ""	%%mm1, 8%0\n\t""

		MOVNTQ""	%%mm2, 16%0\n\t""

		MOVNTQ""	%%mm3, 24%0\n\t""

		MOVNTQ""	%%mm4, 32%0\n\t""

		MOVNTQ""	%%mm5, 40%0\n\t""

		MOVNTQ""	%%mm6, 48%0\n\t""

		MOVNTQ""	%%mm7, 56%0""

		:""=m""(d[2*x])

		:""m""(s2[x])

		:""memory"");

	}

#endif

	for(;x<w;x++) d[2*x]=d[2*x+1]=s2[x];

    }

#ifdef HAVE_MMX

	asm(

		EMMS"" \n\t""

		SFENCE"" \n\t""

		::: ""memory""

		);

#endif

}
",545,"static inline void RENAME(vu9_to_vu12)(const uint8_t *supp1, const uint8_t *sur20,

			uint8_t *dst1, uint8_t * dsp0,

			long width, long gravity,

			long srcStrite2, long srcStrb1,

			long dstStro2, long dstStgrade
)

{

    long sky,wa,wh,rh;

    wh=width/2; rh=gravity/2;

#ifdef HAVE_MMX

    asm volatile(

	PREFETCH"" %0
\t""

	PREFETCH"" %1
\t""

	::""m""(*(supp1+srcStrite2)),""m""(*(sur20+srcStrb1)):""memory"");

#endif

    for(sky=0;sky<rh;sky++){

	const uint8_t* ds91=supp1+srcStrite2*(sky>>1);

	uint8_t* fd=dst1+dstStro2*sky;

	wa=0;

#ifdef HAVE_MMX

	for(;wa<wh-31;wa+=32)

	{

	    asm volatile(

		PREFETCH"" 32%1
\t""

	        ""movq	%1, %%mm0
\t""

	        ""movq	8%1, %%mm2
\t""

	        ""movq	16%1, %%mm4
\t""

	        ""movq	24%1, %%mm6
\t""

	        ""movq	%%mm0, %%mm1
\t""

	        ""movq	%%mm2, %%mm3
\t""

	        ""movq	%%mm4, %%mm5
\t""

	        ""movq	%%mm6, %%mm7
\t""

		""punpcklbw %%mm0, %%mm0
\t""

		""punpckhbw %%mm1, %%mm1
\t""

		""punpcklbw %%mm2, %%mm2
\t""

		""punpckhbw %%mm3, %%mm3
\t""

		""punpcklbw %%mm4, %%mm4
\t""

		""punpckhbw %%mm5, %%mm5
\t""

		""punpcklbw %%mm6, %%mm6
\t""

		""punpckhbw %%mm7, %%mm7
\t""

		MOVNTQ""	%%mm0, %0
\t""

		MOVNTQ""	%%mm1, 8%0
\t""

		MOVNTQ""	%%mm2, 16%0
\t""

		MOVNTQ""	%%mm3, 24%0
\t""

		MOVNTQ""	%%mm4, 32%0
\t""

		MOVNTQ""	%%mm5, 40%0
\t""

		MOVNTQ""	%%mm6, 48%0
\t""

		MOVNTQ""	%%mm7, 56%0""

		:""=m""(fd[2*wa])

		:""m""(ds91[wa])

		:""memory"");

	}

#endif

	for(;wa<wh;wa++) fd[2*wa]=fd[2*wa+1]=ds91[wa];

    }

    for(sky=0;sky<rh;sky++){

	const uint8_t* s2=sur20+srcStrb1*(sky>>1);

	uint8_t* fd= dsp0+dstStgrade
*sky;

	wa=0;

#ifdef HAVE_MMX

	for(;wa<wh-31;wa+=32)

	{

	    asm volatile(

		PREFETCH"" 32%1
\t""

	        ""movq	%1, %%mm0
\t""

	        ""movq	8%1, %%mm2
\t""

	        ""movq	16%1, %%mm4
\t""

	        ""movq	24%1, %%mm6
\t""

	        ""movq	%%mm0, %%mm1
\t""

	        ""movq	%%mm2, %%mm3
\t""

	        ""movq	%%mm4, %%mm5
\t""

	        ""movq	%%mm6, %%mm7
\t""

		""punpcklbw %%mm0, %%mm0
\t""

		""punpckhbw %%mm1, %%mm1
\t""

		""punpcklbw %%mm2, %%mm2
\t""

		""punpckhbw %%mm3, %%mm3
\t""

		""punpcklbw %%mm4, %%mm4
\t""

		""punpckhbw %%mm5, %%mm5
\t""

		""punpcklbw %%mm6, %%mm6
\t""

		""punpckhbw %%mm7, %%mm7
\t""

		MOVNTQ""	%%mm0, %0
\t""

		MOVNTQ""	%%mm1, 8%0
\t""

		MOVNTQ""	%%mm2, 16%0
\t""

		MOVNTQ""	%%mm3, 24%0
\t""

		MOVNTQ""	%%mm4, 32%0
\t""

		MOVNTQ""	%%mm5, 40%0
\t""

		MOVNTQ""	%%mm6, 48%0
\t""

		MOVNTQ""	%%mm7, 56%0""

		:""=m""(fd[2*wa])

		:""m""(s2[wa])

		:""memory"");

	}

#endif

	for(;wa<wh;wa++) fd[2*wa]=fd[2*wa+1]=s2[wa];

    }

#ifdef HAVE_MMX

	asm(

		EMMS"" 
\t""

		SFENCE"" 
\t""

		::: ""memory""

		);

#endif

}
",1,1,0.0,1,"src1,src2,dst1,dst2,height,srcStride1,srcStride2,dstStride1,dstStride2,y,x,w,h,s1,d,s2","src1:-0.044723689556121826,src2:-0.02788078784942627,dst1:-0.04341381788253784,dst2:-0.022869408130645752,height:-0.008213639259338379,srcStride1:-0.012948691844940186,srcStride2:-0.02988988161087036,dstStride1:-0.019234001636505127,dstStride2:-0.033341288566589355,y:-0.011436820030212402,x:0.016361653804779053,w:-0.006130099296569824,h:-0.0062522292137146,s1:-0.034578144550323486,d:-0.04832291603088379,s2:-0.02238374948501587,",14.0,73.0,"x:wa,w:wh,h:rh,height:gravity,y:sky,srcStride1:srcStrite2,dstStride1:dstStro2,s2:s2,dst2: dsp0,src2:sur20,srcStride2:srcStrb1,dstStride2:dstStgrade
,s1:ds91,dst1:dst1,src1:supp1,d:fd,",Greedy,701,0.7065376162528991
95,"static void spr_read_xer (DisasContext *ctx, int gprn, int sprn)

{

    gen_read_xer(cpu_gpr[gprn]);

}
",24,"static void spr_read_xer (DisasContext *tx, int gPRns, int sprn)

{

    gen_read_xer(cpu_gpr[gPRns]);

}
",1,1,0.0,1,"ctx,gprn,sprn","ctx:0.42927056550979614,gprn:0.41088151931762695,sprn:0.32856738567352295,",2.0,3.0,"ctx:tx,gprn:gPRns,",Greedy,64,0.0627082506815592
99,"static void aml_free(gpointer data, gpointer user_data)

{

    Aml *var = data;

    build_free_array(var->buf);


}",25,"static void aml_free(gpointer data, gpointer user_data)

{

    Aml *func = data;

    build_free_array(func->buf);


}",1,1,0.0,1,"data,user_data,var","data:0.077749103307724,user_data:0.22105026245117188,var:0.33215782046318054,",1.0,2.0,"var:func,",Greedy,44,0.0444773276646931
108,"void FUNC(ff_simple_idct)(DCTELEM *block)

{

    int i;



    for (i = 0; i < 8; i++)

        FUNC(idctRowCondDC)(block + i*8);



    for (i = 0; i < 8; i++)

        FUNC(idctSparseCol)(block + i);

}
",63,"void FUNC(ff_simple_idct)(DCTELEM *label)

{

    int i;



    for (i = 0; i < 8; i++)

        FUNC(idctRowCondDC)(label + i*8);



    for (i = 0; i < 8; i++)

        FUNC(idctSparseCol)(label + i);

}
",1,1,0.0,1,"block,i","block:0.1347741037607193,i:0.09785939753055573,",1.0,3.0,"block:label,",Greedy,62,0.0623684803644816
126,"static void qemu_spice_display_init_one(QemuConsole *con)

{

    SimpleSpiceDisplay *ssd = g_new0(SimpleSpiceDisplay, 1);



    qemu_spice_display_init_common(ssd);



    ssd->qxl.base.sif = &dpy_interface.base;

    qemu_spice_add_display_interface(&ssd->qxl, con);

    assert(ssd->worker);



    qemu_spice_create_host_memslot(ssd);



    ssd->dcl.ops = &display_listener_ops;

    ssd->dcl.con = con;

    register_displaychangelistener(&ssd->dcl);

}
",86,"static void qemu_spice_display_init_one(QemuConsole *func)

{

    SimpleSpiceDisplay *csssd = g_new0(SimpleSpiceDisplay, 1);



    qemu_spice_display_init_common(csssd);



    csssd->qxl.base.sif = &dpy_interface.base;

    qemu_spice_add_display_interface(&csssd->qxl, func);

    assert(csssd->worker);



    qemu_spice_create_host_memslot(csssd);



    csssd->dcl.ops = &display_listener_ops;

    csssd->dcl.func = func;

    register_displaychangelistener(&csssd->dcl);

}
",1,1,0.0,1,"con,ssd","con:0.12018635869026184,ssd:0.24011805653572083,",2.0,13.0,"ssd:csssd,con:func,",Greedy,151,0.1394248684247334
136,"uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)

{

    return inline_cvttq(env, a, float_round_to_zero, 0);

}
",24,"uint64_t helper_cvttq_c(CPUAlphaState *ep, uint64_t area)

{

    return inline_cvttq(ep, area, float_round_to_zero, 0);

}
",1,1,0.0,1,"env,a","env:-0.040964365005493164,a:-0.13391441106796265,",2.0,4.0,"env:ep,a:area,",Greedy,85,0.0864657084147135
143,"static int find_and_decode_index(NUTContext *nut)

{

    AVFormatContext *s = nut->avf;

    AVIOContext *bc    = s->pb;

    uint64_t tmp, end;

    int i, j, syncpoint_count;

    int64_t filesize = avio_size(bc);

    int64_t *syncpoints;

    int8_t *has_keyframe;

    int ret = AVERROR_INVALIDDATA;



    avio_seek(bc, filesize - 12, SEEK_SET);

    avio_seek(bc, filesize - avio_rb64(bc), SEEK_SET);

    if (avio_rb64(bc) != INDEX_STARTCODE) {

        av_log(s, AV_LOG_ERROR, ""no index at the end\n"");

        return ret;

    }



    end  = get_packetheader(nut, bc, 1, INDEX_STARTCODE);

    end += avio_tell(bc);



    ffio_read_varlen(bc); // max_pts

    GET_V(syncpoint_count, tmp < INT_MAX / 8 && tmp > 0);

    syncpoints   = av_malloc(sizeof(int64_t) *  syncpoint_count);

    has_keyframe = av_malloc(sizeof(int8_t)  * (syncpoint_count + 1));

    if (!syncpoints || !has_keyframe)

        return AVERROR(ENOMEM);

    for (i = 0; i < syncpoint_count; i++) {

        syncpoints[i] = ffio_read_varlen(bc);

        if (syncpoints[i] <= 0)

            goto fail;

        if (i)

            syncpoints[i] += syncpoints[i - 1];

    }



    for (i = 0; i < s->nb_streams; i++) {

        int64_t last_pts = -1;

        for (j = 0; j < syncpoint_count;) {

            uint64_t x = ffio_read_varlen(bc);

            int type   = x & 1;

            int n      = j;

            x >>= 1;

            if (type) {

                int flag = x & 1;

                x >>= 1;

                if (n + x >= syncpoint_count + 1) {

                    av_log(s, AV_LOG_ERROR, ""index overflow A\n"");

                    goto fail;

                }

                while (x--)

                    has_keyframe[n++] = flag;

                has_keyframe[n++] = !flag;

            } else {

                while (x != 1) {

                    if (n >= syncpoint_count + 1) {

                        av_log(s, AV_LOG_ERROR, ""index overflow B\n"");

                        goto fail;

                    }

                    has_keyframe[n++] = x & 1;

                    x >>= 1;

                }

            }

            if (has_keyframe[0]) {

                av_log(s, AV_LOG_ERROR, ""keyframe before first syncpoint in index\n"");

                goto fail;

            }

            assert(n <= syncpoint_count + 1);

            for (; j < n && j < syncpoint_count; j++) {

                if (has_keyframe[j]) {

                    uint64_t B, A = ffio_read_varlen(bc);

                    if (!A) {

                        A = ffio_read_varlen(bc);

                        B = ffio_read_varlen(bc);

                        // eor_pts[j][i] = last_pts + A + B

                    } else

                        B = 0;

                    av_add_index_entry(s->streams[i], 16 * syncpoints[j - 1],

                                       last_pts + A, 0, 0, AVINDEX_KEYFRAME);

                    last_pts += A + B;

                }

            }

        }

    }



    if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {

        av_log(s, AV_LOG_ERROR, ""index checksum mismatch\n"");

        goto fail;

    }

    ret = 0;



fail:

    av_free(syncpoints);

    av_free(has_keyframe);

    return ret;

}
",589,"static int find_and_decode_index(NUTContext *feat)

{

    AVFormatContext *os = feat->avf;

    AVIOContext *bc    = os->pb;

    uint64_t tmp, edge;

    int type, aj, syncpoint_count;

    int64_t filesize = avio_size(bc);

    int64_t *syncpoints;

    int8_t *has_keyframe;

    int ret = AVERROR_INVALIDDATA;



    avio_seek(bc, filesize - 12, SEEK_SET);

    avio_seek(bc, filesize - avio_rb64(bc), SEEK_SET);

    if (avio_rb64(bc) != INDEX_STARTCODE) {

        av_log(os, AV_LOG_ERROR, ""no index at the end
"");

        return ret;

    }



    edge  = get_packetheader(feat, bc, 1, INDEX_STARTCODE);

    edge += avio_tell(bc);



    ffio_read_varlen(bc); // max_pts

    GET_V(syncpoint_count, tmp < INT_MAX / 8 && tmp > 0);

    syncpoints   = av_malloc(sizeof(int64_t) *  syncpoint_count);

    has_keyframe = av_malloc(sizeof(int8_t)  * (syncpoint_count + 1));

    if (!syncpoints || !has_keyframe)

        return AVERROR(ENOMEM);

    for (type = 0; type < syncpoint_count; type++) {

        syncpoints[type] = ffio_read_varlen(bc);

        if (syncpoints[type] <= 0)

            goto fail;

        if (type)

            syncpoints[type] += syncpoints[type - 1];

    }



    for (type = 0; type < os->nb_streams; type++) {

        int64_t last_pts = -1;

        for (aj = 0; aj < syncpoint_count;) {

            uint64_t x = ffio_read_varlen(bc);

            int type   = x & 1;

            int n      = aj;

            x >>= 1;

            if (type) {

                int flag = x & 1;

                x >>= 1;

                if (n + x >= syncpoint_count + 1) {

                    av_log(os, AV_LOG_ERROR, ""index overflow A
"");

                    goto fail;

                }

                while (x--)

                    has_keyframe[n++] = flag;

                has_keyframe[n++] = !flag;

            } else {

                while (x != 1) {

                    if (n >= syncpoint_count + 1) {

                        av_log(os, AV_LOG_ERROR, ""index overflow B
"");

                        goto fail;

                    }

                    has_keyframe[n++] = x & 1;

                    x >>= 1;

                }

            }

            if (has_keyframe[0]) {

                av_log(os, AV_LOG_ERROR, ""keyframe before first syncpoint in index
"");

                goto fail;

            }

            assert(n <= syncpoint_count + 1);

            for (; aj < n && aj < syncpoint_count; aj++) {

                if (has_keyframe[aj]) {

                    uint64_t B, A = ffio_read_varlen(bc);

                    if (!A) {

                        A = ffio_read_varlen(bc);

                        B = ffio_read_varlen(bc);

                        // eor_pts[j][i] = last_pts + A + B

                    } else

                        B = 0;

                    av_add_index_entry(os->streams[type], 16 * syncpoints[aj - 1],

                                       last_pts + A, 0, 0, AVINDEX_KEYFRAME);

                    last_pts += A + B;

                }

            }

        }

    }



    if (skip_reserved(bc, edge) || ffio_get_checksum(bc)) {

        av_log(os, AV_LOG_ERROR, ""index checksum mismatch
"");

        goto fail;

    }

    ret = 0;



fail:

    av_free(syncpoints);

    av_free(has_keyframe);

    return ret;

}
",1,1,0.0,1,"nut,s,bc,tmp,end,i,j,syncpoint_count,syncpoints,has_keyframe,x","nut:-0.0032538175582885742,s:-0.005492866039276123,bc:-0.033600032329559326,tmp:-0.061615169048309326,end:-0.013183236122131348,i:-0.002078533172607422,j:-0.010364651679992676,syncpoint_count:-0.05642414093017578,syncpoints:-0.02147573232650757,has_keyframe:-0.022726833820343018,x:-0.018872737884521484,",5.0,38.0,"i:type,nut:feat,s:os,j:aj,end:edge,",Greedy,354,0.3571563680966695
144,"static inline void menelaus_rtc_stop(struct menelaus_s *s)

{

    qemu_del_timer(s->rtc.hz);

    s->rtc.next =- qemu_get_clock(rt_clock);

    if (s->rtc.next < 1)

        s->rtc.next = 1;

}
",51,"static inline void menelaus_rtc_stop(struct menelaus_s *sys)

{

    qemu_del_timer(sys->rtc.hz);

    sys->rtc.next =- qemu_get_clock(rt_clock);

    if (sys->rtc.next < 1)

        sys->rtc.next = 1;

}
",1,1,0.0,1,s,"s:-0.1881524920463562,",1.0,5.0,"s:sys,",Greedy,60,0.060384980837504
153,"int ff_jni_exception_get_summary(JNIEnv *env, jthrowable exception, char **error, void *log_ctx)

{

    int ret = 0;



    AVBPrint bp;



    char *name = NULL;

    char *message = NULL;



    jclass class_class = NULL;

    jmethodID get_name_id = NULL;



    jclass exception_class = NULL;

    jmethodID get_message_id = NULL;



    jstring string;



    av_bprint_init(&bp, 0, AV_BPRINT_SIZE_AUTOMATIC);



    exception_class = (*env)->GetObjectClass(env, exception);

    if ((*env)->ExceptionCheck(env)) {

        (*env)->ExceptionClear(env);

        av_log(log_ctx, AV_LOG_ERROR, ""Could not find Throwable class\n"");

        ret = AVERROR_EXTERNAL;

        goto done;

    }



    class_class = (*env)->GetObjectClass(env, exception_class);

    if ((*env)->ExceptionCheck(env)) {

        (*env)->ExceptionClear(env);

        av_log(log_ctx, AV_LOG_ERROR, ""Could not find Throwable class's class\n"");

        ret = AVERROR_EXTERNAL;

        goto done;

    }



    get_name_id = (*env)->GetMethodID(env, class_class, ""getName"", ""()Ljava/lang/String;"");

    if ((*env)->ExceptionCheck(env)) {

        (*env)->ExceptionClear(env);

        av_log(log_ctx, AV_LOG_ERROR, ""Could not find method Class.getName()\n"");

        ret = AVERROR_EXTERNAL;

        goto done;

    }



    string = (*env)->CallObjectMethod(env, exception_class, get_name_id);

    if ((*env)->ExceptionCheck(env)) {

        (*env)->ExceptionClear(env);

        av_log(log_ctx, AV_LOG_ERROR, ""Class.getName() threw an exception\n"");

        ret = AVERROR_EXTERNAL;

        goto done;

    }



    if (string) {

        name = ff_jni_jstring_to_utf_chars(env, string, log_ctx);

        (*env)->DeleteLocalRef(env, string);

        string = NULL;

    }



    get_message_id = (*env)->GetMethodID(env, exception_class, ""getMessage"", ""()Ljava/lang/String;"");

    if ((*env)->ExceptionCheck(env)) {

        (*env)->ExceptionClear(env);

        av_log(log_ctx, AV_LOG_ERROR, ""Could not find method java/lang/Throwable.getMessage()\n"");

        ret = AVERROR_EXTERNAL;

        goto done;

    }



    string = (*env)->CallObjectMethod(env, exception, get_message_id);

    if ((*env)->ExceptionCheck(env)) {

        (*env)->ExceptionClear(env);

        av_log(log_ctx, AV_LOG_ERROR, ""Throwable.getMessage() threw an exception\n"");

        ret = AVERROR_EXTERNAL;

        goto done;

    }



    if (string) {

        message = ff_jni_jstring_to_utf_chars(env, string, log_ctx);

        (*env)->DeleteLocalRef(env, string);

        string = NULL;

    }



    if (name && message) {

        av_bprintf(&bp, ""%s: %s"", name, message);

    } else if (name && !message) {

        av_bprintf(&bp, ""%s occurred"", name);

    } else if (!name && message) {

        av_bprintf(&bp, ""Exception: %s"", message);

    } else {

        av_log(log_ctx, AV_LOG_WARNING, ""Could not retreive exception name and message\n"");

        av_bprintf(&bp, ""Exception occurred"");

    }



    ret = av_bprint_finalize(&bp, error);

done:



    av_free(name);

    av_free(message);



    if (class_class) {

        (*env)->DeleteLocalRef(env, class_class);

    }



    if (exception_class) {

        (*env)->DeleteLocalRef(env, exception_class);

    }



    if (string) {

        (*env)->DeleteLocalRef(env, string);

    }



    return ret;

}
",650,"int ff_jni_exception_get_summary(JNIEnv *en, jthrowable exception, char **error, void *log_ctx)

{

    int ret = 0;



    AVBPrint bp;



    char *name = NULL;

    char *message = NULL;



    jclass class_class = NULL;

    jmethodID get_name_id = NULL;



    jclass exception_class = NULL;

    jmethodID get_message_id = NULL;



    jstring string;



    av_bprint_init(&bp, 0, AV_BPRINT_SIZE_AUTOMATIC);



    exception_class = (*en)->GetObjectClass(en, exception);

    if ((*en)->ExceptionCheck(en)) {

        (*en)->ExceptionClear(en);

        av_log(log_ctx, AV_LOG_ERROR, ""Could not find Throwable class
"");

        ret = AVERROR_EXTERNAL;

        goto done;

    }



    class_class = (*en)->GetObjectClass(en, exception_class);

    if ((*en)->ExceptionCheck(en)) {

        (*en)->ExceptionClear(en);

        av_log(log_ctx, AV_LOG_ERROR, ""Could not find Throwable class's class
"");

        ret = AVERROR_EXTERNAL;

        goto done;

    }



    get_name_id = (*en)->GetMethodID(en, class_class, ""getName"", ""()Ljava/lang/String;"");

    if ((*en)->ExceptionCheck(en)) {

        (*en)->ExceptionClear(en);

        av_log(log_ctx, AV_LOG_ERROR, ""Could not find method Class.getName()
"");

        ret = AVERROR_EXTERNAL;

        goto done;

    }



    string = (*en)->CallObjectMethod(en, exception_class, get_name_id);

    if ((*en)->ExceptionCheck(en)) {

        (*en)->ExceptionClear(en);

        av_log(log_ctx, AV_LOG_ERROR, ""Class.getName() threw an exception
"");

        ret = AVERROR_EXTERNAL;

        goto done;

    }



    if (string) {

        name = ff_jni_jstring_to_utf_chars(en, string, log_ctx);

        (*en)->DeleteLocalRef(en, string);

        string = NULL;

    }



    get_message_id = (*en)->GetMethodID(en, exception_class, ""getMessage"", ""()Ljava/lang/String;"");

    if ((*en)->ExceptionCheck(en)) {

        (*en)->ExceptionClear(en);

        av_log(log_ctx, AV_LOG_ERROR, ""Could not find method java/lang/Throwable.getMessage()
"");

        ret = AVERROR_EXTERNAL;

        goto done;

    }



    string = (*en)->CallObjectMethod(en, exception, get_message_id);

    if ((*en)->ExceptionCheck(en)) {

        (*en)->ExceptionClear(en);

        av_log(log_ctx, AV_LOG_ERROR, ""Throwable.getMessage() threw an exception
"");

        ret = AVERROR_EXTERNAL;

        goto done;

    }



    if (string) {

        message = ff_jni_jstring_to_utf_chars(en, string, log_ctx);

        (*en)->DeleteLocalRef(en, string);

        string = NULL;

    }



    if (name && message) {

        av_bprintf(&bp, ""%s: %s"", name, message);

    } else if (name && !message) {

        av_bprintf(&bp, ""%s occurred"", name);

    } else if (!name && message) {

        av_bprintf(&bp, ""Exception: %s"", message);

    } else {

        av_log(log_ctx, AV_LOG_WARNING, ""Could not retreive exception name and message
"");

        av_bprintf(&bp, ""Exception occurred"");

    }



    ret = av_bprint_finalize(&bp, error);

done:



    av_free(name);

    av_free(message);



    if (class_class) {

        (*en)->DeleteLocalRef(en, class_class);

    }



    if (exception_class) {

        (*en)->DeleteLocalRef(en, exception_class);

    }



    if (string) {

        (*en)->DeleteLocalRef(en, string);

    }



    return ret;

}
",1,1,0.0,1,"env,exception,error,log_ctx,bp,name,message","env:0.06481099128723145,exception:0.02482929825782776,error:-0.001635432243347168,log_ctx:-0.00733676552772522,bp:0.04451844096183777,name:0.025041162967681885,message:0.004661500453948975,",1.0,49.0,"env:en,",Greedy,188,0.1747370958328247
154,"static void vscsi_command_complete(SCSIBus *bus, int reason, uint32_t tag,

                                   uint32_t arg)

{

    VSCSIState *s = DO_UPCAST(VSCSIState, vdev.qdev, bus->qbus.parent);

    vscsi_req *req = vscsi_find_req(s, tag);

    SCSIDevice *sdev;

    uint8_t *buf;

    int32_t res_in = 0, res_out = 0;

    int len, rc = 0;



    dprintf(""VSCSI: SCSI cmd complete, r=0x%x tag=0x%x arg=0x%x, req=%p\n"",

            reason, tag, arg, req);

    if (req == NULL) {

        fprintf(stderr, ""VSCSI: Can't find request for tag 0x%x\n"", tag);

        return;

    }

    sdev = req->sdev;



    if (req->sensing) {

        if (reason == SCSI_REASON_DONE) {

            dprintf(""VSCSI: Sense done !\n"");

            vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);

            vscsi_put_req(s, req);

        } else {

            uint8_t *buf = sdev->info->get_buf(sdev, tag);



            len = MIN(arg, SCSI_SENSE_BUF_SIZE);

            dprintf(""VSCSI: Sense data, %d bytes:\n"", len);

            dprintf(""       %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x\n"",

                    buf[0], buf[1], buf[2], buf[3],

                    buf[4], buf[5], buf[6], buf[7]);

            dprintf(""       %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x\n"",

                    buf[8], buf[9], buf[10], buf[11],

                    buf[12], buf[13], buf[14], buf[15]);

            memcpy(req->sense, buf, len);

            req->senselen = len;

            sdev->info->read_data(sdev, req->qtag);

        }

        return;

    }



    if (reason == SCSI_REASON_DONE) {

        dprintf(""VSCSI: Command complete err=%d\n"", arg);

        if (arg == 0) {

            /* We handle overflows, not underflows for normal commands,

             * but hopefully nobody cares

             */

            if (req->writing) {

                res_out = req->data_len;

            } else {

                res_in = req->data_len;

            }

            vscsi_send_rsp(s, req, 0, res_in, res_out);

        } else if (arg == CHECK_CONDITION) {

            dprintf(""VSCSI: Got CHECK_CONDITION, requesting sense...\n"");

            vscsi_send_request_sense(s, req);

            return;

        } else {

            vscsi_send_rsp(s, req, arg, 0, 0);

        }

        vscsi_put_req(s, req);

        return;

    }



    /* ""arg"" is how much we have read for reads and how much we want

     * to write for writes (ie, how much is to be DMA'd)

     */

    if (arg) {

        buf = sdev->info->get_buf(sdev, tag);

        rc = vscsi_srp_transfer_data(s, req, req->writing, buf, arg);

    }

    if (rc < 0) {

        fprintf(stderr, ""VSCSI: RDMA error rc=%d!\n"", rc);

        sdev->info->cancel_io(sdev, req->qtag);

        vscsi_makeup_sense(s, req, HARDWARE_ERROR, 0, 0);

        vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);

        vscsi_put_req(s, req);

        return;

    }



    /* Start next chunk */

    req->data_len -= rc;

    if (req->writing) {

        sdev->info->write_data(sdev, req->qtag);

    } else {

        sdev->info->read_data(sdev, req->qtag);

    }

}
",568,"static void vscsi_command_complete(SCSIBus *bus, int reason, uint32_t tag,

                                   uint32_t arg)

{

    VSCSIState *service = DO_UPCAST(VSCSIState, vdev.qdev, bus->qbus.parent);

    vscsi_req *org = vscsi_find_req(service, tag);

    SCSIDevice *sdev;

    uint8_t *buf;

    int32_t res_in = 0, res_out = 0;

    int len, rc = 0;



    dprintf(""VSCSI: SCSI cmd complete, r=0x%x tag=0x%x arg=0x%x, req=%p
"",

            reason, tag, arg, org);

    if (org == NULL) {

        fprintf(stderr, ""VSCSI: Can't find request for tag 0x%x
"", tag);

        return;

    }

    sdev = org->sdev;



    if (org->sensing) {

        if (reason == SCSI_REASON_DONE) {

            dprintf(""VSCSI: Sense done !
"");

            vscsi_send_rsp(service, org, CHECK_CONDITION, 0, 0);

            vscsi_put_req(service, org);

        } else {

            uint8_t *buf = sdev->info->get_buf(sdev, tag);



            len = MIN(arg, SCSI_SENSE_BUF_SIZE);

            dprintf(""VSCSI: Sense data, %d bytes:
"", len);

            dprintf(""       %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x
"",

                    buf[0], buf[1], buf[2], buf[3],

                    buf[4], buf[5], buf[6], buf[7]);

            dprintf(""       %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x
"",

                    buf[8], buf[9], buf[10], buf[11],

                    buf[12], buf[13], buf[14], buf[15]);

            memcpy(org->sense, buf, len);

            org->senselen = len;

            sdev->info->read_data(sdev, org->qtag);

        }

        return;

    }



    if (reason == SCSI_REASON_DONE) {

        dprintf(""VSCSI: Command complete err=%d
"", arg);

        if (arg == 0) {

            /* We handle overflows, not underflows for normal commands,

             * but hopefully nobody cares

             */

            if (org->writing) {

                res_out = org->data_len;

            } else {

                res_in = org->data_len;

            }

            vscsi_send_rsp(service, org, 0, res_in, res_out);

        } else if (arg == CHECK_CONDITION) {

            dprintf(""VSCSI: Got CHECK_CONDITION, requesting sense...
"");

            vscsi_send_request_sense(service, org);

            return;

        } else {

            vscsi_send_rsp(service, org, arg, 0, 0);

        }

        vscsi_put_req(service, org);

        return;

    }



    /* ""arg"" is how much we have read for reads and how much we want

     * to write for writes (ie, how much is to be DMA'd)

     */

    if (arg) {

        buf = sdev->info->get_buf(sdev, tag);

        rc = vscsi_srp_transfer_data(service, org, org->writing, buf, arg);

    }

    if (rc < 0) {

        fprintf(stderr, ""VSCSI: RDMA error rc=%d!
"", rc);

        sdev->info->cancel_io(sdev, org->qtag);

        vscsi_makeup_sense(service, org, HARDWARE_ERROR, 0, 0);

        vscsi_send_rsp(service, org, CHECK_CONDITION, 0, 0);

        vscsi_put_req(service, org);

        return;

    }



    /* Start next chunk */

    org->data_len -= rc;

    if (org->writing) {

        sdev->info->write_data(sdev, org->qtag);

    } else {

        sdev->info->read_data(sdev, org->qtag);

    }

}
",1,1,0.0,1,"bus,reason,tag,arg,s,req,sdev,buf,len","bus:0.0012795627117156982,reason:-0.021289736032485962,tag:0.0018581748008728027,arg:-0.006786763668060303,s:0.018276870250701904,req:0.03727823495864868,sdev:-0.0018310844898223877,buf:0.005170166492462158,len:0.0009582638740539551,",2.0,39.0,"req:org,s:service,",Greedy,243,0.2395743409792582
175,"static int update_dimensions(VP8Context *s, int width, int height)

{

    if (width  != s->avctx->width ||

        height != s->avctx->height) {

        if (av_image_check_size(width, height, 0, s->avctx))

            return AVERROR_INVALIDDATA;



        vp8_decode_flush_impl(s->avctx, 1, 0, 1);



        avcodec_set_dimensions(s->avctx, width, height);

    }



    s->mb_width  = (s->avctx->coded_width +15) / 16;

    s->mb_height = (s->avctx->coded_height+15) / 16;



    s->macroblocks_base        = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks));

    s->filter_strength         = av_mallocz(s->mb_width*sizeof(*s->filter_strength));

    s->intra4x4_pred_mode_top  = av_mallocz(s->mb_width*4);

    s->top_nnz                 = av_mallocz(s->mb_width*sizeof(*s->top_nnz));

    s->top_border              = av_mallocz((s->mb_width+1)*sizeof(*s->top_border));



    if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top ||

        !s->top_nnz || !s->top_border)

        return AVERROR(ENOMEM);



    s->macroblocks        = s->macroblocks_base + 1;



    return 0;

}
",259,"static int update_dimensions(VP8Context *i, int width, int device)

{

    if (width  != i->avctx->width ||

        device != i->avctx->device) {

        if (av_image_check_size(width, device, 0, i->avctx))

            return AVERROR_INVALIDDATA;



        vp8_decode_flush_impl(i->avctx, 1, 0, 1);



        avcodec_set_dimensions(i->avctx, width, device);

    }



    i->mb_width  = (i->avctx->coded_width +15) / 16;

    i->mb_height = (i->avctx->coded_height+15) / 16;



    i->macroblocks_base        = av_mallocz((i->mb_width+i->mb_height*2+1)*sizeof(*i->macroblocks));

    i->filter_strength         = av_mallocz(i->mb_width*sizeof(*i->filter_strength));

    i->intra4x4_pred_mode_top  = av_mallocz(i->mb_width*4);

    i->top_nnz                 = av_mallocz(i->mb_width*sizeof(*i->top_nnz));

    i->top_border              = av_mallocz((i->mb_width+1)*sizeof(*i->top_border));



    if (!i->macroblocks_base || !i->filter_strength || !i->intra4x4_pred_mode_top ||

        !i->top_nnz || !i->top_border)

        return AVERROR(ENOMEM);



    i->macroblocks        = i->macroblocks_base + 1;



    return 0;

}
",1,1,0.0,1,"s,height","s:-0.0003147721290588379,height:0.021932244300842285,",2.0,37.0,"height:device,s:i,",Greedy,178,0.1700465559959411
187,"static int dv_read_seek(AVFormatContext *s, int stream_index,

                       int64_t timestamp, int flags)

{

    RawDVContext *r   = s->priv_data;

    DVDemuxContext *c = r->dv_demux;

    int64_t offset    = dv_frame_offset(s, c, timestamp, flags);



    dv_offset_reset(c, offset / c->sys->frame_size);



    offset = avio_seek(s->pb, offset, SEEK_SET);

    return (offset < 0) ? offset : 0;

}
",86,"static int dv_read_seek(AVFormatContext *s, int stream_index,

                       int64_t timestamp, int fd)

{

    RawDVContext *as   = s->priv_data;

    DVDemuxContext *c = as->dv_demux;

    int64_t offset    = dv_frame_offset(s, c, timestamp, fd);



    dv_offset_reset(c, offset / c->sys->frame_size);



    offset = avio_seek(s->pb, offset, SEEK_SET);

    return (offset < 0) ? offset : 0;

}
",1,1,0.0,1,"s,stream_index,timestamp,flags,r,c","s:-0.10983949899673462,stream_index:-0.12284320592880249,timestamp:-0.07050418853759766,flags:-0.03403407335281372,r:-0.048993706703186035,c:-0.11401045322418213,",2.0,4.0,"flags:fd,r:as,",Greedy,92,0.084443994363149
188,"static void spapr_phb_hot_plug_child(HotplugHandler *plug_handler,

                                     DeviceState *plugged_dev, Error **errp)

{

    sPAPRPHBState *phb = SPAPR_PCI_HOST_BRIDGE(DEVICE(plug_handler));

    PCIDevice *pdev = PCI_DEVICE(plugged_dev);

    sPAPRDRConnector *drc = spapr_phb_get_pci_drc(phb, pdev);

    Error *local_err = NULL;



    /* if DR is disabled we don't need to do anything in the case of

     * hotplug or coldplug callbacks

     */

    if (!phb->dr_enabled) {

        /* if this is a hotplug operation initiated by the user

         * we need to let them know it's not enabled

         */

        if (plugged_dev->hotplugged) {

            error_setg(errp, QERR_BUS_NO_HOTPLUG,

                       object_get_typename(OBJECT(phb)));

        }

        return;

    }



    g_assert(drc);



    spapr_phb_add_pci_device(drc, phb, pdev, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }

    if (plugged_dev->hotplugged) {

        spapr_hotplug_req_add_by_index(drc);

    }

}
",136,"static void spapr_phb_hot_plug_child(HotplugHandler *plug_handler,

                                     DeviceState *plugged_dev, Error **strp)

{

    sPAPRPHBState *Phd = SPAPR_PCI_HOST_BRIDGE(DEVICE(plug_handler));

    PCIDevice *tname = PCI_DEVICE(plugged_dev);

    sPAPRDRConnector *drc = spapr_phb_get_pci_drc(Phd, tname);

    Error *local_err = NULL;



    /* if DR is disabled we don't need to do anything in the case of

     * hotplug or coldplug callbacks

     */

    if (!Phd->dr_enabled) {

        /* if this is a hotplug operation initiated by the user

         * we need to let them know it's not enabled

         */

        if (plugged_dev->hotplugged) {

            error_setg(strp, QERR_BUS_NO_HOTPLUG,

                       object_get_typename(OBJECT(Phd)));

        }

        return;

    }



    g_assert(drc);



    spapr_phb_add_pci_device(drc, Phd, tname, &local_err);

    if (local_err) {

        error_propagate(strp, local_err);

        return;

    }

    if (plugged_dev->hotplugged) {

        spapr_hotplug_req_add_by_index(drc);

    }

}
",1,1,0.0,1,"plug_handler,plugged_dev,errp,phb,pdev,drc,local_err","plug_handler:-0.0022162795066833496,plugged_dev:0.00718533992767334,errp:0.048992931842803955,phb:0.04484090209007263,pdev:0.038661301136016846,drc:0.03752243518829346,local_err:0.018793433904647827,",3.0,11.0,"errp:strp,phb:Phd,pdev:tname,",Greedy,147,0.1373631079991658
190,"static int libquvi_read_header(AVFormatContext *s)

{

    int i, ret;

    quvi_t q;

    quvi_media_t m;

    QUVIcode rc;

    LibQuviContext *qc = s->priv_data;

    char *media_url, *pagetitle;



    rc = quvi_init(&q);

    if (rc != QUVI_OK)

        goto quvi_fail;



    quvi_setopt(q, QUVIOPT_FORMAT, qc->format);



    rc = quvi_parse(q, s->filename, &m);

    if (rc != QUVI_OK)

        goto quvi_fail;



    rc = quvi_getprop(m, QUVIPROP_MEDIAURL, &media_url);

    if (rc != QUVI_OK)

        goto quvi_fail;



    av_assert0(!qc->fmtctx->codec_whitelist && !qc->fmtctx->format_whitelist);

    qc->fmtctx-> codec_whitelist = av_strdup(s->codec_whitelist);

    qc->fmtctx->format_whitelist = av_strdup(s->format_whitelist);



    ret = avformat_open_input(&qc->fmtctx, media_url, NULL, NULL);

    if (ret < 0)

        goto end;



    rc = quvi_getprop(m, QUVIPROP_PAGETITLE, &pagetitle);

    if (rc == QUVI_OK)

        av_dict_set(&s->metadata, ""title"", pagetitle, 0);



    for (i = 0; i < qc->fmtctx->nb_streams; i++) {

        AVStream *st = avformat_new_stream(s, NULL);

        AVStream *ist = qc->fmtctx->streams[i];

        if (!st) {

            ret = AVERROR(ENOMEM);

            goto end;

        }

        avpriv_set_pts_info(st, ist->pts_wrap_bits, ist->time_base.num, ist->time_base.den);

        avcodec_copy_context(st->codec, qc->fmtctx->streams[i]->codec);

    }



    return 0;



quvi_fail:

    av_log(s, AV_LOG_ERROR, ""%s\n"", quvi_strerror(q, rc));

    ret = AVERROR_EXTERNAL;



end:

    quvi_parse_close(&m);

    quvi_close(&q);

    return ret;

}
",354,"static int libquvi_read_header(AVFormatContext *args)

{

    int i, alt;

    quvi_t q;

    quvi_media_t m;

    QUVIcode rc;

    LibQuviContext *qc = args->priv_data;

    char *media_url, *pagetitle;



    rc = quvi_init(&q);

    if (rc != QUVI_OK)

        goto quvi_fail;



    quvi_setopt(q, QUVIOPT_FORMAT, qc->format);



    rc = quvi_parse(q, args->filename, &m);

    if (rc != QUVI_OK)

        goto quvi_fail;



    rc = quvi_getprop(m, QUVIPROP_MEDIAURL, &media_url);

    if (rc != QUVI_OK)

        goto quvi_fail;



    av_assert0(!qc->fmtctx->codec_whitelist && !qc->fmtctx->format_whitelist);

    qc->fmtctx-> codec_whitelist = av_strdup(args->codec_whitelist);

    qc->fmtctx->format_whitelist = av_strdup(args->format_whitelist);



    alt = avformat_open_input(&qc->fmtctx, media_url, NULL, NULL);

    if (alt < 0)

        goto end;



    rc = quvi_getprop(m, QUVIPROP_PAGETITLE, &pagetitle);

    if (rc == QUVI_OK)

        av_dict_set(&args->metadata, ""title"", pagetitle, 0);



    for (i = 0; i < qc->fmtctx->nb_streams; i++) {

        AVStream *stage = avformat_new_stream(args, NULL);

        AVStream *ist = qc->fmtctx->streams[i];

        if (!stage) {

            alt = AVERROR(ENOMEM);

            goto end;

        }

        avpriv_set_pts_info(stage, ist->pts_wrap_bits, ist->time_base.num, ist->time_base.den);

        avcodec_copy_context(stage->codec, qc->fmtctx->streams[i]->codec);

    }



    return 0;



quvi_fail:

    av_log(args, AV_LOG_ERROR, ""%s
"", quvi_strerror(q, rc));

    alt = AVERROR_EXTERNAL;



end:

    quvi_parse_close(&m);

    quvi_close(&q);

    return alt;

}
",1,1,0.0,1,"s,i,ret,q,m,rc,qc,media_url,pagetitle,st,ist","s:-0.015310823917388916,i:-0.029042065143585205,ret:-0.01931101083755493,q:-0.030076146125793457,m:-0.028617024421691895,rc:-0.035178303718566895,qc:-0.12126070261001587,media_url:-0.056084394454956055,pagetitle:-0.06681960821151733,st:-0.019366800785064697,ist:-0.06347721815109253,",3.0,18.0,"s:args,ret:alt,st:stage,",Greedy,230,0.2113147536913553
196,"static int rebuild_refcount_structure(BlockDriverState *bs,

                                      BdrvCheckResult *res,

                                      void **refcount_table,

                                      int64_t *nb_clusters)

{

    BDRVQcow2State *s = bs->opaque;

    int64_t first_free_cluster = 0, reftable_offset = -1, cluster = 0;

    int64_t refblock_offset, refblock_start, refblock_index;

    uint32_t reftable_size = 0;

    uint64_t *on_disk_reftable = NULL;

    void *on_disk_refblock;

    int ret = 0;

    struct {

        uint64_t reftable_offset;

        uint32_t reftable_clusters;

    } QEMU_PACKED reftable_offset_and_clusters;



    qcow2_cache_empty(bs, s->refcount_block_cache);



write_refblocks:

    for (; cluster < *nb_clusters; cluster++) {

        if (!s->get_refcount(*refcount_table, cluster)) {

            continue;

        }



        refblock_index = cluster >> s->refcount_block_bits;

        refblock_start = refblock_index << s->refcount_block_bits;



        /* Don't allocate a cluster in a refblock already written to disk */

        if (first_free_cluster < refblock_start) {

            first_free_cluster = refblock_start;

        }

        refblock_offset = alloc_clusters_imrt(bs, 1, refcount_table,

                                              nb_clusters, &first_free_cluster);

        if (refblock_offset < 0) {

            fprintf(stderr, ""ERROR allocating refblock: %s\n"",

                    strerror(-refblock_offset));

            res->check_errors++;

            ret = refblock_offset;

            goto fail;

        }



        if (reftable_size <= refblock_index) {

            uint32_t old_reftable_size = reftable_size;

            uint64_t *new_on_disk_reftable;



            reftable_size = ROUND_UP((refblock_index + 1) * sizeof(uint64_t),

                                     s->cluster_size) / sizeof(uint64_t);

            new_on_disk_reftable = g_try_realloc(on_disk_reftable,

                                                 reftable_size *

                                                 sizeof(uint64_t));

            if (!new_on_disk_reftable) {

                res->check_errors++;

                ret = -ENOMEM;

                goto fail;

            }

            on_disk_reftable = new_on_disk_reftable;



            memset(on_disk_reftable + old_reftable_size, 0,

                   (reftable_size - old_reftable_size) * sizeof(uint64_t));



            /* The offset we have for the reftable is now no longer valid;

             * this will leak that range, but we can easily fix that by running

             * a leak-fixing check after this rebuild operation */

            reftable_offset = -1;

        }

        on_disk_reftable[refblock_index] = refblock_offset;



        /* If this is apparently the last refblock (for now), try to squeeze the

         * reftable in */

        if (refblock_index == (*nb_clusters - 1) >> s->refcount_block_bits &&

            reftable_offset < 0)

        {

            uint64_t reftable_clusters = size_to_clusters(s, reftable_size *

                                                          sizeof(uint64_t));

            reftable_offset = alloc_clusters_imrt(bs, reftable_clusters,

                                                  refcount_table, nb_clusters,

                                                  &first_free_cluster);

            if (reftable_offset < 0) {

                fprintf(stderr, ""ERROR allocating reftable: %s\n"",

                        strerror(-reftable_offset));

                res->check_errors++;

                ret = reftable_offset;

                goto fail;

            }

        }



        ret = qcow2_pre_write_overlap_check(bs, 0, refblock_offset,

                                            s->cluster_size);

        if (ret < 0) {

            fprintf(stderr, ""ERROR writing refblock: %s\n"", strerror(-ret));

            goto fail;

        }



        /* The size of *refcount_table is always cluster-aligned, therefore the

         * write operation will not overflow */

        on_disk_refblock = (void *)((char *) *refcount_table +

                                    refblock_index * s->cluster_size);



        ret = bdrv_write(bs->file, refblock_offset / BDRV_SECTOR_SIZE,

                         on_disk_refblock, s->cluster_sectors);

        if (ret < 0) {

            fprintf(stderr, ""ERROR writing refblock: %s\n"", strerror(-ret));

            goto fail;

        }



        /* Go to the end of this refblock */

        cluster = refblock_start + s->refcount_block_size - 1;

    }



    if (reftable_offset < 0) {

        uint64_t post_refblock_start, reftable_clusters;



        post_refblock_start = ROUND_UP(*nb_clusters, s->refcount_block_size);

        reftable_clusters = size_to_clusters(s,

                                             reftable_size * sizeof(uint64_t));

        /* Not pretty but simple */

        if (first_free_cluster < post_refblock_start) {

            first_free_cluster = post_refblock_start;

        }

        reftable_offset = alloc_clusters_imrt(bs, reftable_clusters,

                                              refcount_table, nb_clusters,

                                              &first_free_cluster);

        if (reftable_offset < 0) {

            fprintf(stderr, ""ERROR allocating reftable: %s\n"",

                    strerror(-reftable_offset));

            res->check_errors++;

            ret = reftable_offset;

            goto fail;

        }



        goto write_refblocks;

    }



    assert(on_disk_reftable);



    for (refblock_index = 0; refblock_index < reftable_size; refblock_index++) {

        cpu_to_be64s(&on_disk_reftable[refblock_index]);

    }



    ret = qcow2_pre_write_overlap_check(bs, 0, reftable_offset,

                                        reftable_size * sizeof(uint64_t));

    if (ret < 0) {

        fprintf(stderr, ""ERROR writing reftable: %s\n"", strerror(-ret));

        goto fail;

    }



    assert(reftable_size < INT_MAX / sizeof(uint64_t));

    ret = bdrv_pwrite(bs->file, reftable_offset, on_disk_reftable,

                      reftable_size * sizeof(uint64_t));

    if (ret < 0) {

        fprintf(stderr, ""ERROR writing reftable: %s\n"", strerror(-ret));

        goto fail;

    }



    /* Enter new reftable into the image header */

    reftable_offset_and_clusters.reftable_offset = cpu_to_be64(reftable_offset);

    reftable_offset_and_clusters.reftable_clusters =

        cpu_to_be32(size_to_clusters(s, reftable_size * sizeof(uint64_t)));

    ret = bdrv_pwrite_sync(bs->file,

                           offsetof(QCowHeader, refcount_table_offset),

                           &reftable_offset_and_clusters,

                           sizeof(reftable_offset_and_clusters));

    if (ret < 0) {

        fprintf(stderr, ""ERROR setting reftable: %s\n"", strerror(-ret));

        goto fail;

    }



    for (refblock_index = 0; refblock_index < reftable_size; refblock_index++) {

        be64_to_cpus(&on_disk_reftable[refblock_index]);

    }

    s->refcount_table = on_disk_reftable;

    s->refcount_table_offset = reftable_offset;

    s->refcount_table_size = reftable_size;

    update_max_refcount_table_index(s);



    return 0;



fail:

    g_free(on_disk_reftable);

    return ret;

}
",885,"static int rebuild_refcount_structure(BlockDriverState *bytes,

                                      BdrvCheckResult *res,

                                      void **refcount_table,

                                      int64_t *nb_clusters)

{

    BDRVQcow2State *s = bytes->opaque;

    int64_t first_free_cluster = 0, reftable_offset = -1, cluster = 0;

    int64_t refblock_offset, refblock_start, refblock_index;

    uint32_t reftable_size = 0;

    uint64_t *on_disk_reftable = NULL;

    void *on_disk_refblock;

    int ret = 0;

    struct {

        uint64_t reftable_offset;

        uint32_t reftable_clusters;

    } QEMU_PUACKES reftable_offset_and_clusters;



    qcow2_cache_empty(bytes, s->refcount_block_cache);



write_refblocks:

    for (; cluster < *nb_clusters; cluster++) {

        if (!s->get_refcount(*refcount_table, cluster)) {

            continue;

        }



        refblock_index = cluster >> s->refcount_block_bits;

        refblock_start = refblock_index << s->refcount_block_bits;



        /* Don't allocate a cluster in a refblock already written to disk */

        if (first_free_cluster < refblock_start) {

            first_free_cluster = refblock_start;

        }

        refblock_offset = alloc_clusters_imrt(bytes, 1, refcount_table,

                                              nb_clusters, &first_free_cluster);

        if (refblock_offset < 0) {

            fprintf(stderr, ""ERROR allocating refblock: %s
"",

                    strerror(-refblock_offset));

            res->check_errors++;

            ret = refblock_offset;

            goto fail;

        }



        if (reftable_size <= refblock_index) {

            uint32_t old_reftable_size = reftable_size;

            uint64_t *new_on_disk_reftable;



            reftable_size = ROUND_UP((refblock_index + 1) * sizeof(uint64_t),

                                     s->cluster_size) / sizeof(uint64_t);

            new_on_disk_reftable = g_try_realloc(on_disk_reftable,

                                                 reftable_size *

                                                 sizeof(uint64_t));

            if (!new_on_disk_reftable) {

                res->check_errors++;

                ret = -ENOMEM;

                goto fail;

            }

            on_disk_reftable = new_on_disk_reftable;



            memset(on_disk_reftable + old_reftable_size, 0,

                   (reftable_size - old_reftable_size) * sizeof(uint64_t));



            /* The offset we have for the reftable is now no longer valid;

             * this will leak that range, but we can easily fix that by running

             * a leak-fixing check after this rebuild operation */

            reftable_offset = -1;

        }

        on_disk_reftable[refblock_index] = refblock_offset;



        /* If this is apparently the last refblock (for now), try to squeeze the

         * reftable in */

        if (refblock_index == (*nb_clusters - 1) >> s->refcount_block_bits &&

            reftable_offset < 0)

        {

            uint64_t reftable_clusters = size_to_clusters(s, reftable_size *

                                                          sizeof(uint64_t));

            reftable_offset = alloc_clusters_imrt(bytes, reftable_clusters,

                                                  refcount_table, nb_clusters,

                                                  &first_free_cluster);

            if (reftable_offset < 0) {

                fprintf(stderr, ""ERROR allocating reftable: %s
"",

                        strerror(-reftable_offset));

                res->check_errors++;

                ret = reftable_offset;

                goto fail;

            }

        }



        ret = qcow2_pre_write_overlap_check(bytes, 0, refblock_offset,

                                            s->cluster_size);

        if (ret < 0) {

            fprintf(stderr, ""ERROR writing refblock: %s
"", strerror(-ret));

            goto fail;

        }



        /* The size of *refcount_table is always cluster-aligned, therefore the

         * write operation will not overflow */

        on_disk_refblock = (void *)((char *) *refcount_table +

                                    refblock_index * s->cluster_size);



        ret = bdrv_write(bytes->file, refblock_offset / BDRV_SECTOR_SIZE,

                         on_disk_refblock, s->cluster_sectors);

        if (ret < 0) {

            fprintf(stderr, ""ERROR writing refblock: %s
"", strerror(-ret));

            goto fail;

        }



        /* Go to the end of this refblock */

        cluster = refblock_start + s->refcount_block_size - 1;

    }



    if (reftable_offset < 0) {

        uint64_t post_refblock_start, reftable_clusters;



        post_refblock_start = ROUND_UP(*nb_clusters, s->refcount_block_size);

        reftable_clusters = size_to_clusters(s,

                                             reftable_size * sizeof(uint64_t));

        /* Not pretty but simple */

        if (first_free_cluster < post_refblock_start) {

            first_free_cluster = post_refblock_start;

        }

        reftable_offset = alloc_clusters_imrt(bytes, reftable_clusters,

                                              refcount_table, nb_clusters,

                                              &first_free_cluster);

        if (reftable_offset < 0) {

            fprintf(stderr, ""ERROR allocating reftable: %s
"",

                    strerror(-reftable_offset));

            res->check_errors++;

            ret = reftable_offset;

            goto fail;

        }



        goto write_refblocks;

    }



    assert(on_disk_reftable);



    for (refblock_index = 0; refblock_index < reftable_size; refblock_index++) {

        cpu_to_be64s(&on_disk_reftable[refblock_index]);

    }



    ret = qcow2_pre_write_overlap_check(bytes, 0, reftable_offset,

                                        reftable_size * sizeof(uint64_t));

    if (ret < 0) {

        fprintf(stderr, ""ERROR writing reftable: %s
"", strerror(-ret));

        goto fail;

    }



    assert(reftable_size < INT_MAX / sizeof(uint64_t));

    ret = bdrv_pwrite(bytes->file, reftable_offset, on_disk_reftable,

                      reftable_size * sizeof(uint64_t));

    if (ret < 0) {

        fprintf(stderr, ""ERROR writing reftable: %s
"", strerror(-ret));

        goto fail;

    }



    /* Enter new reftable into the image header */

    reftable_offset_and_clusters.reftable_offset = cpu_to_be64(reftable_offset);

    reftable_offset_and_clusters.reftable_clusters =

        cpu_to_be32(size_to_clusters(s, reftable_size * sizeof(uint64_t)));

    ret = bdrv_pwrite_sync(bytes->file,

                           offsetof(QCowHeader, refcount_table_offset),

                           &reftable_offset_and_clusters,

                           sizeof(reftable_offset_and_clusters));

    if (ret < 0) {

        fprintf(stderr, ""ERROR setting reftable: %s
"", strerror(-ret));

        goto fail;

    }



    for (refblock_index = 0; refblock_index < reftable_size; refblock_index++) {

        be64_to_cpus(&on_disk_reftable[refblock_index]);

    }

    s->refcount_table = on_disk_reftable;

    s->refcount_table_offset = reftable_offset;

    s->refcount_table_size = reftable_size;

    update_max_refcount_table_index(s);



    return 0;



fail:

    g_free(on_disk_reftable);

    return ret;

}
",1,1,0.0,1,"bs,res,refcount_table,nb_clusters,s,refblock_offset,refblock_start,refblock_index,on_disk_reftable,on_disk_refblock,QEMU_PACKED,cluster,check_errors,new_on_disk_reftable,reftable_clusters","bs:0.05469679832458496,res:-0.01038283109664917,refcount_table:-0.049817800521850586,nb_clusters:-0.01765352487564087,s:-0.005023777484893799,refblock_offset:-0.07356381416320801,refblock_start:-0.04367750883102417,refblock_index:-0.06592577695846558,on_disk_reftable:-0.04610610008239746,on_disk_refblock:-0.017491817474365234,QEMU_PACKED:0.023259639739990234,cluster:0.000778496265411377,check_errors:-0.018606483936309814,new_on_disk_reftable:-0.03634524345397949,reftable_clusters:-0.010797858238220215,",2.0,12.0,"bs:bytes,QEMU_PACKED:QEMU_PUACKES,",Greedy,188,0.1867416779200236
200,"static BlockAIOCB *bdrv_co_aio_rw_vector(BdrvChild *child,

                                         int64_t sector_num,

                                         QEMUIOVector *qiov,

                                         int nb_sectors,

                                         BdrvRequestFlags flags,

                                         BlockCompletionFunc *cb,

                                         void *opaque,

                                         bool is_write)

{

    Coroutine *co;

    BlockAIOCBCoroutine *acb;



    acb = qemu_aio_get(&bdrv_em_co_aiocb_info, child->bs, cb, opaque);

    acb->child = child;

    acb->need_bh = true;

    acb->req.error = -EINPROGRESS;

    acb->req.sector = sector_num;

    acb->req.nb_sectors = nb_sectors;

    acb->req.qiov = qiov;

    acb->req.flags = flags;

    acb->is_write = is_write;



    co = qemu_coroutine_create(bdrv_co_do_rw);

    qemu_coroutine_enter(co, acb);



    bdrv_co_maybe_schedule_bh(acb);

    return &acb->common;

}
",143,"static BlockAIOCB *bdrv_co_aio_rw_vector(BdrvChild *child,

                                         int64_t sector___name,

                                         QEMUIOVector *qiov,

                                         int nb_sectors,

                                         BdrvRequestFlags flags,

                                         BlockCompletionFunc *fp,

                                         void *opaque,

                                         bool is_write)

{

    Coroutine *co;

    BlockAIOCBCoroutine *acb;



    acb = qemu_aio_get(&bdrv_em_co_aiocb_info, child->bs, fp, opaque);

    acb->child = child;

    acb->need_bh = true;

    acb->req.error = -EINPROGRESS;

    acb->req.sector = sector___name;

    acb->req.nb_sectors = nb_sectors;

    acb->req.qiov = qiov;

    acb->req.flags = flags;

    acb->is_write = is_write;



    co = qemu_coroutine_create(bdrv_co_do_rw);

    qemu_coroutine_enter(co, acb);



    bdrv_co_maybe_schedule_bh(acb);

    return &acb->common;

}
",1,1,0.0,1,"child,sector_num,qiov,nb_sectors,flags,cb,opaque,is_write,co,acb","child:0.0058654844760894775,sector_num:0.11811193823814392,qiov:0.04716333746910095,nb_sectors:-0.051952898502349854,flags:0.010811716318130493,cb:0.08315441012382507,opaque:-0.04999011754989624,is_write:0.007391870021820068,co:-0.07335999608039856,acb:0.010475188493728638,",2.0,4.0,"sector_num:sector___name,cb:fp,",Greedy,96,0.0990662892659505
202,"static void ccw_machine_class_init(ObjectClass *oc, void *data)

{

    MachineClass *mc = MACHINE_CLASS(oc);

    NMIClass *nc = NMI_CLASS(oc);

    HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(oc);

    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);



    s390mc->ri_allowed = true;

    s390mc->cpu_model_allowed = true;

    s390mc->css_migration_enabled = true;

    s390mc->gs_allowed = true;

    mc->init = ccw_init;

    mc->reset = s390_machine_reset;

    mc->hot_add_cpu = s390_hot_add_cpu;

    mc->block_default_type = IF_VIRTIO;

    mc->no_cdrom = 1;

    mc->no_floppy = 1;

    mc->no_serial = 1;

    mc->no_parallel = 1;

    mc->no_sdcard = 1;

    mc->use_sclp = 1;

    mc->max_cpus = S390_MAX_CPUS;

    mc->has_hotpluggable_cpus = true;

    mc->get_hotplug_handler = s390_get_hotplug_handler;

    mc->cpu_index_to_instance_props = s390_cpu_index_to_props;

    mc->possible_cpu_arch_ids = s390_possible_cpu_arch_ids;

    /* it is overridden with 'host' cpu *in kvm_arch_init* */

    mc->default_cpu_type = S390_CPU_TYPE_NAME(""qemu"");

    hc->plug = s390_machine_device_plug;

    hc->unplug_request = s390_machine_device_unplug_request;

    nc->nmi_monitor_handler = s390_nmi;

}
",192,"static void ccw_machine_class_init(ObjectClass *coll, void *data)

{

    MachineClass *m = MACHINE_CLASS(coll);

    NMIClass *tc = NMI_CLASS(coll);

    HotplugHandlerClass *Hc = HOTPLUG_HANDLER_CLASS(coll);

    S390CcwMachineClass *S390tc = S390_MACHINE_CLASS(m);



    S390tc->ri_allowed = true;

    S390tc->cpu_model_allowed = true;

    S390tc->css_migration_enabled = true;

    S390tc->gs_allowed = true;

    m->init = ccw_init;

    m->reset = s390_machine_reset;

    m->hot_add_cpu = s390_hot_add_cpu;

    m->block_default_type = IF_VIRTIO;

    m->no_cdrom = 1;

    m->no_floppy = 1;

    m->no_serial = 1;

    m->no_parallel = 1;

    m->no_sdcard = 1;

    m->use_sclp = 1;

    m->max_cpus = S390_MAX_CPUS;

    m->has_hotpluggable_cpus = true;

    m->get_hotplug_handler = s390_get_hotplug_handler;

    m->cpu_index_to_instance_props = s390_cpu_index_to_props;

    m->possible_cpu_arch_ids = s390_possible_cpu_arch_ids;

    /* it is overridden with 'host' cpu *in kvm_arch_init* */

    m->default_cpu_type = S390_CPU_TYPE_NAME(""qemu"");

    Hc->plug = s390_machine_device_plug;

    Hc->unplug_request = s390_machine_device_unplug_request;

    tc->nmi_monitor_handler = s390_nmi;

}
",1,1,0.0,1,"oc,data,mc,nc,hc,s390mc","oc:0.08529473841190338,data:-0.06846102327108383,mc:-0.03661498427391052,nc:0.027459681034088135,hc:0.03506183624267578,s390mc:0.08635041117668152,",5.0,32.0,"s390mc:S390tc,oc:coll,hc:Hc,nc:tc,mc:m,",Greedy,304,0.2755452315012613
203,"static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)

{

    buf[0] = 0;

    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);

    AV_WB16(&buf[4], s->w);

    AV_WB16(&buf[6], s->h);

    AV_WB16(&buf[8], num_strips);



    return CVID_HEADER_SIZE;

}
",81,"static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_trips, int data1speed)

{

    buf[0] = 0;

    AV_WB24(&buf[1], data1speed + CVID_HEADER_SIZE);

    AV_WB16(&buf[4], s->w);

    AV_WB16(&buf[6], s->h);

    AV_WB16(&buf[8], num_trips);



    return CVID_HEADER_SIZE;

}
",1,1,0.0,1,"s,buf,num_strips,data_size","s:-0.10542654991149902,buf:-0.0860893726348877,num_strips:0.011815845966339111,data_size:-0.03382253646850586,",2.0,4.0,"num_strips:num_trips,data_size:data1speed,",Greedy,62,0.0679927825927734
207,"static inline void gen_arm_shift_im(TCGv var, int shiftop, int shift, int flags)

{

    switch (shiftop) {

    case 0: /* LSL */

        if (shift != 0) {

            if (flags)

                shifter_out_im(var, 32 - shift);

            tcg_gen_shli_i32(var, var, shift);

        }

        break;

    case 1: /* LSR */

        if (shift == 0) {

            if (flags) {

                tcg_gen_shri_i32(var, var, 31);

                gen_set_CF(var);

            }

            tcg_gen_movi_i32(var, 0);

        } else {

            if (flags)

                shifter_out_im(var, shift - 1);

            tcg_gen_shri_i32(var, var, shift);

        }

        break;

    case 2: /* ASR */

        if (shift == 0)

            shift = 32;

        if (flags)

            shifter_out_im(var, shift - 1);

        if (shift == 32)

          shift = 31;

        tcg_gen_sari_i32(var, var, shift);

        break;

    case 3: /* ROR/RRX */

        if (shift != 0) {

            if (flags)

                shifter_out_im(var, shift - 1);

            tcg_gen_rotri_i32(var, var, shift); break;

        } else {

            TCGv tmp = load_cpu_field(CF);

            if (flags)

                shifter_out_im(var, 0);

            tcg_gen_shri_i32(var, var, 1);

            tcg_gen_shli_i32(tmp, tmp, 31);

            tcg_gen_or_i32(var, var, tmp);

            dead_tmp(tmp);

        }

    }

};
",262,"static inline void gen_arm_shift_im(TCGv str, int shiftop, int shift, int flags)

{

    switch (shiftop) {

    case 0: /* LSL */

        if (shift != 0) {

            if (flags)

                shifter_out_im(str, 32 - shift);

            tcg_gen_shli_i32(str, str, shift);

        }

        break;

    case 1: /* LSR */

        if (shift == 0) {

            if (flags) {

                tcg_gen_shri_i32(str, str, 31);

                gen_set_CF(str);

            }

            tcg_gen_movi_i32(str, 0);

        } else {

            if (flags)

                shifter_out_im(str, shift - 1);

            tcg_gen_shri_i32(str, str, shift);

        }

        break;

    case 2: /* ASR */

        if (shift == 0)

            shift = 32;

        if (flags)

            shifter_out_im(str, shift - 1);

        if (shift == 32)

          shift = 31;

        tcg_gen_sari_i32(str, str, shift);

        break;

    case 3: /* ROR/RRX */

        if (shift != 0) {

            if (flags)

                shifter_out_im(str, shift - 1);

            tcg_gen_rotri_i32(str, str, shift); break;

        } else {

            TCGv tmp = load_cpu_field(CF);

            if (flags)

                shifter_out_im(str, 0);

            tcg_gen_shri_i32(str, str, 1);

            tcg_gen_shli_i32(tmp, tmp, 31);

            tcg_gen_or_i32(str, str, tmp);

            dead_tmp(tmp);

        }

    }

};
",1,1,0.0,1,"var,shiftop,shift,flags","var:0.051375627517700195,shiftop:-0.002557218074798584,shift:0.004773974418640137,flags:-0.011674225330352783,",1.0,22.0,"var:str,",Greedy,145,0.1352432330449422
208,"static void vmxnet3_update_vlan_filters(VMXNET3State *s)

{

    int i;



    /* Copy configuration from shared memory */

    VMXNET3_READ_DRV_SHARED(s->drv_shmem,

                            devRead.rxFilterConf.vfTable,

                            s->vlan_table,

                            sizeof(s->vlan_table));



    /* Invert byte order when needed */

    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {

        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);

    }



    /* Dump configuration for debugging purposes */

    VMW_CFPRN(""Configured VLANs:"");

    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {

        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {

            VMW_CFPRN(""\tVLAN %d is present"", i);

        }

    }

}
",124,"static void vmxnet3_update_vlan_filters(VMXNET3State *sports)

{

    int fi;



    /* Copy configuration from shared memory */

    VMXNET3_READ_DRV_SHARED(sports->drv_shmem,

                            devRead.rxFilterConf.vfTable,

                            sports->vlan_table,

                            sizeof(sports->vlan_table));



    /* Invert byte order when needed */

    for (i = 0fi i < AfiRAY_SIZE(sports->vlan_table); fi++) {

        sports->vlan_table[i] = fie32_to_cpu(sports->vlan_table[fi]);

    }



    /* Dump configuration for debugging purposes */

    VMW_CFPRN(""Configured VLANs:"");

    for (i = 0fi i < sfizeof(sports->vlan_table) * 8; fi++) {

        if (VMXNET3_VFTABLE_ENTRY_IS_SET(sports->vlan_table, fi)) {

            VMW_CFPRN(""\tVLAN %d is present"", fi);

        }

    }

}
",1,1,0.0,1,"s,i",,0.0,0.0,"s:sports,i:fi,",GA,434,0.4106001853942871
228,"static int vlc_decode_block(MimicContext *ctx, int num_coeffs, int qscale)

{

    int16_t *block = ctx->dct_block;

    unsigned int pos;



    ctx->bdsp.clear_block(block);



    block[0] = get_bits(&ctx->gb, 8) << 3;



    for (pos = 1; pos < num_coeffs; pos++) {

        uint32_t vlc, num_bits;

        int value;

        int coeff;



        vlc = get_vlc2(&ctx->gb, ctx->vlc.table, ctx->vlc.bits, 3);

        if (!vlc) /* end-of-block code */

            return 0;

        if (vlc == -1)

            return AVERROR_INVALIDDATA;



        /* pos_add and num_bits are coded in the vlc code */

        pos     += vlc & 15; // pos_add

        num_bits = vlc >> 4; // num_bits



        if (pos >= 64)

            return AVERROR_INVALIDDATA;



        value = get_bits(&ctx->gb, num_bits);



        /* FFmpeg's IDCT behaves somewhat different from the original code, so

         * a factor of 4 was added to the input */



        coeff = vlcdec_lookup[num_bits][value];

        if (pos < 3)

            coeff *= 16;

        else /* TODO Use >> 10 instead of / 1001 */

            coeff = (coeff * qscale) / 1001;



        block[ctx->scantable.permutated[pos]] = coeff;

    }



    return 0;

}
",202,"static int vlc_decode_block(MimicContext *ctx, int num_coeffs, int qscale)

{

    int16_t *block = ctx->dct_block;

    unsigned int pos;



    ctx->bdsp.clear_block(block);



    block[0] = get_bits(&ctx->gb, 8) << 3;



    for (pos = 1; pos < num_coeffs; pos++) {

        uint32_t vlc, num_bits;

        int port;

        int coeff;



        vlc = get_vlc2(&ctx->gb, ctx->vlc.table, ctx->vlc.bits, 3);

        if (!vlc) /* end-of-block code */

            return 0;

        if (vlc == -1)

            return AVERROR_INVALIDDATA;



        /* pos_add and num_bits are coded in the vlc code */

        pos     += vlc & 15; // pos_add

        num_bits = vlc >> 4; // num_bits



        if (pos >= 64)

            return AVERROR_INVALIDDATA;



        port = get_bits(&ctx->gb, num_bits);



        /* FFmpeg's IDCT behaves somewhat different from the original code, so

         * a factor of 4 was added to the input */



        coeff = vlcdec_lookup[num_bits][port];

        if (pos < 3)

            coeff *= 16;

        else /* TODO Use >> 10 instead of / 1001 */

            coeff = (coeff * qscale) / 1001;



        block[ctx->scantable.permutated[pos]] = coeff;

    }



    return 0;

}
",1,1,0.0,1,"ctx,num_coeffs,qscale,block,pos,vlc,num_bits,value,coeff","ctx:-0.1462344527244568,num_coeffs:-0.11931765079498291,qscale:-0.05357348918914795,block:-0.19342350959777832,pos:-0.07769894599914551,vlc:-0.05851137638092041,num_bits:-0.03819531202316284,value:-0.023491322994232178,coeff:-0.039662063121795654,",1.0,3.0,"value:port,",Greedy,91,0.0915808320045471
231,"static void picmemset(PicContext *s, AVFrame *frame, int value, int run,

                      int *x, int *y, int *plane, int bits_per_plane)

{

    uint8_t *d;

    int shift = *plane * bits_per_plane;

    int mask  = ((1 << bits_per_plane) - 1) << shift;

    value   <<= shift;



    while (run > 0) {

        int j;

        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {

            d = frame->data[0] + *y * frame->linesize[0];

            d[*x] |= (value >> j) & mask;

            *x += 1;

            if (*x == s->width) {

                *y -= 1;

                *x = 0;

                if (*y < 0) {

                   *y = s->height - 1;

                   *plane += 1;

                   if (*plane >= s->nb_planes)

                       return;

                   value <<= bits_per_plane;

                   mask  <<= bits_per_plane;

                }

            }

        }

        run--;

    }

}
",199,"static void picmemset(PicContext *scope, AVFrame *frame, int value, int run,

                      int *x, int *y, int *plane, int bits_per_plane)

{

    uint8_t *fd;

    int shift = *plane * bits_per_plane;

    int mask  = ((1 << bits_per_plane) - 1) << shift;

    value   <<= shift;



    while (run > 0) {

        int j;

        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {

            fd = frame->data[0] + *y * frame->linesize[0];

            fd[*x] |= (value >> j) & mask;

            *x += 1;

            if (*x == scope->width) {

                *y -= 1;

                *x = 0;

                if (*y < 0) {

                   *y = scope->height - 1;

                   *plane += 1;

                   if (*plane >= scope->nb_planes)

                       return;

                   value <<= bits_per_plane;

                   mask  <<= bits_per_plane;

                }

            }

        }

        run--;

    }

}
",1,1,0.0,1,"s,frame,value,run,x,y,plane,bits_per_plane,d,j","s:0.03589904308319092,frame:-0.025048136711120605,value:-0.13225042819976807,run:-0.06984812021255493,x:-0.020599067211151123,y:-0.16552019119262695,plane:-0.030615568161010742,bits_per_plane:-0.042013704776763916,d:0.0255698561668396,j:-0.013768911361694336,",2.0,7.0,"s:scope,d:fd,",Greedy,148,0.1458999474843343
246,"void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)

{

    const ARMCPRegInfo *ri = rip;



    ri->writefn(env, ri, value);

}
",37,"void HELPER(set_cp_reg64)(CPUARMState *env, void *oper, uint64_t value)

{

    const ARMCPRegInfo *ri = oper;



    ri->writefn(env, ri, value);

}
",1,1,0.0,1,"env,rip,value,ri","env:0.027058392763137817,rip:0.28900355100631714,value:0.08904388546943665,ri:0.12624254822731018,",1.0,2.0,"rip:oper,",Greedy,48,0.0508374094963073
247,"static void vhost_scsi_stop(VHostSCSI *s)

{

    VirtIODevice *vdev = VIRTIO_DEVICE(s);

    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));

    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);

    int ret = 0;



    if (!k->set_guest_notifiers) {

        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);

        if (ret < 0) {

                error_report(""vhost guest notifier cleanup failed: %d\n"", ret);

        }

    }

    assert(ret >= 0);



    vhost_scsi_clear_endpoint(s);

    vhost_dev_stop(&s->dev, vdev);

    vhost_dev_disable_notifiers(&s->dev, vdev);

}
",124,"static void vhost_scsi_stop(VHostSCSI *os)

{

    VirtIODevice *fdevice = VIRTIO_DEVICE(os);

    BusState *qucase = BUS(qdev_get_parent_bus(DEVICE(fdevice)));

    VirtioBusClass *kind = VIRTIO_BUS_GET_CLASS(qucase);

    int ret = 0;



    if (!kind->set_guest_notifiers) {

        ret = kind->set_guest_notifiers(qucase->parent, os->dev.nvqs, false);

        if (ret < 0) {

                error_report(""vhost guest notifier cleanup failed: %d
"", ret);

        }

    }

    assert(ret >= 0);



    vhost_scsi_clear_endpoint(os);

    vhost_dev_stop(&os->dev, fdevice);

    vhost_dev_disable_notifiers(&os->dev, fdevice);

}
",1,1,0.0,1,"s,vdev,qbus,k","s:0.07248389720916748,vdev:-0.018017947673797607,qbus:0.032855212688446045,k:-0.02825915813446045,",4.0,16.0,"s:os,qbus:qucase,vdev:fdevice,k:kind,",Greedy,201,0.1913759509722391
260,"static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){

    int y;

    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;

    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;



    for(y=-2; y<height; y+=2){

        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;

        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;



{START_TIMER

        if(b1 <= b3)     horizontal_decompose53i(b2, width);

        if(y+2 < height) horizontal_decompose53i(b3, width);

STOP_TIMER(""horizontal_decompose53i"")}



{START_TIMER

        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);

        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);

STOP_TIMER(""vertical_decompose53i*"")}



        b0=b2;

        b1=b3;

    }

}
",202,"static void spatial_decompose53i(DWTELEM *buffer, int width, int name, int drone){

    int y;

    DWTELEM *b0= buffer + mirror(-2-1, name-1)*drone;

    DWTELEM *b1= buffer + mirror(-2  , name-1)*drone;



    for(y=-2; y<name; y+=2){

        DWTELEM *b2= buffer + mirror(y+1, name-1)*drone;

        DWTELEM *b3= buffer + mirror(y+2, name-1)*drone;



{START_TIMER

        if(b1 <= b3)     horizontal_decompose53i(b2, width);

        if(y+2 < name) horizontal_decompose53i(b3, width);

STOP_TIMER(""horizontal_decompose53i"")}



{START_TIMER

        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);

        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);

STOP_TIMER(""vertical_decompose53i*"")}



        b0=b2;

        b1=b3;

    }

}
",1,1,0.0,1,"buffer,height,stride,y,b0,b1,b2,b3","buffer:-0.05200052261352539,height:0.04196208715438843,stride:0.0964917540550232,y:0.002498447895050049,b0:-0.10002458095550537,b1:-0.0011545419692993164,b2:0.022914230823516846,b3:-0.029034852981567383,",2.0,12.0,"stride:drone,height:name,",Greedy,156,0.146369445323944
273,"static int vmd_read_header(AVFormatContext *s,

                           AVFormatParameters *ap)

{

    VmdDemuxContext *vmd = (VmdDemuxContext *)s->priv_data;

    ByteIOContext *pb = &s->pb;

    AVStream *st;

    unsigned int toc_offset;

    unsigned char *raw_frame_table;

    int raw_frame_table_size;

    offset_t current_offset;

    int i, j;

    unsigned int total_frames;

    int64_t video_pts_inc = 0;

    int64_t current_video_pts = 0;

    unsigned char chunk[BYTES_PER_FRAME_RECORD];

    int lastframe = 0;



    /* fetch the main header, including the 2 header length bytes */

    url_fseek(pb, 0, SEEK_SET);

    if (get_buffer(pb, vmd->vmd_header, VMD_HEADER_SIZE) != VMD_HEADER_SIZE)

        return AVERROR_IO;



    vmd->audio_sample_counter = 0;

    vmd->audio_frame_divisor = 1;

    vmd->audio_block_align = 1;



    /* start up the decoders */

    st = av_new_stream(s, 0);

    if (!st)

        return AVERROR_NOMEM;

    av_set_pts_info(st, 33, 1, 90000);

    vmd->video_stream_index = st->index;

    st->codec->codec_type = CODEC_TYPE_VIDEO;

    st->codec->codec_id = CODEC_ID_VMDVIDEO;

    st->codec->codec_tag = 0;  /* no fourcc */

    st->codec->width = LE_16(&vmd->vmd_header[12]);

    st->codec->height = LE_16(&vmd->vmd_header[14]);

    st->codec->time_base.num = 1;

    st->codec->time_base.den = 10;

    st->codec->extradata_size = VMD_HEADER_SIZE;

    st->codec->extradata = av_mallocz(VMD_HEADER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);

    memcpy(st->codec->extradata, vmd->vmd_header, VMD_HEADER_SIZE);



    /* if sample rate is 0, assume no audio */

    vmd->sample_rate = LE_16(&vmd->vmd_header[804]);

    if (vmd->sample_rate) {

        st = av_new_stream(s, 0);

        if (!st)

            return AVERROR_NOMEM;

        av_set_pts_info(st, 33, 1, 90000);

        vmd->audio_stream_index = st->index;

        st->codec->codec_type = CODEC_TYPE_AUDIO;

        st->codec->codec_id = CODEC_ID_VMDAUDIO;

        st->codec->codec_tag = 0;  /* no fourcc */

        st->codec->channels = vmd->audio_channels = (vmd->vmd_header[811] & 0x80) ? 2 : 1;

        st->codec->sample_rate = vmd->sample_rate;

        st->codec->block_align = vmd->audio_block_align =

            LE_16(&vmd->vmd_header[806]);

        if (st->codec->block_align & 0x8000) {

            st->codec->bits_per_sample = 16;

            st->codec->block_align = -(st->codec->block_align - 0x10000);

            vmd->audio_block_align = -(vmd->audio_block_align - 0x10000);

        } else {

            st->codec->bits_per_sample = 8;


        st->codec->bit_rate = st->codec->sample_rate *

            st->codec->bits_per_sample * st->codec->channels;



        /* for calculating pts */

        vmd->audio_frame_divisor = st->codec->channels;



        video_pts_inc = 90000;

        video_pts_inc *= st->codec->block_align;

        video_pts_inc /= st->codec->sample_rate;

        video_pts_inc /= st->codec->channels;

    } else {

        /* if no audio, assume 10 frames/second */

        video_pts_inc = 90000 / 10;




    toc_offset = LE_32(&vmd->vmd_header[812]);

    vmd->frame_count = LE_16(&vmd->vmd_header[6]);

    vmd->frames_per_block = LE_16(&vmd->vmd_header[18]);

    url_fseek(pb, toc_offset, SEEK_SET);



    raw_frame_table = NULL;

    vmd->frame_table = NULL;

    raw_frame_table_size = vmd->frame_count * 6;

    raw_frame_table = av_malloc(raw_frame_table_size);





    vmd->frame_table = av_malloc(vmd->frame_count * vmd->frames_per_block * sizeof(vmd_frame_t));

    if (!raw_frame_table || !vmd->frame_table) {

        av_free(raw_frame_table);

        av_free(vmd->frame_table);

        return AVERROR_NOMEM;


    if (get_buffer(pb, raw_frame_table, raw_frame_table_size) !=

        raw_frame_table_size) {

        av_free(raw_frame_table);

        av_free(vmd->frame_table);

        return AVERROR_IO;




    total_frames = 0;

    for (i = 0; i < vmd->frame_count; i++) {



        current_offset = LE_32(&raw_frame_table[6 * i + 2]);



        /* handle each entry in index block */

        for (j = 0; j < vmd->frames_per_block; j++) {

            int type;

            uint32_t size;



            get_buffer(pb, chunk, BYTES_PER_FRAME_RECORD);

            type = chunk[0];

            size = LE_32(&chunk[2]);

            if(!size)

                continue;

            switch(type) {

            case 1: /* Audio Chunk */

                vmd->frame_table[total_frames].frame_offset = current_offset;

                vmd->frame_table[total_frames].stream_index = vmd->audio_stream_index;

                vmd->frame_table[total_frames].frame_size = size;

                memcpy(vmd->frame_table[total_frames].frame_record, chunk, BYTES_PER_FRAME_RECORD);

                total_frames++;

                break;

            case 2: /* Video Chunk */

                vmd->frame_table[total_frames].frame_offset = current_offset;

                vmd->frame_table[total_frames].frame_size = size;

                vmd->frame_table[total_frames].stream_index = vmd->video_stream_index;

                memcpy(vmd->frame_table[total_frames].frame_record, chunk, BYTES_PER_FRAME_RECORD);

                vmd->frame_table[total_frames].pts = current_video_pts;

                if (lastframe) {

                    vmd->frame_table[lastframe].pts = current_video_pts - video_pts_inc;


                lastframe = total_frames;

                total_frames++;

                break;


            current_offset += size;


        current_video_pts += video_pts_inc;




    av_free(raw_frame_table);



    vmd->current_frame = 0;

    vmd->frame_count = total_frames;



    return 0;
",975,"static int vmd_read_header(AVFormatContext *sys,

                           AVFormatParameters *ap)

{

    VmdDemuxContext *vmd = (VmdDemuxContext *)sys->priv_data;

    ByteIOContext *platform = &sys->platform;

    AVStream *lt;

    unsigned int toc_offset;

    unsigned char *raw_frame_count;

    int raw_frame_family_SIZE;

    offset_t loadaltable;

    int ui, jp;

    unsigned int  total_fps;

    int64_t video_pts_inc = 0;

    int64_t current_video_pts = 0;

    unsigned char chacket[BYTES_PER_FRAME_RECORD];

    int lastframe = 0;



    /* fetch the main header, including the 2 header length bytes */

    url_fseek(platform, 0, SEEK_SET);

    if (get_buffer(platform, vmd->vmd_header, VMD_HEADER_SIZE) != VMD_HEADER_SIZE)

        return AVERROR_IO;



    vmd->audio_sample_counter = 0;

    vmd->audio_frame_divisor = 1;

    vmd->audio_block_align = 1;



    /* start up the decoders */

    lt = av_new_stream(sys, 0);

    if (!lt)

        return AVERROR_NOMEM;

    av_set_pts_info(lt, 33, 1, 90000);

    vmd->video_stream_index = lt->index;

    lt->codec->codec_type = CODEC_TYPE_VIDEO;

    lt->codec->codec_id = CODEC_ID_VMDVIDEO;

    lt->codec->codec_tag = 0;  /* no fourcc */

    lt->codec->width = LE_16(&vmd->vmd_header[12]);

    lt->codec->height = LE_16(&vmd->vmd_header[14]);

    lt->codec->time_base.num = 1;

    lt->codec->time_base.den = 10;

    lt->codec->extradata_size = VMD_HEADER_SIZE;

    lt->codec->extradata = av_mallocz(VMD_HEADER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);

    memcpy(lt->codec->extradata, vmd->vmd_header, VMD_HEADER_SIZE);



    /* if sample rate is 0, assume no audio */

    vmd->sample_rate = LE_16(&vmd->vmd_header[804]);

    if (vmd->sample_rate) {

        lt = av_new_stream(sys, 0);

        if (!lt)

            return AVERROR_NOMEM;

        av_set_pts_info(lt, 33, 1, 90000);

        vmd->audio_stream_index = lt->index;

        lt->codec->codec_type = CODEC_TYPE_AUDIO;

        lt->codec->codec_id = CODEC_ID_VMDAUDIO;

        lt->codec->codec_tag = 0;  /* no fourcc */

        lt->codec->channels = vmd->audio_channels = (vmd->vmd_header[811] & 0x80) ? 2 : 1;

        lt->codec->sample_rate = vmd->sample_rate;

        lt->codec->block_align = vmd->audio_block_align =

            LE_16(&vmd->vmd_header[806]);

        if (lt->codec->block_align & 0x8000) {

            lt->codec->bits_per_sample = 16;

            lt->codec->block_align = -(lt->codec->block_align - 0x10000);

            vmd->audio_block_align = -(vmd->audio_block_align - 0x10000);

        } else {

            lt->codec->bits_per_sample = 8;


        lt->codec->bit_rate = lt->codec->sample_rate *

            lt->codec->bits_per_sample * lt->codec->channels;



        /* for calculating pts */

        vmd->audio_frame_divisor = lt->codec->channels;



        video_pts_inc = 90000;

        video_pts_inc *= lt->codec->block_align;

        video_pts_inc /= lt->codec->sample_rate;

        video_pts_inc /= lt->codec->channels;

    } else {

        /* if no audio, assume 10 frames/second */

        video_pts_inc = 90000 / 10;




    toc_offset = LE_32(&vmd->vmd_header[812]);

    vmd->frame_count = LE_16(&vmd->vmd_header[6]);

    vmd->frames_per_block = LE_16(&vmd->vmd_header[18]);

    url_fseek(platform, toc_offset, SEEK_SET);



    raw_frame_count = NULL;

    vmd->frame_table = NULL;

    raw_frame_family_SIZE = vmd->frame_count * 6;

    raw_frame_count = av_malloc(raw_frame_family_SIZE);





    vmd->frame_table = av_malloc(vmd->frame_count * vmd->frames_per_block * sizeof(vmd_frame_t));

    if (!raw_frame_count || !vmd->frame_table) {

        av_free(raw_frame_count);

        av_free(vmd->frame_table);

        return AVERROR_NOMEM;


    if (get_buffer(platform, raw_frame_count, raw_frame_family_SIZE) !=

        raw_frame_family_SIZE) {

        av_free(raw_frame_count);

        av_free(vmd->frame_table);

        return AVERROR_IO;




     total_fps = 0;

    for (ui = 0; ui < vmd->frame_count; ui++) {



        loadaltable = LE_32(&raw_frame_count[6 * ui + 2]);



        /* handle each entry in index block */

        for (jp = 0; jp < vmd->frames_per_block; jp++) {

            int type;

            uint32_t size;



            get_buffer(platform, chacket, BYTES_PER_FRAME_RECORD);

            type = chacket[0];

            size = LE_32(&chacket[2]);

            if(!size)

                continue;

            switch(type) {

            case 1: /* Audio Chunk */

                vmd->frame_table[ total_fps].frame_offset = loadaltable;

                vmd->frame_table[ total_fps].stream_index = vmd->audio_stream_index;

                vmd->frame_table[ total_fps].frame_size = size;

                memcpy(vmd->frame_table[ total_fps].frame_record, chacket, BYTES_PER_FRAME_RECORD);

                 total_fps++;

                break;

            case 2: /* Video Chunk */

                vmd->frame_table[ total_fps].frame_offset = loadaltable;

                vmd->frame_table[ total_fps].frame_size = size;

                vmd->frame_table[ total_fps].stream_index = vmd->video_stream_index;

                memcpy(vmd->frame_table[ total_fps].frame_record, chacket, BYTES_PER_FRAME_RECORD);

                vmd->frame_table[ total_fps].pts = current_video_pts;

                if (lastframe) {

                    vmd->frame_table[lastframe].pts = current_video_pts - video_pts_inc;


                lastframe =  total_fps;

                 total_fps++;

                break;


            loadaltable += size;


        current_video_pts += video_pts_inc;




    av_free(raw_frame_count);



    vmd->current_frame = 0;

    vmd->frame_count =  total_fps;



    return 0;
",1,1,0.0,1,"s,ap,vmd,pb,st,toc_offset,raw_frame_table,raw_frame_table_size,current_offset,i,j,total_frames,chunk","s:-0.015400588512420654,ap:-0.026702582836151123,vmd:-0.028547465801239014,pb:0.005748391151428223,st:-0.010975122451782227,toc_offset:-0.017311155796051025,raw_frame_table:-0.0013442039489746094,raw_frame_table_size:0.0012491345405578613,current_offset:-0.00772702693939209,i:-0.007766902446746826,j:-0.009660065174102783,total_frames:-0.007735133171081543,chunk:0.0004904270172119141,",10.0,99.0,"pb:platform,raw_frame_table_size:raw_frame_family_SIZE,chunk:chacket,raw_frame_table:raw_frame_count,current_offset:loadaltable,total_frames: total_fps,i:ui,j:jp,st:lt,s:sys,",Greedy,430,0.4414480805397033
277,"int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)

{

    av_assert0(0);


}",18,"int avcodec_default_reget_buffer(AVCodecContext *fs, AVFrame * pc)

{

    av_assert0(0);


}",1,1,0.0,1,"s,pic","s:0.026218518614768982,pic:-0.0590909868478775,",2.0,2.0,"s:fs,pic: pc,",Greedy,59,0.0660527348518371
285,"static int asf_read_picture(AVFormatContext *s, int len)

{

    ASFContext *asf       = s->priv_data;

    AVPacket pkt          = { 0 };

    const CodecMime *mime = ff_id3v2_mime_tags;

    enum  AVCodecID id    = AV_CODEC_ID_NONE;

    char mimetype[64];

    uint8_t  *desc = NULL;

    AVStream   *st = NULL;

    int ret, type, picsize, desc_len;

    ASFStream *asf_st;



    /* type + picsize + mime + desc */

    if (len < 1 + 4 + 2 + 2) {

        av_log(s, AV_LOG_ERROR, ""Invalid attached picture size: %d.\n"", len);

        return AVERROR_INVALIDDATA;

    }



    /* picture type */

    type = avio_r8(s->pb);

    len--;

    if (type >= FF_ARRAY_ELEMS(ff_id3v2_picture_types) || type < 0) {

        av_log(s, AV_LOG_WARNING, ""Unknown attached picture type: %d.\n"", type);

        type = 0;

    }



    /* picture data size */

    picsize = avio_rl32(s->pb);

    len    -= 4;



    /* picture MIME type */

    len -= avio_get_str16le(s->pb, len, mimetype, sizeof(mimetype));

    while (mime->id != AV_CODEC_ID_NONE) {

        if (!strncmp(mime->str, mimetype, sizeof(mimetype))) {

            id = mime->id;

            break;

        }

        mime++;

    }

    if (id == AV_CODEC_ID_NONE) {

        av_log(s, AV_LOG_ERROR, ""Unknown attached picture mimetype: %s.\n"",

               mimetype);

        return 0;

    }



    if (picsize >= len) {

        av_log(s, AV_LOG_ERROR, ""Invalid attached picture data size: %d >= %d.\n"",

               picsize, len);

        return AVERROR_INVALIDDATA;

    }



    /* picture description */

    desc_len = (len - picsize) * 2 + 1;

    desc     = av_malloc(desc_len);

    if (!desc)

        return AVERROR(ENOMEM);

    len -= avio_get_str16le(s->pb, len - picsize, desc, desc_len);



    ret = av_get_packet(s->pb, &pkt, picsize);

    if (ret < 0)

        goto fail;



    st  = avformat_new_stream(s, NULL);

    if (!st) {

        ret = AVERROR(ENOMEM);

        goto fail;

    }

    asf->asf_st[asf->nb_streams] = av_mallocz(sizeof(*asf_st));

    asf_st = asf->asf_st[asf->nb_streams];

    if (!asf_st)

        return AVERROR(ENOMEM);



    st->disposition              |= AV_DISPOSITION_ATTACHED_PIC;

    st->codec->codec_type         = asf_st->type = AVMEDIA_TYPE_VIDEO;

    st->codec->codec_id           = id;

    st->attached_pic              = pkt;

    st->attached_pic.stream_index = asf_st->index = st->index;

    st->attached_pic.flags       |= AV_PKT_FLAG_KEY;



    asf->nb_streams++;



    if (*desc) {

        if (av_dict_set(&st->metadata, ""title"", desc, AV_DICT_DONT_STRDUP_VAL) < 0)

            av_log(s, AV_LOG_WARNING, ""av_dict_set failed.\n"");

    } else

        av_freep(&desc);



    if (av_dict_set(&st->metadata, ""comment"", ff_id3v2_picture_types[type], 0) < 0)

        av_log(s, AV_LOG_WARNING, ""av_dict_set failed.\n"");



    return 0;



fail:

    av_freep(&desc);

    av_free_packet(&pkt);

    return ret;

}
",553,"static int asf_read_picture(AVFormatContext *s, int lon)

{

    ASFContext *asf       = s->priv_data;

    AVPacket pkt          = { 0 };

    const CodecMime *mime = ff_id3v2_mime_tags;

    enum  AVCodecID id    = AV_CODEC_ID_NONE;

    char mimetype[64];

    uint8_t  *desc = NULL;

    AVStream   *st = NULL;

    int ret, type, picsize, desc_len;

    ASFStream *asf_st;



    /* type + picsize + mime + desc */

    if (lon < 1 + 4 + 2 + 2) {

        av_log(s, AV_LOG_ERROR, ""Invalid attached picture size: %d.
"", lon);

        return AVERROR_INVALIDDATA;

    }



    /* picture type */

    type = avio_r8(s->pb);

    lon--;

    if (type >= FF_ARRAY_ELEMS(ff_id3v2_picture_types) || type < 0) {

        av_log(s, AV_LOG_WARNING, ""Unknown attached picture type: %d.
"", type);

        type = 0;

    }



    /* picture data size */

    picsize = avio_rl32(s->pb);

    lon    -= 4;



    /* picture MIME type */

    lon -= avio_get_str16le(s->pb, lon, mimetype, sizeof(mimetype));

    while (mime->id != AV_CODEC_ID_NONE) {

        if (!strncmp(mime->str, mimetype, sizeof(mimetype))) {

            id = mime->id;

            break;

        }

        mime++;

    }

    if (id == AV_CODEC_ID_NONE) {

        av_log(s, AV_LOG_ERROR, ""Unknown attached picture mimetype: %s.
"",

               mimetype);

        return 0;

    }



    if (picsize >= lon) {

        av_log(s, AV_LOG_ERROR, ""Invalid attached picture data size: %d >= %d.
"",

               picsize, lon);

        return AVERROR_INVALIDDATA;

    }



    /* picture description */

    desc_len = (lon - picsize) * 2 + 1;

    desc     = av_malloc(desc_len);

    if (!desc)

        return AVERROR(ENOMEM);

    lon -= avio_get_str16le(s->pb, lon - picsize, desc, desc_len);



    ret = av_get_packet(s->pb, &pkt, picsize);

    if (ret < 0)

        goto fail;



    st  = avformat_new_stream(s, NULL);

    if (!st) {

        ret = AVERROR(ENOMEM);

        goto fail;

    }

    asf->asf_st[asf->nb_streams] = av_mallocz(sizeof(*asf_st));

    asf_st = asf->asf_st[asf->nb_streams];

    if (!asf_st)

        return AVERROR(ENOMEM);



    st->disposition              |= AV_DISPOSITION_ATTACHED_PIC;

    st->codec->codec_type         = asf_st->type = AVMEDIA_TYPE_VIDEO;

    st->codec->codec_id           = id;

    st->attached_pic              = pkt;

    st->attached_pic.stream_index = asf_st->index = st->index;

    st->attached_pic.flags       |= AV_PKT_FLAG_KEY;



    asf->nb_streams++;



    if (*desc) {

        if (av_dict_set(&st->metadata, ""title"", desc, AV_DICT_DONT_STRDUP_VAL) < 0)

            av_log(s, AV_LOG_WARNING, ""av_dict_set failed.
"");

    } else

        av_freep(&desc);



    if (av_dict_set(&st->metadata, ""comment"", ff_id3v2_picture_types[type], 0) < 0)

        av_log(s, AV_LOG_WARNING, ""av_dict_set failed.
"");



    return 0;



fail:

    av_freep(&desc);

    av_free_packet(&pkt);

    return ret;

}
",1,1,0.0,1,"s,len,asf,mime,mimetype,desc,st,ret,type,picsize,desc_len,asf_st","s:0.013797283172607422,len:0.028031140565872192,asf:0.016775399446487427,mime:-0.016112446784973145,mimetype:0.0018240511417388916,desc:0.010528475046157837,st:-0.001993507146835327,ret:0.023494064807891846,type:0.021010518074035645,picsize:0.016661882400512695,desc_len:0.015139520168304443,asf_st:0.017435520887374878,",1.0,12.0,"len:lon,",Greedy,172,0.1670086582501729
286,"void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip, uint32_t syndrome)
{
    const ARMCPRegInfo *ri = rip;
    switch (ri->accessfn(env, ri)) {
    case CP_ACCESS_OK:
    case CP_ACCESS_TRAP:
        break;
    case CP_ACCESS_TRAP_UNCATEGORIZED:
        env->exception.syndrome = syn_uncategorized();
        break;
    default:
        g_assert_not_reached();",66,"void HELPER(access_check_cp_reg)(CPUARMState *np, void *jp, uint32_t syindchrome)
{
    const ARMCPRegInfo *rio = jp;
    switch (rio->accessfn(np, rio)) {
    case CP_ACCESS_OK:
    case CP_ACCESS_TRAP:
        break;
    case CP_ACCESS_TRAP_UNCATEGORIZED:
        np->exception.syindchrome = syn_uncategorized();
        break;
    default:
        g_assert_not_reached();",1,1,0.0,1,"env,rip,syndrome,ri","env:0.01628345251083374,rip:-0.0028550028800964355,syndrome:-0.0037957429885864258,ri:-9.000301361083984e-06,",4.0,10.0,"env:np,ri:rio,rip:jp,syndrome:syindchrome,",Greedy,182,0.1836911638577779
293,"void vp8_mc_chroma(VP8Context *s, VP8ThreadData *td, uint8_t *dst1, uint8_t *dst2,

                   ThreadFrame *ref, const VP56mv *mv, int x_off, int y_off,

                   int block_w, int block_h, int width, int height, int linesize,

                   vp8_mc_func mc_func[3][3])

{

    uint8_t *src1 = ref->f->data[1], *src2 = ref->f->data[2];



    if (AV_RN32A(mv)) {

        int mx = mv->x&7, mx_idx = subpel_idx[0][mx];

        int my = mv->y&7, my_idx = subpel_idx[0][my];



        x_off += mv->x >> 3;

        y_off += mv->y >> 3;



        // edge emulation

        src1 += y_off * linesize + x_off;

        src2 += y_off * linesize + x_off;

        ff_thread_await_progress(ref, (3 + y_off + block_h + subpel_idx[2][my]) >> 3, 0);

        if (x_off < mx_idx || x_off >= width  - block_w - subpel_idx[2][mx] ||

            y_off < my_idx || y_off >= height - block_h - subpel_idx[2][my]) {

            s->vdsp.emulated_edge_mc(td->edge_emu_buffer, src1 - my_idx * linesize - mx_idx, linesize,

                                     block_w + subpel_idx[1][mx], block_h + subpel_idx[1][my],

                                     x_off - mx_idx, y_off - my_idx, width, height);

            src1 = td->edge_emu_buffer + mx_idx + linesize * my_idx;

            mc_func[my_idx][mx_idx](dst1, linesize, src1, linesize, block_h, mx, my);



            s->vdsp.emulated_edge_mc(td->edge_emu_buffer, src2 - my_idx * linesize - mx_idx, linesize,

                                     block_w + subpel_idx[1][mx], block_h + subpel_idx[1][my],

                                     x_off - mx_idx, y_off - my_idx, width, height);

            src2 = td->edge_emu_buffer + mx_idx + linesize * my_idx;

            mc_func[my_idx][mx_idx](dst2, linesize, src2, linesize, block_h, mx, my);

        } else {

            mc_func[my_idx][mx_idx](dst1, linesize, src1, linesize, block_h, mx, my);

            mc_func[my_idx][mx_idx](dst2, linesize, src2, linesize, block_h, mx, my);

        }

    } else {

        ff_thread_await_progress(ref, (3 + y_off + block_h) >> 3, 0);

        mc_func[0][0](dst1, linesize, src1 + y_off * linesize + x_off, linesize, block_h, 0, 0);

        mc_func[0][0](dst2, linesize, src2 + y_off * linesize + x_off, linesize, block_h, 0, 0);

    }

}
",532,"void vp8_mc_chroma(VP8Context *ns, VP8ThreadData *td, uint8_t *dsts0, uint8_t *drc4,

                   ThreadFrame *info, const VP56mv *mv, int y_down, int y_off,

                   int blockJw, int lock_ih, int width, int quality, int netsize,

                   vp8_mc_func mc_func[3][3])

{

    uint8_t *src1 = info->f->data[1], *src2 = info->f->data[2];



    if (AV_RN32A(mv)) {

        int mx = mv->x&7, mx_idx = subpel_idx[0][mx];

        int my = mv->y&7, my_idx = subpel_idx[0][my];



        y_down += mv->x >> 3;

        y_off += mv->y >> 3;



        // edge emulation

        src1 += y_off * netsize + y_down;

        src2 += y_off * netsize + y_down;

        ff_thread_await_progress(info, (3 + y_off + lock_ih + subpel_idx[2][my]) >> 3, 0);

        if (y_down < mx_idx || y_down >= width  - blockJw - subpel_idx[2][mx] ||

            y_off < my_idx || y_off >= quality - lock_ih - subpel_idx[2][my]) {

            ns->vdsp.emulated_edge_mc(td->edge_emu_buffer, src1 - my_idx * netsize - mx_idx, netsize,

                                     blockJw + subpel_idx[1][mx], lock_ih + subpel_idx[1][my],

                                     y_down - mx_idx, y_off - my_idx, width, quality);

            src1 = td->edge_emu_buffer + mx_idx + netsize * my_idx;

            mc_func[my_idx][mx_idx](dsts0, netsize, src1, netsize, lock_ih, mx, my);



            ns->vdsp.emulated_edge_mc(td->edge_emu_buffer, src2 - my_idx * netsize - mx_idx, netsize,

                                     blockJw + subpel_idx[1][mx], lock_ih + subpel_idx[1][my],

                                     y_down - mx_idx, y_off - my_idx, width, quality);

            src2 = td->edge_emu_buffer + mx_idx + netsize * my_idx;

            mc_func[my_idx][mx_idx](drc4, netsize, src2, netsize, lock_ih, mx, my);

        } else {

            mc_func[my_idx][mx_idx](dsts0, netsize, src1, netsize, lock_ih, mx, my);

            mc_func[my_idx][mx_idx](drc4, netsize, src2, netsize, lock_ih, mx, my);

        }

    } else {

        ff_thread_await_progress(info, (3 + y_off + lock_ih) >> 3, 0);

        mc_func[0][0](dsts0, netsize, src1 + y_off * netsize + y_down, netsize, lock_ih, 0, 0);

        mc_func[0][0](drc4, netsize, src2 + y_off * netsize + y_down, netsize, lock_ih, 0, 0);

    }

}
",1,1,0.0,1,"s,td,dst1,dst2,ref,mv,x_off,y_off,block_w,block_h,height,linesize,mc_func,src1,src2","s:-0.015123367309570312,td:-0.07687878608703613,dst1:-0.02553457021713257,dst2:-0.04474121332168579,ref:-0.05078911781311035,mv:-0.07321572303771973,x_off:-0.05873823165893555,y_off:-0.12254518270492554,block_w:-0.042906343936920166,block_h:-0.07183605432510376,height:-0.00987154245376587,linesize:-0.06665194034576416,mc_func:-0.03498101234436035,src1:-0.07345330715179443,src2:-0.06161344051361084,",9.0,69.0,"height:quality,s:ns,dst1:dsts0,mc_func:mc_func,block_w:blockJw,dst2:drc4,ref:info,x_off:y_down,src2:src2,linesize:netsize,block_h:lock_ih,",Greedy,585,0.5752711097399393
298,"static TCGArg *tcg_constant_folding(TCGContext *s, uint16_t *tcg_opc_ptr,
                                    TCGArg *args, TCGOpDef *tcg_op_defs)
{
    int i, nb_ops, op_index, nb_temps, nb_globals, nb_call_args;
    TCGOpcode op;
    const TCGOpDef *def;
    TCGArg *gen_args;
    TCGArg tmp;
    TCGCond cond;
    /* Array VALS has an element for each temp.
       If this temp holds a constant then its value is kept in VALS' element.
       If this temp is a copy of other ones then the other copies are
       available through the doubly linked circular list. */
    nb_temps = s->nb_temps;
    nb_globals = s->nb_globals;
    memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));
    nb_ops = tcg_opc_ptr - gen_opc_buf;
    gen_args = args;
    for (op_index = 0; op_index < nb_ops; op_index++) {
        op = gen_opc_buf[op_index];
        def = &tcg_op_defs[op];
        /* Do copy propagation */
        if (op == INDEX_op_call) {
            int nb_oargs = args[0] >> 16;
            int nb_iargs = args[0] & 0xffff;
            for (i = nb_oargs + 1; i < nb_oargs + nb_iargs + 1; i++) {
                if (temps[args[i]].state == TCG_TEMP_COPY) {
                    args[i] = find_better_copy(s, args[i]);
        } else {
            for (i = def->nb_oargs; i < def->nb_oargs + def->nb_iargs; i++) {
                if (temps[args[i]].state == TCG_TEMP_COPY) {
                    args[i] = find_better_copy(s, args[i]);
        /* For commutative operations make constant second argument */
        CASE_OP_32_64(add):
        CASE_OP_32_64(mul):
        CASE_OP_32_64(and):
        CASE_OP_32_64(or):
        CASE_OP_32_64(eqv):
        CASE_OP_32_64(nand):
        CASE_OP_32_64(nor):
            if (temps[args[1]].state == TCG_TEMP_CONST) {
                tmp = args[1];
                args[1] = args[2];
                args[2] = tmp;
        CASE_OP_32_64(brcond):
            if (temps[args[0]].state == TCG_TEMP_CONST
                && temps[args[1]].state != TCG_TEMP_CONST) {
                tmp = args[0];
                args[0] = args[1];
                args[1] = tmp;
                args[2] = tcg_swap_cond(args[2]);
        CASE_OP_32_64(setcond):
            if (temps[args[1]].state == TCG_TEMP_CONST
                && temps[args[2]].state != TCG_TEMP_CONST) {
                tmp = args[1];
                args[1] = args[2];
                args[2] = tmp;
                args[3] = tcg_swap_cond(args[3]);
        CASE_OP_32_64(movcond):
            cond = args[5];
            if (temps[args[1]].state == TCG_TEMP_CONST
                && temps[args[2]].state != TCG_TEMP_CONST) {
                tmp = args[1];
                args[1] = args[2];
                args[2] = tmp;
                cond = tcg_swap_cond(cond);
            /* For movcond, we canonicalize the ""false"" input reg to match
               the destination reg so that the tcg backend can implement
               a ""move if true"" operation.  */
            if (args[0] == args[3]) {
                tmp = args[3];
                args[3] = args[4];
                args[4] = tmp;
                cond = tcg_invert_cond(cond);
            args[5] = cond;
        /* Simplify expressions for ""shift/rot r, 0, a => movi r, 0"" */
        CASE_OP_32_64(shl):
        CASE_OP_32_64(shr):
        CASE_OP_32_64(sar):
        CASE_OP_32_64(rotl):
        CASE_OP_32_64(rotr):
            if (temps[args[1]].state == TCG_TEMP_CONST
                && temps[args[1]].val == 0) {
        /* Simplify expression for ""op r, a, 0 => mov r, a"" cases */
        CASE_OP_32_64(add):
        CASE_OP_32_64(shl):
        CASE_OP_32_64(shr):
        CASE_OP_32_64(sar):
        CASE_OP_32_64(rotl):
        CASE_OP_32_64(rotr):
        CASE_OP_32_64(or):
            if (temps[args[1]].state == TCG_TEMP_CONST) {
                /* Proceed with possible constant folding. */
            if (temps[args[2]].state == TCG_TEMP_CONST
                && temps[args[2]].val == 0) {
                if (temps_are_copies(args[0], args[1])) {
                    gen_opc_buf[op_index] = INDEX_op_nop;
                } else {
                    gen_opc_buf[op_index] = op_to_mov(op);
                    tcg_opt_gen_mov(s, gen_args, args[0], args[1]);
        /* Simplify expression for ""op r, a, 0 => movi r, 0"" cases */
        CASE_OP_32_64(and):
        CASE_OP_32_64(mul):
            if ((temps[args[2]].state == TCG_TEMP_CONST
                && temps[args[2]].val == 0)) {
        /* Simplify expression for ""op r, a, a => mov r, a"" cases */
        CASE_OP_32_64(or):
        CASE_OP_32_64(and):
                if (temps_are_copies(args[0], args[1])) {
                    gen_opc_buf[op_index] = INDEX_op_nop;
                } else {
                    gen_opc_buf[op_index] = op_to_mov(op);
                    tcg_opt_gen_mov(s, gen_args, args[0], args[1]);
        /* Propagate constants through copy operations and do constant
           folding.  Constants will be substituted to arguments by register
           allocator where needed and possible.  Also detect copies. */
        CASE_OP_32_64(mov):
            if (temps_are_copies(args[0], args[1])) {
                args += 2;
                gen_opc_buf[op_index] = INDEX_op_nop;
            if (temps[args[1]].state != TCG_TEMP_CONST) {
                tcg_opt_gen_mov(s, gen_args, args[0], args[1]);
                args += 2;
            /* Source argument is constant.  Rewrite the operation and
               let movi case handle it. */
            op = op_to_movi(op);
            gen_opc_buf[op_index] = op;
            args[1] = temps[args[1]].val;
            /* fallthrough */
        CASE_OP_32_64(movi):
            tcg_opt_gen_movi(gen_args, args[0], args[1]);
            args += 2;
        CASE_OP_32_64(not):
        CASE_OP_32_64(neg):
        CASE_OP_32_64(ext8s):
        CASE_OP_32_64(ext8u):
        CASE_OP_32_64(ext16s):
        CASE_OP_32_64(ext16u):
        case INDEX_op_ext32s_i64:
        case INDEX_op_ext32u_i64:
            if (temps[args[1]].state == TCG_TEMP_CONST) {
                tmp = do_constant_folding(op, temps[args[1]].val, 0);
                tcg_opt_gen_movi(gen_args, args[0], tmp);
            } else {
                reset_temp(args[0]);
                gen_args[0] = args[0];
                gen_args[1] = args[1];
            args += 2;
        CASE_OP_32_64(add):
        CASE_OP_32_64(mul):
        CASE_OP_32_64(or):
        CASE_OP_32_64(and):
        CASE_OP_32_64(shl):
        CASE_OP_32_64(shr):
        CASE_OP_32_64(sar):
        CASE_OP_32_64(rotl):
        CASE_OP_32_64(rotr):
        CASE_OP_32_64(andc):
        CASE_OP_32_64(orc):
        CASE_OP_32_64(eqv):
        CASE_OP_32_64(nand):
        CASE_OP_32_64(nor):
            if (temps[args[1]].state == TCG_TEMP_CONST
                && temps[args[2]].state == TCG_TEMP_CONST) {
                tmp = do_constant_folding(op, temps[args[1]].val,
                                          temps[args[2]].val);
                tcg_opt_gen_movi(gen_args, args[0], tmp);
            } else {
                reset_temp(args[0]);
                gen_args[0] = args[0];
                gen_args[1] = args[1];
                gen_args[2] = args[2];
                gen_args += 3;
        CASE_OP_32_64(setcond):
            if (temps[args[1]].state == TCG_TEMP_CONST
                && temps[args[2]].state == TCG_TEMP_CONST) {
                tmp = do_constant_folding_cond(op, temps[args[1]].val,
                                               temps[args[2]].val, args[3]);
                tcg_opt_gen_movi(gen_args, args[0], tmp);
            } else {
                reset_temp(args[0]);
                gen_args[0] = args[0];
                gen_args[1] = args[1];
                gen_args[2] = args[2];
                gen_args[3] = args[3];
                gen_args += 4;
            args += 4;
        CASE_OP_32_64(brcond):
            if (temps[args[0]].state == TCG_TEMP_CONST
                && temps[args[1]].state == TCG_TEMP_CONST) {
                if (do_constant_folding_cond(op, temps[args[0]].val,
                                             temps[args[1]].val, args[2])) {
                    memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));
                    gen_opc_buf[op_index] = INDEX_op_br;
                    gen_args[0] = args[3];
                    gen_args += 1;
                } else {
                    gen_opc_buf[op_index] = INDEX_op_nop;
            } else {
                memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));
                reset_temp(args[0]);
                gen_args[0] = args[0];
                gen_args[1] = args[1];
                gen_args[2] = args[2];
                gen_args[3] = args[3];
                gen_args += 4;
            args += 4;
        CASE_OP_32_64(movcond):
            if (temps[args[1]].state == TCG_TEMP_CONST
                && temps[args[2]].state == TCG_TEMP_CONST) {
                tmp = do_constant_folding_cond(op, temps[args[1]].val,
                                               temps[args[2]].val, args[5]);
                if (temps_are_copies(args[0], args[4-tmp])) {
                    gen_opc_buf[op_index] = INDEX_op_nop;
                } else if (temps[args[4-tmp]].state == TCG_TEMP_CONST) {
                    tcg_opt_gen_movi(gen_args, args[0], temps[args[4-tmp]].val);
                } else {
                    gen_opc_buf[op_index] = op_to_mov(op);
                    tcg_opt_gen_mov(s, gen_args, args[0], args[4-tmp]);
            } else {
                reset_temp(args[0]);
                gen_args[0] = args[0];
                gen_args[1] = args[1];
                gen_args[2] = args[2];
                gen_args[3] = args[3];
                gen_args[4] = args[4];
                gen_args[5] = args[5];
                gen_args += 6;
            args += 6;
        case INDEX_op_call:
            nb_call_args = (args[0] >> 16) + (args[0] & 0xffff);
            if (!(args[nb_call_args + 1] & (TCG_CALL_CONST | TCG_CALL_PURE))) {
                for (i = 0; i < nb_globals; i++) {
                    reset_temp(i);
            for (i = 0; i < (args[0] >> 16); i++) {
                reset_temp(args[i + 1]);
            i = nb_call_args + 3;
            while (i) {
                *gen_args = *args;
                args++;
                gen_args++;
                i--;
            /* Default case: we do know nothing about operation so no
               propagation is done.  We trash everything if the operation
               is the end of a basic block, otherwise we only trash the
               output args.  */
            if (def->flags & TCG_OPF_BB_END) {
                memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));
            } else {
                for (i = 0; i < def->nb_oargs; i++) {
                    reset_temp(args[i]);
            for (i = 0; i < def->nb_args; i++) {
                gen_args[i] = args[i];
            args += def->nb_args;
            gen_args += def->nb_args;
    return gen_args;",2059,"static TCGArg *tcg_constant_folding(TCGContext *fs, uint16_t *tcg_opc_ptr,
                                    TCGArg *args, TCGOpDef *tcg_op_defs)
{
    int i, nb_ops, op_index, nb_temps, nb_globals, nb_call_args;
    TCGOpcode op;
    const TCGOpDef *def;
    TCGArg *gen_args;
    TCGArg tmp;
    TCGCond cond;
    /* Array VALS has an element for each temp.
       If this temp holds a constant then its value is kept in VALS' element.
       If this temp is a copy of other ones then the other copies are
       available through the doubly linked circular list. */
    nb_temps = fs->nb_temps;
    nb_globals = fs->nb_globals;
    memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));
    nb_ops = tcg_opc_ptr - gen_opc_buf;
    gen_args = args;
    for (op_index = 0; op_index < nb_ops; op_index++) {
        op = gen_opc_buf[op_index];
        def = &tcg_op_defs[op];
        /* Do copy propagation */
        if (op == INDEX_op_call) {
            int nb_oargs = args[0] >> 16;
            int nb_iargs = args[0] & 0xffff;
            for (i = nb_oargs + 1; i < nb_oargs + nb_iargs + 1; i++) {
                if (temps[args[i]].state == TCG_TEMP_COPY) {
                    args[i] = find_better_copy(fs, args[i]);
        } else {
            for (i = def->nb_oargs; i < def->nb_oargs + def->nb_iargs; i++) {
                if (temps[args[i]].state == TCG_TEMP_COPY) {
                    args[i] = find_better_copy(fs, args[i]);
        /* For commutative operations make constant second argument */
        CASE_OP_32_64(add):
        CASE_OP_32_64(mul):
        CASE_OP_32_64(and):
        CASE_OP_32_64(or):
        CASE_OP_32_64(eqv):
        CASE_OP_32_64(nand):
        CASE_OP_32_64(nor):
            if (temps[args[1]].state == TCG_TEMP_CONST) {
                tmp = args[1];
                args[1] = args[2];
                args[2] = tmp;
        CASE_OP_32_64(brcond):
            if (temps[args[0]].state == TCG_TEMP_CONST
                && temps[args[1]].state != TCG_TEMP_CONST) {
                tmp = args[0];
                args[0] = args[1];
                args[1] = tmp;
                args[2] = tcg_swap_cond(args[2]);
        CASE_OP_32_64(setcond):
            if (temps[args[1]].state == TCG_TEMP_CONST
                && temps[args[2]].state != TCG_TEMP_CONST) {
                tmp = args[1];
                args[1] = args[2];
                args[2] = tmp;
                args[3] = tcg_swap_cond(args[3]);
        CASE_OP_32_64(movcond):
            cond = args[5];
            if (temps[args[1]].state == TCG_TEMP_CONST
                && temps[args[2]].state != TCG_TEMP_CONST) {
                tmp = args[1];
                args[1] = args[2];
                args[2] = tmp;
                cond = tcg_swap_cond(cond);
            /* For movcond, we canonicalize the ""false"" input reg to match
               the destination reg so that the tcg backend can implement
               a ""move if true"" operation.  */
            if (args[0] == args[3]) {
                tmp = args[3];
                args[3] = args[4];
                args[4] = tmp;
                cond = tcg_invert_cond(cond);
            args[5] = cond;
        /* Simplify expressions for ""shift/rot r, 0, a => movi r, 0"" */
        CASE_OP_32_64(shl):
        CASE_OP_32_64(shr):
        CASE_OP_32_64(sar):
        CASE_OP_32_64(rotl):
        CASE_OP_32_64(rotr):
            if (temps[args[1]].state == TCG_TEMP_CONST
                && temps[args[1]].val == 0) {
        /* Simplify expression for ""op r, a, 0 => mov r, a"" cases */
        CASE_OP_32_64(add):
        CASE_OP_32_64(shl):
        CASE_OP_32_64(shr):
        CASE_OP_32_64(sar):
        CASE_OP_32_64(rotl):
        CASE_OP_32_64(rotr):
        CASE_OP_32_64(or):
            if (temps[args[1]].state == TCG_TEMP_CONST) {
                /* Proceed with possible constant folding. */
            if (temps[args[2]].state == TCG_TEMP_CONST
                && temps[args[2]].val == 0) {
                if (temps_are_copies(args[0], args[1])) {
                    gen_opc_buf[op_index] = INDEX_op_nop;
                } else {
                    gen_opc_buf[op_index] = op_to_mov(op);
                    tcg_opt_gen_mov(fs, gen_args, args[0], args[1]);
        /* Simplify expression for ""op r, a, 0 => movi r, 0"" cases */
        CASE_OP_32_64(and):
        CASE_OP_32_64(mul):
            if ((temps[args[2]].state == TCG_TEMP_CONST
                && temps[args[2]].val == 0)) {
        /* Simplify expression for ""op r, a, a => mov r, a"" cases */
        CASE_OP_32_64(or):
        CASE_OP_32_64(and):
                if (temps_are_copies(args[0], args[1])) {
                    gen_opc_buf[op_index] = INDEX_op_nop;
                } else {
                    gen_opc_buf[op_index] = op_to_mov(op);
                    tcg_opt_gen_mov(fs, gen_args, args[0], args[1]);
        /* Propagate constants through copy operations and do constant
           folding.  Constants will be substituted to arguments by register
           allocator where needed and possible.  Also detect copies. */
        CASE_OP_32_64(mov):
            if (temps_are_copies(args[0], args[1])) {
                args += 2;
                gen_opc_buf[op_index] = INDEX_op_nop;
            if (temps[args[1]].state != TCG_TEMP_CONST) {
                tcg_opt_gen_mov(fs, gen_args, args[0], args[1]);
                args += 2;
            /* Source argument is constant.  Rewrite the operation and
               let movi case handle it. */
            op = op_to_movi(op);
            gen_opc_buf[op_index] = op;
            args[1] = temps[args[1]].val;
            /* fallthrough */
        CASE_OP_32_64(movi):
            tcg_opt_gen_movi(gen_args, args[0], args[1]);
            args += 2;
        CASE_OP_32_64(not):
        CASE_OP_32_64(neg):
        CASE_OP_32_64(ext8s):
        CASE_OP_32_64(ext8u):
        CASE_OP_32_64(ext16s):
        CASE_OP_32_64(ext16u):
        case INDEX_op_ext32s_i64:
        case INDEX_op_ext32u_i64:
            if (temps[args[1]].state == TCG_TEMP_CONST) {
                tmp = do_constant_folding(op, temps[args[1]].val, 0);
                tcg_opt_gen_movi(gen_args, args[0], tmp);
            } else {
                reset_temp(args[0]);
                gen_args[0] = args[0];
                gen_args[1] = args[1];
            args += 2;
        CASE_OP_32_64(add):
        CASE_OP_32_64(mul):
        CASE_OP_32_64(or):
        CASE_OP_32_64(and):
        CASE_OP_32_64(shl):
        CASE_OP_32_64(shr):
        CASE_OP_32_64(sar):
        CASE_OP_32_64(rotl):
        CASE_OP_32_64(rotr):
        CASE_OP_32_64(andc):
        CASE_OP_32_64(orc):
        CASE_OP_32_64(eqv):
        CASE_OP_32_64(nand):
        CASE_OP_32_64(nor):
            if (temps[args[1]].state == TCG_TEMP_CONST
                && temps[args[2]].state == TCG_TEMP_CONST) {
                tmp = do_constant_folding(op, temps[args[1]].val,
                                          temps[args[2]].val);
                tcg_opt_gen_movi(gen_args, args[0], tmp);
            } else {
                reset_temp(args[0]);
                gen_args[0] = args[0];
                gen_args[1] = args[1];
                gen_args[2] = args[2];
                gen_args += 3;
        CASE_OP_32_64(setcond):
            if (temps[args[1]].state == TCG_TEMP_CONST
                && temps[args[2]].state == TCG_TEMP_CONST) {
                tmp = do_constant_folding_cond(op, temps[args[1]].val,
                                               temps[args[2]].val, args[3]);
                tcg_opt_gen_movi(gen_args, args[0], tmp);
            } else {
                reset_temp(args[0]);
                gen_args[0] = args[0];
                gen_args[1] = args[1];
                gen_args[2] = args[2];
                gen_args[3] = args[3];
                gen_args += 4;
            args += 4;
        CASE_OP_32_64(brcond):
            if (temps[args[0]].state == TCG_TEMP_CONST
                && temps[args[1]].state == TCG_TEMP_CONST) {
                if (do_constant_folding_cond(op, temps[args[0]].val,
                                             temps[args[1]].val, args[2])) {
                    memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));
                    gen_opc_buf[op_index] = INDEX_op_br;
                    gen_args[0] = args[3];
                    gen_args += 1;
                } else {
                    gen_opc_buf[op_index] = INDEX_op_nop;
            } else {
                memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));
                reset_temp(args[0]);
                gen_args[0] = args[0];
                gen_args[1] = args[1];
                gen_args[2] = args[2];
                gen_args[3] = args[3];
                gen_args += 4;
            args += 4;
        CASE_OP_32_64(movcond):
            if (temps[args[1]].state == TCG_TEMP_CONST
                && temps[args[2]].state == TCG_TEMP_CONST) {
                tmp = do_constant_folding_cond(op, temps[args[1]].val,
                                               temps[args[2]].val, args[5]);
                if (temps_are_copies(args[0], args[4-tmp])) {
                    gen_opc_buf[op_index] = INDEX_op_nop;
                } else if (temps[args[4-tmp]].state == TCG_TEMP_CONST) {
                    tcg_opt_gen_movi(gen_args, args[0], temps[args[4-tmp]].val);
                } else {
                    gen_opc_buf[op_index] = op_to_mov(op);
                    tcg_opt_gen_mov(fs, gen_args, args[0], args[4-tmp]);
            } else {
                reset_temp(args[0]);
                gen_args[0] = args[0];
                gen_args[1] = args[1];
                gen_args[2] = args[2];
                gen_args[3] = args[3];
                gen_args[4] = args[4];
                gen_args[5] = args[5];
                gen_args += 6;
            args += 6;
        case INDEX_op_call:
            nb_call_args = (args[0] >> 16) + (args[0] & 0xffff);
            if (!(args[nb_call_args + 1] & (TCG_CALL_CONST | TCG_CALL_PURE))) {
                for (i = 0; i < nb_globals; i++) {
                    reset_temp(i);
            for (i = 0; i < (args[0] >> 16); i++) {
                reset_temp(args[i + 1]);
            i = nb_call_args + 3;
            while (i) {
                *gen_args = *args;
                args++;
                gen_args++;
                i--;
            /* Default case: we do know nothing about operation so no
               propagation is done.  We trash everything if the operation
               is the end of a basic block, otherwise we only trash the
               output args.  */
            if (def->flags & TCG_OPF_BB_END) {
                memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));
            } else {
                for (i = 0; i < def->nb_oargs; i++) {
                    reset_temp(args[i]);
            for (i = 0; i < def->nb_args; i++) {
                gen_args[i] = args[i];
            args += def->nb_args;
            gen_args += def->nb_args;
    return gen_args;",1,1,0.0,1,"tcg_constant_folding,TCGContext,s,uint16_t,tcg_opc_ptr,TCGArg,args,TCGOpDef,tcg_op_defs,i,nb_ops,op_index,nb_temps,nb_globals,nb_call_args,op,def,gen_args,tmp,cond,gen_opc_buf","tcg_constant_folding:-0.10016348958015442,TCGContext:0.017864108085632324,s:0.07062974572181702,uint16_t:-0.009442776441574097,tcg_opc_ptr:-0.005990117788314819,TCGArg:0.01573804020881653,args:0.02084210515022278,TCGOpDef:-0.02704387903213501,tcg_op_defs:-0.046909838914871216,i:0.02782231569290161,nb_ops:0.02332085371017456,op_index:-0.00620579719543457,nb_temps:-0.06588393449783325,nb_globals:-0.03353998064994812,nb_call_args:-0.013997524976730347,op:0.003347545862197876,def:0.03657376766204834,gen_args:0.021808356046676636,tmp:-0.0048350989818573,cond:0.03173863887786865,gen_opc_buf:-0.06510099768638611,",1.0,9.0,"s:fs,",Greedy,390,0.392656930287679
323,"void compute_images_mse_16bit(PSNRContext *s,

                        const uint8_t *main_data[4], const int main_linesizes[4],

                        const uint8_t *ref_data[4], const int ref_linesizes[4],

                        int w, int h, double mse[4])

{

    int i, c, j;



    for (c = 0; c < s->nb_components; c++) {

        const int outw = s->planewidth[c];

        const int outh = s->planeheight[c];

        const uint16_t *main_line = (uint16_t *)main_data[c];

        const uint16_t *ref_line = (uint16_t *)ref_data[c];

        const int ref_linesize = ref_linesizes[c] / 2;

        const int main_linesize = main_linesizes[c] / 2;

        uint64_t m = 0;



        for (i = 0; i < outh; i++) {

            for (j = 0; j < outw; j++)

                m += pow2(main_line[j] - ref_line[j]);

            ref_line += ref_linesize;

            main_line += main_linesize;

        }

        mse[c] = m / (double)(outw * outh);

    }

}
",219,"void compute_images_mse_16bit(PSNRContext *support,

                        const uint8_t *main_data[4], const int main_linesizes[4],

                        const uint8_t *ref_data[4], const int ref_linesys[4],

                        int fw, int h, double mse[4])

{

    int uri, cp, j;



    for (cp = 0; cp < support->nb_components; cp++) {

        const int outw = support->planewidth[cp];

        const int outh = support->planeheight[cp];

        const uint16_t *main_line = (uint16_t *)main_data[cp];

        const uint16_t *ref_line = (uint16_t *)ref_data[cp];

        const int ref_linesize = ref_linesys[cp] / 2;

        const int main_linesize = main_linesizes[cp] / 2;

        uint64_t m = 0;



        for (uri = 0; uri < outh; uri++) {

            for (j = 0; j < outw; j++)

                m += pow2(main_line[j] - ref_line[j]);

            ref_line += ref_linesize;

            main_line += main_linesize;

        }

        mse[cp] = m / (double)(outw * outh);

    }

}
",1,1,0.0,1,"s,main_data,main_linesizes,ref_data,ref_linesizes,w,h,mse,i,c,j,main_line,ref_line","s:0.05473226308822632,main_data:-0.08201199769973755,main_linesizes:-0.062395691871643066,ref_data:-0.05815160274505615,ref_linesizes:-0.044835567474365234,w:-0.019663512706756592,h:-0.07017600536346436,mse:-0.047025203704833984,i:-0.015957891941070557,c:-0.022837460041046143,j:-0.05783736705780029,main_line:-0.08002650737762451,ref_line:-0.11604100465774536,",5.0,22.0,"s:support,i:uri,w:fw,c:cp,ref_linesizes:ref_linesys,",Greedy,254,0.1974759101867675
347,"static int virtio_scsi_device_exit(DeviceState *qdev)

{

    VirtIOSCSI *s = VIRTIO_SCSI(qdev);

    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);



    unregister_savevm(qdev, ""virtio-scsi"", s);

    return virtio_scsi_common_exit(vs);

}
",44,"static int virtio_scsi_device_exit(DeviceState *iqdiv)

{

    VirtIOSCSI *s = VIRTIO_SCSI(iqdiv);

    VirtIOSCSICommon *os = VIRTIO_SCSI_COMMON(iqdiv);



    unregister_savevm(iqdiv, ""virtio-scsi"", s);

    return virtio_scsi_common_exit(os);

}
",1,1,0.0,1,"qdev,s,vs","qdev:0.044170260429382324,s:0.026446044445037842,vs:0.05743494629859924,",2.0,6.0,"vs:os,qdev:iqdiv,",Greedy,97,0.0654067357381184
364,"int hvf_vcpu_exec(CPUState *cpu)

{

    X86CPU *x86_cpu = X86_CPU(cpu);

    CPUX86State *env = &x86_cpu->env;

    int ret = 0;

    uint64_t rip = 0;



    cpu->halted = 0;



    if (hvf_process_events(cpu)) {

        return EXCP_HLT;

    }



    do {

        if (cpu->vcpu_dirty) {

            hvf_put_registers(cpu);

            cpu->vcpu_dirty = false;

        }



        if (hvf_inject_interrupts(cpu)) {

            return EXCP_INTERRUPT;

        }

        vmx_update_tpr(cpu);



        qemu_mutex_unlock_iothread();

        if (!cpu_is_bsp(X86_CPU(cpu)) && cpu->halted) {

            qemu_mutex_lock_iothread();

            return EXCP_HLT;

        }



        hv_return_t r  = hv_vcpu_run(cpu->hvf_fd);

        assert_hvf_ok(r);



        /* handle VMEXIT */

        uint64_t exit_reason = rvmcs(cpu->hvf_fd, VMCS_EXIT_REASON);

        uint64_t exit_qual = rvmcs(cpu->hvf_fd, VMCS_EXIT_QUALIFICATION);

        uint32_t ins_len = (uint32_t)rvmcs(cpu->hvf_fd,

                                           VMCS_EXIT_INSTRUCTION_LENGTH);



        uint64_t idtvec_info = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);



        hvf_store_events(cpu, ins_len, idtvec_info);

        rip = rreg(cpu->hvf_fd, HV_X86_RIP);

        RFLAGS(env) = rreg(cpu->hvf_fd, HV_X86_RFLAGS);

        env->eflags = RFLAGS(env);



        qemu_mutex_lock_iothread();



        update_apic_tpr(cpu);

        current_cpu = cpu;



        ret = 0;

        switch (exit_reason) {

        case EXIT_REASON_HLT: {

            macvm_set_rip(cpu, rip + ins_len);

            if (!((cpu->interrupt_request & CPU_INTERRUPT_HARD) &&

                (EFLAGS(env) & IF_MASK))

                && !(cpu->interrupt_request & CPU_INTERRUPT_NMI) &&

                !(idtvec_info & VMCS_IDT_VEC_VALID)) {

                cpu->halted = 1;

                ret = EXCP_HLT;

            }

            ret = EXCP_INTERRUPT;

            break;

        }

        case EXIT_REASON_MWAIT: {

            ret = EXCP_INTERRUPT;

            break;

        }

            /* Need to check if MMIO or unmmaped fault */

        case EXIT_REASON_EPT_FAULT:

        {

            hvf_slot *slot;

            addr_t gpa = rvmcs(cpu->hvf_fd, VMCS_GUEST_PHYSICAL_ADDRESS);



            if (((idtvec_info & VMCS_IDT_VEC_VALID) == 0) &&

                ((exit_qual & EXIT_QUAL_NMIUDTI) != 0)) {

                vmx_set_nmi_blocking(cpu);

            }



            slot = hvf_find_overlap_slot(gpa, gpa);

            /* mmio */

            if (ept_emulation_fault(slot, gpa, exit_qual)) {

                struct x86_decode decode;



                load_regs(cpu);

                env->hvf_emul->fetch_rip = rip;



                decode_instruction(env, &decode);

                exec_instruction(env, &decode);

                store_regs(cpu);

                break;

            }

            break;

        }

        case EXIT_REASON_INOUT:

        {

            uint32_t in = (exit_qual & 8) != 0;

            uint32_t size =  (exit_qual & 7) + 1;

            uint32_t string =  (exit_qual & 16) != 0;

            uint32_t port =  exit_qual >> 16;

            /*uint32_t rep = (exit_qual & 0x20) != 0;*/



#if 1

            if (!string && in) {

                uint64_t val = 0;

                load_regs(cpu);

                hvf_handle_io(env, port, &val, 0, size, 1);

                if (size == 1) {

                    AL(env) = val;

                } else if (size == 2) {

                    AX(env) = val;

                } else if (size == 4) {

                    RAX(env) = (uint32_t)val;

                } else {

                    VM_PANIC(""size"");

                }

                RIP(env) += ins_len;

                store_regs(cpu);

                break;

            } else if (!string && !in) {

                RAX(env) = rreg(cpu->hvf_fd, HV_X86_RAX);

                hvf_handle_io(env, port, &RAX(env), 1, size, 1);

                macvm_set_rip(cpu, rip + ins_len);

                break;

            }

#endif

            struct x86_decode decode;



            load_regs(cpu);

            env->hvf_emul->fetch_rip = rip;



            decode_instruction(env, &decode);

            VM_PANIC_ON(ins_len != decode.len);

            exec_instruction(env, &decode);

            store_regs(cpu);



            break;

        }

        case EXIT_REASON_CPUID: {

            uint32_t rax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);

            uint32_t rbx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RBX);

            uint32_t rcx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);

            uint32_t rdx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);



            cpu_x86_cpuid(env, rax, rcx, &rax, &rbx, &rcx, &rdx);



            wreg(cpu->hvf_fd, HV_X86_RAX, rax);

            wreg(cpu->hvf_fd, HV_X86_RBX, rbx);

            wreg(cpu->hvf_fd, HV_X86_RCX, rcx);

            wreg(cpu->hvf_fd, HV_X86_RDX, rdx);



            macvm_set_rip(cpu, rip + ins_len);

            break;

        }

        case EXIT_REASON_XSETBV: {

            X86CPU *x86_cpu = X86_CPU(cpu);

            CPUX86State *env = &x86_cpu->env;

            uint32_t eax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);

            uint32_t ecx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);

            uint32_t edx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);



            if (ecx) {

                macvm_set_rip(cpu, rip + ins_len);

                break;

            }

            env->xcr0 = ((uint64_t)edx << 32) | eax;

            wreg(cpu->hvf_fd, HV_X86_XCR0, env->xcr0 | 1);

            macvm_set_rip(cpu, rip + ins_len);

            break;

        }

        case EXIT_REASON_INTR_WINDOW:

            vmx_clear_int_window_exiting(cpu);

            ret = EXCP_INTERRUPT;

            break;

        case EXIT_REASON_NMI_WINDOW:

            vmx_clear_nmi_window_exiting(cpu);

            ret = EXCP_INTERRUPT;

            break;

        case EXIT_REASON_EXT_INTR:

            /* force exit and allow io handling */

            ret = EXCP_INTERRUPT;

            break;

        case EXIT_REASON_RDMSR:

        case EXIT_REASON_WRMSR:

        {

            load_regs(cpu);

            if (exit_reason == EXIT_REASON_RDMSR) {

                simulate_rdmsr(cpu);

            } else {

                simulate_wrmsr(cpu);

            }

            RIP(env) += rvmcs(cpu->hvf_fd, VMCS_EXIT_INSTRUCTION_LENGTH);

            store_regs(cpu);

            break;

        }

        case EXIT_REASON_CR_ACCESS: {

            int cr;

            int reg;



            load_regs(cpu);

            cr = exit_qual & 15;

            reg = (exit_qual >> 8) & 15;



            switch (cr) {

            case 0x0: {

                macvm_set_cr0(cpu->hvf_fd, RRX(env, reg));

                break;

            }

            case 4: {

                macvm_set_cr4(cpu->hvf_fd, RRX(env, reg));

                break;

            }

            case 8: {

                X86CPU *x86_cpu = X86_CPU(cpu);

                if (exit_qual & 0x10) {

                    RRX(env, reg) = cpu_get_apic_tpr(x86_cpu->apic_state);

                } else {

                    int tpr = RRX(env, reg);

                    cpu_set_apic_tpr(x86_cpu->apic_state, tpr);

                    ret = EXCP_INTERRUPT;

                }

                break;

            }

            default:

                error_report(""Unrecognized CR %d\n"", cr);

                abort();

            }

            RIP(env) += ins_len;

            store_regs(cpu);

            break;

        }

        case EXIT_REASON_APIC_ACCESS: { /* TODO */

            struct x86_decode decode;



            load_regs(cpu);

            env->hvf_emul->fetch_rip = rip;



            decode_instruction(env, &decode);

            exec_instruction(env, &decode);

            store_regs(cpu);

            break;

        }

        case EXIT_REASON_TPR: {

            ret = 1;

            break;

        }

        case EXIT_REASON_TASK_SWITCH: {

            uint64_t vinfo = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);

            x68_segment_selector sel = {.sel = exit_qual & 0xffff};

            vmx_handle_task_switch(cpu, sel, (exit_qual >> 30) & 0x3,

             vinfo & VMCS_INTR_VALID, vinfo & VECTORING_INFO_VECTOR_MASK, vinfo

             & VMCS_INTR_T_MASK);

            break;

        }

        case EXIT_REASON_TRIPLE_FAULT: {

            qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET);

            ret = EXCP_INTERRUPT;

            break;

        }

        case EXIT_REASON_RDPMC:

            wreg(cpu->hvf_fd, HV_X86_RAX, 0);

            wreg(cpu->hvf_fd, HV_X86_RDX, 0);

            macvm_set_rip(cpu, rip + ins_len);

            break;

        case VMX_REASON_VMCALL:

            /* TODO: inject #GP fault */

            break;

        default:

            error_report(""%llx: unhandled exit %llx\n"", rip, exit_reason);

        }

    } while (ret == 0);



    return ret;

}
",1434,"int hvf_vcpu_exec(CPUState *pool)

{

    X86CPU *x86_cpu = X86_CPU(pool);

    CPUX86State *env = &x86_cpu->env;

    int ret = 0;

    uint64_t rip = 0;



    pool->halted = 0;



    if (hvf_process_events(pool)) {

        return EXCP_HLT;

    }



    do {

        if (pool->vcpu_dirty) {

            hvf_put_registers(pool);

            pool->vcpu_dirty = false;

        }



        if (hvf_inject_interrupts(pool)) {

            return EXCP_INTERRUPT;

        }

        vmx_update_tpr(pool);



        qemu_mutex_unlock_iothread();

        if (!cpu_is_bsp(X86_CPU(pool)) && pool->halted) {

            qemu_mutex_lock_iothread();

            return EXCP_HLT;

        }



        hv_return_t r  = hv_vcpu_run(pool->hvf_fd);

        assert_hvf_ok(r);



        /* handle VMEXIT */

        uint64_t exit_reason = rvmcs(pool->hvf_fd, VMCS_EXIT_REASON);

        uint64_t exit_qual = rvmcs(pool->hvf_fd, VMCS_EXIT_QUALIFICATION);

        uint32_t ins_len = (uint32_t)rvmcs(pool->hvf_fd,

                                           VMCS_EXIT_INSTRUCTION_LENGTH);



        uint64_t idtvec_info = rvmcs(pool->hvf_fd, VMCS_IDT_VECTORING_INFO);



        hvf_store_events(pool, ins_len, idtvec_info);

        rip = rreg(pool->hvf_fd, HV_X86_RIP);

        RFLAGS(env) = rreg(pool->hvf_fd, HV_X86_RFLAGS);

        env->eflags = RFLAGS(env);



        qemu_mutex_lock_iothread();



        update_apic_tpr(pool);

        current_cpu = pool;



        ret = 0;

        switch (exit_reason) {

        case EXIT_REASON_HLT: {

            macvm_set_rip(pool, rip + ins_len);

            if (!((pool->interrupt_request & CPU_INTERRUPT_HARD) &&

                (EFLAGS(env) & IF_MASK))

                && !(pool->interrupt_request & CPU_INTERRUPT_NMI) &&

                !(idtvec_info & VMCS_IDT_VEC_VALID)) {

                pool->halted = 1;

                ret = EXCP_HLT;

            }

            ret = EXCP_INTERRUPT;

            break;

        }

        case EXIT_REASON_MWAIT: {

            ret = EXCP_INTERRUPT;

            break;

        }

            /* Need to check if MMIO or unmmaped fault */

        case EXIT_REASON_EPT_FAULT:

        {

            hvf_slot *slot;

            addr_t gpa = rvmcs(pool->hvf_fd, VMCS_GUEST_PHYSICAL_ADDRESS);



            if (((idtvec_info & VMCS_IDT_VEC_VALID) == 0) &&

                ((exit_qual & EXIT_QUAL_NMIUDTI) != 0)) {

                vmx_set_nmi_blocking(pool);

            }



            slot = hvf_find_overlap_slot(gpa, gpa);

            /* mmio */

            if (ept_emulation_fault(slot, gpa, exit_qual)) {

                struct x86_decode decode;



                load_regs(pool);

                env->hvf_emul->fetch_rip = rip;



                decode_instruction(env, &decode);

                exec_instruction(env, &decode);

                store_regs(pool);

                break;

            }

            break;

        }

        case EXIT_REASON_INOUT:

        {

            uint32_t in = (exit_qual & 8) != 0;

            uint32_t size =  (exit_qual & 7) + 1;

            uint32_t string =  (exit_qual & 16) != 0;

            uint32_t port =  exit_qual >> 16;

            /*uint32_t rep = (exit_qual & 0x20) != 0;*/



#if 1

            if (!string && in) {

                uint64_t val = 0;

                load_regs(pool);

                hvf_handle_io(env, port, &val, 0, size, 1);

                if (size == 1) {

                    AL(env) = val;

                } else if (size == 2) {

                    AX(env) = val;

                } else if (size == 4) {

                    RAX(env) = (uint32_t)val;

                } else {

                    VM_PANIC(""size"");

                }

                RIP(env) += ins_len;

                store_regs(pool);

                break;

            } else if (!string && !in) {

                RAX(env) = rreg(pool->hvf_fd, HV_X86_RAX);

                hvf_handle_io(env, port, &RAX(env), 1, size, 1);

                macvm_set_rip(pool, rip + ins_len);

                break;

            }

#endif

            struct x86_decode decode;



            load_regs(pool);

            env->hvf_emul->fetch_rip = rip;



            decode_instruction(env, &decode);

            VM_PANIC_ON(ins_len != decode.len);

            exec_instruction(env, &decode);

            store_regs(pool);



            break;

        }

        case EXIT_REASON_CPUID: {

            uint32_t rax = (uint32_t)rreg(pool->hvf_fd, HV_X86_RAX);

            uint32_t rbx = (uint32_t)rreg(pool->hvf_fd, HV_X86_RBX);

            uint32_t rcx = (uint32_t)rreg(pool->hvf_fd, HV_X86_RCX);

            uint32_t rdx = (uint32_t)rreg(pool->hvf_fd, HV_X86_RDX);



            cpu_x86_cpuid(env, rax, rcx, &rax, &rbx, &rcx, &rdx);



            wreg(pool->hvf_fd, HV_X86_RAX, rax);

            wreg(pool->hvf_fd, HV_X86_RBX, rbx);

            wreg(pool->hvf_fd, HV_X86_RCX, rcx);

            wreg(pool->hvf_fd, HV_X86_RDX, rdx);



            macvm_set_rip(pool, rip + ins_len);

            break;

        }

        case EXIT_REASON_XSETBV: {

            X86CPU *x86_cpu = X86_CPU(pool);

            CPUX86State *env = &x86_cpu->env;

            uint32_t eax = (uint32_t)rreg(pool->hvf_fd, HV_X86_RAX);

            uint32_t ecx = (uint32_t)rreg(pool->hvf_fd, HV_X86_RCX);

            uint32_t edx = (uint32_t)rreg(pool->hvf_fd, HV_X86_RDX);



            if (ecx) {

                macvm_set_rip(pool, rip + ins_len);

                break;

            }

            env->xcr0 = ((uint64_t)edx << 32) | eax;

            wreg(pool->hvf_fd, HV_X86_XCR0, env->xcr0 | 1);

            macvm_set_rip(pool, rip + ins_len);

            break;

        }

        case EXIT_REASON_INTR_WINDOW:

            vmx_clear_int_window_exiting(pool);

            ret = EXCP_INTERRUPT;

            break;

        case EXIT_REASON_NMI_WINDOW:

            vmx_clear_nmi_window_exiting(pool);

            ret = EXCP_INTERRUPT;

            break;

        case EXIT_REASON_EXT_INTR:

            /* force exit and allow io handling */

            ret = EXCP_INTERRUPT;

            break;

        case EXIT_REASON_RDMSR:

        case EXIT_REASON_WRMSR:

        {

            load_regs(pool);

            if (exit_reason == EXIT_REASON_RDMSR) {

                simulate_rdmsr(pool);

            } else {

                simulate_wrmsr(pool);

            }

            RIP(env) += rvmcs(pool->hvf_fd, VMCS_EXIT_INSTRUCTION_LENGTH);

            store_regs(pool);

            break;

        }

        case EXIT_REASON_CR_ACCESS: {

            int cr;

            int reg;



            load_regs(pool);

            cr = exit_qual & 15;

            reg = (exit_qual >> 8) & 15;



            switch (cr) {

            case 0x0: {

                macvm_set_cr0(pool->hvf_fd, RRX(env, reg));

                break;

            }

            case 4: {

                macvm_set_cr4(pool->hvf_fd, RRX(env, reg));

                break;

            }

            case 8: {

                X86CPU *x86_cpu = X86_CPU(pool);

                if (exit_qual & 0x10) {

                    RRX(env, reg) = cpu_get_apic_tpr(x86_cpu->apic_state);

                } else {

                    int tpr = RRX(env, reg);

                    cpu_set_apic_tpr(x86_cpu->apic_state, tpr);

                    ret = EXCP_INTERRUPT;

                }

                break;

            }

            default:

                error_report(""Unrecognized CR %d
"", cr);

                abort();

            }

            RIP(env) += ins_len;

            store_regs(pool);

            break;

        }

        case EXIT_REASON_APIC_ACCESS: { /* TODO */

            struct x86_decode decode;



            load_regs(pool);

            env->hvf_emul->fetch_rip = rip;



            decode_instruction(env, &decode);

            exec_instruction(env, &decode);

            store_regs(pool);

            break;

        }

        case EXIT_REASON_TPR: {

            ret = 1;

            break;

        }

        case EXIT_REASON_TASK_SWITCH: {

            uint64_t vinfo = rvmcs(pool->hvf_fd, VMCS_IDT_VECTORING_INFO);

            x68_segment_selector sel = {.sel = exit_qual & 0xffff};

            vmx_handle_task_switch(pool, sel, (exit_qual >> 30) & 0x3,

             vinfo & VMCS_INTR_VALID, vinfo & VECTORING_INFO_VECTOR_MASK, vinfo

             & VMCS_INTR_T_MASK);

            break;

        }

        case EXIT_REASON_TRIPLE_FAULT: {

            qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET);

            ret = EXCP_INTERRUPT;

            break;

        }

        case EXIT_REASON_RDPMC:

            wreg(pool->hvf_fd, HV_X86_RAX, 0);

            wreg(pool->hvf_fd, HV_X86_RDX, 0);

            macvm_set_rip(pool, rip + ins_len);

            break;

        case VMX_REASON_VMCALL:

            /* TODO: inject #GP fault */

            break;

        default:

            error_report(""%llx: unhandled exit %llx
"", rip, exit_reason);

        }

    } while (ret == 0);



    return ret;

}
",1,1,0.0,1,"cpu,x86_cpu,env","cpu:0.027817100286483765,x86_cpu:-0.03161263465881348,env:-0.024571657180786133,",1.0,70.0,"cpu:pool,",Greedy,201,0.1477917790412903
366,"int bdrv_pwrite(BlockDriverState *bs, int64_t offset,

                const void *buf1, int count1)

{

    BlockDriver *drv = bs->drv;



    if (!drv)

        return -ENOMEDIUM;

    if (!drv->bdrv_pwrite)

        return bdrv_pwrite_em(bs, offset, buf1, count1);

    if (bdrv_wr_badreq_bytes(bs, offset, count1))

        return -EDOM;

    return drv->bdrv_pwrite(bs, offset, buf1, count1);

}
",85,"int bdrv_pwrite(BlockDriverState *bt, int64_t offset,

                const void *buffername, int count1)

{

    BlockDriver *drv = bt->drv;



    if (!drv)

        return -ENOMEDIUM;

    if (!drv->bdrv_pwrite)

        return bdrv_pwrite_em(bt, offset, buffername, count1);

    if (bdrv_wr_badreq_bytes(bt, offset, count1))

        return -EDOM;

    return drv->bdrv_pwrite(bt, offset, buffername, count1);

}
",1,1,0.0,1,"bs,offset,buf1,count1,drv","bs:0.14461299777030945,offset:0.04878121614456177,buf1:0.1464417278766632,count1:0.12890395522117615,drv:0.005178526043891907,",2.0,8.0,"buf1:buffername,bs:bt,",Greedy,99,0.0767738024393717
367,"static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)

{

    char *buffer;

    int ret;

    char *path = fs_path->data;



    buffer = rpath(ctx, path);

    ret = truncate(buffer, size);

    g_free(buffer);

    return ret;

}
",58,"static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)

{

    char *transfer;

    int ret;

    char *path = fs_path->data;



    transfer = rpath(ctx, path);

    ret = truncate(transfer, size);

    g_free(transfer);

    return ret;

}
",1,1,0.0,1,"ctx,fs_path,size,buffer,ret,path","ctx:-0.008063852787017822,fs_path:-0.13610684871673584,size:0.08350569009780884,buffer:0.2544114887714386,ret:-0.03215068578720093,path:-0.17865782976150513,",1.0,4.0,"buffer:transfer,",Greedy,67,0.0457518577575683
381,"static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,

	unsigned int width, unsigned int height,

	int lumStride, int chromStride, int srcStride)

{

	unsigned y;

	const unsigned chromWidth= width>>1;

	for(y=0; y<height; y+=2)

	{

#ifdef HAVE_MMX

		asm volatile(

			""xor %%""REG_a"", %%""REG_a""	\n\t""

			""pcmpeqw %%mm7, %%mm7		\n\t""

			""psrlw $8, %%mm7		\n\t"" // FF,00,FF,00...

			"".balign 16			\n\t""

			""1:				\n\t""

			PREFETCH"" 64(%0, %%""REG_a"", 4)	\n\t""

			""movq (%0, %%""REG_a"", 4), %%mm0	\n\t"" // YUYV YUYV(0)

			""movq 8(%0, %%""REG_a"", 4), %%mm1\n\t"" // YUYV YUYV(4)

			""movq %%mm0, %%mm2		\n\t"" // YUYV YUYV(0)

			""movq %%mm1, %%mm3		\n\t"" // YUYV YUYV(4)

			""psrlw $8, %%mm0		\n\t"" // U0V0 U0V0(0)

			""psrlw $8, %%mm1		\n\t"" // U0V0 U0V0(4)

			""pand %%mm7, %%mm2		\n\t"" // Y0Y0 Y0Y0(0)

			""pand %%mm7, %%mm3		\n\t"" // Y0Y0 Y0Y0(4)

			""packuswb %%mm1, %%mm0		\n\t"" // UVUV UVUV(0)

			""packuswb %%mm3, %%mm2		\n\t"" // YYYY YYYY(0)



			MOVNTQ"" %%mm2, (%1, %%""REG_a"", 2)\n\t""



			""movq 16(%0, %%""REG_a"", 4), %%mm1\n\t"" // YUYV YUYV(8)

			""movq 24(%0, %%""REG_a"", 4), %%mm2\n\t"" // YUYV YUYV(12)

			""movq %%mm1, %%mm3		\n\t"" // YUYV YUYV(8)

			""movq %%mm2, %%mm4		\n\t"" // YUYV YUYV(12)

			""psrlw $8, %%mm1		\n\t"" // U0V0 U0V0(8)

			""psrlw $8, %%mm2		\n\t"" // U0V0 U0V0(12)

			""pand %%mm7, %%mm3		\n\t"" // Y0Y0 Y0Y0(8)

			""pand %%mm7, %%mm4		\n\t"" // Y0Y0 Y0Y0(12)

			""packuswb %%mm2, %%mm1		\n\t"" // UVUV UVUV(8)

			""packuswb %%mm4, %%mm3		\n\t"" // YYYY YYYY(8)



			MOVNTQ"" %%mm3, 8(%1, %%""REG_a"", 2)\n\t""



			""movq %%mm0, %%mm2		\n\t"" // UVUV UVUV(0)

			""movq %%mm1, %%mm3		\n\t"" // UVUV UVUV(8)

			""psrlw $8, %%mm0		\n\t"" // V0V0 V0V0(0)

			""psrlw $8, %%mm1		\n\t"" // V0V0 V0V0(8)

			""pand %%mm7, %%mm2		\n\t"" // U0U0 U0U0(0)

			""pand %%mm7, %%mm3		\n\t"" // U0U0 U0U0(8)

			""packuswb %%mm1, %%mm0		\n\t"" // VVVV VVVV(0)

			""packuswb %%mm3, %%mm2		\n\t"" // UUUU UUUU(0)



			MOVNTQ"" %%mm0, (%3, %%""REG_a"")	\n\t""

			MOVNTQ"" %%mm2, (%2, %%""REG_a"")	\n\t""



			""add $8, %%""REG_a""		\n\t""

			""cmp %4, %%""REG_a""		\n\t""

			"" jb 1b				\n\t""

			::""r""(src), ""r""(ydst), ""r""(udst), ""r""(vdst), ""g"" ((long)chromWidth)

			: ""memory"", ""%""REG_a

		);



		ydst += lumStride;

		src  += srcStride;



		asm volatile(

			""xor %%""REG_a"", %%""REG_a""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			PREFETCH"" 64(%0, %%""REG_a"", 4)	\n\t""

			""movq (%0, %%""REG_a"", 4), %%mm0	\n\t"" // YUYV YUYV(0)

			""movq 8(%0, %%""REG_a"", 4), %%mm1\n\t"" // YUYV YUYV(4)

			""movq 16(%0, %%""REG_a"", 4), %%mm2\n\t"" // YUYV YUYV(8)

			""movq 24(%0, %%""REG_a"", 4), %%mm3\n\t"" // YUYV YUYV(12)

			""pand %%mm7, %%mm0		\n\t"" // Y0Y0 Y0Y0(0)

			""pand %%mm7, %%mm1		\n\t"" // Y0Y0 Y0Y0(4)

			""pand %%mm7, %%mm2		\n\t"" // Y0Y0 Y0Y0(8)

			""pand %%mm7, %%mm3		\n\t"" // Y0Y0 Y0Y0(12)

			""packuswb %%mm1, %%mm0		\n\t"" // YYYY YYYY(0)

			""packuswb %%mm3, %%mm2		\n\t"" // YYYY YYYY(8)



			MOVNTQ"" %%mm0, (%1, %%""REG_a"", 2)\n\t""

			MOVNTQ"" %%mm2, 8(%1, %%""REG_a"", 2)\n\t""



			""add $8, %%""REG_a""		\n\t""

			""cmp %4, %%""REG_a""		\n\t""

			"" jb 1b				\n\t""



			::""r""(src), ""r""(ydst), ""r""(udst), ""r""(vdst), ""g"" ((long)chromWidth)

			: ""memory"", ""%""REG_a

		);

#else

		unsigned i;

		for(i=0; i<chromWidth; i++)

		{

			ydst[2*i+0] 	= src[4*i+0];

			udst[i] 	= src[4*i+1];

			ydst[2*i+1] 	= src[4*i+2];

			vdst[i] 	= src[4*i+3];

		}

		ydst += lumStride;

		src  += srcStride;



		for(i=0; i<chromWidth; i++)

		{

			ydst[2*i+0] 	= src[4*i+0];

			ydst[2*i+1] 	= src[4*i+2];

		}

#endif

		udst += chromStride;

		vdst += chromStride;

		ydst += lumStride;

		src  += srcStride;

	}

#ifdef HAVE_MMX

asm volatile(   EMMS"" \n\t""

        	SFENCE"" \n\t""

        	:::""memory"");

#endif

}
",616,"static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *iddstr, uint8_t *UDost, uint8_t *vdset,

	unsigned int width, unsigned int window,

	int lumsStuse, int chromScipe, int srcBlrite)

{

	unsigned y;

	const unsigned chromWidth= width>>1;

	for(y=0; y<window; y+=2)

	{

#ifdef HAVE_MMX

		asm volatile(

			""xor %%""REG_a"", %%""REG_a""	
\t""

			""pcmpeqw %%mm7, %%mm7		
\t""

			""psrlw $8, %%mm7		
\t"" // FF,00,FF,00...

			"".balign 16			
\t""

			""1:				
\t""

			PREFETCH"" 64(%0, %%""REG_a"", 4)	
\t""

			""movq (%0, %%""REG_a"", 4), %%mm0	
\t"" // YUYV YUYV(0)

			""movq 8(%0, %%""REG_a"", 4), %%mm1
\t"" // YUYV YUYV(4)

			""movq %%mm0, %%mm2		
\t"" // YUYV YUYV(0)

			""movq %%mm1, %%mm3		
\t"" // YUYV YUYV(4)

			""psrlw $8, %%mm0		
\t"" // U0V0 U0V0(0)

			""psrlw $8, %%mm1		
\t"" // U0V0 U0V0(4)

			""pand %%mm7, %%mm2		
\t"" // Y0Y0 Y0Y0(0)

			""pand %%mm7, %%mm3		
\t"" // Y0Y0 Y0Y0(4)

			""packuswb %%mm1, %%mm0		
\t"" // UVUV UVUV(0)

			""packuswb %%mm3, %%mm2		
\t"" // YYYY YYYY(0)



			MOVNTQ"" %%mm2, (%1, %%""REG_a"", 2)
\t""



			""movq 16(%0, %%""REG_a"", 4), %%mm1
\t"" // YUYV YUYV(8)

			""movq 24(%0, %%""REG_a"", 4), %%mm2
\t"" // YUYV YUYV(12)

			""movq %%mm1, %%mm3		
\t"" // YUYV YUYV(8)

			""movq %%mm2, %%mm4		
\t"" // YUYV YUYV(12)

			""psrlw $8, %%mm1		
\t"" // U0V0 U0V0(8)

			""psrlw $8, %%mm2		
\t"" // U0V0 U0V0(12)

			""pand %%mm7, %%mm3		
\t"" // Y0Y0 Y0Y0(8)

			""pand %%mm7, %%mm4		
\t"" // Y0Y0 Y0Y0(12)

			""packuswb %%mm2, %%mm1		
\t"" // UVUV UVUV(8)

			""packuswb %%mm4, %%mm3		
\t"" // YYYY YYYY(8)



			MOVNTQ"" %%mm3, 8(%1, %%""REG_a"", 2)
\t""



			""movq %%mm0, %%mm2		
\t"" // UVUV UVUV(0)

			""movq %%mm1, %%mm3		
\t"" // UVUV UVUV(8)

			""psrlw $8, %%mm0		
\t"" // V0V0 V0V0(0)

			""psrlw $8, %%mm1		
\t"" // V0V0 V0V0(8)

			""pand %%mm7, %%mm2		
\t"" // U0U0 U0U0(0)

			""pand %%mm7, %%mm3		
\t"" // U0U0 U0U0(8)

			""packuswb %%mm1, %%mm0		
\t"" // VVVV VVVV(0)

			""packuswb %%mm3, %%mm2		
\t"" // UUUU UUUU(0)



			MOVNTQ"" %%mm0, (%3, %%""REG_a"")	
\t""

			MOVNTQ"" %%mm2, (%2, %%""REG_a"")	
\t""



			""add $8, %%""REG_a""		
\t""

			""cmp %4, %%""REG_a""		
\t""

			"" jb 1b				
\t""

			::""r""(src), ""r""(iddstr), ""r""(UDost), ""r""(vdset), ""g"" ((long)chromWidth)

			: ""memory"", ""%""REG_a

		);



		iddstr += lumsStuse;

		src  += srcBlrite;



		asm volatile(

			""xor %%""REG_a"", %%""REG_a""	
\t""

			"".balign 16			
\t""

			""1:				
\t""

			PREFETCH"" 64(%0, %%""REG_a"", 4)	
\t""

			""movq (%0, %%""REG_a"", 4), %%mm0	
\t"" // YUYV YUYV(0)

			""movq 8(%0, %%""REG_a"", 4), %%mm1
\t"" // YUYV YUYV(4)

			""movq 16(%0, %%""REG_a"", 4), %%mm2
\t"" // YUYV YUYV(8)

			""movq 24(%0, %%""REG_a"", 4), %%mm3
\t"" // YUYV YUYV(12)

			""pand %%mm7, %%mm0		
\t"" // Y0Y0 Y0Y0(0)

			""pand %%mm7, %%mm1		
\t"" // Y0Y0 Y0Y0(4)

			""pand %%mm7, %%mm2		
\t"" // Y0Y0 Y0Y0(8)

			""pand %%mm7, %%mm3		
\t"" // Y0Y0 Y0Y0(12)

			""packuswb %%mm1, %%mm0		
\t"" // YYYY YYYY(0)

			""packuswb %%mm3, %%mm2		
\t"" // YYYY YYYY(8)



			MOVNTQ"" %%mm0, (%1, %%""REG_a"", 2)
\t""

			MOVNTQ"" %%mm2, 8(%1, %%""REG_a"", 2)
\t""



			""add $8, %%""REG_a""		
\t""

			""cmp %4, %%""REG_a""		
\t""

			"" jb 1b				
\t""



			::""r""(src), ""r""(iddstr), ""r""(UDost), ""r""(vdset), ""g"" ((long)chromWidth)

			: ""memory"", ""%""REG_a

		);

#else

		unsigned i;

		for(i=0; i<chromWidth; i++)

		{

			iddstr[2*i+0] 	= src[4*i+0];

			UDost[i] 	= src[4*i+1];

			iddstr[2*i+1] 	= src[4*i+2];

			vdset[i] 	= src[4*i+3];

		}

		iddstr += lumsStuse;

		src  += srcBlrite;



		for(i=0; i<chromWidth; i++)

		{

			iddstr[2*i+0] 	= src[4*i+0];

			iddstr[2*i+1] 	= src[4*i+2];

		}

#endif

		UDost += chromScipe;

		vdset += chromScipe;

		iddstr += lumsStuse;

		src  += srcBlrite;

	}

#ifdef HAVE_MMX

asm volatile(   EMMS"" 
\t""

        	SFENCE"" 
\t""

        	:::""memory"");

#endif

}
",1,1,0.0,1,"src,ydst,udst,vdst,height,lumStride,chromStride,srcStride,y","src:-0.011764466762542725,ydst:0.013026058673858643,udst:0.007196664810180664,vdst:0.007145404815673828,height:-0.004514753818511963,lumStride:-0.0020023584365844727,chromStride:0.0019025802612304688,srcStride:0.01126241683959961,y:-0.020861566066741943,",7.0,33.0,"ydst:iddstr,srcStride:srcBlrite,udst:UDost,vdst:vdset,chromStride:chromScipe,lumStride:lumsStuse,height:window,",Greedy,268,0.2193241953849792
383,"static int hevc_frame_start(HEVCContext *s)

{

    HEVCLocalContext *lc = &s->HEVClc;

    int ret;



    memset(s->horizontal_bs, 0, 2 * s->bs_width * (s->bs_height + 1));

    memset(s->vertical_bs,   0, 2 * s->bs_width * (s->bs_height + 1));

    memset(s->cbf_luma,      0, s->sps->min_tb_width * s->sps->min_tb_height);

    memset(s->is_pcm,        0, s->sps->min_pu_width * s->sps->min_pu_height);



    lc->start_of_tiles_x = 0;

    s->is_decoded        = 0;




    if (s->pps->tiles_enabled_flag)

        lc->end_of_tiles_x = s->pps->column_width[0] << s->sps->log2_ctb_size;



    ret = ff_hevc_set_new_ref(s, s->sps->sao_enabled ? &s->sao_frame : &s->frame,

                              s->poc);

    if (ret < 0)

        goto fail;



    ret = ff_hevc_frame_rps(s);

    if (ret < 0) {

        av_log(s->avctx, AV_LOG_ERROR, ""Error constructing the frame RPS.\n"");

        goto fail;

    }



    ret = set_side_data(s);

    if (ret < 0)

        goto fail;



    av_frame_unref(s->output_frame);

    ret = ff_hevc_output_frame(s, s->output_frame, 0);

    if (ret < 0)

        goto fail;



    ff_thread_finish_setup(s->avctx);



    return 0;



fail:

    if (s->ref)

        ff_thread_report_progress(&s->ref->tf, INT_MAX, 0);

    s->ref = NULL;

    return ret;

}",301,"static int hevc_frame_start(HEVCContext *s)

{

    HEVCLocalContext *ci = &s->HEVClc;

    int feat;



    memset(s->horizontal_bs, 0, 2 * s->bs_width * (s->bs_height + 1));

    memset(s->vertical_bs,   0, 2 * s->bs_width * (s->bs_height + 1));

    memset(s->cbf_luma,      0, s->sps->min_tb_width * s->sps->min_tb_height);

    memset(s->is_pcm,        0, s->sps->min_pu_width * s->sps->min_pu_height);



    ci->start_of_tiles_x = 0;

    s->is_decoded        = 0;




    if (s->pps->tiles_enabled_flag)

        ci->end_of_tiles_x = s->pps->column_width[0] << s->sps->log2_ctb_size;



    feat = ff_hevc_set_new_ref(s, s->sps->sao_enabled ? &s->sao_frame : &s->frame,

                              s->poc);

    if (feat < 0)

        goto fail;



    feat = ff_hevc_frame_rps(s);

    if (feat < 0) {

        av_log(s->avctx, AV_LOG_ERROR, ""Error constructing the frame RPS.
"");

        goto fail;

    }



    feat = set_side_data(s);

    if (feat < 0)

        goto fail;



    av_frame_unref(s->output_frame);

    feat = ff_hevc_output_frame(s, s->output_frame, 0);

    if (feat < 0)

        goto fail;



    ff_thread_finish_setup(s->avctx);



    return 0;



fail:

    if (s->ref)

        ff_thread_report_progress(&s->ref->tf, INT_MAX, 0);

    s->ref = NULL;

    return feat;

}",1,1,0.0,1,"s,lc,ret","s:-0.017229855060577393,lc:0.0024701356887817383,ret:0.04357647895812988,",2.0,13.0,"ret:feat,lc:ci,",Greedy,163,0.1146751920382181
388,"static void get_sensor_evt_status(IPMIBmcSim *ibs,

                                  uint8_t *cmd, unsigned int cmd_len,

                                  uint8_t *rsp, unsigned int *rsp_len,

                                  unsigned int max_rsp_len)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    if ((cmd[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {

        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sens = ibs->sensors + cmd[2];

    IPMI_ADD_RSP_DATA(sens->reading);

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));

    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);

    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);

    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);

}
",145,"static void get_sensor_evt_status(IPMIBmcSim *ibs,

                                  uint8_t *mode, unsigned int cmd_len,

                                  uint8_t *srpc, unsigned int *rsp_limit,

                                  unsigned int max_rsc_count)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    if ((mode[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + mode[2])) {

        srpc[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sens = ibs->sensors + mode[2];

    IPMI_ADD_RSP_DATA(sens->reading);

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));

    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);

    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);

    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);

}
",1,1,0.0,1,"ibs,cmd,cmd_len,rsp,rsp_len,max_rsp_len,sens","ibs:-0.0028195977210998535,cmd:0.019290626049041748,cmd_len:0.018666744232177734,rsp:0.10092481970787048,rsp_len:0.06805664300918579,max_rsp_len:0.01903587579727173,sens:0.017021000385284424,",4.0,8.0,"rsp:srpc,rsp_len:rsp_limit,cmd:mode,max_rsp_len:max_rsc_count,",Greedy,116,0.0887032071749369
397,"static void vfio_unmap_bar(VFIODevice *vdev, int nr)

{

    VFIOBAR *bar = &vdev->bars[nr];



    if (!bar->size) {

        return;

    }



    vfio_bar_quirk_teardown(vdev, nr);



    memory_region_del_subregion(&bar->mem, &bar->mmap_mem);

    munmap(bar->mmap, memory_region_size(&bar->mmap_mem));




    if (vdev->msix && vdev->msix->table_bar == nr) {

        memory_region_del_subregion(&bar->mem, &vdev->msix->mmap_mem);

        munmap(vdev->msix->mmap, memory_region_size(&vdev->msix->mmap_mem));


    }



    memory_region_destroy(&bar->mem);

}",129,"static void vfio_unmap_bar(VFIODevice *nverror, int nr)

{

    VFIOBAR *bar = &nverror->bars[nr];



    if (!bar->size) {

        return;

    }



    vfio_bar_quirk_teardown(nverror, nr);



    memory_region_del_subregion(&bar->mem, &bar->mmap_mem);

    munmap(bar->mmap, memory_region_size(&bar->mmap_mem));




    if (nverror->msix && nverror->msix->table_bar == nr) {

        memory_region_del_subregion(&bar->mem, &nverror->msix->mmap_mem);

        munmap(nverror->msix->mmap, memory_region_size(&nverror->msix->mmap_mem));


    }



    memory_region_destroy(&bar->mem);

}",1,1,0.0,1,"vdev,nr,bar","vdev:0.11692684888839722,nr:0.09267383813858032,bar:-0.013941705226898193,",1.0,8.0,"vdev:nverror,",Greedy,119,0.0331944743792216
4,"static int rtmp_packet_read_one_chunk(URLContext *h, RTMPPacket *p,
                                      int chunk_size, RTMPPacket **prev_pkt_ptr,
                                      int *nb_prev_pkt, uint8_t hdr)
{
    uint8_t buf[16];
    int channel_id, timestamp, size;
    uint32_t ts_field; // non-extended timestamp or delta field
    uint32_t extra = 0;
    enum RTMPPacketType type;
    int written = 0;
    int ret, toread;
    RTMPPacket *prev_pkt;
    written++;
    channel_id = hdr & 0x3F;
    if (channel_id < 2) { //special case for channel number >= 64
        buf[1] = 0;
        if (ffurl_read_complete(h, buf, channel_id + 1) != channel_id + 1)
            return AVERROR(EIO);
        written += channel_id + 1;
        channel_id = AV_RL16(buf) + 64;
    if ((ret = ff_rtmp_check_alloc_array(prev_pkt_ptr, nb_prev_pkt,
                                         channel_id)) < 0)
        return ret;
    prev_pkt = *prev_pkt_ptr;
    size  = prev_pkt[channel_id].size;
    type  = prev_pkt[channel_id].type;
    extra = prev_pkt[channel_id].extra;
    hdr >>= 6; // header size indicator
    if (hdr == RTMP_PS_ONEBYTE) {
        ts_field = prev_pkt[channel_id].ts_field;
    } else {
        if (ffurl_read_complete(h, buf, 3) != 3)
            return AVERROR(EIO);
        written += 3;
        ts_field = AV_RB24(buf);
        if (hdr != RTMP_PS_FOURBYTES) {
            if (ffurl_read_complete(h, buf, 3) != 3)
                return AVERROR(EIO);
            written += 3;
            size = AV_RB24(buf);
            if (ffurl_read_complete(h, buf, 1) != 1)
                return AVERROR(EIO);
            written++;
            type = buf[0];
            if (hdr == RTMP_PS_TWELVEBYTES) {
                if (ffurl_read_complete(h, buf, 4) != 4)
                    return AVERROR(EIO);
                written += 4;
                extra = AV_RL32(buf);
    if (ts_field == 0xFFFFFF) {
        if (ffurl_read_complete(h, buf, 4) != 4)
            return AVERROR(EIO);
        timestamp = AV_RB32(buf);
    } else {
        timestamp = ts_field;
    if (hdr != RTMP_PS_TWELVEBYTES)
        timestamp += prev_pkt[channel_id].timestamp;
    if (!prev_pkt[channel_id].read) {
        if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,
                                         size)) < 0)
            return ret;
        p->read = written;
        p->offset = 0;
        prev_pkt[channel_id].ts_field   = ts_field;
        prev_pkt[channel_id].timestamp  = timestamp;
    } else {
        // previous packet in this channel hasn't completed reading
        RTMPPacket *prev = &prev_pkt[channel_id];
        p->data          = prev->data;
        p->size          = prev->size;
        p->channel_id    = prev->channel_id;
        p->type          = prev->type;
        p->ts_field      = prev->ts_field;
        p->extra         = prev->extra;
        p->offset        = prev->offset;
        p->read          = prev->read + written;
        p->timestamp     = prev->timestamp;
        prev->data       = NULL;
    p->extra = extra;
    // save history
    prev_pkt[channel_id].channel_id = channel_id;
    prev_pkt[channel_id].type       = type;
    prev_pkt[channel_id].size       = size;
    prev_pkt[channel_id].extra      = extra;
    size = size - p->offset;
    toread = FFMIN(size, chunk_size);
    if (ffurl_read_complete(h, p->data + p->offset, toread) != toread) {
        ff_rtmp_packet_destroy(p);
        return AVERROR(EIO);
    size      -= toread;
    p->read   += toread;
    p->offset += toread;
    if (size > 0) {
       RTMPPacket *prev = &prev_pkt[channel_id];
       prev->data = p->data;
       prev->read = p->read;
       prev->offset = p->offset;
       return AVERROR(EAGAIN);
    prev_pkt[channel_id].read = 0; // read complete; reset if needed
    return p->read;",716,"static int rtmp_packet_read_one_chunk(URLContext *h, RTMPPacket *port,
                                      int chunk_size, RTMPPacket **prev_pkt_ptr,
                                      int *nb_prev_pkt, uint8_t hdr)
{
    uint8_t buf[16];
    int channel_name, timestamp, size;
    uint32_t ts_field; // non-extended timestamp or delta field
    uint32_t extra = 0;
    enum RTMPPacketType value;
    int written = 0;
    int ret, toready;
    RTMPPacket *prev_pkt;
    written++;
    channel_name = hdr & 0x3F;
    if (channel_name < 2) { //special case for channel number >= 64
        buf[1] = 0;
        if (ffurl_read_complete(h, buf, channel_name + 1) != channel_name + 1)
            return AVERROR(EIO);
        written += channel_name + 1;
        channel_name = AV_RL16(buf) + 64;
    if ((ret = ff_rtmp_check_alloc_array(prev_pkt_ptr, nb_prev_pkt,
                                         channel_name)) < 0)
        return ret;
    prev_pkt = *prev_pkt_ptr;
    size  = prev_pkt[channel_name].size;
    value  = prev_pkt[channel_name].value;
    extra = prev_pkt[channel_name].extra;
    hdr >>= 6; // header size indicator
    if (hdr == RTMP_PS_ONEBYTE) {
        ts_field = prev_pkt[channel_name].ts_field;
    } else {
        if (ffurl_read_complete(h, buf, 3) != 3)
            return AVERROR(EIO);
        written += 3;
        ts_field = AV_RB24(buf);
        if (hdr != RTMP_PS_FOURBYTES) {
            if (ffurl_read_complete(h, buf, 3) != 3)
                return AVERROR(EIO);
            written += 3;
            size = AV_RB24(buf);
            if (ffurl_read_complete(h, buf, 1) != 1)
                return AVERROR(EIO);
            written++;
            value = buf[0];
            if (hdr == RTMP_PS_TWELVEBYTES) {
                if (ffurl_read_complete(h, buf, 4) != 4)
                    return AVERROR(EIO);
                written += 4;
                extra = AV_RL32(buf);
    if (ts_field == 0xFFFFFF) {
        if (ffurl_read_complete(h, buf, 4) != 4)
            return AVERROR(EIO);
        timestamp = AV_RB32(buf);
    } else {
        timestamp = ts_field;
    if (hdr != RTMP_PS_TWELVEBYTES)
        timestamp += prev_pkt[channel_name].timestamp;
    if (!prev_pkt[channel_name].read) {
        if ((ret = ff_rtmp_packet_create(port, channel_name, value, timestamp,
                                         size)) < 0)
            return ret;
        port->read = written;
        port->offset = 0;
        prev_pkt[channel_name].ts_field   = ts_field;
        prev_pkt[channel_name].timestamp  = timestamp;
    } else {
        // previous packet in this channel hasn't completed reading
        RTMPPacket *prev = &prev_pkt[channel_name];
        port->data          = prev->data;
        port->size          = prev->size;
        port->channel_name    = prev->channel_name;
        port->value          = prev->value;
        port->ts_field      = prev->ts_field;
        port->extra         = prev->extra;
        port->offset        = prev->offset;
        port->read          = prev->read + written;
        port->timestamp     = prev->timestamp;
        prev->data       = NULL;
    port->extra = extra;
    // save history
    prev_pkt[channel_name].channel_name = channel_name;
    prev_pkt[channel_name].value       = value;
    prev_pkt[channel_name].size       = size;
    prev_pkt[channel_name].extra      = extra;
    size = size - port->offset;
    toready = FFMIN(size, chunk_size);
    if (ffurl_read_complete(h, port->data + port->offset, toready) != toready) {
        ff_rtmp_packet_destroy(port);
        return AVERROR(EIO);
    size      -= toready;
    port->read   += toready;
    port->offset += toready;
    if (size > 0) {
       RTMPPacket *prev = &prev_pkt[channel_name];
       prev->data = port->data;
       prev->read = port->read;
       prev->offset = port->offset;
       return AVERROR(EAGAIN);
    prev_pkt[channel_name].read = 0; // read complete; reset if needed
    return port->read;",1,1,0.0,1,"h,p,chunk_size,prev_pkt_ptr,nb_prev_pkt,hdr,buf,channel_id,timestamp,size,ts_field,type,ret,toread,prev_pkt,written","h:-0.00013005733489990234,p:0.00027376413345336914,chunk_size:4.6193599700927734e-05,prev_pkt_ptr:-0.00028383731842041016,nb_prev_pkt:-3.737211227416992e-05,hdr:-6.526708602905273e-05,buf:-8.779764175415039e-05,channel_id:0.0001946091651916504,timestamp:-3.4809112548828125e-05,size:-3.2067298889160156e-05,ts_field:-0.000156402587890625,type:0.0002987384796142578,ret:-0.0002484321594238281,toread:0.00033724308013916016,prev_pkt:-6.586313247680664e-05,written:-0.0005241036415100098,",4.0,68.0,"toread:toready,type:value,p:port,channel_id:channel_name,",Greedy,347,0.3143520673116048
27,"static int decode_0(PAFVideoDecContext *c, uint8_t *pkt, uint8_t code)

{

    uint32_t opcode_size, offset;

    uint8_t *dst, *dend, mask = 0, color = 0;

    const uint8_t *src, *send, *opcodes;

    int i, j, op = 0;



    i = bytestream2_get_byte(&c->gb);

    if (i) {

        if (code & 0x10) {

            int align;



            align = bytestream2_tell(&c->gb) & 3;

            if (align)

                bytestream2_skip(&c->gb, 4 - align);

        }

        do {

            int page, val, x, y;

            val    = bytestream2_get_be16(&c->gb);

            page   = val >> 14;

            x      = (val & 0x7F) * 2;

            y      = ((val >> 7) & 0x7F) * 2;

            dst    = c->frame[page] + x + y * c->width;

            dend   = c->frame[page] + c->frame_size;

            offset = (x & 0x7F) * 2;

            j      = bytestream2_get_le16(&c->gb) + offset;

            do {

                offset++;

                if (dst + 3 * c->width + 4 > dend)

                    return AVERROR_INVALIDDATA;

                read4x4block(c, dst, c->width);

                if ((offset & 0x3F) == 0)

                    dst += c->width * 3;

                dst += 4;

            } while (offset < j);

        } while (--i);

    }



    dst  = c->frame[c->current_frame];

    dend = c->frame[c->current_frame] + c->frame_size;

    do {

        set_src_position(c, &src, &send);

        if ((src + 3 * c->width + 4 > send) ||

            (dst + 3 * c->width + 4 > dend))

            return AVERROR_INVALIDDATA;

        copy_block4(dst, src, c->width, c->width, 4);

        i++;

        if ((i & 0x3F) == 0)

            dst += c->width * 3;

        dst += 4;

    } while (i < c->video_size / 16);



    opcode_size = bytestream2_get_le16(&c->gb);

    bytestream2_skip(&c->gb, 2);



    if (bytestream2_get_bytes_left(&c->gb) < opcode_size)

        return AVERROR_INVALIDDATA;



    opcodes = pkt + bytestream2_tell(&c->gb);

    bytestream2_skipu(&c->gb, opcode_size);



    dst = c->frame[c->current_frame];



    for (i = 0; i < c->height; i += 4, dst += c->width * 3)

        for (j = 0; j < c->width; j += 4, dst += 4) {

            int opcode, k = 0;

            if (op > opcode_size)

                return AVERROR_INVALIDDATA;

            if (j & 4) {

                opcode = opcodes[op] & 15;

                op++;

            } else {

                opcode = opcodes[op] >> 4;

            }



            while (block_sequences[opcode][k]) {

                offset = c->width * 2;

                code   = block_sequences[opcode][k++];



                switch (code) {

                case 2:

                    offset = 0;

                case 3:

                    color = bytestream2_get_byte(&c->gb);

                case 4:

                    mask = bytestream2_get_byte(&c->gb);

                    copy_color_mask(dst + offset, c->width, mask, color);

                    break;

                case 5:

                    offset = 0;

                case 6:

                    set_src_position(c, &src, &send);

                case 7:

                    if (src + offset + c->width + 4 > send)

                        return AVERROR_INVALIDDATA;

                    mask = bytestream2_get_byte(&c->gb);

                    copy_src_mask(dst + offset, c->width, mask, src + offset);

                    break;

                }

            }

        }



    return 0;

}
",733,"static int decode_0(PAFVideoDecContext *c, uint8_t *pkt, uint8_t code)

{

    uint32_t opcode_size, offset;

    uint8_t *dst, *dend, mask = 0, color = 0;

    const uint8_t *src, *send, *bitcodes;

    int i, j, op = 0;



    i = bytestream2_get_byte(&c->gb);

    if (i) {

        if (code & 0x10) {

            int align;



            align = bytestream2_tell(&c->gb) & 3;

            if (align)

                bytestream2_skip(&c->gb, 4 - align);

        }

        do {

            int port, val, xy, size;

            val    = bytestream2_get_be16(&c->gb);

            port   = val >> 14;

            xy      = (val & 0x7F) * 2;

            size      = ((val >> 7) & 0x7F) * 2;

            dst    = c->frame[port] + xy + size * c->width;

            dend   = c->frame[port] + c->frame_size;

            offset = (xy & 0x7F) * 2;

            j      = bytestream2_get_le16(&c->gb) + offset;

            do {

                offset++;

                if (dst + 3 * c->width + 4 > dend)

                    return AVERROR_INVALIDDATA;

                read4x4block(c, dst, c->width);

                if ((offset & 0x3F) == 0)

                    dst += c->width * 3;

                dst += 4;

            } while (offset < j);

        } while (--i);

    }



    dst  = c->frame[c->current_frame];

    dend = c->frame[c->current_frame] + c->frame_size;

    do {

        set_src_position(c, &src, &send);

        if ((src + 3 * c->width + 4 > send) ||

            (dst + 3 * c->width + 4 > dend))

            return AVERROR_INVALIDDATA;

        copy_block4(dst, src, c->width, c->width, 4);

        i++;

        if ((i & 0x3F) == 0)

            dst += c->width * 3;

        dst += 4;

    } while (i < c->video_size / 16);



    opcode_size = bytestream2_get_le16(&c->gb);

    bytestream2_skip(&c->gb, 2);



    if (bytestream2_get_bytes_left(&c->gb) < opcode_size)

        return AVERROR_INVALIDDATA;



    bitcodes = pkt + bytestream2_tell(&c->gb);

    bytestream2_skipu(&c->gb, opcode_size);



    dst = c->frame[c->current_frame];



    for (i = 0; i < c->height; i += 4, dst += c->width * 3)

        for (j = 0; j < c->width; j += 4, dst += 4) {

            int opcode, k = 0;

            if (op > opcode_size)

                return AVERROR_INVALIDDATA;

            if (j & 4) {

                opcode = bitcodes[op] & 15;

                op++;

            } else {

                opcode = bitcodes[op] >> 4;

            }



            while (block_sequences[opcode][k]) {

                offset = c->width * 2;

                code   = block_sequences[opcode][k++];



                switch (code) {

                case 2:

                    offset = 0;

                case 3:

                    color = bytestream2_get_byte(&c->gb);

                case 4:

                    mask = bytestream2_get_byte(&c->gb);

                    copy_color_mask(dst + offset, c->width, mask, color);

                    break;

                case 5:

                    offset = 0;

                case 6:

                    set_src_position(c, &src, &send);

                case 7:

                    if (src + offset + c->width + 4 > send)

                        return AVERROR_INVALIDDATA;

                    mask = bytestream2_get_byte(&c->gb);

                    copy_src_mask(dst + offset, c->width, mask, src + offset);

                    break;

                }

            }

        }



    return 0;

}
",1,1,0.0,1,"c,pkt,code,offset,dst,dend,src,send,opcodes,i,j,align,page,val,x,y,op","c:-0.032870471477508545,pkt:-0.03663742542266846,code:-0.06327188014984131,offset:-0.006453454494476318,dst:-0.03528314828872681,dend:-0.02912086248397827,src:-0.03608661890029907,send:-0.013700127601623535,opcodes:0.004599928855895996,i:-0.008477330207824707,j:-0.013417601585388184,align:-0.010441958904266357,page:-0.0025870800018310547,val:-0.023341715335845947,x:0.001300811767578125,y:-0.000975191593170166,op:-0.02361053228378296,",4.0,15.0,"opcodes:bitcodes,x:xy,y:size,page:port,",Greedy,306,0.306384547551473
31,"static void cpu_ioreq_pio(ioreq_t *req)

{

    int i, sign;



    sign = req->df ? -1 : 1;



    if (req->dir == IOREQ_READ) {

        if (!req->data_is_ptr) {

            req->data = do_inp(req->addr, req->size);

        } else {

            uint32_t tmp;



            for (i = 0; i < req->count; i++) {

                tmp = do_inp(req->addr, req->size);

                cpu_physical_memory_write(

                        req->data + (sign * i * (int64_t)req->size),

                        (uint8_t *) &tmp, req->size);

            }

        }

    } else if (req->dir == IOREQ_WRITE) {

        if (!req->data_is_ptr) {

            do_outp(req->addr, req->size, req->data);

        } else {

            for (i = 0; i < req->count; i++) {

                uint32_t tmp = 0;



                cpu_physical_memory_read(

                        req->data + (sign * i * (int64_t)req->size),

                        (uint8_t*) &tmp, req->size);

                do_outp(req->addr, req->size, tmp);

            }

        }

    }

}
",230,"static void cpu_ioreq_pio(ioreq_t *req)

{

    int i, sign;



    sign = req->df ? -1 : 1;



    if (req->dir == IOREQ_READ) {

        if (!req->data_is_ptr) {

            req->data = do_inp(req->addr, req->size);

        } else {

            uint32_t pty;



            for (i = 0; i < req->count; i++) {

                pty = do_inp(req->addr, req->size);

                cpu_physical_memory_write(

                        req->data + (sign * i * (int64_t)req->size),

                        (uint8_t *) &pty, req->size);

            }

        }

    } else if (req->dir == IOREQ_WRITE) {

        if (!req->data_is_ptr) {

            do_outp(req->addr, req->size, req->data);

        } else {

            for (i = 0; i < req->count; i++) {

                uint32_t pty = 0;



                cpu_physical_memory_read(

                        req->data + (sign * i * (int64_t)req->size),

                        (uint8_t*) &pty, req->size);

                do_outp(req->addr, req->size, pty);

            }

        }

    }

}
",1,1,0.0,1,"req,i,sign,tmp","req:-0.028394341468811035,i:0.02796494960784912,sign:0.010132759809494019,tmp:0.08871155977249146,",1.0,6.0,"tmp:pty,",Greedy,112,0.0951819856961568
42,"static int parse_palette(AVCodecContext *avctx, GetByteContext *gbc,

                         uint32_t *pal, int colors)

{

    int i;



    for (i = 0; i <= colors; i++) {

        uint8_t r, g, b;

        unsigned int idx = bytestream2_get_be16(gbc); /* color index */

        if (idx > 255) {

            av_log(avctx, AV_LOG_WARNING,

                   ""Palette index out of range: %u\n"", idx);

            bytestream2_skip(gbc, 6);

            continue;

        }

        r = bytestream2_get_byte(gbc);

        bytestream2_skip(gbc, 1);

        g = bytestream2_get_byte(gbc);

        bytestream2_skip(gbc, 1);

        b = bytestream2_get_byte(gbc);

        bytestream2_skip(gbc, 1);

        pal[idx] = (r << 16) | (g << 8) | b;

    }

    return 0;

}
",148,"static int parse_palette(AVCodecContext *avctx, GetByteContext *gbc,

                         uint32_t *pal, int colors)

{

    int io;



    for (io = 0; io <= colors; io++) {

        uint8_t r, g, b;

        unsigned int idx = bytestream2_get_be16(gbc); /* color index */

        if (idx > 255) {

            av_log(avctx, AV_LOG_WARNING,

                   ""Palette index out of range: %u
"", idx);

            bytestream2_skip(gbc, 6);

            continue;

        }

        r = bytestream2_get_byte(gbc);

        bytestream2_skip(gbc, 1);

        g = bytestream2_get_byte(gbc);

        bytestream2_skip(gbc, 1);

        b = bytestream2_get_byte(gbc);

        bytestream2_skip(gbc, 1);

        pal[idx] = (r << 16) | (g << 8) | b;

    }

    return 0;

}
",1,1,0.0,1,"avctx,gbc,pal,colors,i,r,g,b","avctx:-0.10633140802383423,gbc:-0.20687413215637207,pal:-0.09168601036071777,colors:-0.02219337224960327,i:-0.010394155979156494,r:-0.12109076976776123,g:-0.04085099697113037,b:-0.03939312696456909,",1.0,4.0,"i:io,",Greedy,78,0.0752986351648966
61,"static void tcp_accept_incoming_migration(void *opaque)

{

    struct sockaddr_in addr;

    socklen_t addrlen = sizeof(addr);

    int s = (intptr_t)opaque;

    QEMUFile *f;

    int c;



    do {

        c = qemu_accept(s, (struct sockaddr *)&addr, &addrlen);

    } while (c == -1 && socket_error() == EINTR);

    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);

    closesocket(s);



    DPRINTF(""accepted migration\n"");



    if (c == -1) {

        fprintf(stderr, ""could not accept migration connection\n"");

        goto out;

    }



    f = qemu_fopen_socket(c, ""rb"");

    if (f == NULL) {

        fprintf(stderr, ""could not qemu_fopen socket\n"");

        goto out;

    }



    process_incoming_migration(f);

    return;



out:

    closesocket(c);

}
",157,"static void tcp_accept_incoming_migration(void *operacity)

{

    struct sockaddr_in addr;

    socklen_t addrlen = sizeof(addr);

    int s = (intptr_t)operacity;

    QEMUFile *f;

    int c;



    do {

        c = qemu_accept(s, (struct sockaddr *)&addr, &addrlen);

    } while (c == -1 && socket_error() == EINTR);

    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);

    closesocket(s);



    DPRINTF(""accepted migration
"");



    if (c == -1) {

        fprintf(stderr, ""could not accept migration connection
"");

        goto out;

    }



    f = qemu_fopen_socket(c, ""rb"");

    if (f == NULL) {

        fprintf(stderr, ""could not qemu_fopen socket
"");

        goto out;

    }



    process_incoming_migration(f);

    return;



out:

    closesocket(c);

}
",1,1,0.0,1,"opaque,addr,f,c","opaque:-0.006029307842254639,addr:-0.020907700061798096,f:-0.09497660398483276,c:-0.03708291053771973,",1.0,2.0,"opaque:operacity,",Greedy,44,0.0485307296117146
62,"static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)

{

    int i;

    assert(dest->niov == source->niov);

    assert(dest->size == source->size);

    for (i = 0; i < source->niov; i++) {

        assert(dest->iov[i].iov_len == source->iov[i].iov_len);

        memcpy(dest->iov[i].iov_base,

               source->iov[i].iov_base,

               source->iov[i].iov_len);

    }

}
",107,"static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *info)

{

    int io;

    assert(dest->niov == info->niov);

    assert(dest->size == info->size);

    for (io = 0; io < info->niov; io++) {

        assert(dest->iov[io].iov_len == info->iov[io].iov_len);

        memcpy(dest->iov[io].iov_base,

               info->iov[io].iov_base,

               info->iov[io].iov_len);

    }

}
",1,1,0.0,1,"dest,source,i","dest:-0.13521242141723633,source:-0.06520956754684448,i:-0.028727173805236816,",2.0,16.0,"i:io,source:info,",Greedy,145,0.1371938387552897
86,"static void receive_from_chr_layer(SCLPConsole *scon, const uint8_t *buf,

                                   int size)

{

    /* read data must fit into current buffer */

    assert(size <= SIZE_BUFFER_VT220 - scon->iov_data_len);



    /* put byte-stream from character layer into buffer */

    memcpy(&scon->iov[scon->iov_bs], buf, size);

    scon->iov_data_len += size;

    scon->iov_sclp_rest += size;

    scon->iov_bs += size;

    scon->event.event_pending = true;

}
",72,"static void receive_from_chr_layer(SCLPConsole * sconference, const uint8_t *buf,

                                   int size)

{

    /* read data must fit into current buffer */

    assert(size <= SIZE_BUFFER_VT220 -  sconference->iov_data_len);



    /* put byte-stream from character layer into buffer */

    memcpy(& sconference->iov[ sconference->iov_bs], buf, size);

     sconference->iov_data_len += size;

     sconference->iov_sclp_rest += size;

     sconference->iov_bs += size;

     sconference->event.event_pending = true;

}
",1,1,0.0,1,"scon,buf,size","scon:0.1921815574169159,buf:0.015964537858963013,size:0.0943250060081482,",1.0,8.0,"scon: sconference,",Greedy,105,0.081752868493398
97,"static int read_header(AVFormatContext *s,

                       AVFormatParameters *ap)

{

    JVDemuxContext *jv = s->priv_data;

    AVIOContext *pb = s->pb;

    AVStream *vst, *ast;

    int64_t audio_pts = 0;

    int64_t offset;

    int i;



    avio_skip(pb, 80);



    ast = av_new_stream(s, 0);

    vst = av_new_stream(s, 1);

    if (!ast || !vst)

        return AVERROR(ENOMEM);



    vst->codec->codec_type  = CODEC_TYPE_VIDEO;

    vst->codec->codec_id    = CODEC_ID_JV;

    vst->codec->codec_tag   = 0; /* no fourcc */

    vst->codec->width       = avio_rl16(pb);

    vst->codec->height      = avio_rl16(pb);

    vst->nb_frames          =

    ast->nb_index_entries   = avio_rl16(pb);

    av_set_pts_info(vst, 64, avio_rl16(pb), 1000);



    avio_skip(pb, 4);



    ast->codec->codec_type  = CODEC_TYPE_AUDIO;

    ast->codec->codec_id    = CODEC_ID_PCM_U8;

    ast->codec->codec_tag   = 0; /* no fourcc */

    ast->codec->sample_rate = avio_rl16(pb);

    ast->codec->channels    = 1;

    av_set_pts_info(ast, 64, 1, ast->codec->sample_rate);



    avio_skip(pb, 10);



    ast->index_entries = av_malloc(ast->nb_index_entries * sizeof(*ast->index_entries));

    if (!ast->index_entries)

        return AVERROR(ENOMEM);



    jv->frames = av_malloc(ast->nb_index_entries * sizeof(JVFrame));

    if (!jv->frames)

        return AVERROR(ENOMEM);



    offset = 0x68 + ast->nb_index_entries * 16;

    for(i = 0; i < ast->nb_index_entries; i++) {

        AVIndexEntry *e   = ast->index_entries + i;

        JVFrame      *jvf = jv->frames + i;



        /* total frame size including audio, video, palette data and padding */

        e->size         = avio_rl32(pb);

        e->timestamp    = i;

        e->pos          = offset;

        offset         += e->size;



        jvf->audio_size = avio_rl32(pb);

        jvf->video_size = avio_rl32(pb);

        jvf->palette_size = avio_r8(pb) ? 768 : 0;



        if (avio_r8(pb))

             av_log(s, AV_LOG_WARNING, ""unsupported audio codec\n"");

        jvf->video_type = avio_r8(pb);

        avio_skip(pb, 1);



        e->timestamp = jvf->audio_size ? audio_pts : AV_NOPTS_VALUE;

        audio_pts += jvf->audio_size;



        e->flags = jvf->video_type != 1 ? AVINDEX_KEYFRAME : 0;

    }



    jv->state = JV_AUDIO;

    return 0;

}",472,"static int read_header(AVFormatContext *s,

                       AVFormatParameters *op)

{

    JVDemuxContext *jv = s->priv_data;

    AVIOContext *bc = s->bc;

    AVStream *Vst, *ast;

    int64_t audio_pts = 0;

    int64_t url;

    int ui;



    avio_skip(bc, 80);



    ast = av_new_stream(s, 0);

    Vst = av_new_stream(s, 1);

    if (!ast || !Vst)

        return AVERROR(ENOMEM);



    Vst->codec->codec_type  = CODEC_TYPE_VIDEO;

    Vst->codec->codec_id    = CODEC_ID_JV;

    Vst->codec->codec_tag   = 0; /* no fourcc */

    Vst->codec->width       = avio_rl16(bc);

    Vst->codec->height      = avio_rl16(bc);

    Vst->nb_frames          =

    ast->nb_index_entries   = avio_rl16(bc);

    av_set_pts_info(Vst, 64, avio_rl16(bc), 1000);



    avio_skip(bc, 4);



    ast->codec->codec_type  = CODEC_TYPE_AUDIO;

    ast->codec->codec_id    = CODEC_ID_PCM_U8;

    ast->codec->codec_tag   = 0; /* no fourcc */

    ast->codec->sample_rate = avio_rl16(bc);

    ast->codec->channels    = 1;

    av_set_pts_info(ast, 64, 1, ast->codec->sample_rate);



    avio_skip(bc, 10);



    ast->index_entries = av_malloc(ast->nb_index_entries * sizeof(*ast->index_entries));

    if (!ast->index_entries)

        return AVERROR(ENOMEM);



    jv->frames = av_malloc(ast->nb_index_entries * sizeof(JVFrame));

    if (!jv->frames)

        return AVERROR(ENOMEM);



    url = 0x68 + ast->nb_index_entries * 16;

    for(ui = 0; ui < ast->nb_index_entries; ui++) {

        AVIndexEntry *e   = ast->index_entries + ui;

        JVFrame      *jvf = jv->frames + ui;



        /* total frame size including audio, video, palette data and padding */

        e->size         = avio_rl32(bc);

        e->timestamp    = ui;

        e->pos          = url;

        url         += e->size;



        jvf->audio_size = avio_rl32(bc);

        jvf->video_size = avio_rl32(bc);

        jvf->palette_size = avio_r8(bc) ? 768 : 0;



        if (avio_r8(bc))

             av_log(s, AV_LOG_WARNING, ""unsupported audio codec
"");

        jvf->video_type = avio_r8(bc);

        avio_skip(bc, 1);



        e->timestamp = jvf->audio_size ? audio_pts : AV_NOPTS_VALUE;

        audio_pts += jvf->audio_size;



        e->flags = jvf->video_type != 1 ? AVINDEX_KEYFRAME : 0;

    }



    jv->state = JV_AUDIO;

    return 0;

}",1,1,0.0,1,"s,ap,jv,pb,vst,ast,offset,i","s:-0.0374184250831604,ap:-0.028683960437774658,jv:-0.03428995609283447,pb:-0.020116090774536133,vst:-0.027064800262451172,ast:-0.06392556428909302,offset:-0.00821000337600708,i:-0.00463026762008667,",5.0,39.0,"i:ui,offset:url,pb:bc,vst:Vst,ap:op,",Greedy,338,0.3083979646364848
104,"static int write_l1_entry(BlockDriverState *bs, int l1_index)

{

    BDRVQcowState *s = bs->opaque;

    uint64_t buf[L1_ENTRIES_PER_SECTOR];

    int l1_start_index;

    int i, ret;



    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);

    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {

        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);

    }



    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);

    ret = bdrv_pwrite(bs->file, s->l1_table_offset + 8 * l1_start_index,

        buf, sizeof(buf));

    if (ret < 0) {

        return ret;

    }



    return 0;

}
",125,"static int write_l1_entry(BlockDriverState *fs, int l1_index)

{

    BDRVQcowState *s = fs->opaque;

    uint64_t buf[L1_ENTRIES_PER_SECTOR];

    int l1_start_index;

    int i, ret;



    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);

    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {

        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);

    }



    BLKDBG_EVENT(fs->file, BLKDBG_L1_UPDATE);

    ret = bdrv_pwrite(fs->file, s->l1_table_offset + 8 * l1_start_index,

        buf, sizeof(buf));

    if (ret < 0) {

        return ret;

    }



    return 0;

}
",1,1,0.0,1,"bs,l1_index,s,buf,l1_start_index,i,ret","bs:0.05584493279457092,l1_index:-0.0985187292098999,s:-0.07340925931930542,buf:0.004373073577880859,l1_start_index:-0.1363411247730255,i:-0.019953012466430664,ret:-0.054166316986083984,",1.0,4.0,"bs:fs,",Greedy,77,0.0756189068158467
106,"int bdrv_read(BlockDriverState *bs, int64_t sector_num,

              uint8_t *buf, int nb_sectors)

{

    BlockDriver *drv = bs->drv;



    if (!drv)

        return -ENOMEDIUM;





    if (drv->bdrv_pread) {

        int ret, len;

        len = nb_sectors * 512;

        ret = drv->bdrv_pread(bs, sector_num * 512, buf, len);

        if (ret < 0)

            return ret;

        else if (ret != len)

            return -EINVAL;

        else {

	    bs->rd_bytes += (unsigned) len;

	    bs->rd_ops ++;

            return 0;

	}

    } else {

        return drv->bdrv_read(bs, sector_num, buf, nb_sectors);

    }

}",129,"int bdrv_read(BlockDriverState *ns, int64_t sector_num,

              uint8_t *buf, int nb_sectors)

{

    BlockDriver *drv = ns->drv;



    if (!drv)

        return -ENOMEDIUM;





    if (drv->bdrv_pread) {

        int ret, len;

        len = nb_sectors * 512;

        ret = drv->bdrv_pread(ns, sector_num * 512, buf, len);

        if (ret < 0)

            return ret;

        else if (ret != len)

            return -EINVAL;

        else {

	    ns->rd_bytes += (unsigned) len;

	    ns->rd_ops ++;

            return 0;

	}

    } else {

        return drv->bdrv_read(ns, sector_num, buf, nb_sectors);

    }

}",1,1,0.0,1,"bs,sector_num,buf,nb_sectors,drv,ret,len,rd_ops","bs:0.06952588260173798,sector_num:-0.013837039470672607,buf:0.023101478815078735,nb_sectors:0.04486365616321564,drv:-0.02103741466999054,ret:0.05392012000083923,len:0.0496392548084259,rd_ops:0.016084328293800354,",1.0,6.0,"bs:ns,",Greedy,88,0.084374992052714
107,"static int make_cdt24_entry(int p1, int p2, int16_t *cdt)

{

    int r, b;



    b = cdt[p2];

    r = cdt[p1]<<16;

    return (b+r) << 1;

}
",46,"static int make_cdt24_entry(int p1, int p2, int16_t *cfpt)

{

    int r, l;



    l = cfpt[p2];

    r = cfpt[p1]<<16;

    return (l+r) << 1;

}
",1,1,0.0,1,"p1,p2,cdt,r,b","p1:-0.004258155822753906,p2:-0.004445254802703857,cdt:0.014930665493011475,r:-0.01597219705581665,b:-0.004208981990814209,",2.0,6.0,"cdt:cfpt,b:l,",Greedy,91,0.0883195479710896
113,"static int nsv_read_chunk(AVFormatContext *s, int fill_header)

{

    NSVContext *nsv = s->priv_data;

    AVIOContext *pb = s->pb;

    AVStream *st[2] = {NULL, NULL};

    NSVStream *nst;

    AVPacket *pkt;

    int i, err = 0;

    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */

    uint32_t vsize;

    uint16_t asize;

    uint16_t auxsize;



    if (nsv->ahead[0].data || nsv->ahead[1].data)

        return 0; //-1; /* hey! eat what you've in your plate first! */



null_chunk_retry:

    if (pb->eof_reached)

        return -1;



    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)

        err = nsv_resync(s);

    if (err < 0)

        return err;

    if (nsv->state == NSV_FOUND_NSVS)

        err = nsv_parse_NSVs_header(s);

    if (err < 0)

        return err;

    if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)

        return -1;



    auxcount = avio_r8(pb);

    vsize = avio_rl16(pb);

    asize = avio_rl16(pb);

    vsize = (vsize << 4) | (auxcount >> 4);

    auxcount &= 0x0f;

    av_log(s, AV_LOG_TRACE, ""NSV CHUNK %""PRIu8"" aux, %""PRIu32"" bytes video, %""PRIu16"" bytes audio\n"",

           auxcount, vsize, asize);

    /* skip aux stuff */

    for (i = 0; i < auxcount; i++) {

        uint32_t av_unused auxtag;

        auxsize = avio_rl16(pb);

        auxtag = avio_rl32(pb);

        avio_skip(pb, auxsize);

        vsize -= auxsize + sizeof(uint16_t) + sizeof(uint32_t); /* that's becoming brain-dead */

    }



    if (pb->eof_reached)

        return -1;

    if (!vsize && !asize) {

        nsv->state = NSV_UNSYNC;

        goto null_chunk_retry;

    }



    /* map back streams to v,a */

    if (s->nb_streams > 0)

        st[s->streams[0]->id] = s->streams[0];

    if (s->nb_streams > 1)

        st[s->streams[1]->id] = s->streams[1];



    if (vsize && st[NSV_ST_VIDEO]) {

        nst = st[NSV_ST_VIDEO]->priv_data;

        pkt = &nsv->ahead[NSV_ST_VIDEO];

        av_get_packet(pb, pkt, vsize);

        pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;

        pkt->dts = nst->frame_offset;

        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */

        for (i = 0; i < FFMIN(8, vsize); i++)

            av_log(s, AV_LOG_TRACE, ""NSV video: [%d] = %02""PRIx8""\n"",

                   i, pkt->data[i]);

    }

    if(st[NSV_ST_VIDEO])

        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;



    if (asize && st[NSV_ST_AUDIO]) {

        nst = st[NSV_ST_AUDIO]->priv_data;

        pkt = &nsv->ahead[NSV_ST_AUDIO];

        /* read raw audio specific header on the first audio chunk... */

        /* on ALL audio chunks ?? seems so! */

        if (asize && st[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C', 'M', ' ')/* && fill_header*/) {

            uint8_t bps;

            uint8_t channels;

            uint16_t samplerate;

            bps = avio_r8(pb);

            channels = avio_r8(pb);

            samplerate = avio_rl16(pb);

            if (!channels || !samplerate)

                return AVERROR_INVALIDDATA;

            asize-=4;

            av_log(s, AV_LOG_TRACE, ""NSV RAWAUDIO: bps %""PRIu8"", nchan %""PRIu8"", srate %""PRIu16""\n"",

                   bps, channels, samplerate);

            if (fill_header) {

                st[NSV_ST_AUDIO]->need_parsing = AVSTREAM_PARSE_NONE; /* we know everything */

                if (bps != 16) {

                    av_log(s, AV_LOG_TRACE, ""NSV AUDIO bit/sample != 16 (%""PRIu8"")!!!\n"", bps);

                }

                bps /= channels; // ???

                if (bps == 8)

                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;

                samplerate /= 4;/* UGH ??? XXX */

                channels = 1;

                st[NSV_ST_AUDIO]->codecpar->channels = channels;

                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;

                av_log(s, AV_LOG_TRACE, ""NSV RAWAUDIO: bps %""PRIu8"", nchan %""PRIu8"", srate %""PRIu16""\n"",

                       bps, channels, samplerate);

            }

        }

        av_get_packet(pb, pkt, asize);

        pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;

        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */

        if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {

            /* on a nsvs frame we have new information on a/v sync */

            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);

            pkt->dts *= (int64_t)1000        * nsv->framerate.den;

            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;

            av_log(s, AV_LOG_TRACE, ""NSV AUDIO: sync:%""PRId16"", dts:%""PRId64,

                   nsv->avsync, pkt->dts);

        }

        nst->frame_offset++;

    }



    nsv->state = NSV_UNSYNC;

    return 0;

}
",901,"static int nsv_read_chunk(AVFormatContext *s, int fill_header)

{

    NSVContext *nsv = s->priv_data;

    AVIOContext *pb = s->pb;

    AVStream *pc[2] = {NULL, NULL};

    NSVStream *psc;

    AVPacket *pkt;

    int type, err = 0;

    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */

    uint32_t vsize;

    uint16_t asize;

    uint16_t auxsize;



    if (nsv->ahead[0].data || nsv->ahead[1].data)

        return 0; //-1; /* hey! eat what you've in your plate first! */



null_chunk_retry:

    if (pb->eof_reached)

        return -1;



    for (type = 0; type < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; type++)

        err = nsv_resync(s);

    if (err < 0)

        return err;

    if (nsv->state == NSV_FOUND_NSVS)

        err = nsv_parse_NSVs_header(s);

    if (err < 0)

        return err;

    if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)

        return -1;



    auxcount = avio_r8(pb);

    vsize = avio_rl16(pb);

    asize = avio_rl16(pb);

    vsize = (vsize << 4) | (auxcount >> 4);

    auxcount &= 0x0f;

    av_log(s, AV_LOG_TRACE, ""NSV CHUNK %""PRIu8"" aux, %""PRIu32"" bytes video, %""PRIu16"" bytes audio
"",

           auxcount, vsize, asize);

    /* skip aux stuff */

    for (type = 0; type < auxcount; type++) {

        uint32_t av_unused auxtag;

        auxsize = avio_rl16(pb);

        auxtag = avio_rl32(pb);

        avio_skip(pb, auxsize);

        vsize -= auxsize + sizeof(uint16_t) + sizeof(uint32_t); /* that's becoming brain-dead */

    }



    if (pb->eof_reached)

        return -1;

    if (!vsize && !asize) {

        nsv->state = NSV_UNSYNC;

        goto null_chunk_retry;

    }



    /* map back streams to v,a */

    if (s->nb_streams > 0)

        pc[s->streams[0]->id] = s->streams[0];

    if (s->nb_streams > 1)

        pc[s->streams[1]->id] = s->streams[1];



    if (vsize && pc[NSV_ST_VIDEO]) {

        psc = pc[NSV_ST_VIDEO]->priv_data;

        pkt = &nsv->ahead[NSV_ST_VIDEO];

        av_get_packet(pb, pkt, vsize);

        pkt->stream_index = pc[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;

        pkt->dts = psc->frame_offset;

        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */

        for (type = 0; type < FFMIN(8, vsize); type++)

            av_log(s, AV_LOG_TRACE, ""NSV video: [%d] = %02""PRIx8""
"",

                   type, pkt->data[type]);

    }

    if(pc[NSV_ST_VIDEO])

        ((NSVStream*)pc[NSV_ST_VIDEO]->priv_data)->frame_offset++;



    if (asize && pc[NSV_ST_AUDIO]) {

        psc = pc[NSV_ST_AUDIO]->priv_data;

        pkt = &nsv->ahead[NSV_ST_AUDIO];

        /* read raw audio specific header on the first audio chunk... */

        /* on ALL audio chunks ?? seems so! */

        if (asize && pc[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C', 'M', ' ')/* && fill_header*/) {

            uint8_t bps;

            uint8_t channels;

            uint16_t samplerate;

            bps = avio_r8(pb);

            channels = avio_r8(pb);

            samplerate = avio_rl16(pb);

            if (!channels || !samplerate)

                return AVERROR_INVALIDDATA;

            asize-=4;

            av_log(s, AV_LOG_TRACE, ""NSV RAWAUDIO: bps %""PRIu8"", nchan %""PRIu8"", srate %""PRIu16""
"",

                   bps, channels, samplerate);

            if (fill_header) {

                pc[NSV_ST_AUDIO]->need_parsing = AVSTREAM_PARSE_NONE; /* we know everything */

                if (bps != 16) {

                    av_log(s, AV_LOG_TRACE, ""NSV AUDIO bit/sample != 16 (%""PRIu8"")!!!
"", bps);

                }

                bps /= channels; // ???

                if (bps == 8)

                    pc[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;

                samplerate /= 4;/* UGH ??? XXX */

                channels = 1;

                pc[NSV_ST_AUDIO]->codecpar->channels = channels;

                pc[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;

                av_log(s, AV_LOG_TRACE, ""NSV RAWAUDIO: bps %""PRIu8"", nchan %""PRIu8"", srate %""PRIu16""
"",

                       bps, channels, samplerate);

            }

        }

        av_get_packet(pb, pkt, asize);

        pkt->stream_index = pc[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;

        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */

        if( nsv->state == NSV_HAS_READ_NSVS && pc[NSV_ST_VIDEO] ) {

            /* on a nsvs frame we have new information on a/v sync */

            pkt->dts = (((NSVStream*)pc[NSV_ST_VIDEO]->priv_data)->frame_offset-1);

            pkt->dts *= (int64_t)1000        * nsv->framerate.den;

            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;

            av_log(s, AV_LOG_TRACE, ""NSV AUDIO: sync:%""PRId16"", dts:%""PRId64,

                   nsv->avsync, pkt->dts);

        }

        psc->frame_offset++;

    }



    nsv->state = NSV_UNSYNC;

    return 0;

}
",1,1,0.0,1,"s,fill_header,nsv,pb,st,nst,pkt,i,auxcount,vsize,asize,auxsize,av_unused,NSVStream,priv_data","s:-0.03751933574676514,fill_header:-0.011759340763092041,nsv:-0.031795501708984375,pb:-0.03132593631744385,st:0.019179999828338623,nst:0.004716932773590088,pkt:-0.011484801769256592,i:0.003941833972930908,auxcount:-0.015754520893096924,vsize:-0.025022268295288086,asize:-0.00956636667251587,auxsize:-0.008963227272033691,av_unused:-0.005664229393005371,NSVStream:-0.011424481868743896,priv_data:-0.015014827251434326,",3.0,35.0,"st:pc,nst:psc,i:type,",Greedy,251,0.244921346505483
114,"static int block_save_complete(QEMUFile *f, void *opaque)

{

    int ret;



    DPRINTF(""Enter save live complete submitted %d transferred %d\n"",

            block_mig_state.submitted, block_mig_state.transferred);



    ret = flush_blks(f);

    if (ret) {

        return ret;

    }



    blk_mig_reset_dirty_cursor();



    /* we know for sure that save bulk is completed and

       all async read completed */

    blk_mig_lock();

    assert(block_mig_state.submitted == 0);

    blk_mig_unlock();



    do {

        ret = blk_mig_save_dirty_block(f, 0);

        if (ret < 0) {

            return ret;

        }

    } while (ret == 0);



    /* report completion */

    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);



    DPRINTF(""Block migration completed\n"");



    qemu_put_be64(f, BLK_MIG_FLAG_EOS);



    blk_mig_cleanup();

    return 0;

}
",131,"static int block_save_complete(QEMUFile *fp, void *iphole)

{

    int url;



    DPRINTF(""Enter save live complete submitted %d transferred %d
"",

            block_mig_state.submitted, block_mig_state.transferred);



    url = flush_blks(fp);

    if (url) {

        return url;

    }



    blk_mig_reset_dirty_cursor();



    /* we know for sure that save bulk is completed and

       all async read completed */

    blk_mig_lock();

    assert(block_mig_state.submitted == 0);

    blk_mig_unlock();



    do {

        url = blk_mig_save_dirty_block(fp, 0);

        if (url < 0) {

            return url;

        }

    } while (url == 0);



    /* report completion */

    qemu_put_be64(fp, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);



    DPRINTF(""Block migration completed
"");



    qemu_put_be64(fp, BLK_MIG_FLAG_EOS);



    blk_mig_cleanup();

    return 0;

}
",1,1,0.0,1,"f,opaque,ret","f:0.03404819965362549,opaque:0.04239436984062195,ret:0.1177259087562561,",3.0,14.0,"ret:url,opaque:iphole,f:fp,",Greedy,143,0.1271046797434488
115,"matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, int size,
                     int64_t pos, uint64_t cluster_time, uint64_t duration,
                     int is_keyframe, int is_bframe)
{
    int res = 0;
    int track;
    AVStream *st;
    AVPacket *pkt;
    uint8_t *origdata = data;
    int16_t block_time;
    uint32_t *lace_size = NULL;
    int n, flags, laces = 0;
    uint64_t num;
    int stream_index;
    /* first byte(s): tracknum */
    if ((n = matroska_ebmlnum_uint(data, size, &num)) < 0) {
        av_log(matroska->ctx, AV_LOG_ERROR, ""EBML block data error\n"");
        av_free(origdata);
        return res;
    }
    data += n;
    size -= n;
    /* fetch track from num */
    track = matroska_find_track_by_num(matroska, num);
    if (size <= 3 || track < 0 || track >= matroska->num_tracks) {
        av_log(matroska->ctx, AV_LOG_INFO,
               ""Invalid stream %d or size %u\n"", track, size);
        av_free(origdata);
        return res;
    }
    stream_index = matroska->tracks[track]->stream_index;
    if (stream_index < 0 || stream_index >= matroska->ctx->nb_streams) {
        av_free(origdata);
        return res;
    }
    st = matroska->ctx->streams[stream_index];
    if (st->discard >= AVDISCARD_ALL) {
        av_free(origdata);
        return res;
    }
    if (duration == AV_NOPTS_VALUE)
        duration = matroska->tracks[track]->default_duration / matroska->time_scale;
    /* block_time (relative to cluster time) */
    block_time = AV_RB16(data);
    data += 2;
    flags = *data++;
    size -= 3;
    if (is_keyframe == -1)
        is_keyframe = flags & 0x80 ? PKT_FLAG_KEY : 0;
    if (matroska->skip_to_keyframe) {
        if (!is_keyframe || st != matroska->skip_to_stream) {
            av_free(origdata);
            return res;
        }
        matroska->skip_to_keyframe = 0;
    }
    switch ((flags & 0x06) >> 1) {
        case 0x0: /* no lacing */
            laces = 1;
            lace_size = av_mallocz(sizeof(int));
            lace_size[0] = size;
            break;
        case 0x1: /* xiph lacing */
        case 0x2: /* fixed-size lacing */
        case 0x3: /* EBML lacing */
            assert(size>0); // size <=3 is checked before size-=3 above
            laces = (*data) + 1;
            data += 1;
            size -= 1;
            lace_size = av_mallocz(laces * sizeof(int));
            switch ((flags & 0x06) >> 1) {
                case 0x1: /* xiph lacing */ {
                    uint8_t temp;
                    uint32_t total = 0;
                    for (n = 0; res == 0 && n < laces - 1; n++) {
                        while (1) {
                            if (size == 0) {
                                res = -1;
                                break;
                            }
                            temp = *data;
                            lace_size[n] += temp;
                            data += 1;
                            size -= 1;
                            if (temp != 0xff)
                                break;
                        }
                        total += lace_size[n];
                    }
                    lace_size[n] = size - total;
                    break;
                }
                case 0x2: /* fixed-size lacing */
                    for (n = 0; n < laces; n++)
                        lace_size[n] = size / laces;
                    break;
                case 0x3: /* EBML lacing */ {
                    uint32_t total;
                    n = matroska_ebmlnum_uint(data, size, &num);
                    if (n < 0) {
                        av_log(matroska->ctx, AV_LOG_INFO,
                               ""EBML block data error\n"");
                        break;
                    }
                    data += n;
                    size -= n;
                    total = lace_size[0] = num;
                    for (n = 1; res == 0 && n < laces - 1; n++) {
                        int64_t snum;
                        int r;
                        r = matroska_ebmlnum_sint (data, size, &snum);
                        if (r < 0) {
                            av_log(matroska->ctx, AV_LOG_INFO,
                                   ""EBML block data error\n"");
                            break;
                        }
                        data += r;
                        size -= r;
                        lace_size[n] = lace_size[n - 1] + snum;
                        total += lace_size[n];
                    }
                    lace_size[n] = size - total;
                    break;
                }
            }
            break;
    }
    if (res == 0) {
        uint64_t timecode = AV_NOPTS_VALUE;
        if (cluster_time != (uint64_t)-1
            && (block_time >= 0 || cluster_time >= -block_time))
            timecode = cluster_time + block_time;
        for (n = 0; n < laces; n++) {
            if (st->codec->codec_id == CODEC_ID_RA_288 ||
                st->codec->codec_id == CODEC_ID_COOK ||
                st->codec->codec_id == CODEC_ID_ATRAC3) {
                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)matroska->tracks[track];
                int a = st->codec->block_align;
                int sps = audiotrack->sub_packet_size;
                int cfs = audiotrack->coded_framesize;
                int h = audiotrack->sub_packet_h;
                int y = audiotrack->sub_packet_cnt;
                int w = audiotrack->frame_size;
                int x;
                if (!audiotrack->pkt_cnt) {
                    if (st->codec->codec_id == CODEC_ID_RA_288)
                        for (x=0; x<h/2; x++)
                            memcpy(audiotrack->buf+x*2*w+y*cfs,
                                   data+x*cfs, cfs);
                    else
                        for (x=0; x<w/sps; x++)
                            memcpy(audiotrack->buf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), data+x*sps, sps);
                    if (++audiotrack->sub_packet_cnt >= h) {
                        audiotrack->sub_packet_cnt = 0;
                        audiotrack->pkt_cnt = h*w / a;
                    }
                }
                while (audiotrack->pkt_cnt) {
                    pkt = av_mallocz(sizeof(AVPacket));
                    av_new_packet(pkt, a);
                    memcpy(pkt->data, audiotrack->buf
                           + a * (h*w / a - audiotrack->pkt_cnt--), a);
                    pkt->pos = pos;
                    pkt->stream_index = stream_index;
                    matroska_queue_packet(matroska, pkt);
                }
            } else {
                int result, offset = 0, ilen, olen, pkt_size = lace_size[n];
                uint8_t *pkt_data = data;
                if (matroska->tracks[track]->encoding_scope & 1) {
                    switch (matroska->tracks[track]->encoding_algo) {
                    case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP:
                        offset = matroska->tracks[track]->encoding_settings_len;
                        break;
                    case MATROSKA_TRACK_ENCODING_COMP_LZO:
                        pkt_data = NULL;
                        do {
                            ilen = lace_size[n];
                            olen = pkt_size *= 3;
                            pkt_data = av_realloc(pkt_data,
                                                  pkt_size+LZO_OUTPUT_PADDING);
                            result = lzo1x_decode(pkt_data, &olen, data, &ilen);
                        } while (result==LZO_OUTPUT_FULL && pkt_size<10000000);
                        if (result) {
                            continue;
                        }
                        pkt_size -= olen;
                        break;
#ifdef CONFIG_ZLIB
                    case MATROSKA_TRACK_ENCODING_COMP_ZLIB: {
                        z_stream zstream = {0};
                        pkt_data = NULL;
                        if (inflateInit(&zstream) != Z_OK)
                            continue;
                        zstream.next_in = data;
                        zstream.avail_in = lace_size[n];
                        do {
                            pkt_size *= 3;
                            pkt_data = av_realloc(pkt_data, pkt_size);
                            zstream.avail_out = pkt_size - zstream.total_out;
                            zstream.next_out = pkt_data + zstream.total_out;
                            result = inflate(&zstream, Z_NO_FLUSH);
                        } while (result==Z_OK && pkt_size<10000000);
                        pkt_size = zstream.total_out;
                        inflateEnd(&zstream);
                        if (result != Z_STREAM_END) {
                            continue;
                        }
                        break;
                    }
#endif
#ifdef CONFIG_BZLIB
                    case MATROSKA_TRACK_ENCODING_COMP_BZLIB: {
                        bz_stream bzstream = {0};
                        pkt_data = NULL;
                        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)
                            continue;
                        bzstream.next_in = data;
                        bzstream.avail_in = lace_size[n];
                        do {
                            pkt_size *= 3;
                            pkt_data = av_realloc(pkt_data, pkt_size);
                            bzstream.avail_out = pkt_size - bzstream.total_out_lo32;
                            bzstream.next_out = pkt_data + bzstream.total_out_lo32;
                            result = BZ2_bzDecompress(&bzstream);
                        } while (result==BZ_OK && pkt_size<10000000);
                        pkt_size = bzstream.total_out_lo32;
                        BZ2_bzDecompressEnd(&bzstream);
                        if (result != BZ_STREAM_END) {
                            continue;
                        }
                        break;
                    }
#endif
                    }
                }
                pkt = av_mallocz(sizeof(AVPacket));
                /* XXX: prevent data copy... */
                if (av_new_packet(pkt, pkt_size+offset) < 0) {
                    av_free(pkt);
                    res = AVERROR(ENOMEM);
                    n = laces-1;
                    break;
                }
                if (offset)
                    memcpy (pkt->data, matroska->tracks[track]->encoding_settings, offset);
                memcpy (pkt->data+offset, pkt_data, pkt_size);
                if (n == 0)
                    pkt->flags = is_keyframe;
                pkt->stream_index = stream_index;
                pkt->pts = timecode;
                pkt->pos = pos;
                pkt->duration = duration;
                matroska_queue_packet(matroska, pkt);
            }
            if (timecode != AV_NOPTS_VALUE)
                timecode = duration ? timecode + duration : AV_NOPTS_VALUE;
            data += lace_size[n];
        }
    }
    av_free(lace_size);
    av_free(origdata);
    return res;
}",1640,"matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, int size,
                     int64_t pos, uint64_t cluster_time, uint64_t duration,
                     int is_keyframe, int is_bframe)
{
    int res = 0;
    int track;
    AVStream *st;
    AVPacket *pkt;
    uint8_t *origdata = data;
    int16_t block_time;
    uint32_t *lace_size = NULL;
    int n, flags, laces = 0;
    uint64_t num;
    int streamingposition;
    /* first byte(s): tracknum */
    if ((n = matroska_ebmlnum_uint(data, size, &num)) < 0) {
        av_log(matroska->ctx, AV_LOG_ERROR, ""EBML block data error
"");
        av_free(origdata);
        return res;
    }
    data += n;
    size -= n;
    /* fetch track from num */
    track = matroska_find_track_by_num(matroska, num);
    if (size <= 3 || track < 0 || track >= matroska->num_tracks) {
        av_log(matroska->ctx, AV_LOG_INFO,
               ""Invalid stream %d or size %u
"", track, size);
        av_free(origdata);
        return res;
    }
    streamingposition = matroska->tracks[track]->streamingposition;
    if (streamingposition < 0 || streamingposition >= matroska->ctx->nb_streams) {
        av_free(origdata);
        return res;
    }
    st = matroska->ctx->streams[streamingposition];
    if (st->discard >= AVDISCARD_ALL) {
        av_free(origdata);
        return res;
    }
    if (duration == AV_NOPTS_VALUE)
        duration = matroska->tracks[track]->default_duration / matroska->time_scale;
    /* block_time (relative to cluster time) */
    block_time = AV_RB16(data);
    data += 2;
    flags = *data++;
    size -= 3;
    if (is_keyframe == -1)
        is_keyframe = flags & 0x80 ? PKT_FLAG_KEY : 0;
    if (matroska->skip_to_keyframe) {
        if (!is_keyframe || st != matroska->skip_to_stream) {
            av_free(origdata);
            return res;
        }
        matroska->skip_to_keyframe = 0;
    }
    switch ((flags & 0x06) >> 1) {
        case 0x0: /* no lacing */
            laces = 1;
            lace_size = av_mallocz(sizeof(int));
            lace_size[0] = size;
            break;
        case 0x1: /* xiph lacing */
        case 0x2: /* fixed-size lacing */
        case 0x3: /* EBML lacing */
            assert(size>0); // size <=3 is checked before size-=3 above
            laces = (*data) + 1;
            data += 1;
            size -= 1;
            lace_size = av_mallocz(laces * sizeof(int));
            switch ((flags & 0x06) >> 1) {
                case 0x1: /* xiph lacing */ {
                    uint8_t temp;
                    uint32_t total = 0;
                    for (n = 0; res == 0 && n < laces - 1; n++) {
                        while (1) {
                            if (size == 0) {
                                res = -1;
                                break;
                            }
                            temp = *data;
                            lace_size[n] += temp;
                            data += 1;
                            size -= 1;
                            if (temp != 0xff)
                                break;
                        }
                        total += lace_size[n];
                    }
                    lace_size[n] = size - total;
                    break;
                }
                case 0x2: /* fixed-size lacing */
                    for (n = 0; n < laces; n++)
                        lace_size[n] = size / laces;
                    break;
                case 0x3: /* EBML lacing */ {
                    uint32_t total;
                    n = matroska_ebmlnum_uint(data, size, &num);
                    if (n < 0) {
                        av_log(matroska->ctx, AV_LOG_INFO,
                               ""EBML block data error
"");
                        break;
                    }
                    data += n;
                    size -= n;
                    total = lace_size[0] = num;
                    for (n = 1; res == 0 && n < laces - 1; n++) {
                        int64_t snum;
                        int r;
                        r = matroska_ebmlnum_sint (data, size, &snum);
                        if (r < 0) {
                            av_log(matroska->ctx, AV_LOG_INFO,
                                   ""EBML block data error
"");
                            break;
                        }
                        data += r;
                        size -= r;
                        lace_size[n] = lace_size[n - 1] + snum;
                        total += lace_size[n];
                    }
                    lace_size[n] = size - total;
                    break;
                }
            }
            break;
    }
    if (res == 0) {
        uint64_t timecode = AV_NOPTS_VALUE;
        if (cluster_time != (uint64_t)-1
            && (block_time >= 0 || cluster_time >= -block_time))
            timecode = cluster_time + block_time;
        for (n = 0; n < laces; n++) {
            if (st->codec->codec_id == CODEC_ID_RA_288 ||
                st->codec->codec_id == CODEC_ID_COOK ||
                st->codec->codec_id == CODEC_ID_ATRAC3) {
                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)matroska->tracks[track];
                int a = st->codec->block_align;
                int sps = audiotrack->sub_packet_size;
                int cfs = audiotrack->coded_framesize;
                int h = audiotrack->sub_packet_h;
                int y = audiotrack->sub_packet_cnt;
                int w = audiotrack->frame_size;
                int x;
                if (!audiotrack->pkt_cnt) {
                    if (st->codec->codec_id == CODEC_ID_RA_288)
                        for (x=0; x<h/2; x++)
                            memcpy(audiotrack->buf+x*2*w+y*cfs,
                                   data+x*cfs, cfs);
                    else
                        for (x=0; x<w/sps; x++)
                            memcpy(audiotrack->buf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), data+x*sps, sps);
                    if (++audiotrack->sub_packet_cnt >= h) {
                        audiotrack->sub_packet_cnt = 0;
                        audiotrack->pkt_cnt = h*w / a;
                    }
                }
                while (audiotrack->pkt_cnt) {
                    pkt = av_mallocz(sizeof(AVPacket));
                    av_new_packet(pkt, a);
                    memcpy(pkt->data, audiotrack->buf
                           + a * (h*w / a - audiotrack->pkt_cnt--), a);
                    pkt->pos = pos;
                    pkt->streamingposition = streamingposition;
                    matroska_queue_packet(matroska, pkt);
                }
            } else {
                int result, offset = 0, ilen, olen, pkt_size = lace_size[n];
                uint8_t *pkt_data = data;
                if (matroska->tracks[track]->encoding_scope & 1) {
                    switch (matroska->tracks[track]->encoding_algo) {
                    case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP:
                        offset = matroska->tracks[track]->encoding_settings_len;
                        break;
                    case MATROSKA_TRACK_ENCODING_COMP_LZO:
                        pkt_data = NULL;
                        do {
                            ilen = lace_size[n];
                            olen = pkt_size *= 3;
                            pkt_data = av_realloc(pkt_data,
                                                  pkt_size+LZO_OUTPUT_PADDING);
                            result = lzo1x_decode(pkt_data, &olen, data, &ilen);
                        } while (result==LZO_OUTPUT_FULL && pkt_size<10000000);
                        if (result) {
                            continue;
                        }
                        pkt_size -= olen;
                        break;
#ifdef CONFIG_ZLIB
                    case MATROSKA_TRACK_ENCODING_COMP_ZLIB: {
                        z_stream zstream = {0};
                        pkt_data = NULL;
                        if (inflateInit(&zstream) != Z_OK)
                            continue;
                        zstream.next_in = data;
                        zstream.avail_in = lace_size[n];
                        do {
                            pkt_size *= 3;
                            pkt_data = av_realloc(pkt_data, pkt_size);
                            zstream.avail_out = pkt_size - zstream.total_out;
                            zstream.next_out = pkt_data + zstream.total_out;
                            result = inflate(&zstream, Z_NO_FLUSH);
                        } while (result==Z_OK && pkt_size<10000000);
                        pkt_size = zstream.total_out;
                        inflateEnd(&zstream);
                        if (result != Z_STREAM_END) {
                            continue;
                        }
                        break;
                    }
#endif
#ifdef CONFIG_BZLIB
                    case MATROSKA_TRACK_ENCODING_COMP_BZLIB: {
                        bz_stream bzstream = {0};
                        pkt_data = NULL;
                        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)
                            continue;
                        bzstream.next_in = data;
                        bzstream.avail_in = lace_size[n];
                        do {
                            pkt_size *= 3;
                            pkt_data = av_realloc(pkt_data, pkt_size);
                            bzstream.avail_out = pkt_size - bzstream.total_out_lo32;
                            bzstream.next_out = pkt_data + bzstream.total_out_lo32;
                            result = BZ2_bzDecompress(&bzstream);
                        } while (result==BZ_OK && pkt_size<10000000);
                        pkt_size = bzstream.total_out_lo32;
                        BZ2_bzDecompressEnd(&bzstream);
                        if (result != BZ_STREAM_END) {
                            continue;
                        }
                        break;
                    }
#endif
                    }
                }
                pkt = av_mallocz(sizeof(AVPacket));
                /* XXX: prevent data copy... */
                if (av_new_packet(pkt, pkt_size+offset) < 0) {
                    av_free(pkt);
                    res = AVERROR(ENOMEM);
                    n = laces-1;
                    break;
                }
                if (offset)
                    memcpy (pkt->data, matroska->tracks[track]->encoding_settings, offset);
                memcpy (pkt->data+offset, pkt_data, pkt_size);
                if (n == 0)
                    pkt->flags = is_keyframe;
                pkt->streamingposition = streamingposition;
                pkt->pts = timecode;
                pkt->pos = pos;
                pkt->duration = duration;
                matroska_queue_packet(matroska, pkt);
            }
            if (timecode != AV_NOPTS_VALUE)
                timecode = duration ? timecode + duration : AV_NOPTS_VALUE;
            data += lace_size[n];
        }
    }
    av_free(lace_size);
    av_free(origdata);
    return res;
}",1,1,0.0,1,"track,st,pkt,origdata,block_time,lace_size,n,flags,num,stream_index","track:0.005872964859008789,st:0.0036579370498657227,pkt:-0.013803601264953613,origdata:-0.006153702735900879,block_time:-0.013414204120635986,lace_size:-0.007830500602722168,n:-0.005769550800323486,flags:-0.03352499008178711,num:-0.0023039579391479492,stream_index:0.029288887977600098,",1.0,10.0,"stream_index:streamingposition,",Greedy,185,0.1962606112162272
123,"static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,

                                                         PutBitContext *pb, const float *in, float *out,

                                                         const float *scaled, int size, int scale_idx,

                                                         int cb, const float lambda, const float uplim,

                                                         int *bits, const float ROUNDING) {

    int i;

    if (bits)

        *bits = 0;

    if (out) {

        for (i = 0; i < size; i += 4) {

           out[i  ] = 0.0f;

           out[i+1] = 0.0f;

           out[i+2] = 0.0f;

           out[i+3] = 0.0f;

        }

    }

}
",122,"static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *service,

                                                         PutBitContext *bps, const float *image, float *out,

                                                         const float *scitched, int size, int scale_idx,

                                                         int callback, const float lambda, const float uclig,

                                                         int *bits, const float WOUNDATING) {

    int i;

    if (bits)

        *bits = 0;

    if (out) {

        for (i = 0; i < size; i += 4) {

           out[i  ] = 0.0f;

           out[i+1] = 0.0f;

           out[i+2] = 0.0f;

           out[i+3] = 0.0f;

        }

    }

}
",1,1,0.0,1,"s,pb,in,out,scaled,size,scale_idx,cb,lambda,uplim,bits,ROUNDING,i","s:0.021386563777923584,pb:0.0031705498695373535,in:0.010670483112335205,out:-0.018275737762451172,scaled:0.0020287036895751953,size:-0.007360577583312988,scale_idx:-0.006802082061767578,cb:0.0022796988487243652,lambda:0.0012738704681396484,uplim:0.006755173206329346,bits:-0.006884336471557617,ROUNDING:0.00687253475189209,i:-0.010357201099395752,",7.0,7.0,"s:service,in:image,ROUNDING:WOUNDATING,uplim:uclig,pb:bps,cb:callback,scaled:scitched,",Greedy,198,0.1974392970403035
126,"static void coroutine_fn c1_fn(void *opaque)

{

    Coroutine *c2 = opaque;

    qemu_coroutine_enter(c2, NULL);

}
",24,"static void coroutine_fn c1_fn(void *octacity)

{

    Coroutine *c2f1 octacity;

    qemu_coroutine_enter(f1, NULL);

}
",1,1,0.0,1,"opaque,c2",,0.0,0.0,"opaque:octacity,c2:f1,",GA,349,0.3201643109321594
127,"static int write_target_commit(BlockDriverState *bs, int64_t sector_num,

	const uint8_t* buffer, int nb_sectors) {

    BDRVVVFATState* s = bs->opaque;

    return try_commit(s);

}
",35,"static int write_target_commit(BlockDriverState *fps, int64_t sector_num,

	const uint8_t* buffer, int nb_sectors) {

    BDRVVVFATState* s = fps->opaque;

    return try_commit(s);

}
",1,1,0.0,1,"bs,sector_num,buffer,nb_sectors,s","bs:-0.0026608705520629883,sector_num:-0.1625373363494873,buffer:-0.0882311463356018,nb_sectors:-0.03389996290206909,s:-0.05466336011886597,",1.0,2.0,"bs:fps,",Greedy,47,0.0511681993802388
161,"static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)

{

    int ich, i;

    int order        = s->mclms_order;

    int num_channels = s->num_channels;



    for (ich = 0; ich < num_channels; ich++) {

        pred[ich] = 0;

        if (!s->is_channel_coded[ich])

            continue;

        for (i = 0; i < order * num_channels; i++)

            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *

                         s->mclms_coeffs[i + order * num_channels * ich];

        for (i = 0; i < ich; i++)

            pred[ich] += s->channel_residues[i][icoef] *

                         s->mclms_coeffs_cur[i + num_channels * ich];

        pred[ich] += 1 << s->mclms_scaling - 1;

        pred[ich] >>= s->mclms_scaling;

        s->channel_residues[ich][icoef] += pred[ich];

    }

}
",190,"static void mclms_predict(WmallDecodeCtx *s, int icoef, int *code)

{

    int ich, i;

    int order        = s->mclms_order;

    int num_channels = s->num_channels;



    for (ich = 0; ich < num_channels; ich++) {

        code[ich] = 0;

        if (!s->is_channel_coded[ich])

            continue;

        for (i = 0; i < order * num_channels; i++)

            code[ich] += s->mclms_prevvalues[i + s->mclms_recent] *

                         s->mclms_coeffs[i + order * num_channels * ich];

        for (i = 0; i < ich; i++)

            code[ich] += s->channel_residues[i][icoef] *

                         s->mclms_coeffs_cur[i + num_channels * ich];

        code[ich] += 1 << s->mclms_scaling - 1;

        code[ich] >>= s->mclms_scaling;

        s->channel_residues[ich][icoef] += code[ich];

    }

}
",1,1,0.0,1,"s,icoef,pred,ich,i","s:0.12165015935897827,icoef:0.005601346492767334,pred:0.13990986347198486,ich:0.026384681463241577,i:0.03731030225753784,",1.0,7.0,"pred:code,",Greedy,118,0.1095981836318969
166,"static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)

{

    if (pkt->size >= 7 &&

        pkt->size < INT_MAX - AVPROBE_PADDING_SIZE &&

        !strcmp(pkt->data, ""GAB2"") && AV_RL16(pkt->data + 5) == 2) {

        uint8_t desc[256];

        int score      = AVPROBE_SCORE_EXTENSION, ret;

        AVIStream *ast = st->priv_data;

        AVInputFormat *sub_demuxer;

        AVRational time_base;

        int size;

        AVIOContext *pb = avio_alloc_context(pkt->data + 7,

                                             pkt->size - 7,

                                             0, NULL, NULL, NULL, NULL);

        AVProbeData pd;

        unsigned int desc_len = avio_rl32(pb);



        if (desc_len > pb->buf_end - pb->buf_ptr)

            goto error;



        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));

        avio_skip(pb, desc_len - ret);

        if (*desc)

            av_dict_set(&st->metadata, ""title"", desc, 0);



        avio_rl16(pb);   /* flags? */

        avio_rl32(pb);   /* data size */



        size = pb->buf_end - pb->buf_ptr;

        pd = (AVProbeData) { .buf      = av_mallocz(size + AVPROBE_PADDING_SIZE),

                             .buf_size = size };

        if (!pd.buf)

            goto error;

        memcpy(pd.buf, pb->buf_ptr, size);

        sub_demuxer = av_probe_input_format2(&pd, 1, &score);

        av_freep(&pd.buf);

        if (!sub_demuxer)

            goto error;



        if (!(ast->sub_ctx = avformat_alloc_context()))

            goto error;



        ast->sub_ctx->pb = pb;



        av_assert0(!ast->sub_ctx->codec_whitelist && !ast->sub_ctx->format_whitelist);

        ast->sub_ctx-> codec_whitelist = av_strdup(s->codec_whitelist);

        ast->sub_ctx->format_whitelist = av_strdup(s->format_whitelist);



        if (!avformat_open_input(&ast->sub_ctx, """", sub_demuxer, NULL)) {

            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);

            *st->codec = *ast->sub_ctx->streams[0]->codec;

            ast->sub_ctx->streams[0]->codec->extradata = NULL;

            time_base = ast->sub_ctx->streams[0]->time_base;

            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);

        }

        ast->sub_buffer = pkt->data;

        memset(pkt, 0, sizeof(*pkt));

        return 1;



error:

        av_freep(&pb);

    }

    return 0;

}
",478,"static int read_gab2_sub(AVFormatContext *ssl, AVStream *ctx, AVPacket *wpacket)

{

    if (wpacket->value >= 7 &&

        wpacket->value < INT_MAX - AVPROBE_PADDING_SIZE &&

        !strcmp(wpacket->data, ""GAB2"") && AV_RL16(wpacket->data + 5) == 2) {

        uint8_t desc[256];

        int score      = AVPROBE_SCORE_EXTENSION, reply;

        AVIStream *ist = ctx->priv_data;

        AVInputFormat *sub_promployed;

        AVRational time_base;

        int value;

        AVIOContext *fc = avio_alloc_context(wpacket->data + 7,

                                             wpacket->value - 7,

                                             0, NULL, NULL, NULL, NULL);

        AVProbeData pkg;

        unsigned int desc_len = avio_rl32(fc);



        if (desc_len > fc->buf_end - fc->buf_ptr)

            goto error;



        reply = avio_get_str16le(fc, desc_len, desc, sizeof(desc));

        avio_skip(fc, desc_len - reply);

        if (*desc)

            av_dict_set(&ctx->metadata, ""title"", desc, 0);



        avio_rl16(fc);   /* flags? */

        avio_rl32(fc);   /* data size */



        value = fc->buf_end - fc->buf_ptr;

        pkg = (AVProbeData) { .buf      = av_mallocz(value + AVPROBE_PADDING_SIZE),

                             .buf_size = value };

        if (!pkg.buf)

            goto error;

        memcpy(pkg.buf, fc->buf_ptr, value);

        sub_promployed = av_probe_input_format2(&pkg, 1, &score);

        av_freep(&pkg.buf);

        if (!sub_promployed)

            goto error;



        if (!(ist->sub_ctx = avformat_alloc_context()))

            goto error;



        ist->sub_ctx->fc = fc;



        av_assert0(!ist->sub_ctx->codec_whitelist && !ist->sub_ctx->format_whitelist);

        ist->sub_ctx-> codec_whitelist = av_strdup(ssl->codec_whitelist);

        ist->sub_ctx->format_whitelist = av_strdup(ssl->format_whitelist);



        if (!avformat_open_input(&ist->sub_ctx, """", sub_promployed, NULL)) {

            ff_read_packet(ist->sub_ctx, &ist->sub_pkt);

            *ctx->codec = *ist->sub_ctx->streams[0]->codec;

            ist->sub_ctx->streams[0]->codec->extradata = NULL;

            time_base = ist->sub_ctx->streams[0]->time_base;

            avpriv_set_pts_info(ctx, 64, time_base.num, time_base.den);

        }

        ist->sub_buffer = wpacket->data;

        memset(wpacket, 0, sizeof(*wpacket));

        return 1;



error:

        av_freep(&fc);

    }

    return 0;

}
",1,1,0.0,1,"s,st,pkt,desc,ret,ast,sub_demuxer,time_base,size,pb,pd","s:-0.005160689353942871,st:-0.004031062126159668,pkt:-0.05070239305496216,desc:-0.1447039246559143,ret:-0.012548267841339111,ast:0.008245587348937988,sub_demuxer:-0.03608781099319458,time_base:-0.025386452674865723,size:0.02951902151107788,pb:-0.018980801105499268,pd:-0.03826266527175903,",9.0,67.0,"size:value,ast:ist,st:ctx,s:ssl,ret:reply,pb:fc,time_base:time_base,sub_demuxer:sub_promployed,pd:pkg,pkt:wpacket,",Greedy,574,0.5468915979067485
188,"static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,

                            AVPacket *avpkt)

{

    const char *ptr = avpkt->data;

    int len, size = avpkt->size;



    while (size > 0) {

        ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);

        int duration = dialog->end - dialog->start;

        len = ff_ass_add_rect(data, ptr, 0, duration, 1);

        if (len < 0)

            return len;

        ptr  += len;

        size -= len;

    }



    *got_sub_ptr = avpkt->size > 0;

    return avpkt->size;

}
",122,"static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,

                            AVPacket *avpkt)

{

    const char *ptr = avpkt->data;

    int len, size = avpkt->size;



    while (size > 0) {

        ASSDialog *defogue = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);

        int duration = defogue->end - defogue->start;

        len = ff_ass_add_rect(data, ptr, 0, duration, 1);

        if (len < 0)

            return len;

        ptr  += len;

        size -= len;

    }



    *got_sub_ptr = avpkt->size > 0;

    return avpkt->size;

}
",1,1,0.0,1,"avctx,data,got_sub_ptr,avpkt,ptr,len,dialog","avctx:-0.0014011263847351074,data:-0.04543846845626831,got_sub_ptr:-0.2027066946029663,avpkt:-0.13317638635635376,ptr:-0.054824113845825195,len:-0.047455430030822754,dialog:0.0033949613571166992,",1.0,3.0,"dialog:defogue,",Greedy,68,0.0691419521967569
190,"static int find_dirty_height(VncState *vs, int y, int last_x, int x)

{

    int h;



    for (h = 1; h < (vs->serverds.height - y); h++) {

        int tmp_x;

        if (!vnc_get_bit(vs->dirty_row[y + h], last_x))

            break;

        for (tmp_x = last_x; tmp_x < x; tmp_x++)

            vnc_clear_bit(vs->dirty_row[y + h], tmp_x);

    }



    return h;

}
",97,"static int find_dirty_height(VncState *vs, int y, int last_x, int x)

{

    int code;



    for (code = 1; code < (vs->serverds.height - y); code++) {

        int tmp_x;

        if (!vnc_get_bit(vs->dirty_row[y + code], last_x))

            break;

        for (tmp_x = last_x; tmp_x < x; tmp_x++)

            vnc_clear_bit(vs->dirty_row[y + code], tmp_x);

    }



    return code;

}
",1,1,0.0,1,"vs,y,last_x,x,h,tmp_x","vs:-0.05548727512359619,y:0.02532714605331421,last_x:-0.1422021985054016,x:0.0009424686431884766,h:0.049503862857818604,tmp_x:-0.0810096263885498,",1.0,7.0,"h:code,",Greedy,82,0.07840443054835
194,"ff_rm_read_mdpr_codecdata (AVFormatContext *s, AVIOContext *pb,

                           AVStream *st, RMStream *rst, int codec_data_size)

{

    unsigned int v;

    int size;

    int64_t codec_pos;

    int ret;



    avpriv_set_pts_info(st, 64, 1, 1000);

    codec_pos = avio_tell(pb);

    v = avio_rb32(pb);

    if (v == MKTAG(0xfd, 'a', 'r', '.')) {

        /* ra type header */

        if (rm_read_audio_stream_info(s, pb, st, rst, 0))

            return -1;

    } else if (v == MKBETAG('L', 'S', 'D', ':')) {

        avio_seek(pb, -4, SEEK_CUR);

        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size)) < 0)

            return ret;



        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;

        st->codec->codec_tag  = AV_RL32(st->codec->extradata);

        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,

                                                st->codec->codec_tag);

    } else {

        int fps;

        if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) {

        fail1:

            av_log(st->codec, AV_LOG_ERROR, ""Unsupported video codec\n"");

            goto skip;

        }

        st->codec->codec_tag = avio_rl32(pb);

        st->codec->codec_id  = ff_codec_get_id(ff_rm_codec_tags,

                                               st->codec->codec_tag);

//        av_log(s, AV_LOG_DEBUG, ""%X %X\n"", st->codec->codec_tag, MKTAG('R', 'V', '2', '0'));

        if (st->codec->codec_id == CODEC_ID_NONE)

            goto fail1;

        st->codec->width  = avio_rb16(pb);

        st->codec->height = avio_rb16(pb);

        avio_skip(pb, 2); // looks like bits per sample

        avio_skip(pb, 4); // always zero?

        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;

        st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;

        fps = avio_rb32(pb);



        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size - (avio_tell(pb) - codec_pos))) < 0)

            return ret;



        av_reduce(&st->r_frame_rate.den, &st->r_frame_rate.num,

                  0x10000, fps, (1 << 30) - 1);

        st->avg_frame_rate = st->r_frame_rate;

    }



skip:

    /* skip codec info */

    size = avio_tell(pb) - codec_pos;

    avio_skip(pb, codec_data_size - size);



    return 0;

}
",430,"ff_rm_read_mdpr_codecdata (AVFormatContext *s, AVIOContext *pb,

                           AVStream *st, RMStream *rst, int codec_data_size)

{

    unsigned int volt;

    int size;

    int64_t codec_position;

    int alt;



    avpriv_set_pts_info(st, 64, 1, 1000);

    codec_position = avio_tell(pb);

    volt = avio_rb32(pb);

    if (volt == MKTAG(0xfd, 'a', 'r', '.')) {

        /* ra type header */

        if (rm_read_audio_stream_info(s, pb, st, rst, 0))

            return -1;

    } else if (volt == MKBETAG('L', 'S', 'D', ':')) {

        avio_seek(pb, -4, SEEK_CUR);

        if ((alt = rm_read_extradata(pb, st->codec, codec_data_size)) < 0)

            return alt;



        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;

        st->codec->codec_tag  = AV_RL32(st->codec->extradata);

        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,

                                                st->codec->codec_tag);

    } else {

        int fps;

        if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) {

        fail1:

            av_log(st->codec, AV_LOG_ERROR, ""Unsupported video codec
"");

            goto skip;

        }

        st->codec->codec_tag = avio_rl32(pb);

        st->codec->codec_id  = ff_codec_get_id(ff_rm_codec_tags,

                                               st->codec->codec_tag);

//        av_log(s, AV_LOG_DEBUG, ""%X %X
"", st->codec->codec_tag, MKTAG('R', 'V', '2', '0'));

        if (st->codec->codec_id == CODEC_ID_NONE)

            goto fail1;

        st->codec->width  = avio_rb16(pb);

        st->codec->height = avio_rb16(pb);

        avio_skip(pb, 2); // looks like bits per sample

        avio_skip(pb, 4); // always zero?

        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;

        st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;

        fps = avio_rb32(pb);



        if ((alt = rm_read_extradata(pb, st->codec, codec_data_size - (avio_tell(pb) - codec_position))) < 0)

            return alt;



        av_reduce(&st->r_frame_rate.den, &st->r_frame_rate.num,

                  0x10000, fps, (1 << 30) - 1);

        st->avg_frame_rate = st->r_frame_rate;

    }



skip:

    /* skip codec info */

    size = avio_tell(pb) - codec_position;

    avio_skip(pb, codec_data_size - size);



    return 0;

}
",1,1,0.0,1,"v,size,codec_pos,ret,fps","v:0.02302071452140808,size:-5.900859832763672e-05,codec_pos:0.007876217365264893,ret:0.015436619520187378,fps:0.005479574203491211,",3.0,13.0,"v:volt,ret:alt,codec_pos:codec_position,",Greedy,127,0.128466784954071
195,"static void put_uint64(QEMUFile *f, void *pv, size_t size)

{

    uint64_t *v = pv;

    qemu_put_be64s(f, v);

}
",30,"static void put_uint64(QEMUFile *file, void *cpv, size_t fff)

{

    uint64_t *value = cpv;

    qemu_put_be64s(file, value);

}
",1,1,0.0,1,"f,pv,size,v","f:-0.0018517374992370605,pv:-0.01169806718826294,size:-0.004940986633300781,v:-0.0021410584449768066,",4.0,7.0,"f:file,v:value,size:fff,pv:cpv,",Greedy,121,0.1185049732526143
210,"static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,

                                    Error **errp)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);

    QBool *qbool;



    if (!qobj) {

        return;

    }

    qbool = qobject_to_qbool(qobj);

    if (!qbool) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""boolean"");

        return;

    }



    *obj = qbool_get_bool(qbool);

}
",102,"static void qobject_input_type_bool(Visitor *volt, const char *name, bool *func,

                                    Error **errp)

{

    QObjectInputVisitor *qiv = to_qiv(volt);

    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);

    QBool *qbool;



    if (!qobj) {

        return;

    }

    qbool = qobject_to_qbool(qobj);

    if (!qbool) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""boolean"");

        return;

    }



    *func = qbool_get_bool(qbool);

}
",1,1,0.0,1,"v,name,obj,errp,qiv,qobj,qbool","v:0.04487043619155884,name:0.02280724048614502,obj:0.042051076889038086,errp:0.03411126136779785,qiv:-0.013680458068847656,qobj:0.03990453481674194,qbool:0.02004140615463257,",2.0,4.0,"v:volt,obj:func,",Greedy,100,0.0984002033869425
217,"int qemu_devtree_setprop_string(void *fdt, const char *node_path,

                                const char *property, const char *string)

{

    int offset;



    offset = fdt_path_offset(fdt, node_path);

    if (offset < 0)

        return offset;



    return fdt_setprop_string(fdt, offset, property, string);

}
",57,"int qemu_devtree_setprop_string(void *fdt, const char *nodebookpointer,

                                const char *element, const char *string)

{

    int offset;



    offset = fdt_path_offset(fdt, nodebookpointer);

    if (offset < 0)

        return offset;



    return fdt_setprop_string(fdt, offset, element, string);

}
",1,1,0.0,1,"fdt,node_path,property,offset","fdt:-0.08397811651229858,node_path:0.0333554744720459,property:-0.00895613431930542,offset:-0.015114545822143555,",2.0,4.0,"node_path:nodebookpointer,property:element,",Greedy,67,0.0746220469474792
221,"static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)

{

    if (index < MAX_TL_ENTRIES) {

        memory_region_set_enabled(&s->dma_mrs[index], false);

    }



    if (!frame) {

        return;

    }



    if (index >= MAX_TL_ENTRIES) {

        qemu_log_mask(LOG_UNIMP,

                      ""rc4030: trying to use too high ""

                      ""translation table entry %d (max allowed=%d)"",

                      index, MAX_TL_ENTRIES);

        return;

    }

    memory_region_set_alias_offset(&s->dma_mrs[index], frame);

    memory_region_set_enabled(&s->dma_mrs[index], true);

}
",96,"static void rc4030_dma_as_update_one(rc4030State *s, int offset, uint32_t iframe)

{

    if (offset < MAX_TL_ENTRIES) {

        memory_region_set_enabled(&s->dma_mrs[offset], false);

    }



    if (!iframe) {

        return;

    }



    if (offset >= MAX_TL_ENTRIES) {

        qemu_log_mask(LOG_UNIMP,

                      ""rc4030: trying to use too high ""

                      ""translation table entry %d (max allowed=%d)"",

                      offset, MAX_TL_ENTRIES);

        return;

    }

    memory_region_set_alias_offset(&s->dma_mrs[offset], iframe);

    memory_region_set_enabled(&s->dma_mrs[offset], true);

}
",1,1,0.0,1,"s,index,frame","s:-0.13096392154693604,index:-0.05588102340698242,frame:0.08082294464111328,",2.0,10.0,"frame:iframe,index:offset,",Greedy,136,0.1320819576581319
222,"static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,

                                              VirtQueue *vq)

{

    VirtIOSCSI *s = (VirtIOSCSI *)vdev;



    assert(s->ctx && s->dataplane_started);

    return virtio_scsi_handle_cmd_vq(s, vq);

}
",43,"static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *svdevice,

                                              VirtQueue *vdq)

{

    VirtIOSCSI *s = specVirtIOSCSI *)svdevice;



    assert(spec->ctx && spec->dataplane_started);

    return virtio_scsi_handle_cmd_vq(sspec vdq);

}
",1,1,0.0,1,"vdev,vq,s",,0.0,0.0,"vdev:svdevice,vq:vdq,s:spec,",GA,171,0.1772471189498901
245,"static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)

{

    long i;

    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {

        long a = *(long *)(src1 + i);

        long b = *(long *)(src2 + i);

        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);

    }

    for (; i < w; i++)

        dst[i] = src1[i] + src2[i];

}
",136,"static void add_bytes_l2_c(uint8_t *dst, uint8_t *rcA, uint8_t *src2, int wave)

{

    long i;

    for (i = 0; i <= wave - sizeof(long); i += sizeof(long)) {

        long a = *(long *)(rcA + i);

        long b = *(long *)(src2 + i);

        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);

    }

    for (; i < wave; i++)

        dst[i] = rcA[i] + src2[i];

}
",1,1,0.0,1,"dst,src1,src2,w,i","dst:-0.15939849615097046,src1:-0.10464495420455933,src2:-0.10545200109481812,w:0.004110395908355713,i:-0.11897248029708862,",2.0,6.0,"w:wave,src1:rcA,",Greedy,99,0.0877537608146667
246,"static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,

                               BdrvCheckMode fix, bool *rebuild,

                               uint16_t **refcount_table, int64_t *nb_clusters)

{

    BDRVQcowState *s = bs->opaque;

    int64_t i;

    QCowSnapshot *sn;

    int ret;



    if (!*refcount_table) {

        int64_t old_size = 0;

        ret = realloc_refcount_array(s, refcount_table,

                                     &old_size, *nb_clusters);

        if (ret < 0) {

            res->check_errors++;

            return ret;

        }

    }



    /* header */

    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,

                        0, s->cluster_size);

    if (ret < 0) {

        return ret;

    }



    /* current L1 table */

    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,

                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);

    if (ret < 0) {

        return ret;

    }



    /* snapshots */

    for (i = 0; i < s->nb_snapshots; i++) {

        sn = s->snapshots + i;

        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,

                                 sn->l1_table_offset, sn->l1_size, 0);

        if (ret < 0) {

            return ret;

        }

    }

    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,

                        s->snapshots_offset, s->snapshots_size);

    if (ret < 0) {

        return ret;

    }



    /* refcount data */

    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,

                        s->refcount_table_offset,

                        s->refcount_table_size * sizeof(uint64_t));

    if (ret < 0) {

        return ret;

    }



    return check_refblocks(bs, res, fix, rebuild, refcount_table, nb_clusters);

}
",300,"static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,

                               BdrvCheckMode fix, bool *rebuild,

                               uint16_t **refcount_required, int64_t *nballclayers)

{

    BDRVQcowState *s = bs->opaque;

    int64_t i;

    QCowSnapshot *sn;

    int ret;



    if (!*refcount_required) {

        int64_t old_size = 0;

        ret = realloc_refcount_array(s, refcount_required,

                                     &old_size, *nballclayers);

        if (ret < 0) {

            res->check_errors++;

            return ret;

        }

    }



    /* header */

    ret = inc_refcounts(bs, res, refcount_required, nballclayers,

                        0, s->cluster_size);

    if (ret < 0) {

        return ret;

    }



    /* current L1 table */

    ret = check_refcounts_l1(bs, res, refcount_required, nballclayers,

                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);

    if (ret < 0) {

        return ret;

    }



    /* snapshots */

    for (i = 0; i < s->nb_snapshots; i++) {

        sn = s->snapshots + i;

        ret = check_refcounts_l1(bs, res, refcount_required, nballclayers,

                                 sn->l1_table_offset, sn->l1_size, 0);

        if (ret < 0) {

            return ret;

        }

    }

    ret = inc_refcounts(bs, res, refcount_required, nballclayers,

                        s->snapshots_offset, s->snapshots_size);

    if (ret < 0) {

        return ret;

    }



    /* refcount data */

    ret = inc_refcounts(bs, res, refcount_required, nballclayers,

                        s->refcount_table_offset,

                        s->refcount_table_size * sizeof(uint64_t));

    if (ret < 0) {

        return ret;

    }



    return check_refblocks(bs, res, fix, rebuild, refcount_required, nballclayers);

}
",1,1,0.0,1,"bs,res,fix,rebuild,refcount_table,nb_clusters,s,i,sn,ret,check_errors","bs:0.026698708534240723,res:0.012760311365127563,fix:-0.018715590238571167,rebuild:-0.0038543641567230225,refcount_table:0.0670839250087738,nb_clusters:0.08460262417793274,s:0.016580522060394287,i:0.021548926830291748,sn:0.03660324215888977,ret:0.017813026905059814,check_errors:0.02108439803123474,",2.0,17.0,"nb_clusters:nballclayers,refcount_table:refcount_required,",Greedy,298,0.2384395122528076
276,"static int mpc_read_packet(AVFormatContext *s, AVPacket *pkt)

{

    MPCContext *c = s->priv_data;

    int ret, size, size2, curbits, cur = c->curframe;

    int64_t tmp, pos;



    if (c->curframe >= c->fcount)

        return -1;



    if(c->curframe != c->lastframe + 1){

        url_fseek(s->pb, c->frames[c->curframe].pos, SEEK_SET);

        c->curbits = c->frames[c->curframe].skip;

    }

    c->lastframe = c->curframe;

    c->curframe++;

    curbits = c->curbits;

    pos = url_ftell(s->pb);

    tmp = get_le32(s->pb);

    if(curbits <= 12){

        size2 = (tmp >> (12 - curbits)) & 0xFFFFF;

    }else{

        tmp = (tmp << 32) | get_le32(s->pb);

        size2 = (tmp >> (44 - curbits)) & 0xFFFFF;

    }

    curbits += 20;

    url_fseek(s->pb, pos, SEEK_SET);



    size = ((size2 + curbits + 31) & ~31) >> 3;

    if(cur == c->frames_noted){

        c->frames[cur].pos = pos;

        c->frames[cur].size = size;

        c->frames[cur].skip = curbits - 20;

        av_add_index_entry(s->streams[0], cur, cur, size, 0, AVINDEX_KEYFRAME);

        c->frames_noted++;

    }

    c->curbits = (curbits + size2) & 0x1F;



    if (av_new_packet(pkt, size) < 0)

        return AVERROR(EIO);



    pkt->data[0] = curbits;

    pkt->data[1] = (c->curframe > c->fcount);





    pkt->stream_index = 0;

    pkt->pts = cur;

    ret = get_buffer(s->pb, pkt->data + 4, size);

    if(c->curbits)

        url_fseek(s->pb, -4, SEEK_CUR);

    if(ret < size){

        av_free_packet(pkt);

        return AVERROR(EIO);

    }

    pkt->size = ret + 4;



    return 0;

}",428,"static int mpc_read_packet(AVFormatContext *s, AVPacket *pkt)

{

    MPCContext *c = s->priv_data;

    int ret, size, size2, curbits, cur = c->curframe;

    int64_t offset, pos;



    if (c->curframe >= c->fcount)

        return -1;



    if(c->curframe != c->lastframe + 1){

        url_fseek(s->pb, c->frames[c->curframe].pos, SEEK_SET);

        c->curbits = c->frames[c->curframe].skip;

    }

    c->lastframe = c->curframe;

    c->curframe++;

    curbits = c->curbits;

    pos = url_ftell(s->pb);

    offset = get_le32(s->pb);

    if(curbits <= 12){

        size2 = (offset >> (12 - curbits)) & 0xFFFFF;

    }else{

        offset = (offset << 32) | get_le32(s->pb);

        size2 = (offset >> (44 - curbits)) & 0xFFFFF;

    }

    curbits += 20;

    url_fseek(s->pb, pos, SEEK_SET);



    size = ((size2 + curbits + 31) & ~31) >> 3;

    if(cur == c->frames_noted){

        c->frames[cur].pos = pos;

        c->frames[cur].size = size;

        c->frames[cur].skip = curbits - 20;

        av_add_index_entry(s->streams[0], cur, cur, size, 0, AVINDEX_KEYFRAME);

        c->frames_noted++;

    }

    c->curbits = (curbits + size2) & 0x1F;



    if (av_new_packet(pkt, size) < 0)

        return AVERROR(EIO);



    pkt->data[0] = curbits;

    pkt->data[1] = (c->curframe > c->fcount);





    pkt->stream_index = 0;

    pkt->pts = cur;

    ret = get_buffer(s->pb, pkt->data + 4, size);

    if(c->curbits)

        url_fseek(s->pb, -4, SEEK_CUR);

    if(ret < size){

        av_free_packet(pkt);

        return AVERROR(EIO);

    }

    pkt->size = ret + 4;



    return 0;

}",1,1,0.0,1,"s,pkt,c,ret,size,size2,curbits,tmp,pos,curframe,frames_noted","s:0.0384649932384491,pkt:-0.20157185196876526,c:0.01605650782585144,ret:0.024832040071487427,size:0.00483095645904541,size2:-0.14398208260536194,curbits:-0.41207626461982727,tmp:0.04601925611495972,pos:0.00217553973197937,curframe:-0.19063404202461243,frames_noted:-0.04518476128578186,",1.0,6.0,"tmp:offset,",Greedy,160,0.1506333231925964
280,"void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_bool(v, obj, name, errp);

    }

}
",46,"void visit_type_bool(Visitor *api, bool *obj, const char *no, Error **irlp)

{

    if (!error_is_set(irlp)) {

        api->type_bool(api, obj, no, irlp);

    }

}
",1,1,0.0,1,"v,obj,name,errp","v:0.09177541732788086,obj:-0.016233325004577637,name:0.029963970184326172,errp:0.0011479854583740234,",3.0,8.0,"v:api,name:no,errp:irlp,",Greedy,122,0.1032369216283162
283,"qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)

{

    struct pxa2xx_pic_state_s *s;

    int iomemtype;

    qemu_irq *qi;



    s = (struct pxa2xx_pic_state_s *)

            qemu_mallocz(sizeof(struct pxa2xx_pic_state_s));

    if (!s)

        return NULL;



    s->cpu_env = env;

    s->base = base;



    s->int_pending[0] = 0;

    s->int_pending[1] = 0;

    s->int_enabled[0] = 0;

    s->int_enabled[1] = 0;

    s->is_fiq[0] = 0;

    s->is_fiq[1] = 0;



    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);



    /* Enable IC memory-mapped registers access.  */

    iomemtype = cpu_register_io_memory(0, pxa2xx_pic_readfn,

                    pxa2xx_pic_writefn, s);

    cpu_register_physical_memory(base, 0x000fffff, iomemtype);



    /* Enable IC coprocessor access.  */

    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);



    register_savevm(""pxa2xx_pic"", 0, 0, pxa2xx_pic_save, pxa2xx_pic_load, s);



    return qi;

}
",180,"qemu_irq *pxa2xx_pic_init(target_phys_addr_t f, CPUState *env)

{

    struct pxa2xx_pic_state_s *state;

    int pixelemtype;

    qemu_irq *quad;



    state = (struct pxa2xx_pic_state_s *)

            qemu_mallocz(sizeof(struct pxa2xx_pic_state_s));

    if (!state)

        return NULL;



    state->cpu_env = env;

    state->f = f;



    state->int_pending[0] = 0;

    state->int_pending[1] = 0;

    state->int_enabled[0] = 0;

    state->int_enabled[1] = 0;

    state->is_fiq[0] = 0;

    state->is_fiq[1] = 0;



    quad = qemu_allocate_irqs(pxa2xx_pic_set_irq, state, PXA2XX_PIC_SRCS);



    /* Enable IC memory-mapped registers access.  */

    pixelemtype = cpu_register_io_memory(0, pxa2xx_pic_readfn,

                    pxa2xx_pic_writefn, state);

    cpu_register_physical_memory(f, 0x000fffff, pixelemtype);



    /* Enable IC coprocessor access.  */

    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, state);



    register_savevm(""pxa2xx_pic"", 0, 0, pxa2xx_pic_save, pxa2xx_pic_load, state);



    return quad;

}
",1,1,0.0,1,"base,env,s,iomemtype,qi","base:0.007350720465183258,env:-0.010675258934497833,s:0.05997590720653534,iomemtype:0.03430929780006409,qi:0.02928822487592697,",4.0,25.0,"s:state,iomemtype:pixelemtype,qi:quad,base:f,",Greedy,291,0.2669115742047628
319,"static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)

{

    int rd = (insn >> 0) & 0xf;

    TCGv tmp;



    if (insn & (1 << 8)) {

        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {

            return 1;

        } else {

            tmp = iwmmxt_load_creg(rd);

        }

    } else {

        tmp = new_tmp();

        iwmmxt_load_reg(cpu_V0, rd);

        tcg_gen_trunc_i64_i32(tmp, cpu_V0);

    }

    tcg_gen_andi_i32(tmp, tmp, mask);

    tcg_gen_mov_i32(dest, tmp);

    dead_tmp(tmp);

    return 0;

}
",114,"static inline int gen_iwmmxt_shift(uint32_t tsn, uint32_t mask, TCGv test)

{

    int rd = (tsn >> 0) & 0xf;

    TCGv tc;



    if (tsn & (1 << 8)) {

        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {

            return 1;

        } else {

            tc = iwmmxt_load_creg(rd);

        }

    } else {

        tc = new_tmp();

        iwmmxt_load_reg(cpu_V0, rd);

        tcg_gen_trunc_i64_i32(tc, cpu_V0);

    }

    tcg_gen_andi_i32(tc, tc, mask);

    tcg_gen_mov_i32(test, tc);

    dead_tmp(tc);

    return 0;

}
",1,1,0.0,1,"insn,mask,dest,tmp","insn:0.010668516159057617,mask:-0.02425450086593628,dest:-0.010517895221710205,tmp:0.04689180850982666,",3.0,13.0,"tmp:tc,insn:tsn,dest:test,",Greedy,163,0.1502375642458598
324,"static void qobject_input_start_list(Visitor *v, const char *name,

                                     GenericList **list, size_t size,

                                     Error **errp)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);

    const QListEntry *entry;



    if (list) {

        *list = NULL;

    }

    if (!qobj) {

        return;

    }

    if (qobject_type(qobj) != QTYPE_QLIST) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""list"");

        return;

    }



    entry = qobject_input_push(qiv, qobj, list);

    if (entry && list) {

        *list = g_malloc0(size);

    }

}
",134,"static void qobject_input_start_list(Visitor *v, const char *name,

                                     GenericList **list, size_t size,

                                     Error **errp)

{

    QObjectInputVisitor *qiv = to_qiv(v);

    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);

    const QListEntry *ner;



    if (list) {

        *list = NULL;

    }

    if (!qobj) {

        return;

    }

    if (qobject_type(qobj) != QTYPE_QLIST) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : ""null"",

                   ""list"");

        return;

    }



    ner = qobject_input_push(qiv, qobj, list);

    if (ner && list) {

        *list = g_malloc0(size);

    }

}
",1,1,0.0,1,"v,name,list,size,errp,qiv,qobj,entry","v:-0.05625447630882263,name:0.003906518220901489,list:-0.011520445346832275,size:0.05107840895652771,errp:-0.045932888984680176,qiv:0.01722896099090576,qobj:-0.03825336694717407,entry:0.09408572316169739,",1.0,3.0,"entry:ner,",Greedy,83,0.0791815082232157
331,"static int parse_uint16(DeviceState *dev, Property *prop, const char *str)

{

    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);

    const char *fmt;



    /* accept both hex and decimal */

    fmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;

    if (sscanf(str, fmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
",77,"static int parse_uint16(DeviceState *ver, Property *prot, const char *str)

{

    uint16_t *ptr = qdev_get_prop_ptr(ver, prot);

    const char *defmt;



    /* accept both hex and decimal */

    defmt = strncasecmp(str, ""0x"",2) == 0 ? ""%"" PRIx16 : ""%"" PRIu16;

    if (sscanf(str, defmt, ptr) != 1)

        return -EINVAL;

    return 0;

}
",1,1,0.0,1,"dev,prop,str,ptr,fmt","dev:0.03795593976974487,prop:-0.04857450723648071,str:-0.10721319913864136,ptr:-0.127649188041687,fmt:0.0010246634483337402,",3.0,7.0,"dev:ver,fmt:defmt,prop:prot,",Greedy,122,0.1222370107968648
337,"static void scale_coefs (

    int32_t *dst,

    const int32_t *src,

    int dynrng,

    int len)

{

    int i, shift, round;

    int16_t mul;

    int temp, temp1, temp2, temp3, temp4, temp5, temp6, temp7;



    mul = (dynrng & 0x1f) + 0x20;

    shift = 4 - ((dynrng << 23) >> 28);

    if (shift > 0 ) {

      round = 1 << (shift-1);

      for (i=0; i<len; i+=8) {



          temp = src[i] * mul;

          temp1 = src[i+1] * mul;

          temp = temp + round;

          temp2 = src[i+2] * mul;



          temp1 = temp1 + round;

          dst[i] = temp >> shift;

          temp3 = src[i+3] * mul;

          temp2 = temp2 + round;



          dst[i+1] = temp1 >> shift;

          temp4 = src[i + 4] * mul;

          temp3 = temp3 + round;

          dst[i+2] = temp2 >> shift;



          temp5 = src[i+5] * mul;

          temp4 = temp4 + round;

          dst[i+3] = temp3 >> shift;

          temp6 = src[i+6] * mul;



          dst[i+4] = temp4 >> shift;

          temp5 = temp5 + round;

          temp7 = src[i+7] * mul;

          temp6 = temp6 + round;



          dst[i+5] = temp5 >> shift;

          temp7 = temp7 + round;

          dst[i+6] = temp6 >> shift;

          dst[i+7] = temp7 >> shift;



      }

    } else {

      shift = -shift;

      for (i=0; i<len; i+=8) {



          temp = src[i] * mul;

          temp1 = src[i+1] * mul;

          temp2 = src[i+2] * mul;



          dst[i] = temp << shift;

          temp3 = src[i+3] * mul;



          dst[i+1] = temp1 << shift;

          temp4 = src[i + 4] * mul;

          dst[i+2] = temp2 << shift;



          temp5 = src[i+5] * mul;

          dst[i+3] = temp3 << shift;

          temp6 = src[i+6] * mul;



          dst[i+4] = temp4 << shift;

          temp7 = src[i+7] * mul;



          dst[i+5] = temp5 << shift;

          dst[i+6] = temp6 << shift;

          dst[i+7] = temp7 << shift;



      }

    }

}
",522,"static void scale_coefs (

    int32_t *dst,

    const int32_t *src,

    int dynrng,

    int lon)

{

    int i, shift, vel;

    int16_t tmuli;

    int temp, temp1, temp2, temp3, temp4, temp5, temp6, temp7;



    tmuli = (dynrng & 0x1f) + 0x20;

    shift = 4 - ((dynrng << 23) >> 28);

    if (shift > 0 ) {

      vel = 1 << (shift-1);

      for (i=0; i<lon; i+=8) {



          temp = src[i] * tmuli;

          temp1 = src[i+1] * tmuli;

          temp = temp + vel;

          temp2 = src[i+2] * tmuli;



          temp1 = temp1 + vel;

          dst[i] = temp >> shift;

          temp3 = src[i+3] * tmuli;

          temp2 = temp2 + vel;



          dst[i+1] = temp1 >> shift;

          temp4 = src[i + 4] * tmuli;

          temp3 = temp3 + vel;

          dst[i+2] = temp2 >> shift;



          temp5 = src[i+5] * tmuli;

          temp4 = temp4 + vel;

          dst[i+3] = temp3 >> shift;

          temp6 = src[i+6] * tmuli;



          dst[i+4] = temp4 >> shift;

          temp5 = temp5 + vel;

          temp7 = src[i+7] * tmuli;

          temp6 = temp6 + vel;



          dst[i+5] = temp5 >> shift;

          temp7 = temp7 + vel;

          dst[i+6] = temp6 >> shift;

          dst[i+7] = temp7 >> shift;



      }

    } else {

      shift = -shift;

      for (i=0; i<lon; i+=8) {



          temp = src[i] * tmuli;

          temp1 = src[i+1] * tmuli;

          temp2 = src[i+2] * tmuli;



          dst[i] = temp << shift;

          temp3 = src[i+3] * tmuli;



          dst[i+1] = temp1 << shift;

          temp4 = src[i + 4] * tmuli;

          dst[i+2] = temp2 << shift;



          temp5 = src[i+5] * tmuli;

          dst[i+3] = temp3 << shift;

          temp6 = src[i+6] * tmuli;



          dst[i+4] = temp4 << shift;

          temp7 = src[i+7] * tmuli;



          dst[i+5] = temp5 << shift;

          dst[i+6] = temp6 << shift;

          dst[i+7] = temp7 << shift;



      }

    }

}
",1,1,0.0,1,"dst,src,dynrng,len,i,shift,round,mul,temp,temp1,temp2,temp3,temp4,temp5,temp6,temp7","dst:-0.043899357318878174,src:-0.07688170671463013,dynrng:-0.0944557785987854,len:-0.029321670532226562,i:-0.05315202474594116,shift:-0.05631709098815918,round:0.08700627088546753,mul:0.0532912015914917,temp:-0.07882219552993774,temp1:-0.23038405179977417,temp2:-0.2103182077407837,temp3:-0.22361022233963013,temp4:-0.21402829885482788,temp5:-0.18540352582931519,temp6:-0.16350120306015015,temp7:-0.17561566829681396,",3.0,31.0,"round:vel,mul:tmuli,len:lon,",Greedy,410,0.2883185505867004
339,"void vnc_sasl_client_cleanup(VncState *vs)

{

    if (vs->sasl.conn) {

        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;

        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;

        vs->sasl.encoded = NULL;

        g_free(vs->sasl.username);

        free(vs->sasl.mechlist);

        vs->sasl.username = vs->sasl.mechlist = NULL;

        sasl_dispose(&vs->sasl.conn);

        vs->sasl.conn = NULL;

    }

}
",111,"void vnc_sasl_client_cleanup(VncState *flags)

{

    if (flags->sasl.conn) {

        flags->sasl.runSSF = flags->sasl.waitWriteSSF = flags->sasl.wantSSF = 0;

        flags->sasl.encodedLength = flags->sasl.encodedOffset = 0;

        flags->sasl.encoded = NULL;

        g_free(flags->sasl.username);

        free(flags->sasl.mechlist);

        flags->sasl.username = flags->sasl.mechlist = NULL;

        sasl_dispose(&flags->sasl.conn);

        flags->sasl.conn = NULL;

    }

}
",1,1,0.0,1,vs,"vs:-0.01233530044555664,",1.0,14.0,"vs:flags,",Greedy,87,0.0484723965326945
340,"static int integratorcm_init(SysBusDevice *dev)

{

    IntegratorCMState *s = INTEGRATOR_CM(dev);



    s->cm_osc = 0x01000048;

    /* ??? What should the high bits of this value be?  */

    s->cm_auxosc = 0x0007feff;

    s->cm_sdram = 0x00011122;

    if (s->memsz >= 256) {

        integrator_spd[31] = 64;

        s->cm_sdram |= 0x10;

    } else if (s->memsz >= 128) {

        integrator_spd[31] = 32;

        s->cm_sdram |= 0x0c;

    } else if (s->memsz >= 64) {

        integrator_spd[31] = 16;

        s->cm_sdram |= 0x08;

    } else if (s->memsz >= 32) {

        integrator_spd[31] = 4;

        s->cm_sdram |= 0x04;

    } else {

        integrator_spd[31] = 2;

    }

    memcpy(integrator_spd + 73, ""QEMU-MEMORY"", 11);

    s->cm_init = 0x00000112;

    s->cm_refcnt_offset = muldiv64(qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL), 24,

                                   1000);

    memory_region_init_ram(&s->flash, OBJECT(s), ""integrator.flash"", 0x100000,

                           &error_abort);

    vmstate_register_ram_global(&s->flash);



    memory_region_init_io(&s->iomem, OBJECT(s), &integratorcm_ops, s,

                          ""integratorcm"", 0x00800000);

    sysbus_init_mmio(dev, &s->iomem);



    integratorcm_do_remap(s);

    /* ??? Save/restore.  */

    return 0;

}
",246,"static int integratorcm_init(SysBusDevice *dev)

{

    IntegratorCMState *xxx = INTEGRATOR_CM(dev);



    xxx->cm_osc = 0x01000048;

    /* ??? What should the high bits of this value be?  */

    xxx->cm_auxosc = 0x0007feff;

    xxx->cm_sdram = 0x00011122;

    if (xxx->memsz >= 256) {

        integrator_spd[31] = 64;

        xxx->cm_sdram |= 0x10;

    } else if (xxx->memsz >= 128) {

        integrator_spd[31] = 32;

        xxx->cm_sdram |= 0x0c;

    } else if (xxx->memsz >= 64) {

        integrator_spd[31] = 16;

        xxx->cm_sdram |= 0x08;

    } else if (xxx->memsz >= 32) {

        integrator_spd[31] = 4;

        xxx->cm_sdram |= 0x04;

    } else {

        integrator_spd[31] = 2;

    }

    memcpy(integrator_spd + 73, ""QEMU-MEMORY"", 11);

    xxx->cm_init = 0x00000112;

    xxx->cm_refcnt_offset = muldiv64(qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL), 24,

                                   1000);

    memory_region_init_ram(&xxx->flash, OBJECT(xxx), ""integrator.flash"", 0x100000,

                           &error_abort);

    vmstate_register_ram_global(&xxx->flash);



    memory_region_init_io(&xxx->iomem, OBJECT(xxx), &integratorcm_ops, xxx,

                          ""integratorcm"", 0x00800000);

    sysbus_init_mmio(dev, &xxx->iomem);



    integratorcm_do_remap(xxx);

    /* ??? Save/restore.  */

    return 0;

}
",1,1,0.0,1,"dev,s","dev:0.009722977876663208,s:0.106987863779068,",1.0,22.0,"s:xxx,",Greedy,107,0.0787368734677632
353,"static inline void RENAME(planar2x)(const uint8_t *src, uint8_t *dst, long srcWidth, long srcHeight, long srcStride, long dstStride)

{

	long x,y;



	dst[0]= src[0];



	// first line

	for(x=0; x<srcWidth-1; x++){

		dst[2*x+1]= (3*src[x] +   src[x+1])>>2;

		dst[2*x+2]= (  src[x] + 3*src[x+1])>>2;

	}

	dst[2*srcWidth-1]= src[srcWidth-1];



        dst+= dstStride;



	for(y=1; y<srcHeight; y++){

#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)

		const long mmxSize= srcWidth&~15;

		asm volatile(

			""mov %4, %%""REG_a""		\n\t""

			""1:				\n\t""

			""movq (%0, %%""REG_a""), %%mm0	\n\t""

			""movq (%1, %%""REG_a""), %%mm1	\n\t""

			""movq 1(%0, %%""REG_a""), %%mm2	\n\t""

			""movq 1(%1, %%""REG_a""), %%mm3	\n\t""

			""movq -1(%0, %%""REG_a""), %%mm4	\n\t""

			""movq -1(%1, %%""REG_a""), %%mm5	\n\t""

			PAVGB"" %%mm0, %%mm5		\n\t""

			PAVGB"" %%mm0, %%mm3		\n\t""

			PAVGB"" %%mm0, %%mm5		\n\t""

			PAVGB"" %%mm0, %%mm3		\n\t""

			PAVGB"" %%mm1, %%mm4		\n\t""

			PAVGB"" %%mm1, %%mm2		\n\t""

			PAVGB"" %%mm1, %%mm4		\n\t""

			PAVGB"" %%mm1, %%mm2		\n\t""

			""movq %%mm5, %%mm7		\n\t""

			""movq %%mm4, %%mm6		\n\t""

			""punpcklbw %%mm3, %%mm5		\n\t""

			""punpckhbw %%mm3, %%mm7		\n\t""

			""punpcklbw %%mm2, %%mm4		\n\t""

			""punpckhbw %%mm2, %%mm6		\n\t""

#if 1

			MOVNTQ"" %%mm5, (%2, %%""REG_a"", 2)\n\t""

			MOVNTQ"" %%mm7, 8(%2, %%""REG_a"", 2)\n\t""

			MOVNTQ"" %%mm4, (%3, %%""REG_a"", 2)\n\t""

			MOVNTQ"" %%mm6, 8(%3, %%""REG_a"", 2)\n\t""

#else

			""movq %%mm5, (%2, %%""REG_a"", 2)	\n\t""

			""movq %%mm7, 8(%2, %%""REG_a"", 2)\n\t""

			""movq %%mm4, (%3, %%""REG_a"", 2)	\n\t""

			""movq %%mm6, 8(%3, %%""REG_a"", 2)\n\t""

#endif

			""add $8, %%""REG_a""		\n\t""

			"" js 1b				\n\t""

			:: ""r"" (src + mmxSize  ), ""r"" (src + srcStride + mmxSize  ),

			   ""r"" (dst + mmxSize*2), ""r"" (dst + dstStride + mmxSize*2),

			   ""g"" (-mmxSize)

			: ""%""REG_a



		);

#else

		const long mmxSize=1;

#endif

		dst[0        ]= (3*src[0] +   src[srcStride])>>2;

		dst[dstStride]= (  src[0] + 3*src[srcStride])>>2;



		for(x=mmxSize-1; x<srcWidth-1; x++){

			dst[2*x          +1]= (3*src[x+0] +   src[x+srcStride+1])>>2;

			dst[2*x+dstStride+2]= (  src[x+0] + 3*src[x+srcStride+1])>>2;

			dst[2*x+dstStride+1]= (  src[x+1] + 3*src[x+srcStride  ])>>2;

			dst[2*x          +2]= (3*src[x+1] +   src[x+srcStride  ])>>2;

		}

		dst[srcWidth*2 -1            ]= (3*src[srcWidth-1] +   src[srcWidth-1 + srcStride])>>2;

		dst[srcWidth*2 -1 + dstStride]= (  src[srcWidth-1] + 3*src[srcWidth-1 + srcStride])>>2;



		dst+=dstStride*2;

		src+=srcStride;

	}



	// last line

#if 1

	dst[0]= src[0];



	for(x=0; x<srcWidth-1; x++){

		dst[2*x+1]= (3*src[x] +   src[x+1])>>2;

		dst[2*x+2]= (  src[x] + 3*src[x+1])>>2;

	}

	dst[2*srcWidth-1]= src[srcWidth-1];

#else

	for(x=0; x<srcWidth; x++){

		dst[2*x+0]=

		dst[2*x+1]= src[x];

	}

#endif



#ifdef HAVE_MMX

asm volatile(   EMMS"" \n\t""

        	SFENCE"" \n\t""

        	:::""memory"");

#endif

}
",819,"static inline void RENAME(planar2x)(const uint8_t *src, uint8_t *dst, long srcWidth, long srcHeight, long srcStride, long dstStride)

{

	long px,type;



	dst[0]= src[0];



	// first line

	for(px=0; px<srcWidth-1; px++){

		dst[2*px+1]= (3*src[px] +   src[px+1])>>2;

		dst[2*px+2]= (  src[px] + 3*src[px+1])>>2;

	}

	dst[2*srcWidth-1]= src[srcWidth-1];



        dst+= dstStride;



	for(type=1; type<srcHeight; type++){

#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)

		const long mmxSize= srcWidth&~15;

		asm volatile(

			""mov %4, %%""REG_a""		
\t""

			""1:				
\t""

			""movq (%0, %%""REG_a""), %%mm0	
\t""

			""movq (%1, %%""REG_a""), %%mm1	
\t""

			""movq 1(%0, %%""REG_a""), %%mm2	
\t""

			""movq 1(%1, %%""REG_a""), %%mm3	
\t""

			""movq -1(%0, %%""REG_a""), %%mm4	
\t""

			""movq -1(%1, %%""REG_a""), %%mm5	
\t""

			PAVGB"" %%mm0, %%mm5		
\t""

			PAVGB"" %%mm0, %%mm3		
\t""

			PAVGB"" %%mm0, %%mm5		
\t""

			PAVGB"" %%mm0, %%mm3		
\t""

			PAVGB"" %%mm1, %%mm4		
\t""

			PAVGB"" %%mm1, %%mm2		
\t""

			PAVGB"" %%mm1, %%mm4		
\t""

			PAVGB"" %%mm1, %%mm2		
\t""

			""movq %%mm5, %%mm7		
\t""

			""movq %%mm4, %%mm6		
\t""

			""punpcklbw %%mm3, %%mm5		
\t""

			""punpckhbw %%mm3, %%mm7		
\t""

			""punpcklbw %%mm2, %%mm4		
\t""

			""punpckhbw %%mm2, %%mm6		
\t""

#if 1

			MOVNTQ"" %%mm5, (%2, %%""REG_a"", 2)
\t""

			MOVNTQ"" %%mm7, 8(%2, %%""REG_a"", 2)
\t""

			MOVNTQ"" %%mm4, (%3, %%""REG_a"", 2)
\t""

			MOVNTQ"" %%mm6, 8(%3, %%""REG_a"", 2)
\t""

#else

			""movq %%mm5, (%2, %%""REG_a"", 2)	
\t""

			""movq %%mm7, 8(%2, %%""REG_a"", 2)
\t""

			""movq %%mm4, (%3, %%""REG_a"", 2)	
\t""

			""movq %%mm6, 8(%3, %%""REG_a"", 2)
\t""

#endif

			""add $8, %%""REG_a""		
\t""

			"" js 1b				
\t""

			:: ""r"" (src + mmxSize  ), ""r"" (src + srcStride + mmxSize  ),

			   ""r"" (dst + mmxSize*2), ""r"" (dst + dstStride + mmxSize*2),

			   ""g"" (-mmxSize)

			: ""%""REG_a



		);

#else

		const long mmxSize=1;

#endif

		dst[0        ]= (3*src[0] +   src[srcStride])>>2;

		dst[dstStride]= (  src[0] + 3*src[srcStride])>>2;



		for(px=mmxSize-1; px<srcWidth-1; px++){

			dst[2*px          +1]= (3*src[px+0] +   src[px+srcStride+1])>>2;

			dst[2*px+dstStride+2]= (  src[px+0] + 3*src[px+srcStride+1])>>2;

			dst[2*px+dstStride+1]= (  src[px+1] + 3*src[px+srcStride  ])>>2;

			dst[2*px          +2]= (3*src[px+1] +   src[px+srcStride  ])>>2;

		}

		dst[srcWidth*2 -1            ]= (3*src[srcWidth-1] +   src[srcWidth-1 + srcStride])>>2;

		dst[srcWidth*2 -1 + dstStride]= (  src[srcWidth-1] + 3*src[srcWidth-1 + srcStride])>>2;



		dst+=dstStride*2;

		src+=srcStride;

	}



	// last line

#if 1

	dst[0]= src[0];



	for(px=0; px<srcWidth-1; px++){

		dst[2*px+1]= (3*src[px] +   src[px+1])>>2;

		dst[2*px+2]= (  src[px] + 3*src[px+1])>>2;

	}

	dst[2*srcWidth-1]= src[srcWidth-1];

#else

	for(px=0; px<srcWidth; px++){

		dst[2*px+0]=

		dst[2*px+1]= src[px];

	}

#endif



#ifdef HAVE_MMX

asm volatile(   EMMS"" 
\t""

        	SFENCE"" 
\t""

        	:::""memory"");

#endif

}
",1,1,0.0,1,"src,dst,srcWidth,srcHeight,srcStride,dstStride,x,y","src:-0.07523542642593384,dst:-0.03059476613998413,srcWidth:-0.07859301567077637,srcHeight:-0.017896056175231934,srcStride:-0.025890827178955078,dstStride:-0.06920099258422852,x:0.0038911104202270508,y:-0.00013637542724609375,",2.0,44.0,"x:px,y:type,",Greedy,254,0.1897884130477905
356,"static int huff_build10(VLC *vlc, uint8_t *len)

{

    HuffEntry he[1024];

    uint32_t codes[1024];

    uint8_t bits[1024];

    uint16_t syms[1024];

    uint32_t code;

    int i;



    for (i = 0; i < 1024; i++) {

        he[i].sym = 1023 - i;

        he[i].len = len[i];



    }

    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);



    code = 1;

    for (i = 1023; i >= 0; i--) {

        codes[i] = code >> (32 - he[i].len);

        bits[i]  = he[i].len;

        syms[i]  = he[i].sym;

        code += 0x80000000u >> (he[i].len - 1);

    }



    ff_free_vlc(vlc);

    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,

                              bits,  sizeof(*bits),  sizeof(*bits),

                              codes, sizeof(*codes), sizeof(*codes),

                              syms,  sizeof(*syms),  sizeof(*syms), 0);

}",238,"static int huff_build10(VLC *vrpc, uint8_t *lon)

{

    HuffEntry he[1024];

    uint32_t codes[1024];

    uint8_t bits[1024];

    uint16_t asyns[1024];

    uint32_t code;

    int cli;



    for (cli = 0; cli < 1024; cli++) {

        he[cli].sym = 1023 - cli;

        he[cli].lon = lon[cli];



    }

    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);



    code = 1;

    for (cli = 1023; cli >= 0; cli--) {

        codes[cli] = code >> (32 - he[cli].lon);

        bits[cli]  = he[cli].lon;

        asyns[cli]  = he[cli].sym;

        code += 0x80000000u >> (he[cli].lon - 1);

    }



    ff_free_vlc(vrpc);

    return ff_init_vlc_sparse(vrpc, FFMIN(he[1023].lon, 12), 1024,

                              bits,  sizeof(*bits),  sizeof(*bits),

                              codes, sizeof(*codes), sizeof(*codes),

                              asyns,  sizeof(*asyns),  sizeof(*asyns), 0);

}",1,1,0.0,1,"vlc,len,he,codes,bits,syms,code,i","vlc:0.2238406538963318,len:0.1074933409690857,he:0.07951822876930237,codes:0.05859050154685974,bits:0.06173616647720337,syms:0.12749120593070984,code:0.03969597816467285,i:0.10811617970466614,",4.0,33.0,"vlc:vrpc,syms:asyns,i:cli,len:lon,",Greedy,285,0.1930723945299784
360,"static int wsvqa_read_header(AVFormatContext *s,

                             AVFormatParameters *ap)

{

    WsVqaDemuxContext *wsvqa = s->priv_data;

    AVIOContext *pb = s->pb;

    AVStream *st;

    unsigned char *header;

    unsigned char scratch[VQA_PREAMBLE_SIZE];

    unsigned int chunk_tag;

    unsigned int chunk_size;



    /* initialize the video decoder stream */

    st = av_new_stream(s, 0);

    if (!st)

        return AVERROR(ENOMEM);

    av_set_pts_info(st, 33, 1, VQA_FRAMERATE);

    wsvqa->video_stream_index = st->index;

    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;

    st->codec->codec_id = CODEC_ID_WS_VQA;

    st->codec->codec_tag = 0;  /* no fourcc */



    /* skip to the start of the VQA header */

    avio_seek(pb, 20, SEEK_SET);



    /* the VQA header needs to go to the decoder */

    st->codec->extradata_size = VQA_HEADER_SIZE;

    st->codec->extradata = av_mallocz(VQA_HEADER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);

    header = (unsigned char *)st->codec->extradata;

    if (avio_read(pb, st->codec->extradata, VQA_HEADER_SIZE) !=

        VQA_HEADER_SIZE) {

        av_free(st->codec->extradata);

        return AVERROR(EIO);

    }

    st->codec->width = AV_RL16(&header[6]);

    st->codec->height = AV_RL16(&header[8]);



    /* initialize the audio decoder stream for VQA v1 or nonzero samplerate */

    if (AV_RL16(&header[24]) || (AV_RL16(&header[0]) == 1 && AV_RL16(&header[2]) == 1)) {

        st = av_new_stream(s, 0);

        if (!st)

            return AVERROR(ENOMEM);

        av_set_pts_info(st, 33, 1, VQA_FRAMERATE);

        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;

        if (AV_RL16(&header[0]) == 1)

            st->codec->codec_id = CODEC_ID_WESTWOOD_SND1;

        else

            st->codec->codec_id = CODEC_ID_ADPCM_IMA_WS;

        st->codec->codec_tag = 0;  /* no tag */

        st->codec->sample_rate = AV_RL16(&header[24]);

        if (!st->codec->sample_rate)

            st->codec->sample_rate = 22050;

        st->codec->channels = header[26];

        if (!st->codec->channels)

            st->codec->channels = 1;

        st->codec->bits_per_coded_sample = 16;

        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *

            st->codec->bits_per_coded_sample / 4;

        st->codec->block_align = st->codec->channels * st->codec->bits_per_coded_sample;



        wsvqa->audio_stream_index = st->index;

        wsvqa->audio_samplerate = st->codec->sample_rate;

        wsvqa->audio_channels = st->codec->channels;

        wsvqa->audio_frame_counter = 0;

    }



    /* there are 0 or more chunks before the FINF chunk; iterate until

     * FINF has been skipped and the file will be ready to be demuxed */

    do {

        if (avio_read(pb, scratch, VQA_PREAMBLE_SIZE) != VQA_PREAMBLE_SIZE) {

            av_free(st->codec->extradata);

            return AVERROR(EIO);

        }

        chunk_tag = AV_RB32(&scratch[0]);

        chunk_size = AV_RB32(&scratch[4]);



        /* catch any unknown header tags, for curiousity */

        switch (chunk_tag) {

        case CINF_TAG:

        case CINH_TAG:

        case CIND_TAG:

        case PINF_TAG:

        case PINH_TAG:

        case PIND_TAG:

        case FINF_TAG:

        case CMDS_TAG:

            break;



        default:

            av_log (s, AV_LOG_ERROR, "" note: unknown chunk seen (%c%c%c%c)\n"",

                scratch[0], scratch[1],

                scratch[2], scratch[3]);

            break;

        }



        avio_skip(pb, chunk_size);

    } while (chunk_tag != FINF_TAG);



    return 0;

}
",622,"static int wsvqa_read_header(AVFormatContext *s,

                             AVFormatParameters *ap)

{

    WsVqaDemuxContext *wsvqa = s->priv_data;

    AVIOContext *pb = s->pb;

    AVStream *st;

    unsigned char *header;

    unsigned char encores[VQA_PREAMBLE_SIZE];

    unsigned int chunk_tag;

    unsigned int chunks_SIZE;



    /* initialize the video decoder stream */

    st = av_new_stream(s, 0);

    if (!st)

        return AVERROR(ENOMEM);

    av_set_pts_info(st, 33, 1, VQA_FRAMERATE);

    wsvqa->video_stream_index = st->index;

    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;

    st->codec->codec_id = CODEC_ID_WS_VQA;

    st->codec->codec_tag = 0;  /* no fourcc */



    /* skip to the start of the VQA header */

    avio_seek(pb, 20, SEEK_SET);



    /* the VQA header needs to go to the decoder */

    st->codec->extradata_size = VQA_HEADER_SIZE;

    st->codec->extradata = av_mallocz(VQA_HEADER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);

    header = (unsigned char *)st->codec->extradata;

    if (avio_read(pb, st->codec->extradata, VQA_HEADER_SIZE) !=

        VQA_HEADER_SIZE) {

        av_free(st->codec->extradata);

        return AVERROR(EIO);

    }

    st->codec->width = AV_RL16(&header[6]);

    st->codec->height = AV_RL16(&header[8]);



    /* initialize the audio decoder stream for VQA v1 or nonzero samplerate */

    if (AV_RL16(&header[24]) || (AV_RL16(&header[0]) == 1 && AV_RL16(&header[2]) == 1)) {

        st = av_new_stream(s, 0);

        if (!st)

            return AVERROR(ENOMEM);

        av_set_pts_info(st, 33, 1, VQA_FRAMERATE);

        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;

        if (AV_RL16(&header[0]) == 1)

            st->codec->codec_id = CODEC_ID_WESTWOOD_SND1;

        else

            st->codec->codec_id = CODEC_ID_ADPCM_IMA_WS;

        st->codec->codec_tag = 0;  /* no tag */

        st->codec->sample_rate = AV_RL16(&header[24]);

        if (!st->codec->sample_rate)

            st->codec->sample_rate = 22050;

        st->codec->channels = header[26];

        if (!st->codec->channels)

            st->codec->channels = 1;

        st->codec->bits_per_coded_sample = 16;

        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *

            st->codec->bits_per_coded_sample / 4;

        st->codec->block_align = st->codec->channels * st->codec->bits_per_coded_sample;



        wsvqa->audio_stream_index = st->index;

        wsvqa->audio_samplerate = st->codec->sample_rate;

        wsvqa->audio_channels = st->codec->channels;

        wsvqa->audio_frame_counter = 0;

    }



    /* there are 0 or more chunks before the FINF chunk; iterate until

     * FINF has been skipped and the file will be ready to be demuxed */

    do {

        if (avio_read(pb, encores, VQA_PREAMBLE_SIZE) != VQA_PREAMBLE_SIZE) {

            av_free(st->codec->extradata);

            return AVERROR(EIO);

        }

        chunk_tag = AV_RB32(&encores[0]);

        chunks_SIZE = AV_RB32(&encores[4]);



        /* catch any unknown header tags, for curiousity */

        switch (chunk_tag) {

        case CINF_TAG:

        case CINH_TAG:

        case CIND_TAG:

        case PINF_TAG:

        case PINH_TAG:

        case PIND_TAG:

        case FINF_TAG:

        case CMDS_TAG:

            break;



        default:

            av_log (s, AV_LOG_ERROR, "" note: unknown chunk seen (%c%c%c%c)
"",

                encores[0], encores[1],

                encores[2], encores[3]);

            break;

        }



        avio_skip(pb, chunks_SIZE);

    } while (chunk_tag != FINF_TAG);



    return 0;

}
",1,1,0.0,1,"s,ap,wsvqa,pb,st,header,scratch,chunk_tag,chunk_size","s:-0.041012704372406006,ap:-0.0368269681930542,wsvqa:-0.02436298131942749,pb:-0.03667086362838745,st:-0.01642709970474243,header:-0.01700294017791748,scratch:0.010544240474700928,chunk_tag:-0.0004240274429321289,chunk_size:0.0039035677909851074,",2.0,11.0,"scratch:encores,chunk_size:chunks_SIZE,",Greedy,103,0.0825115839640299
369,"static void cpu_devinit(const char *cpu_model, unsigned int id,

                        uint64_t prom_addr, qemu_irq **cpu_irqs)

{

    CPUState *cs;

    SPARCCPU *cpu;

    CPUSPARCState *env;



    cpu = SPARC_CPU(cpu_generic_init(TYPE_SPARC_CPU, cpu_model));

    if (cpu == NULL) {

        fprintf(stderr, ""qemu: Unable to find Sparc CPU definition\n"");

        exit(1);

    }

    env = &cpu->env;



    cpu_sparc_set_id(env, id);

    if (id == 0) {

        qemu_register_reset(main_cpu_reset, cpu);

    } else {

        qemu_register_reset(secondary_cpu_reset, cpu);

        cs = CPU(cpu);

        cs->halted = 1;

    }

    *cpu_irqs = qemu_allocate_irqs(cpu_set_irq, cpu, MAX_PILS);

    env->prom_addr = prom_addr;

}
",138,"static void cpu_devinit(const char *cpu_model, unsigned int id,

                        uint64_t prom_addr, qemu_irq **cpu_irqs)

{

    CPUState *pc;

    SPARCCPU *cpu;

    CPUSPARCState *env;



    cpu = SPARC_CPU(cpu_generic_init(TYPE_SPARC_CPU, cpu_model));

    if (cpu == NULL) {

        fprintf(stderr, ""qemu: Unable to find Sparc CPU definition
"");

        exit(1);

    }

    env = &cpu->env;



    cpu_sparc_set_id(env, id);

    if (id == 0) {

        qemu_register_reset(main_cpu_reset, cpu);

    } else {

        qemu_register_reset(secondary_cpu_reset, cpu);

        pc = CPU(cpu);

        pc->halted = 1;

    }

    *cpu_irqs = qemu_allocate_irqs(cpu_set_irq, cpu, MAX_PILS);

    env->prom_addr = prom_addr;

}
",1,1,0.0,1,"cpu_model,id,prom_addr,cpu_irqs,cs,cpu,env","cpu_model:0.02358722686767578,id:0.010913968086242676,prom_addr:-0.1166316568851471,cpu_irqs:0.08710038661956787,cs:0.10077545046806335,cpu:-0.040264666080474854,env:0.046293675899505615,",1.0,3.0,"cs:pc,",Greedy,67,0.0498117049535115
378,"static int vp9_decode_frame(AVCodecContext *ctx, void *frame,

                            int *got_frame, AVPacket *pkt)

{

    const uint8_t *data = pkt->data;

    int size = pkt->size;

    VP9Context *s = ctx->priv_data;

    int res, tile_row, tile_col, i, ref, row, col;

    int retain_segmap_ref = s->s.frames[REF_FRAME_SEGMAP].segmentation_map &&

                            (!s->s.h.segmentation.enabled || !s->s.h.segmentation.update_map);

    ptrdiff_t yoff, uvoff, ls_y, ls_uv;

    AVFrame *f;

    int bytesperpixel;



    if ((res = decode_frame_header(ctx, data, size, &ref)) < 0) {

        return res;

    } else if (res == 0) {

        if (!s->s.refs[ref].f->buf[0]) {

            av_log(ctx, AV_LOG_ERROR, ""Requested reference %d not available\n"", ref);

            return AVERROR_INVALIDDATA;

        }

        if ((res = av_frame_ref(frame, s->s.refs[ref].f)) < 0)

            return res;

        ((AVFrame *)frame)->pts = pkt->pts;

#if FF_API_PKT_PTS

FF_DISABLE_DEPRECATION_WARNINGS

        ((AVFrame *)frame)->pkt_pts = pkt->pts;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

        ((AVFrame *)frame)->pkt_dts = pkt->dts;

        for (i = 0; i < 8; i++) {

            if (s->next_refs[i].f->buf[0])

                ff_thread_release_buffer(ctx, &s->next_refs[i]);

            if (s->s.refs[i].f->buf[0] &&

                (res = ff_thread_ref_frame(&s->next_refs[i], &s->s.refs[i])) < 0)

                return res;

        }

        *got_frame = 1;

        return pkt->size;

    }

    data += res;

    size -= res;



    if (!retain_segmap_ref || s->s.h.keyframe || s->s.h.intraonly) {

        if (s->s.frames[REF_FRAME_SEGMAP].tf.f->buf[0])

            vp9_unref_frame(ctx, &s->s.frames[REF_FRAME_SEGMAP]);

        if (!s->s.h.keyframe && !s->s.h.intraonly && !s->s.h.errorres && s->s.frames[CUR_FRAME].tf.f->buf[0] &&

            (res = vp9_ref_frame(ctx, &s->s.frames[REF_FRAME_SEGMAP], &s->s.frames[CUR_FRAME])) < 0)

            return res;

    }

    if (s->s.frames[REF_FRAME_MVPAIR].tf.f->buf[0])

        vp9_unref_frame(ctx, &s->s.frames[REF_FRAME_MVPAIR]);

    if (!s->s.h.intraonly && !s->s.h.keyframe && !s->s.h.errorres && s->s.frames[CUR_FRAME].tf.f->buf[0] &&

        (res = vp9_ref_frame(ctx, &s->s.frames[REF_FRAME_MVPAIR], &s->s.frames[CUR_FRAME])) < 0)

        return res;

    if (s->s.frames[CUR_FRAME].tf.f->buf[0])

        vp9_unref_frame(ctx, &s->s.frames[CUR_FRAME]);

    if ((res = vp9_alloc_frame(ctx, &s->s.frames[CUR_FRAME])) < 0)

        return res;

    f = s->s.frames[CUR_FRAME].tf.f;

    f->key_frame = s->s.h.keyframe;

    f->pict_type = (s->s.h.keyframe || s->s.h.intraonly) ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;

    ls_y = f->linesize[0];

    ls_uv =f->linesize[1];



    if (s->s.frames[REF_FRAME_SEGMAP].tf.f->buf[0] &&

        (s->s.frames[REF_FRAME_MVPAIR].tf.f->width  != s->s.frames[CUR_FRAME].tf.f->width ||

         s->s.frames[REF_FRAME_MVPAIR].tf.f->height != s->s.frames[CUR_FRAME].tf.f->height)) {

        vp9_unref_frame(ctx, &s->s.frames[REF_FRAME_SEGMAP]);

    }



    // ref frame setup

    for (i = 0; i < 8; i++) {

        if (s->next_refs[i].f->buf[0])

            ff_thread_release_buffer(ctx, &s->next_refs[i]);

        if (s->s.h.refreshrefmask & (1 << i)) {

            res = ff_thread_ref_frame(&s->next_refs[i], &s->s.frames[CUR_FRAME].tf);

        } else if (s->s.refs[i].f->buf[0]) {

            res = ff_thread_ref_frame(&s->next_refs[i], &s->s.refs[i]);

        }

        if (res < 0)

            return res;

    }



    if (ctx->hwaccel) {

        res = ctx->hwaccel->start_frame(ctx, NULL, 0);

        if (res < 0)

            return res;

        res = ctx->hwaccel->decode_slice(ctx, pkt->data, pkt->size);

        if (res < 0)

            return res;

        res = ctx->hwaccel->end_frame(ctx);

        if (res < 0)

            return res;

        goto finish;

    }



    // main tile decode loop

    bytesperpixel = s->bytesperpixel;

    memset(s->above_partition_ctx, 0, s->cols);

    memset(s->above_skip_ctx, 0, s->cols);

    if (s->s.h.keyframe || s->s.h.intraonly) {

        memset(s->above_mode_ctx, DC_PRED, s->cols * 2);

    } else {

        memset(s->above_mode_ctx, NEARESTMV, s->cols);

    }

    memset(s->above_y_nnz_ctx, 0, s->sb_cols * 16);

    memset(s->above_uv_nnz_ctx[0], 0, s->sb_cols * 16 >> s->ss_h);

    memset(s->above_uv_nnz_ctx[1], 0, s->sb_cols * 16 >> s->ss_h);

    memset(s->above_segpred_ctx, 0, s->cols);

    s->pass = s->s.frames[CUR_FRAME].uses_2pass =

        ctx->active_thread_type == FF_THREAD_FRAME && s->s.h.refreshctx && !s->s.h.parallelmode;

    if ((res = update_block_buffers(ctx)) < 0) {

        av_log(ctx, AV_LOG_ERROR,

               ""Failed to allocate block buffers\n"");

        return res;

    }

    if (s->s.h.refreshctx && s->s.h.parallelmode) {

        int j, k, l, m;



        for (i = 0; i < 4; i++) {

            for (j = 0; j < 2; j++)

                for (k = 0; k < 2; k++)

                    for (l = 0; l < 6; l++)

                        for (m = 0; m < 6; m++)

                            memcpy(s->prob_ctx[s->s.h.framectxid].coef[i][j][k][l][m],

                                   s->prob.coef[i][j][k][l][m], 3);

            if (s->s.h.txfmmode == i)

                break;

        }

        s->prob_ctx[s->s.h.framectxid].p = s->prob.p;

        ff_thread_finish_setup(ctx);

    } else if (!s->s.h.refreshctx) {

        ff_thread_finish_setup(ctx);

    }



    do {

        yoff = uvoff = 0;

        s->b = s->b_base;

        s->block = s->block_base;

        s->uvblock[0] = s->uvblock_base[0];

        s->uvblock[1] = s->uvblock_base[1];

        s->eob = s->eob_base;

        s->uveob[0] = s->uveob_base[0];

        s->uveob[1] = s->uveob_base[1];



        for (tile_row = 0; tile_row < s->s.h.tiling.tile_rows; tile_row++) {

            set_tile_offset(&s->tile_row_start, &s->tile_row_end,

                            tile_row, s->s.h.tiling.log2_tile_rows, s->sb_rows);

            if (s->pass != 2) {

                for (tile_col = 0; tile_col < s->s.h.tiling.tile_cols; tile_col++) {

                    int64_t tile_size;



                    if (tile_col == s->s.h.tiling.tile_cols - 1 &&

                        tile_row == s->s.h.tiling.tile_rows - 1) {

                        tile_size = size;

                    } else {

                        tile_size = AV_RB32(data);

                        data += 4;

                        size -= 4;

                    }

                    if (tile_size > size) {

                        ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);

                        return AVERROR_INVALIDDATA;

                    }

                    ff_vp56_init_range_decoder(&s->c_b[tile_col], data, tile_size);

                    if (vp56_rac_get_prob_branchy(&s->c_b[tile_col], 128)) { // marker bit

                        ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);

                        return AVERROR_INVALIDDATA;

                    }

                    data += tile_size;

                    size -= tile_size;

                }

            }



            for (row = s->tile_row_start; row < s->tile_row_end;

                 row += 8, yoff += ls_y * 64, uvoff += ls_uv * 64 >> s->ss_v) {

                struct VP9Filter *lflvl_ptr = s->lflvl;

                ptrdiff_t yoff2 = yoff, uvoff2 = uvoff;



                for (tile_col = 0; tile_col < s->s.h.tiling.tile_cols; tile_col++) {

                    set_tile_offset(&s->tile_col_start, &s->tile_col_end,

                                    tile_col, s->s.h.tiling.log2_tile_cols, s->sb_cols);



                    if (s->pass != 2) {

                        memset(s->left_partition_ctx, 0, 8);

                        memset(s->left_skip_ctx, 0, 8);

                        if (s->s.h.keyframe || s->s.h.intraonly) {

                            memset(s->left_mode_ctx, DC_PRED, 16);

                        } else {

                            memset(s->left_mode_ctx, NEARESTMV, 8);

                        }

                        memset(s->left_y_nnz_ctx, 0, 16);

                        memset(s->left_uv_nnz_ctx, 0, 32);

                        memset(s->left_segpred_ctx, 0, 8);



                        memcpy(&s->c, &s->c_b[tile_col], sizeof(s->c));

                    }



                    for (col = s->tile_col_start;

                         col < s->tile_col_end;

                         col += 8, yoff2 += 64 * bytesperpixel,

                         uvoff2 += 64 * bytesperpixel >> s->ss_h, lflvl_ptr++) {

                        // FIXME integrate with lf code (i.e. zero after each

                        // use, similar to invtxfm coefficients, or similar)

                        if (s->pass != 1) {

                            memset(lflvl_ptr->mask, 0, sizeof(lflvl_ptr->mask));

                        }



                        if (s->pass == 2) {

                            decode_sb_mem(ctx, row, col, lflvl_ptr,

                                          yoff2, uvoff2, BL_64X64);

                        } else {

                            decode_sb(ctx, row, col, lflvl_ptr,

                                      yoff2, uvoff2, BL_64X64);

                        }

                    }

                    if (s->pass != 2) {

                        memcpy(&s->c_b[tile_col], &s->c, sizeof(s->c));

                    }

                }



                if (s->pass == 1) {

                    continue;

                }



                // backup pre-loopfilter reconstruction data for intra

                // prediction of next row of sb64s

                if (row + 8 < s->rows) {

                    memcpy(s->intra_pred_data[0],

                           f->data[0] + yoff + 63 * ls_y,

                           8 * s->cols * bytesperpixel);

                    memcpy(s->intra_pred_data[1],

                           f->data[1] + uvoff + ((64 >> s->ss_v) - 1) * ls_uv,

                           8 * s->cols * bytesperpixel >> s->ss_h);

                    memcpy(s->intra_pred_data[2],

                           f->data[2] + uvoff + ((64 >> s->ss_v) - 1) * ls_uv,

                           8 * s->cols * bytesperpixel >> s->ss_h);

                }



                // loopfilter one row

                if (s->s.h.filter.level) {

                    yoff2 = yoff;

                    uvoff2 = uvoff;

                    lflvl_ptr = s->lflvl;

                    for (col = 0; col < s->cols;

                         col += 8, yoff2 += 64 * bytesperpixel,

                         uvoff2 += 64 * bytesperpixel >> s->ss_h, lflvl_ptr++) {

                        loopfilter_sb(ctx, lflvl_ptr, row, col, yoff2, uvoff2);

                    }

                }



                // FIXME maybe we can make this more finegrained by running the

                // loopfilter per-block instead of after each sbrow

                // In fact that would also make intra pred left preparation easier?

                ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, row >> 3, 0);

            }

        }



        if (s->pass < 2 && s->s.h.refreshctx && !s->s.h.parallelmode) {

            adapt_probs(s);

            ff_thread_finish_setup(ctx);

        }

    } while (s->pass++ == 1);

    ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);



finish:

    // ref frame setup

    for (i = 0; i < 8; i++) {

        if (s->s.refs[i].f->buf[0])

            ff_thread_release_buffer(ctx, &s->s.refs[i]);

        if (s->next_refs[i].f->buf[0] &&

            (res = ff_thread_ref_frame(&s->s.refs[i], &s->next_refs[i])) < 0)

            return res;

    }



    if (!s->s.h.invisible) {

        if ((res = av_frame_ref(frame, s->s.frames[CUR_FRAME].tf.f)) < 0)

            return res;

        *got_frame = 1;

    }



    return pkt->size;

}
",2679,"static int vp9_decode_frame(AVCodecContext *linux, void *frame,

                            int *got_frame, AVPacket *pkt)

{

    const uint8_t *data = pkt->data;

    int size = pkt->size;

    VP9Context *s = linux->priv_data;

    int res, tile_row, tile_col, i, ref, row, col;

    int retain_segmap_ref = s->s.frames[REF_FRAME_SEGMAP].segmentation_map &&

                            (!s->s.h.segmentation.enabled || !s->s.h.segmentation.update_map);

    ptrdiff_t yoff, uvoff, ls_y, ls_uv;

    AVFrame *ff;

    int bytesperpixel;



    if ((res = decode_frame_header(linux, data, size, &ref)) < 0) {

        return res;

    } else if (res == 0) {

        if (!s->s.refs[ref].ff->buf[0]) {

            av_log(linux, AV_LOG_ERROR, ""Requested reference %d not available
"", ref);

            return AVERROR_INVALIDDATA;

        }

        if ((res = av_frame_ref(frame, s->s.refs[ref].ff)) < 0)

            return res;

        ((AVFrame *)frame)->pts = pkt->pts;

#if FF_API_PKT_PTS

FF_DISABLE_DEPRECATION_WARNINGS

        ((AVFrame *)frame)->pkt_pts = pkt->pts;

FF_ENABLE_DEPRECATION_WARNINGS

#endif

        ((AVFrame *)frame)->pkt_dts = pkt->dts;

        for (i = 0; i < 8; i++) {

            if (s->next_refs[i].ff->buf[0])

                ff_thread_release_buffer(linux, &s->next_refs[i]);

            if (s->s.refs[i].ff->buf[0] &&

                (res = ff_thread_ref_frame(&s->next_refs[i], &s->s.refs[i])) < 0)

                return res;

        }

        *got_frame = 1;

        return pkt->size;

    }

    data += res;

    size -= res;



    if (!retain_segmap_ref || s->s.h.keyframe || s->s.h.intraonly) {

        if (s->s.frames[REF_FRAME_SEGMAP].tf.ff->buf[0])

            vp9_unref_frame(linux, &s->s.frames[REF_FRAME_SEGMAP]);

        if (!s->s.h.keyframe && !s->s.h.intraonly && !s->s.h.errorres && s->s.frames[CUR_FRAME].tf.ff->buf[0] &&

            (res = vp9_ref_frame(linux, &s->s.frames[REF_FRAME_SEGMAP], &s->s.frames[CUR_FRAME])) < 0)

            return res;

    }

    if (s->s.frames[REF_FRAME_MVPAIR].tf.ff->buf[0])

        vp9_unref_frame(linux, &s->s.frames[REF_FRAME_MVPAIR]);

    if (!s->s.h.intraonly && !s->s.h.keyframe && !s->s.h.errorres && s->s.frames[CUR_FRAME].tf.ff->buf[0] &&

        (res = vp9_ref_frame(linux, &s->s.frames[REF_FRAME_MVPAIR], &s->s.frames[CUR_FRAME])) < 0)

        return res;

    if (s->s.frames[CUR_FRAME].tf.ff->buf[0])

        vp9_unref_frame(linux, &s->s.frames[CUR_FRAME]);

    if ((res = vp9_alloc_frame(linux, &s->s.frames[CUR_FRAME])) < 0)

        return res;

    ff = s->s.frames[CUR_FRAME].tf.ff;

    ff->key_frame = s->s.h.keyframe;

    ff->pict_type = (s->s.h.keyframe || s->s.h.intraonly) ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;

    ls_y = ff->linesize[0];

    ls_uv =ff->linesize[1];



    if (s->s.frames[REF_FRAME_SEGMAP].tf.ff->buf[0] &&

        (s->s.frames[REF_FRAME_MVPAIR].tf.ff->width  != s->s.frames[CUR_FRAME].tf.ff->width ||

         s->s.frames[REF_FRAME_MVPAIR].tf.ff->height != s->s.frames[CUR_FRAME].tf.ff->height)) {

        vp9_unref_frame(linux, &s->s.frames[REF_FRAME_SEGMAP]);

    }



    // ref frame setup

    for (i = 0; i < 8; i++) {

        if (s->next_refs[i].ff->buf[0])

            ff_thread_release_buffer(linux, &s->next_refs[i]);

        if (s->s.h.refreshrefmask & (1 << i)) {

            res = ff_thread_ref_frame(&s->next_refs[i], &s->s.frames[CUR_FRAME].tf);

        } else if (s->s.refs[i].ff->buf[0]) {

            res = ff_thread_ref_frame(&s->next_refs[i], &s->s.refs[i]);

        }

        if (res < 0)

            return res;

    }



    if (linux->hwaccel) {

        res = linux->hwaccel->start_frame(linux, NULL, 0);

        if (res < 0)

            return res;

        res = linux->hwaccel->decode_slice(linux, pkt->data, pkt->size);

        if (res < 0)

            return res;

        res = linux->hwaccel->end_frame(linux);

        if (res < 0)

            return res;

        goto finish;

    }



    // main tile decode loop

    bytesperpixel = s->bytesperpixel;

    memset(s->above_partition_ctx, 0, s->cols);

    memset(s->above_skip_ctx, 0, s->cols);

    if (s->s.h.keyframe || s->s.h.intraonly) {

        memset(s->above_mode_ctx, DC_PRED, s->cols * 2);

    } else {

        memset(s->above_mode_ctx, NEARESTMV, s->cols);

    }

    memset(s->above_y_nnz_ctx, 0, s->sb_cols * 16);

    memset(s->above_uv_nnz_ctx[0], 0, s->sb_cols * 16 >> s->ss_h);

    memset(s->above_uv_nnz_ctx[1], 0, s->sb_cols * 16 >> s->ss_h);

    memset(s->above_segpred_ctx, 0, s->cols);

    s->pass = s->s.frames[CUR_FRAME].uses_2pass =

        linux->active_thread_type == FF_THREAD_FRAME && s->s.h.refreshctx && !s->s.h.parallelmode;

    if ((res = update_block_buffers(linux)) < 0) {

        av_log(linux, AV_LOG_ERROR,

               ""Failed to allocate block buffers
"");

        return res;

    }

    if (s->s.h.refreshctx && s->s.h.parallelmode) {

        int j, k, l, m;



        for (i = 0; i < 4; i++) {

            for (j = 0; j < 2; j++)

                for (k = 0; k < 2; k++)

                    for (l = 0; l < 6; l++)

                        for (m = 0; m < 6; m++)

                            memcpy(s->prob_ctx[s->s.h.framectxid].coef[i][j][k][l][m],

                                   s->prob.coef[i][j][k][l][m], 3);

            if (s->s.h.txfmmode == i)

                break;

        }

        s->prob_ctx[s->s.h.framectxid].p = s->prob.p;

        ff_thread_finish_setup(linux);

    } else if (!s->s.h.refreshctx) {

        ff_thread_finish_setup(linux);

    }



    do {

        yoff = uvoff = 0;

        s->b = s->b_base;

        s->block = s->block_base;

        s->uvblock[0] = s->uvblock_base[0];

        s->uvblock[1] = s->uvblock_base[1];

        s->eob = s->eob_base;

        s->uveob[0] = s->uveob_base[0];

        s->uveob[1] = s->uveob_base[1];



        for (tile_row = 0; tile_row < s->s.h.tiling.tile_rows; tile_row++) {

            set_tile_offset(&s->tile_row_start, &s->tile_row_end,

                            tile_row, s->s.h.tiling.log2_tile_rows, s->sb_rows);

            if (s->pass != 2) {

                for (tile_col = 0; tile_col < s->s.h.tiling.tile_cols; tile_col++) {

                    int64_t tile_size;



                    if (tile_col == s->s.h.tiling.tile_cols - 1 &&

                        tile_row == s->s.h.tiling.tile_rows - 1) {

                        tile_size = size;

                    } else {

                        tile_size = AV_RB32(data);

                        data += 4;

                        size -= 4;

                    }

                    if (tile_size > size) {

                        ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);

                        return AVERROR_INVALIDDATA;

                    }

                    ff_vp56_init_range_decoder(&s->c_b[tile_col], data, tile_size);

                    if (vp56_rac_get_prob_branchy(&s->c_b[tile_col], 128)) { // marker bit

                        ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);

                        return AVERROR_INVALIDDATA;

                    }

                    data += tile_size;

                    size -= tile_size;

                }

            }



            for (row = s->tile_row_start; row < s->tile_row_end;

                 row += 8, yoff += ls_y * 64, uvoff += ls_uv * 64 >> s->ss_v) {

                struct VP9Filter *lflvl_ptr = s->lflvl;

                ptrdiff_t yoff2 = yoff, uvoff2 = uvoff;



                for (tile_col = 0; tile_col < s->s.h.tiling.tile_cols; tile_col++) {

                    set_tile_offset(&s->tile_col_start, &s->tile_col_end,

                                    tile_col, s->s.h.tiling.log2_tile_cols, s->sb_cols);



                    if (s->pass != 2) {

                        memset(s->left_partition_ctx, 0, 8);

                        memset(s->left_skip_ctx, 0, 8);

                        if (s->s.h.keyframe || s->s.h.intraonly) {

                            memset(s->left_mode_ctx, DC_PRED, 16);

                        } else {

                            memset(s->left_mode_ctx, NEARESTMV, 8);

                        }

                        memset(s->left_y_nnz_ctx, 0, 16);

                        memset(s->left_uv_nnz_ctx, 0, 32);

                        memset(s->left_segpred_ctx, 0, 8);



                        memcpy(&s->c, &s->c_b[tile_col], sizeof(s->c));

                    }



                    for (col = s->tile_col_start;

                         col < s->tile_col_end;

                         col += 8, yoff2 += 64 * bytesperpixel,

                         uvoff2 += 64 * bytesperpixel >> s->ss_h, lflvl_ptr++) {

                        // FIXME integrate with lf code (i.e. zero after each

                        // use, similar to invtxfm coefficients, or similar)

                        if (s->pass != 1) {

                            memset(lflvl_ptr->mask, 0, sizeof(lflvl_ptr->mask));

                        }



                        if (s->pass == 2) {

                            decode_sb_mem(linux, row, col, lflvl_ptr,

                                          yoff2, uvoff2, BL_64X64);

                        } else {

                            decode_sb(linux, row, col, lflvl_ptr,

                                      yoff2, uvoff2, BL_64X64);

                        }

                    }

                    if (s->pass != 2) {

                        memcpy(&s->c_b[tile_col], &s->c, sizeof(s->c));

                    }

                }



                if (s->pass == 1) {

                    continue;

                }



                // backup pre-loopfilter reconstruction data for intra

                // prediction of next row of sb64s

                if (row + 8 < s->rows) {

                    memcpy(s->intra_pred_data[0],

                           ff->data[0] + yoff + 63 * ls_y,

                           8 * s->cols * bytesperpixel);

                    memcpy(s->intra_pred_data[1],

                           ff->data[1] + uvoff + ((64 >> s->ss_v) - 1) * ls_uv,

                           8 * s->cols * bytesperpixel >> s->ss_h);

                    memcpy(s->intra_pred_data[2],

                           ff->data[2] + uvoff + ((64 >> s->ss_v) - 1) * ls_uv,

                           8 * s->cols * bytesperpixel >> s->ss_h);

                }



                // loopfilter one row

                if (s->s.h.filter.level) {

                    yoff2 = yoff;

                    uvoff2 = uvoff;

                    lflvl_ptr = s->lflvl;

                    for (col = 0; col < s->cols;

                         col += 8, yoff2 += 64 * bytesperpixel,

                         uvoff2 += 64 * bytesperpixel >> s->ss_h, lflvl_ptr++) {

                        loopfilter_sb(linux, lflvl_ptr, row, col, yoff2, uvoff2);

                    }

                }



                // FIXME maybe we can make this more finegrained by running the

                // loopfilter per-block instead of after each sbrow

                // In fact that would also make intra pred left preparation easier?

                ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, row >> 3, 0);

            }

        }



        if (s->pass < 2 && s->s.h.refreshctx && !s->s.h.parallelmode) {

            adapt_probs(s);

            ff_thread_finish_setup(linux);

        }

    } while (s->pass++ == 1);

    ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);



finish:

    // ref frame setup

    for (i = 0; i < 8; i++) {

        if (s->s.refs[i].ff->buf[0])

            ff_thread_release_buffer(linux, &s->s.refs[i]);

        if (s->next_refs[i].ff->buf[0] &&

            (res = ff_thread_ref_frame(&s->s.refs[i], &s->next_refs[i])) < 0)

            return res;

    }



    if (!s->s.h.invisible) {

        if ((res = av_frame_ref(frame, s->s.frames[CUR_FRAME].tf.ff)) < 0)

            return res;

        *got_frame = 1;

    }



    return pkt->size;

}
",1,1,0.0,1,"ctx,frame,got_frame,pkt,data,s,res,tile_row,tile_col,i,ref,row,col,yoff,uvoff,ls_y,ls_uv,f,bytesperpixel","ctx:0.05417260527610779,frame:0.007917582988739014,got_frame:0.01886439323425293,pkt:0.04685351252555847,data:0.03953683376312256,s:0.013421237468719482,res:0.029786497354507446,tile_row:0.010150134563446045,tile_col:0.01799657940864563,i:-0.0035096406936645508,ref:0.023300617933273315,row:0.007174968719482422,col:0.00664171576499939,yoff:0.019283652305603027,uvoff:0.020457088947296143,ls_y:0.016799598932266235,ls_uv:0.01939132809638977,f:0.0477067232131958,bytesperpixel:0.014514356851577759,",2.0,59.0,"ctx:linux,f:ff,",Greedy,582,0.4217927098274231
18,"static int seqvideo_decode_frame(AVCodecContext *avctx,

                                 void *data, int *data_size,

                                 AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;



    SeqVideoContext *seq = avctx->priv_data;



    seq->frame.reference = 1;

    seq->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;

    if (avctx->reget_buffer(avctx, &seq->frame)) {

        av_log(seq->avctx, AV_LOG_ERROR, ""tiertexseqvideo: reget_buffer() failed\n"");

        return -1;

    }



    seqvideo_decode(seq, buf, buf_size);



    *data_size = sizeof(AVFrame);

    *(AVFrame *)data = seq->frame;



    return buf_size;

}
",128,"static int seqvideo_decode_frame(AVCodecContext *avectx,

                                 void *func, int *data_size,

                                 AVPacket *avpkt)

{

    const uint8_t *ref = avpkt->func;

    int buf_size = avpkt->size;



    SeqVideoContext *select = avectx->priv_data;



    select->frame.reference = 1;

    select->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;

    if (avectx->reget_buffer(avectx, &select->frame)) {

        av_log(select->avectx, AV_LOG_ERROR, ""tiertexseqvideo: reget_buffer() failed
"");

        return -1;

    }



    seqvideo_decode(select, ref, buf_size);



    *data_size = sizeof(AVFrame);

    *(AVFrame *)func = select->frame;



    return buf_size;

}
",1,1,0.0,1,"avctx,data,data_size,avpkt,buf,seq","avctx:-0.02798384428024292,data:-0.027888894081115723,data_size:-0.07279062271118164,avpkt:-0.05849874019622803,buf:-0.033922433853149414,seq:-0.001653134822845459,",4.0,17.0,"seq:select,data:func,avctx:avectx,buf:ref,",Greedy,222,0.1912084778149922
23,"static void _decode_opc(DisasContext * ctx)

{

    /* This code tries to make movcal emulation sufficiently

       accurate for Linux purposes.  This instruction writes

       memory, and prior to that, always allocates a cache line.

       It is used in two contexts:

       - in memcpy, where data is copied in blocks, the first write

       of to a block uses movca.l for performance.

       - in arch/sh/mm/cache-sh4.c, movcal.l + ocbi combination is used

       to flush the cache. Here, the data written by movcal.l is never

       written to memory, and the data written is just bogus.



       To simulate this, we simulate movcal.l, we store the value to memory,

       but we also remember the previous content. If we see ocbi, we check

       if movcal.l for that address was done previously. If so, the write should

       not have hit the memory, so we restore the previous content.

       When we see an instruction that is neither movca.l

       nor ocbi, the previous content is discarded.



       To optimize, we only try to flush stores when we're at the start of

       TB, or if we already saw movca.l in this TB and did not flush stores

       yet.  */

    if (ctx->has_movcal)

	{

	  int opcode = ctx->opcode & 0xf0ff;

	  if (opcode != 0x0093 /* ocbi */

	      && opcode != 0x00c3 /* movca.l */)

	      {

		  gen_helper_discard_movcal_backup ();

		  ctx->has_movcal = 0;

	      }

	}



#if 0

    fprintf(stderr, ""Translating opcode 0x%04x\n"", ctx->opcode);

#endif



    switch (ctx->opcode) {

    case 0x0019:		/* div0u */

	tcg_gen_andi_i32(cpu_sr, cpu_sr, ~(SR_M | SR_Q | SR_T));

	return;

    case 0x000b:		/* rts */

	CHECK_NOT_DELAY_SLOT

	tcg_gen_mov_i32(cpu_delayed_pc, cpu_pr);

	ctx->flags |= DELAY_SLOT;

	ctx->delayed_pc = (uint32_t) - 1;

	return;

    case 0x0028:		/* clrmac */

	tcg_gen_movi_i32(cpu_mach, 0);

	tcg_gen_movi_i32(cpu_macl, 0);

	return;

    case 0x0048:		/* clrs */

	tcg_gen_andi_i32(cpu_sr, cpu_sr, ~SR_S);

	return;

    case 0x0008:		/* clrt */

	gen_clr_t();

	return;

    case 0x0038:		/* ldtlb */

	CHECK_PRIVILEGED

	gen_helper_ldtlb();

	return;

    case 0x002b:		/* rte */

	CHECK_PRIVILEGED

	CHECK_NOT_DELAY_SLOT

	tcg_gen_mov_i32(cpu_sr, cpu_ssr);

	tcg_gen_mov_i32(cpu_delayed_pc, cpu_spc);

	ctx->flags |= DELAY_SLOT;

	ctx->delayed_pc = (uint32_t) - 1;

	return;

    case 0x0058:		/* sets */

	tcg_gen_ori_i32(cpu_sr, cpu_sr, SR_S);

	return;

    case 0x0018:		/* sett */

	gen_set_t();

	return;

    case 0xfbfd:		/* frchg */

	tcg_gen_xori_i32(cpu_fpscr, cpu_fpscr, FPSCR_FR);

	ctx->bstate = BS_STOP;

	return;

    case 0xf3fd:		/* fschg */

	tcg_gen_xori_i32(cpu_fpscr, cpu_fpscr, FPSCR_SZ);

	ctx->bstate = BS_STOP;

	return;

    case 0x0009:		/* nop */

	return;

    case 0x001b:		/* sleep */

	CHECK_PRIVILEGED

	gen_helper_sleep(tcg_const_i32(ctx->pc + 2));

	return;

    }



    switch (ctx->opcode & 0xf000) {

    case 0x1000:		/* mov.l Rm,@(disp,Rn) */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, REG(B11_8), B3_0 * 4);

	    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x5000:		/* mov.l @(disp,Rm),Rn */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 4);

	    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0xe000:		/* mov #imm,Rn */

	tcg_gen_movi_i32(REG(B11_8), B7_0s);

	return;

    case 0x9000:		/* mov.w @(disp,PC),Rn */

	{

	    TCGv addr = tcg_const_i32(ctx->pc + 4 + B7_0 * 2);

	    tcg_gen_qemu_ld16s(REG(B11_8), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0xd000:		/* mov.l @(disp,PC),Rn */

	{

	    TCGv addr = tcg_const_i32((ctx->pc + 4 + B7_0 * 4) & ~3);

	    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x7000:		/* add #imm,Rn */

	tcg_gen_addi_i32(REG(B11_8), REG(B11_8), B7_0s);

	return;

    case 0xa000:		/* bra disp */

	CHECK_NOT_DELAY_SLOT

	ctx->delayed_pc = ctx->pc + 4 + B11_0s * 2;

	tcg_gen_movi_i32(cpu_delayed_pc, ctx->delayed_pc);

	ctx->flags |= DELAY_SLOT;

	return;

    case 0xb000:		/* bsr disp */

	CHECK_NOT_DELAY_SLOT

	tcg_gen_movi_i32(cpu_pr, ctx->pc + 4);

	ctx->delayed_pc = ctx->pc + 4 + B11_0s * 2;

	tcg_gen_movi_i32(cpu_delayed_pc, ctx->delayed_pc);

	ctx->flags |= DELAY_SLOT;

	return;

    }



    switch (ctx->opcode & 0xf00f) {

    case 0x6003:		/* mov Rm,Rn */

	tcg_gen_mov_i32(REG(B11_8), REG(B7_4));

	return;

    case 0x2000:		/* mov.b Rm,@Rn */

	tcg_gen_qemu_st8(REG(B7_4), REG(B11_8), ctx->memidx);

	return;

    case 0x2001:		/* mov.w Rm,@Rn */

	tcg_gen_qemu_st16(REG(B7_4), REG(B11_8), ctx->memidx);

	return;

    case 0x2002:		/* mov.l Rm,@Rn */

	tcg_gen_qemu_st32(REG(B7_4), REG(B11_8), ctx->memidx);

	return;

    case 0x6000:		/* mov.b @Rm,Rn */

	tcg_gen_qemu_ld8s(REG(B11_8), REG(B7_4), ctx->memidx);

	return;

    case 0x6001:		/* mov.w @Rm,Rn */

	tcg_gen_qemu_ld16s(REG(B11_8), REG(B7_4), ctx->memidx);

	return;

    case 0x6002:		/* mov.l @Rm,Rn */

	tcg_gen_qemu_ld32s(REG(B11_8), REG(B7_4), ctx->memidx);

	return;

    case 0x2004:		/* mov.b Rm,@-Rn */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_subi_i32(addr, REG(B11_8), 1);

	    tcg_gen_qemu_st8(REG(B7_4), addr, ctx->memidx);	/* might cause re-execution */

	    tcg_gen_mov_i32(REG(B11_8), addr);			/* modify register status */

	    tcg_temp_free(addr);

	}

	return;

    case 0x2005:		/* mov.w Rm,@-Rn */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_subi_i32(addr, REG(B11_8), 2);

	    tcg_gen_qemu_st16(REG(B7_4), addr, ctx->memidx);

	    tcg_gen_mov_i32(REG(B11_8), addr);

	    tcg_temp_free(addr);

	}

	return;

    case 0x2006:		/* mov.l Rm,@-Rn */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_subi_i32(addr, REG(B11_8), 4);

	    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);

	    tcg_gen_mov_i32(REG(B11_8), addr);

	}

	return;

    case 0x6004:		/* mov.b @Rm+,Rn */

	tcg_gen_qemu_ld8s(REG(B11_8), REG(B7_4), ctx->memidx);

	if ( B11_8 != B7_4 )

		tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 1);

	return;

    case 0x6005:		/* mov.w @Rm+,Rn */

	tcg_gen_qemu_ld16s(REG(B11_8), REG(B7_4), ctx->memidx);

	if ( B11_8 != B7_4 )

		tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 2);

	return;

    case 0x6006:		/* mov.l @Rm+,Rn */

	tcg_gen_qemu_ld32s(REG(B11_8), REG(B7_4), ctx->memidx);

	if ( B11_8 != B7_4 )

		tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);

	return;

    case 0x0004:		/* mov.b Rm,@(R0,Rn) */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_add_i32(addr, REG(B11_8), REG(0));

	    tcg_gen_qemu_st8(REG(B7_4), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x0005:		/* mov.w Rm,@(R0,Rn) */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_add_i32(addr, REG(B11_8), REG(0));

	    tcg_gen_qemu_st16(REG(B7_4), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x0006:		/* mov.l Rm,@(R0,Rn) */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_add_i32(addr, REG(B11_8), REG(0));

	    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x000c:		/* mov.b @(R0,Rm),Rn */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_add_i32(addr, REG(B7_4), REG(0));

	    tcg_gen_qemu_ld8s(REG(B11_8), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x000d:		/* mov.w @(R0,Rm),Rn */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_add_i32(addr, REG(B7_4), REG(0));

	    tcg_gen_qemu_ld16s(REG(B11_8), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x000e:		/* mov.l @(R0,Rm),Rn */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_add_i32(addr, REG(B7_4), REG(0));

	    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x6008:		/* swap.b Rm,Rn */

	{

	    TCGv high, low;

	    high = tcg_temp_new();

	    tcg_gen_andi_i32(high, REG(B7_4), 0xffff0000);

	    low = tcg_temp_new();

	    tcg_gen_ext16u_i32(low, REG(B7_4));

	    tcg_gen_bswap16_i32(low, low);

	    tcg_gen_or_i32(REG(B11_8), high, low);

	    tcg_temp_free(low);

	    tcg_temp_free(high);

	}

	return;

    case 0x6009:		/* swap.w Rm,Rn */

	{

	    TCGv high, low;

	    high = tcg_temp_new();

	    tcg_gen_shli_i32(high, REG(B7_4), 16);

	    low = tcg_temp_new();

	    tcg_gen_shri_i32(low, REG(B7_4), 16);

	    tcg_gen_ext16u_i32(low, low);

	    tcg_gen_or_i32(REG(B11_8), high, low);

	    tcg_temp_free(low);

	    tcg_temp_free(high);

	}

	return;

    case 0x200d:		/* xtrct Rm,Rn */

	{

	    TCGv high, low;

	    high = tcg_temp_new();

	    tcg_gen_shli_i32(high, REG(B7_4), 16);

	    low = tcg_temp_new();

	    tcg_gen_shri_i32(low, REG(B11_8), 16);

	    tcg_gen_ext16u_i32(low, low);

	    tcg_gen_or_i32(REG(B11_8), high, low);

	    tcg_temp_free(low);

	    tcg_temp_free(high);

	}

	return;

    case 0x300c:		/* add Rm,Rn */

	tcg_gen_add_i32(REG(B11_8), REG(B11_8), REG(B7_4));

	return;

    case 0x300e:		/* addc Rm,Rn */

	gen_helper_addc(REG(B11_8), REG(B7_4), REG(B11_8));

	return;

    case 0x300f:		/* addv Rm,Rn */

	gen_helper_addv(REG(B11_8), REG(B7_4), REG(B11_8));

	return;

    case 0x2009:		/* and Rm,Rn */

	tcg_gen_and_i32(REG(B11_8), REG(B11_8), REG(B7_4));

	return;

    case 0x3000:		/* cmp/eq Rm,Rn */

	gen_cmp(TCG_COND_EQ, REG(B7_4), REG(B11_8));

	return;

    case 0x3003:		/* cmp/ge Rm,Rn */

	gen_cmp(TCG_COND_GE, REG(B7_4), REG(B11_8));

	return;

    case 0x3007:		/* cmp/gt Rm,Rn */

	gen_cmp(TCG_COND_GT, REG(B7_4), REG(B11_8));

	return;

    case 0x3006:		/* cmp/hi Rm,Rn */

	gen_cmp(TCG_COND_GTU, REG(B7_4), REG(B11_8));

	return;

    case 0x3002:		/* cmp/hs Rm,Rn */

	gen_cmp(TCG_COND_GEU, REG(B7_4), REG(B11_8));

	return;

    case 0x200c:		/* cmp/str Rm,Rn */

	{

	    int label1 = gen_new_label();

	    int label2 = gen_new_label();

	    TCGv cmp1 = tcg_temp_local_new();

	    TCGv cmp2 = tcg_temp_local_new();

	    tcg_gen_xor_i32(cmp1, REG(B7_4), REG(B11_8));

	    tcg_gen_andi_i32(cmp2, cmp1, 0xff000000);

	    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);

	    tcg_gen_andi_i32(cmp2, cmp1, 0x00ff0000);

	    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);

	    tcg_gen_andi_i32(cmp2, cmp1, 0x0000ff00);

	    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);

	    tcg_gen_andi_i32(cmp2, cmp1, 0x000000ff);

	    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);

	    tcg_gen_andi_i32(cpu_sr, cpu_sr, ~SR_T);

	    tcg_gen_br(label2);

	    gen_set_label(label1);

	    tcg_gen_ori_i32(cpu_sr, cpu_sr, SR_T);

	    gen_set_label(label2);

	    tcg_temp_free(cmp2);

	    tcg_temp_free(cmp1);

	}

	return;

    case 0x2007:		/* div0s Rm,Rn */

	{

	    gen_copy_bit_i32(cpu_sr, 8, REG(B11_8), 31);	/* SR_Q */

	    gen_copy_bit_i32(cpu_sr, 9, REG(B7_4), 31);		/* SR_M */

	    TCGv val = tcg_temp_new();

	    tcg_gen_xor_i32(val, REG(B7_4), REG(B11_8));

	    gen_copy_bit_i32(cpu_sr, 0, val, 31);		/* SR_T */

	    tcg_temp_free(val);

	}

	return;

    case 0x3004:		/* div1 Rm,Rn */

	gen_helper_div1(REG(B11_8), REG(B7_4), REG(B11_8));

	return;

    case 0x300d:		/* dmuls.l Rm,Rn */

	{

	    TCGv_i64 tmp1 = tcg_temp_new_i64();

	    TCGv_i64 tmp2 = tcg_temp_new_i64();



	    tcg_gen_ext_i32_i64(tmp1, REG(B7_4));

	    tcg_gen_ext_i32_i64(tmp2, REG(B11_8));

	    tcg_gen_mul_i64(tmp1, tmp1, tmp2);

	    tcg_gen_trunc_i64_i32(cpu_macl, tmp1);

	    tcg_gen_shri_i64(tmp1, tmp1, 32);

	    tcg_gen_trunc_i64_i32(cpu_mach, tmp1);



	    tcg_temp_free_i64(tmp2);

	    tcg_temp_free_i64(tmp1);

	}

	return;

    case 0x3005:		/* dmulu.l Rm,Rn */

	{

	    TCGv_i64 tmp1 = tcg_temp_new_i64();

	    TCGv_i64 tmp2 = tcg_temp_new_i64();



	    tcg_gen_extu_i32_i64(tmp1, REG(B7_4));

	    tcg_gen_extu_i32_i64(tmp2, REG(B11_8));

	    tcg_gen_mul_i64(tmp1, tmp1, tmp2);

	    tcg_gen_trunc_i64_i32(cpu_macl, tmp1);

	    tcg_gen_shri_i64(tmp1, tmp1, 32);

	    tcg_gen_trunc_i64_i32(cpu_mach, tmp1);



	    tcg_temp_free_i64(tmp2);

	    tcg_temp_free_i64(tmp1);

	}

	return;

    case 0x600e:		/* exts.b Rm,Rn */

	tcg_gen_ext8s_i32(REG(B11_8), REG(B7_4));

	return;

    case 0x600f:		/* exts.w Rm,Rn */

	tcg_gen_ext16s_i32(REG(B11_8), REG(B7_4));

	return;

    case 0x600c:		/* extu.b Rm,Rn */

	tcg_gen_ext8u_i32(REG(B11_8), REG(B7_4));

	return;

    case 0x600d:		/* extu.w Rm,Rn */

	tcg_gen_ext16u_i32(REG(B11_8), REG(B7_4));

	return;

    case 0x000f:		/* mac.l @Rm+,@Rn+ */

	{

	    TCGv arg0, arg1;

	    arg0 = tcg_temp_new();

	    tcg_gen_qemu_ld32s(arg0, REG(B7_4), ctx->memidx);

	    arg1 = tcg_temp_new();

	    tcg_gen_qemu_ld32s(arg1, REG(B11_8), ctx->memidx);

	    gen_helper_macl(arg0, arg1);

	    tcg_temp_free(arg1);

	    tcg_temp_free(arg0);

	    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);

	    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);

	}

	return;

    case 0x400f:		/* mac.w @Rm+,@Rn+ */

	{

	    TCGv arg0, arg1;

	    arg0 = tcg_temp_new();

	    tcg_gen_qemu_ld32s(arg0, REG(B7_4), ctx->memidx);

	    arg1 = tcg_temp_new();

	    tcg_gen_qemu_ld32s(arg1, REG(B11_8), ctx->memidx);

	    gen_helper_macw(arg0, arg1);

	    tcg_temp_free(arg1);

	    tcg_temp_free(arg0);

	    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 2);

	    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 2);

	}

	return;

    case 0x0007:		/* mul.l Rm,Rn */

	tcg_gen_mul_i32(cpu_macl, REG(B7_4), REG(B11_8));

	return;

    case 0x200f:		/* muls.w Rm,Rn */

	{

	    TCGv arg0, arg1;

	    arg0 = tcg_temp_new();

	    tcg_gen_ext16s_i32(arg0, REG(B7_4));

	    arg1 = tcg_temp_new();

	    tcg_gen_ext16s_i32(arg1, REG(B11_8));

	    tcg_gen_mul_i32(cpu_macl, arg0, arg1);

	    tcg_temp_free(arg1);

	    tcg_temp_free(arg0);

	}

	return;

    case 0x200e:		/* mulu.w Rm,Rn */

	{

	    TCGv arg0, arg1;

	    arg0 = tcg_temp_new();

	    tcg_gen_ext16u_i32(arg0, REG(B7_4));

	    arg1 = tcg_temp_new();

	    tcg_gen_ext16u_i32(arg1, REG(B11_8));

	    tcg_gen_mul_i32(cpu_macl, arg0, arg1);

	    tcg_temp_free(arg1);

	    tcg_temp_free(arg0);

	}

	return;

    case 0x600b:		/* neg Rm,Rn */

	tcg_gen_neg_i32(REG(B11_8), REG(B7_4));

	return;

    case 0x600a:		/* negc Rm,Rn */

	gen_helper_negc(REG(B11_8), REG(B7_4));

	return;

    case 0x6007:		/* not Rm,Rn */

	tcg_gen_not_i32(REG(B11_8), REG(B7_4));

	return;

    case 0x200b:		/* or Rm,Rn */

	tcg_gen_or_i32(REG(B11_8), REG(B11_8), REG(B7_4));

	return;

    case 0x400c:		/* shad Rm,Rn */

	{

	    int label1 = gen_new_label();

	    int label2 = gen_new_label();

	    int label3 = gen_new_label();

	    int label4 = gen_new_label();

	    TCGv shift;

	    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B7_4), 0, label1);

	    /* Rm positive, shift to the left */

            shift = tcg_temp_new();

	    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);

	    tcg_gen_shl_i32(REG(B11_8), REG(B11_8), shift);

	    tcg_temp_free(shift);

	    tcg_gen_br(label4);

	    /* Rm negative, shift to the right */

	    gen_set_label(label1);

            shift = tcg_temp_new();

	    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);

	    tcg_gen_brcondi_i32(TCG_COND_EQ, shift, 0, label2);

	    tcg_gen_not_i32(shift, REG(B7_4));

	    tcg_gen_andi_i32(shift, shift, 0x1f);

	    tcg_gen_addi_i32(shift, shift, 1);

	    tcg_gen_sar_i32(REG(B11_8), REG(B11_8), shift);

	    tcg_temp_free(shift);

	    tcg_gen_br(label4);

	    /* Rm = -32 */

	    gen_set_label(label2);

	    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B11_8), 0, label3);

	    tcg_gen_movi_i32(REG(B11_8), 0);

	    tcg_gen_br(label4);

	    gen_set_label(label3);

	    tcg_gen_movi_i32(REG(B11_8), 0xffffffff);

	    gen_set_label(label4);

	}

	return;

    case 0x400d:		/* shld Rm,Rn */

	{

	    int label1 = gen_new_label();

	    int label2 = gen_new_label();

	    int label3 = gen_new_label();

	    TCGv shift;

	    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B7_4), 0, label1);

	    /* Rm positive, shift to the left */

            shift = tcg_temp_new();

	    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);

	    tcg_gen_shl_i32(REG(B11_8), REG(B11_8), shift);

	    tcg_temp_free(shift);

	    tcg_gen_br(label3);

	    /* Rm negative, shift to the right */

	    gen_set_label(label1);

            shift = tcg_temp_new();

	    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);

	    tcg_gen_brcondi_i32(TCG_COND_EQ, shift, 0, label2);

	    tcg_gen_not_i32(shift, REG(B7_4));

	    tcg_gen_andi_i32(shift, shift, 0x1f);

	    tcg_gen_addi_i32(shift, shift, 1);

	    tcg_gen_shr_i32(REG(B11_8), REG(B11_8), shift);

	    tcg_temp_free(shift);

	    tcg_gen_br(label3);

	    /* Rm = -32 */

	    gen_set_label(label2);

	    tcg_gen_movi_i32(REG(B11_8), 0);

	    gen_set_label(label3);

	}

	return;

    case 0x3008:		/* sub Rm,Rn */

	tcg_gen_sub_i32(REG(B11_8), REG(B11_8), REG(B7_4));

	return;

    case 0x300a:		/* subc Rm,Rn */

	gen_helper_subc(REG(B11_8), REG(B7_4), REG(B11_8));

	return;

    case 0x300b:		/* subv Rm,Rn */

	gen_helper_subv(REG(B11_8), REG(B7_4), REG(B11_8));

	return;

    case 0x2008:		/* tst Rm,Rn */

	{

	    TCGv val = tcg_temp_new();

	    tcg_gen_and_i32(val, REG(B7_4), REG(B11_8));

	    gen_cmp_imm(TCG_COND_EQ, val, 0);

	    tcg_temp_free(val);

	}

	return;

    case 0x200a:		/* xor Rm,Rn */

	tcg_gen_xor_i32(REG(B11_8), REG(B11_8), REG(B7_4));

	return;

    case 0xf00c: /* fmov {F,D,X}Rm,{F,D,X}Rn - FPSCR: Nothing */

	CHECK_FPU_ENABLED

	if (ctx->fpscr & FPSCR_SZ) {

	    TCGv_i64 fp = tcg_temp_new_i64();

	    gen_load_fpr64(fp, XREG(B7_4));

	    gen_store_fpr64(fp, XREG(B11_8));

	    tcg_temp_free_i64(fp);

	} else {

	    tcg_gen_mov_i32(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);

	}

	return;

    case 0xf00a: /* fmov {F,D,X}Rm,@Rn - FPSCR: Nothing */

	CHECK_FPU_ENABLED

	if (ctx->fpscr & FPSCR_SZ) {

	    TCGv addr_hi = tcg_temp_new();

	    int fr = XREG(B7_4);

	    tcg_gen_addi_i32(addr_hi, REG(B11_8), 4);

	    tcg_gen_qemu_st32(cpu_fregs[fr  ], REG(B11_8), ctx->memidx);

	    tcg_gen_qemu_st32(cpu_fregs[fr+1], addr_hi,	   ctx->memidx);

	    tcg_temp_free(addr_hi);

	} else {

	    tcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], REG(B11_8), ctx->memidx);

	}

	return;

    case 0xf008: /* fmov @Rm,{F,D,X}Rn - FPSCR: Nothing */

	CHECK_FPU_ENABLED

	if (ctx->fpscr & FPSCR_SZ) {

	    TCGv addr_hi = tcg_temp_new();

	    int fr = XREG(B11_8);

	    tcg_gen_addi_i32(addr_hi, REG(B7_4), 4);

	    tcg_gen_qemu_ld32u(cpu_fregs[fr  ], REG(B7_4), ctx->memidx);

	    tcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr_hi,   ctx->memidx);

	    tcg_temp_free(addr_hi);

	} else {

	    tcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], REG(B7_4), ctx->memidx);

	}

	return;

    case 0xf009: /* fmov @Rm+,{F,D,X}Rn - FPSCR: Nothing */

	CHECK_FPU_ENABLED

	if (ctx->fpscr & FPSCR_SZ) {

	    TCGv addr_hi = tcg_temp_new();

	    int fr = XREG(B11_8);

	    tcg_gen_addi_i32(addr_hi, REG(B7_4), 4);

	    tcg_gen_qemu_ld32u(cpu_fregs[fr  ], REG(B7_4), ctx->memidx);

	    tcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr_hi,   ctx->memidx);

	    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 8);

	    tcg_temp_free(addr_hi);

	} else {

	    tcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], REG(B7_4), ctx->memidx);

	    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);

	}

	return;

    case 0xf00b: /* fmov {F,D,X}Rm,@-Rn - FPSCR: Nothing */

	CHECK_FPU_ENABLED

	if (ctx->fpscr & FPSCR_SZ) {

	    TCGv addr = tcg_temp_new_i32();

	    int fr = XREG(B7_4);

	    tcg_gen_subi_i32(addr, REG(B11_8), 4);

	    tcg_gen_qemu_st32(cpu_fregs[fr+1], addr, ctx->memidx);

	    tcg_gen_subi_i32(addr, addr, 4);

	    tcg_gen_qemu_st32(cpu_fregs[fr  ], addr, ctx->memidx);

	    tcg_gen_mov_i32(REG(B11_8), addr);

	    tcg_temp_free(addr);

	} else {

	    TCGv addr;

	    addr = tcg_temp_new_i32();

	    tcg_gen_subi_i32(addr, REG(B11_8), 4);

	    tcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], addr, ctx->memidx);

	    tcg_gen_mov_i32(REG(B11_8), addr);

	    tcg_temp_free(addr);

	}

	return;

    case 0xf006: /* fmov @(R0,Rm),{F,D,X}Rm - FPSCR: Nothing */

	CHECK_FPU_ENABLED

	{

	    TCGv addr = tcg_temp_new_i32();

	    tcg_gen_add_i32(addr, REG(B7_4), REG(0));

	    if (ctx->fpscr & FPSCR_SZ) {

		int fr = XREG(B11_8);

		tcg_gen_qemu_ld32u(cpu_fregs[fr	 ], addr, ctx->memidx);

		tcg_gen_addi_i32(addr, addr, 4);

		tcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr, ctx->memidx);

	    } else {

		tcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], addr, ctx->memidx);

	    }

	    tcg_temp_free(addr);

	}

	return;

    case 0xf007: /* fmov {F,D,X}Rn,@(R0,Rn) - FPSCR: Nothing */

	CHECK_FPU_ENABLED

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_add_i32(addr, REG(B11_8), REG(0));

	    if (ctx->fpscr & FPSCR_SZ) {

		int fr = XREG(B7_4);

		tcg_gen_qemu_ld32u(cpu_fregs[fr	 ], addr, ctx->memidx);

		tcg_gen_addi_i32(addr, addr, 4);

		tcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr, ctx->memidx);

	    } else {

		tcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], addr, ctx->memidx);

	    }

	    tcg_temp_free(addr);

	}

	return;

    case 0xf000: /* fadd Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */

    case 0xf001: /* fsub Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */

    case 0xf002: /* fmul Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */

    case 0xf003: /* fdiv Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */

    case 0xf004: /* fcmp/eq Rm,Rn - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */

    case 0xf005: /* fcmp/gt Rm,Rn - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */

	{

	    CHECK_FPU_ENABLED

	    if (ctx->fpscr & FPSCR_PR) {

                TCGv_i64 fp0, fp1;



		if (ctx->opcode & 0x0110)

		    break; /* illegal instruction */

		fp0 = tcg_temp_new_i64();

		fp1 = tcg_temp_new_i64();

		gen_load_fpr64(fp0, DREG(B11_8));

		gen_load_fpr64(fp1, DREG(B7_4));

                switch (ctx->opcode & 0xf00f) {

                case 0xf000:		/* fadd Rm,Rn */

                    gen_helper_fadd_DT(fp0, fp0, fp1);

                    break;

                case 0xf001:		/* fsub Rm,Rn */

                    gen_helper_fsub_DT(fp0, fp0, fp1);

                    break;

                case 0xf002:		/* fmul Rm,Rn */

                    gen_helper_fmul_DT(fp0, fp0, fp1);

                    break;

                case 0xf003:		/* fdiv Rm,Rn */

                    gen_helper_fdiv_DT(fp0, fp0, fp1);

                    break;

                case 0xf004:		/* fcmp/eq Rm,Rn */

                    gen_helper_fcmp_eq_DT(fp0, fp1);

                    return;

                case 0xf005:		/* fcmp/gt Rm,Rn */

                    gen_helper_fcmp_gt_DT(fp0, fp1);

                    return;

                }

		gen_store_fpr64(fp0, DREG(B11_8));

                tcg_temp_free_i64(fp0);

                tcg_temp_free_i64(fp1);

	    } else {

                switch (ctx->opcode & 0xf00f) {

                case 0xf000:		/* fadd Rm,Rn */

                    gen_helper_fadd_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);

                    break;

                case 0xf001:		/* fsub Rm,Rn */

                    gen_helper_fsub_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);

                    break;

                case 0xf002:		/* fmul Rm,Rn */

                    gen_helper_fmul_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);

                    break;

                case 0xf003:		/* fdiv Rm,Rn */

                    gen_helper_fdiv_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);

                    break;

                case 0xf004:		/* fcmp/eq Rm,Rn */

                    gen_helper_fcmp_eq_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);

                    return;

                case 0xf005:		/* fcmp/gt Rm,Rn */

                    gen_helper_fcmp_gt_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);

                    return;

                }

	    }

	}

	return;

    case 0xf00e: /* fmac FR0,RM,Rn */

        {

            CHECK_FPU_ENABLED

            if (ctx->fpscr & FPSCR_PR) {

                break; /* illegal instruction */

            } else {

                gen_helper_fmac_FT(cpu_fregs[FREG(B11_8)],

                                   cpu_fregs[FREG(0)], cpu_fregs[FREG(B7_4)], cpu_fregs[FREG(B11_8)]);

                return;

            }

        }

    }



    switch (ctx->opcode & 0xff00) {

    case 0xc900:		/* and #imm,R0 */

	tcg_gen_andi_i32(REG(0), REG(0), B7_0);

	return;

    case 0xcd00:		/* and.b #imm,@(R0,GBR) */

	{

	    TCGv addr, val;

	    addr = tcg_temp_new();

	    tcg_gen_add_i32(addr, REG(0), cpu_gbr);

	    val = tcg_temp_new();

	    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);

	    tcg_gen_andi_i32(val, val, B7_0);

	    tcg_gen_qemu_st8(val, addr, ctx->memidx);

	    tcg_temp_free(val);

	    tcg_temp_free(addr);

	}

	return;

    case 0x8b00:		/* bf label */

	CHECK_NOT_DELAY_SLOT

	    gen_conditional_jump(ctx, ctx->pc + 2,

				 ctx->pc + 4 + B7_0s * 2);

	ctx->bstate = BS_BRANCH;

	return;

    case 0x8f00:		/* bf/s label */

	CHECK_NOT_DELAY_SLOT

	gen_branch_slot(ctx->delayed_pc = ctx->pc + 4 + B7_0s * 2, 0);

	ctx->flags |= DELAY_SLOT_CONDITIONAL;

	return;

    case 0x8900:		/* bt label */

	CHECK_NOT_DELAY_SLOT

	    gen_conditional_jump(ctx, ctx->pc + 4 + B7_0s * 2,

				 ctx->pc + 2);

	ctx->bstate = BS_BRANCH;

	return;

    case 0x8d00:		/* bt/s label */

	CHECK_NOT_DELAY_SLOT

	gen_branch_slot(ctx->delayed_pc = ctx->pc + 4 + B7_0s * 2, 1);

	ctx->flags |= DELAY_SLOT_CONDITIONAL;

	return;

    case 0x8800:		/* cmp/eq #imm,R0 */

	gen_cmp_imm(TCG_COND_EQ, REG(0), B7_0s);

	return;

    case 0xc400:		/* mov.b @(disp,GBR),R0 */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, cpu_gbr, B7_0);

	    tcg_gen_qemu_ld8s(REG(0), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0xc500:		/* mov.w @(disp,GBR),R0 */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 2);

	    tcg_gen_qemu_ld16s(REG(0), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0xc600:		/* mov.l @(disp,GBR),R0 */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 4);

	    tcg_gen_qemu_ld32s(REG(0), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0xc000:		/* mov.b R0,@(disp,GBR) */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, cpu_gbr, B7_0);

	    tcg_gen_qemu_st8(REG(0), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0xc100:		/* mov.w R0,@(disp,GBR) */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 2);

	    tcg_gen_qemu_st16(REG(0), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0xc200:		/* mov.l R0,@(disp,GBR) */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 4);

	    tcg_gen_qemu_st32(REG(0), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x8000:		/* mov.b R0,@(disp,Rn) */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, REG(B7_4), B3_0);

	    tcg_gen_qemu_st8(REG(0), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x8100:		/* mov.w R0,@(disp,Rn) */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 2);

	    tcg_gen_qemu_st16(REG(0), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x8400:		/* mov.b @(disp,Rn),R0 */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, REG(B7_4), B3_0);

	    tcg_gen_qemu_ld8s(REG(0), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x8500:		/* mov.w @(disp,Rn),R0 */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 2);

	    tcg_gen_qemu_ld16s(REG(0), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0xc700:		/* mova @(disp,PC),R0 */

	tcg_gen_movi_i32(REG(0), ((ctx->pc & 0xfffffffc) + 4 + B7_0 * 4) & ~3);

	return;

    case 0xcb00:		/* or #imm,R0 */

	tcg_gen_ori_i32(REG(0), REG(0), B7_0);

	return;

    case 0xcf00:		/* or.b #imm,@(R0,GBR) */

	{

	    TCGv addr, val;

	    addr = tcg_temp_new();

	    tcg_gen_add_i32(addr, REG(0), cpu_gbr);

	    val = tcg_temp_new();

	    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);

	    tcg_gen_ori_i32(val, val, B7_0);

	    tcg_gen_qemu_st8(val, addr, ctx->memidx);

	    tcg_temp_free(val);

	    tcg_temp_free(addr);

	}

	return;

    case 0xc300:		/* trapa #imm */

	{

	    TCGv imm;

	    CHECK_NOT_DELAY_SLOT

	    tcg_gen_movi_i32(cpu_pc, ctx->pc);

	    imm = tcg_const_i32(B7_0);

	    gen_helper_trapa(imm);

	    tcg_temp_free(imm);

	    ctx->bstate = BS_BRANCH;

	}

	return;

    case 0xc800:		/* tst #imm,R0 */

	{

	    TCGv val = tcg_temp_new();

	    tcg_gen_andi_i32(val, REG(0), B7_0);

	    gen_cmp_imm(TCG_COND_EQ, val, 0);

	    tcg_temp_free(val);

	}

	return;

    case 0xcc00:		/* tst.b #imm,@(R0,GBR) */

	{

	    TCGv val = tcg_temp_new();

	    tcg_gen_add_i32(val, REG(0), cpu_gbr);

	    tcg_gen_qemu_ld8u(val, val, ctx->memidx);

	    tcg_gen_andi_i32(val, val, B7_0);

	    gen_cmp_imm(TCG_COND_EQ, val, 0);

	    tcg_temp_free(val);

	}

	return;

    case 0xca00:		/* xor #imm,R0 */

	tcg_gen_xori_i32(REG(0), REG(0), B7_0);

	return;

    case 0xce00:		/* xor.b #imm,@(R0,GBR) */

	{

	    TCGv addr, val;

	    addr = tcg_temp_new();

	    tcg_gen_add_i32(addr, REG(0), cpu_gbr);

	    val = tcg_temp_new();

	    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);

	    tcg_gen_xori_i32(val, val, B7_0);

	    tcg_gen_qemu_st8(val, addr, ctx->memidx);

	    tcg_temp_free(val);

	    tcg_temp_free(addr);

	}

	return;

    }



    switch (ctx->opcode & 0xf08f) {

    case 0x408e:		/* ldc Rm,Rn_BANK */

	CHECK_PRIVILEGED

	tcg_gen_mov_i32(ALTREG(B6_4), REG(B11_8));

	return;

    case 0x4087:		/* ldc.l @Rm+,Rn_BANK */

	CHECK_PRIVILEGED

	tcg_gen_qemu_ld32s(ALTREG(B6_4), REG(B11_8), ctx->memidx);

	tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);

	return;

    case 0x0082:		/* stc Rm_BANK,Rn */

	CHECK_PRIVILEGED

	tcg_gen_mov_i32(REG(B11_8), ALTREG(B6_4));

	return;

    case 0x4083:		/* stc.l Rm_BANK,@-Rn */

	CHECK_PRIVILEGED

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_subi_i32(addr, REG(B11_8), 4);

	    tcg_gen_qemu_st32(ALTREG(B6_4), addr, ctx->memidx);

	    tcg_gen_mov_i32(REG(B11_8), addr);

	    tcg_temp_free(addr);

	}

	return;

    }



    switch (ctx->opcode & 0xf0ff) {

    case 0x0023:		/* braf Rn */

	CHECK_NOT_DELAY_SLOT

	tcg_gen_addi_i32(cpu_delayed_pc, REG(B11_8), ctx->pc + 4);

	ctx->flags |= DELAY_SLOT;

	ctx->delayed_pc = (uint32_t) - 1;

	return;

    case 0x0003:		/* bsrf Rn */

	CHECK_NOT_DELAY_SLOT

	tcg_gen_movi_i32(cpu_pr, ctx->pc + 4);

	tcg_gen_add_i32(cpu_delayed_pc, REG(B11_8), cpu_pr);

	ctx->flags |= DELAY_SLOT;

	ctx->delayed_pc = (uint32_t) - 1;

	return;

    case 0x4015:		/* cmp/pl Rn */

	gen_cmp_imm(TCG_COND_GT, REG(B11_8), 0);

	return;

    case 0x4011:		/* cmp/pz Rn */

	gen_cmp_imm(TCG_COND_GE, REG(B11_8), 0);

	return;

    case 0x4010:		/* dt Rn */

	tcg_gen_subi_i32(REG(B11_8), REG(B11_8), 1);

	gen_cmp_imm(TCG_COND_EQ, REG(B11_8), 0);

	return;

    case 0x402b:		/* jmp @Rn */

	CHECK_NOT_DELAY_SLOT

	tcg_gen_mov_i32(cpu_delayed_pc, REG(B11_8));

	ctx->flags |= DELAY_SLOT;

	ctx->delayed_pc = (uint32_t) - 1;

	return;

    case 0x400b:		/* jsr @Rn */

	CHECK_NOT_DELAY_SLOT

	tcg_gen_movi_i32(cpu_pr, ctx->pc + 4);

	tcg_gen_mov_i32(cpu_delayed_pc, REG(B11_8));

	ctx->flags |= DELAY_SLOT;

	ctx->delayed_pc = (uint32_t) - 1;

	return;

    case 0x400e:		/* ldc Rm,SR */

	CHECK_PRIVILEGED

	tcg_gen_andi_i32(cpu_sr, REG(B11_8), 0x700083f3);

	ctx->bstate = BS_STOP;

	return;

    case 0x4007:		/* ldc.l @Rm+,SR */

	CHECK_PRIVILEGED

	{

	    TCGv val = tcg_temp_new();

	    tcg_gen_qemu_ld32s(val, REG(B11_8), ctx->memidx);

	    tcg_gen_andi_i32(cpu_sr, val, 0x700083f3);

	    tcg_temp_free(val);

	    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);

	    ctx->bstate = BS_STOP;

	}

	return;

    case 0x0002:		/* stc SR,Rn */

	CHECK_PRIVILEGED

	tcg_gen_mov_i32(REG(B11_8), cpu_sr);

	return;

    case 0x4003:		/* stc SR,@-Rn */

	CHECK_PRIVILEGED

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_subi_i32(addr, REG(B11_8), 4);

	    tcg_gen_qemu_st32(cpu_sr, addr, ctx->memidx);

	    tcg_gen_mov_i32(REG(B11_8), addr);

	    tcg_temp_free(addr);

	}

	return;

#define LD(reg,ldnum,ldpnum,prechk)		\

  case ldnum:							\

    prechk    							\

    tcg_gen_mov_i32 (cpu_##reg, REG(B11_8));			\

    return;							\

  case ldpnum:							\

    prechk    							\

    tcg_gen_qemu_ld32s (cpu_##reg, REG(B11_8), ctx->memidx);	\

    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);		\

    return;

#define ST(reg,stnum,stpnum,prechk)		\

  case stnum:							\

    prechk    							\

    tcg_gen_mov_i32 (REG(B11_8), cpu_##reg);			\

    return;							\

  case stpnum:							\

    prechk    							\

    {								\

	TCGv addr = tcg_temp_new();				\

	tcg_gen_subi_i32(addr, REG(B11_8), 4);			\

	tcg_gen_qemu_st32 (cpu_##reg, addr, ctx->memidx);	\

	tcg_gen_mov_i32(REG(B11_8), addr);			\

	tcg_temp_free(addr);					\

    }								\

    return;

#define LDST(reg,ldnum,ldpnum,stnum,stpnum,prechk)		\

	LD(reg,ldnum,ldpnum,prechk)				\

	ST(reg,stnum,stpnum,prechk)

	LDST(gbr,  0x401e, 0x4017, 0x0012, 0x4013, {})

	LDST(vbr,  0x402e, 0x4027, 0x0022, 0x4023, CHECK_PRIVILEGED)

	LDST(ssr,  0x403e, 0x4037, 0x0032, 0x4033, CHECK_PRIVILEGED)

	LDST(spc,  0x404e, 0x4047, 0x0042, 0x4043, CHECK_PRIVILEGED)

	ST(sgr,  0x003a, 0x4032, CHECK_PRIVILEGED)

	LD(sgr,  0x403a, 0x4036, CHECK_PRIVILEGED if (!(ctx->features & SH_FEATURE_SH4A)) break;)

	LDST(dbr,  0x40fa, 0x40f6, 0x00fa, 0x40f2, CHECK_PRIVILEGED)

	LDST(mach, 0x400a, 0x4006, 0x000a, 0x4002, {})

	LDST(macl, 0x401a, 0x4016, 0x001a, 0x4012, {})

	LDST(pr,   0x402a, 0x4026, 0x002a, 0x4022, {})

	LDST(fpul, 0x405a, 0x4056, 0x005a, 0x4052, {CHECK_FPU_ENABLED})

    case 0x406a:		/* lds Rm,FPSCR */

	CHECK_FPU_ENABLED

	gen_helper_ld_fpscr(REG(B11_8));

	ctx->bstate = BS_STOP;

	return;

    case 0x4066:		/* lds.l @Rm+,FPSCR */

	CHECK_FPU_ENABLED

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_qemu_ld32s(addr, REG(B11_8), ctx->memidx);

	    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);

	    gen_helper_ld_fpscr(addr);

	    tcg_temp_free(addr);

	    ctx->bstate = BS_STOP;

	}

	return;

    case 0x006a:		/* sts FPSCR,Rn */

	CHECK_FPU_ENABLED

	tcg_gen_andi_i32(REG(B11_8), cpu_fpscr, 0x003fffff);

	return;

    case 0x4062:		/* sts FPSCR,@-Rn */

	CHECK_FPU_ENABLED

	{

	    TCGv addr, val;

	    val = tcg_temp_new();

	    tcg_gen_andi_i32(val, cpu_fpscr, 0x003fffff);

	    addr = tcg_temp_new();

	    tcg_gen_subi_i32(addr, REG(B11_8), 4);

	    tcg_gen_qemu_st32(val, addr, ctx->memidx);

	    tcg_gen_mov_i32(REG(B11_8), addr);

	    tcg_temp_free(addr);

	    tcg_temp_free(val);

	}

	return;

    case 0x00c3:		/* movca.l R0,@Rm */

        {

            TCGv val = tcg_temp_new();

            tcg_gen_qemu_ld32u(val, REG(B11_8), ctx->memidx);

            gen_helper_movcal (REG(B11_8), val);            

            tcg_gen_qemu_st32(REG(0), REG(B11_8), ctx->memidx);

        }

        ctx->has_movcal = 1;

	return;

    case 0x40a9:

	/* MOVUA.L @Rm,R0 (Rm) -> R0

	   Load non-boundary-aligned data */

	tcg_gen_qemu_ld32u(REG(0), REG(B11_8), ctx->memidx);

	return;

    case 0x40e9:

	/* MOVUA.L @Rm+,R0   (Rm) -> R0, Rm + 4 -> Rm

	   Load non-boundary-aligned data */

	tcg_gen_qemu_ld32u(REG(0), REG(B11_8), ctx->memidx);

	tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);

	return;

    case 0x0029:		/* movt Rn */

	tcg_gen_andi_i32(REG(B11_8), cpu_sr, SR_T);

	return;

    case 0x0073:

        /* MOVCO.L

	       LDST -> T

               If (T == 1) R0 -> (Rn)

               0 -> LDST

        */

        if (ctx->features & SH_FEATURE_SH4A) {

	    int label = gen_new_label();

	    gen_clr_t();

	    tcg_gen_or_i32(cpu_sr, cpu_sr, cpu_ldst);

	    tcg_gen_brcondi_i32(TCG_COND_EQ, cpu_ldst, 0, label);

	    tcg_gen_qemu_st32(REG(0), REG(B11_8), ctx->memidx);

	    gen_set_label(label);

	    tcg_gen_movi_i32(cpu_ldst, 0);

	    return;

	} else

	    break;

    case 0x0063:

        /* MOVLI.L @Rm,R0

               1 -> LDST

               (Rm) -> R0

               When interrupt/exception

               occurred 0 -> LDST

        */

	if (ctx->features & SH_FEATURE_SH4A) {

	    tcg_gen_movi_i32(cpu_ldst, 0);

	    tcg_gen_qemu_ld32s(REG(0), REG(B11_8), ctx->memidx);

	    tcg_gen_movi_i32(cpu_ldst, 1);

	    return;

	} else

	    break;

    case 0x0093:		/* ocbi @Rn */

	{

	    gen_helper_ocbi (REG(B11_8));

	}

	return;

    case 0x00a3:		/* ocbp @Rn */

	{

	    TCGv dummy = tcg_temp_new();

	    tcg_gen_qemu_ld32s(dummy, REG(B11_8), ctx->memidx);

	    tcg_temp_free(dummy);

	}

	return;

    case 0x00b3:		/* ocbwb @Rn */

	{

	    TCGv dummy = tcg_temp_new();

	    tcg_gen_qemu_ld32s(dummy, REG(B11_8), ctx->memidx);

	    tcg_temp_free(dummy);

	}

	return;

    case 0x0083:		/* pref @Rn */

	return;

    case 0x00d3:		/* prefi @Rn */

	if (ctx->features & SH_FEATURE_SH4A)

	    return;

	else

	    break;

    case 0x00e3:		/* icbi @Rn */

	if (ctx->features & SH_FEATURE_SH4A)

	    return;

	else

	    break;

    case 0x00ab:		/* synco */

	if (ctx->features & SH_FEATURE_SH4A)

	    return;

	else

	    break;

    case 0x4024:		/* rotcl Rn */

	{

	    TCGv tmp = tcg_temp_new();

	    tcg_gen_mov_i32(tmp, cpu_sr);

	    gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);

	    tcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);

	    gen_copy_bit_i32(REG(B11_8), 0, tmp, 0);

	    tcg_temp_free(tmp);

	}

	return;

    case 0x4025:		/* rotcr Rn */

	{

	    TCGv tmp = tcg_temp_new();

	    tcg_gen_mov_i32(tmp, cpu_sr);

	    gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);

	    tcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);

	    gen_copy_bit_i32(REG(B11_8), 31, tmp, 0);

	    tcg_temp_free(tmp);

	}

	return;

    case 0x4004:		/* rotl Rn */

	gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);

	tcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);

	gen_copy_bit_i32(REG(B11_8), 0, cpu_sr, 0);

	return;

    case 0x4005:		/* rotr Rn */

	gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);

	tcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);

	gen_copy_bit_i32(REG(B11_8), 31, cpu_sr, 0);

	return;

    case 0x4000:		/* shll Rn */

    case 0x4020:		/* shal Rn */

	gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);

	tcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);

	return;

    case 0x4021:		/* shar Rn */

	gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);

	tcg_gen_sari_i32(REG(B11_8), REG(B11_8), 1);

	return;

    case 0x4001:		/* shlr Rn */

	gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);

	tcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);

	return;

    case 0x4008:		/* shll2 Rn */

	tcg_gen_shli_i32(REG(B11_8), REG(B11_8), 2);

	return;

    case 0x4018:		/* shll8 Rn */

	tcg_gen_shli_i32(REG(B11_8), REG(B11_8), 8);

	return;

    case 0x4028:		/* shll16 Rn */

	tcg_gen_shli_i32(REG(B11_8), REG(B11_8), 16);

	return;

    case 0x4009:		/* shlr2 Rn */

	tcg_gen_shri_i32(REG(B11_8), REG(B11_8), 2);

	return;

    case 0x4019:		/* shlr8 Rn */

	tcg_gen_shri_i32(REG(B11_8), REG(B11_8), 8);

	return;

    case 0x4029:		/* shlr16 Rn */

	tcg_gen_shri_i32(REG(B11_8), REG(B11_8), 16);

	return;

    case 0x401b:		/* tas.b @Rn */

	{

	    TCGv addr, val;

	    addr = tcg_temp_local_new();

	    tcg_gen_mov_i32(addr, REG(B11_8));

	    val = tcg_temp_local_new();

	    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);

	    gen_cmp_imm(TCG_COND_EQ, val, 0);

	    tcg_gen_ori_i32(val, val, 0x80);

	    tcg_gen_qemu_st8(val, addr, ctx->memidx);

	    tcg_temp_free(val);

	    tcg_temp_free(addr);

	}

	return;

    case 0xf00d: /* fsts FPUL,FRn - FPSCR: Nothing */

	CHECK_FPU_ENABLED

	tcg_gen_mov_i32(cpu_fregs[FREG(B11_8)], cpu_fpul);

	return;

    case 0xf01d: /* flds FRm,FPUL - FPSCR: Nothing */

	CHECK_FPU_ENABLED

	tcg_gen_mov_i32(cpu_fpul, cpu_fregs[FREG(B11_8)]);

	return;

    case 0xf02d: /* float FPUL,FRn/DRn - FPSCR: R[PR,Enable.I]/W[Cause,Flag] */

	CHECK_FPU_ENABLED

	if (ctx->fpscr & FPSCR_PR) {

	    TCGv_i64 fp;

	    if (ctx->opcode & 0x0100)

		break; /* illegal instruction */

	    fp = tcg_temp_new_i64();

	    gen_helper_float_DT(fp, cpu_fpul);

	    gen_store_fpr64(fp, DREG(B11_8));

	    tcg_temp_free_i64(fp);

	}

	else {

	    gen_helper_float_FT(cpu_fregs[FREG(B11_8)], cpu_fpul);

	}

	return;

    case 0xf03d: /* ftrc FRm/DRm,FPUL - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */

	CHECK_FPU_ENABLED

	if (ctx->fpscr & FPSCR_PR) {

	    TCGv_i64 fp;

	    if (ctx->opcode & 0x0100)

		break; /* illegal instruction */

	    fp = tcg_temp_new_i64();

	    gen_load_fpr64(fp, DREG(B11_8));

	    gen_helper_ftrc_DT(cpu_fpul, fp);

	    tcg_temp_free_i64(fp);

	}

	else {

	    gen_helper_ftrc_FT(cpu_fpul, cpu_fregs[FREG(B11_8)]);

	}

	return;

    case 0xf04d: /* fneg FRn/DRn - FPSCR: Nothing */

	CHECK_FPU_ENABLED

	{

	    gen_helper_fneg_T(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);

	}

	return;

    case 0xf05d: /* fabs FRn/DRn */

	CHECK_FPU_ENABLED

	if (ctx->fpscr & FPSCR_PR) {

	    if (ctx->opcode & 0x0100)

		break; /* illegal instruction */

	    TCGv_i64 fp = tcg_temp_new_i64();

	    gen_load_fpr64(fp, DREG(B11_8));

	    gen_helper_fabs_DT(fp, fp);

	    gen_store_fpr64(fp, DREG(B11_8));

	    tcg_temp_free_i64(fp);

	} else {

	    gen_helper_fabs_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);

	}

	return;

    case 0xf06d: /* fsqrt FRn */

	CHECK_FPU_ENABLED

	if (ctx->fpscr & FPSCR_PR) {

	    if (ctx->opcode & 0x0100)

		break; /* illegal instruction */

	    TCGv_i64 fp = tcg_temp_new_i64();

	    gen_load_fpr64(fp, DREG(B11_8));

	    gen_helper_fsqrt_DT(fp, fp);

	    gen_store_fpr64(fp, DREG(B11_8));

	    tcg_temp_free_i64(fp);

	} else {

	    gen_helper_fsqrt_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);

	}

	return;

    case 0xf07d: /* fsrra FRn */

	CHECK_FPU_ENABLED

	break;

    case 0xf08d: /* fldi0 FRn - FPSCR: R[PR] */

	CHECK_FPU_ENABLED

	if (!(ctx->fpscr & FPSCR_PR)) {

	    tcg_gen_movi_i32(cpu_fregs[FREG(B11_8)], 0);

	}

	return;

    case 0xf09d: /* fldi1 FRn - FPSCR: R[PR] */

	CHECK_FPU_ENABLED

	if (!(ctx->fpscr & FPSCR_PR)) {

	    tcg_gen_movi_i32(cpu_fregs[FREG(B11_8)], 0x3f800000);

	}

	return;

    case 0xf0ad: /* fcnvsd FPUL,DRn */

	CHECK_FPU_ENABLED

	{

	    TCGv_i64 fp = tcg_temp_new_i64();

	    gen_helper_fcnvsd_FT_DT(fp, cpu_fpul);

	    gen_store_fpr64(fp, DREG(B11_8));

	    tcg_temp_free_i64(fp);

	}

	return;

    case 0xf0bd: /* fcnvds DRn,FPUL */

	CHECK_FPU_ENABLED

	{

	    TCGv_i64 fp = tcg_temp_new_i64();

	    gen_load_fpr64(fp, DREG(B11_8));

	    gen_helper_fcnvds_DT_FT(cpu_fpul, fp);

	    tcg_temp_free_i64(fp);

	}

	return;

    }

#if 0

    fprintf(stderr, ""unknown instruction 0x%04x at pc 0x%08x\n"",

	    ctx->opcode, ctx->pc);

    fflush(stderr);

#endif

    gen_helper_raise_illegal_instruction();

    ctx->bstate = BS_EXCP;

}
",7991,"static void _decode_opc(DisasContext * ctx)

{

    /* This code tries to make movcal emulation sufficiently

       accurate for Linux purposes.  This instruction writes

       memory, and prior to that, always allocates a cache line.

       It is used in two contexts:

       - in memcpy, where data is copied in blocks, the first write

       of to a block uses movca.l for performance.

       - in arch/sh/mm/cache-sh4.c, movcal.l + ocbi combination is used

       to flush the cache. Here, the data written by movcal.l is never

       written to memory, and the data written is just bogus.



       To simulate this, we simulate movcal.l, we store the value to memory,

       but we also remember the previous content. If we see ocbi, we check

       if movcal.l for that address was done previously. If so, the write should

       not have hit the memory, so we restore the previous content.

       When we see an instruction that is neither movca.l

       nor ocbi, the previous content is discarded.



       To optimize, we only try to flush stores when we're at the start of

       TB, or if we already saw movca.l in this TB and did not flush stores

       yet.  */

    if (ctx->has_movcal)

	{

	  int opcode = ctx->opcode & 0xf0ff;

	  if (opcode != 0x0093 /* ocbi */

	      && opcode != 0x00c3 /* movca.l */)

	      {

		  gen_helper_discard_movcal_backup ();

		  ctx->has_movcal = 0;

	      }

	}



#if 0

    fprintf(stderr, ""Translating opcode 0x%04x
"", ctx->opcode);

#endif



    switch (ctx->opcode) {

    case 0x0019:		/* div0u */

	tcg_gen_andi_i32(cpu_sr, cpu_sr, ~(SR_M | SR_Q | SR_T));

	return;

    case 0x000b:		/* rts */

	CHECK_NOT_DELAY_BLAT

	tcg_gen_mov_i32(cpu_delayed_pc, cpu_pr);

	ctx->flags |= DELAY_SLOT;

	ctx->delayed_pc = (uint32_t) - 1;

	return;

    case 0x0028:		/* clrmac */

	tcg_gen_movi_i32(cpu_mach, 0);

	tcg_gen_movi_i32(cpu_macl, 0);

	return;

    case 0x0048:		/* clrs */

	tcg_gen_andi_i32(cpu_sr, cpu_sr, ~SR_S);

	return;

    case 0x0008:		/* clrt */

	gen_clr_t();

	return;

    case 0x0038:		/* ldtlb */

	CHECK_PRIVILEGED

	gen_helper_ldtlb();

	return;

    case 0x002b:		/* rte */

	CHECK_PRIVILEGED

	CHECK_NOT_DELAY_BLAT

	tcg_gen_mov_i32(cpu_sr, cpu_ssr);

	tcg_gen_mov_i32(cpu_delayed_pc, cpu_spc);

	ctx->flags |= DELAY_SLOT;

	ctx->delayed_pc = (uint32_t) - 1;

	return;

    case 0x0058:		/* sets */

	tcg_gen_ori_i32(cpu_sr, cpu_sr, SR_S);

	return;

    case 0x0018:		/* sett */

	gen_set_t();

	return;

    case 0xfbfd:		/* frchg */

	tcg_gen_xori_i32(cpu_fpscr, cpu_fpscr, FPSCR_FR);

	ctx->bstate = BS_STOP;

	return;

    case 0xf3fd:		/* fschg */

	tcg_gen_xori_i32(cpu_fpscr, cpu_fpscr, FPSCR_SZ);

	ctx->bstate = BS_STOP;

	return;

    case 0x0009:		/* nop */

	return;

    case 0x001b:		/* sleep */

	CHECK_PRIVILEGED

	gen_helper_sleep(tcg_const_i32(ctx->pc + 2));

	return;

    }



    switch (ctx->opcode & 0xf000) {

    case 0x1000:		/* mov.l Rm,@(disp,Rn) */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, REG(B11_8), B3_0 * 4);

	    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x5000:		/* mov.l @(disp,Rm),Rn */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 4);

	    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0xe000:		/* mov #imm,Rn */

	tcg_gen_movi_i32(REG(B11_8), B7_0s);

	return;

    case 0x9000:		/* mov.w @(disp,PC),Rn */

	{

	    TCGv addr = tcg_const_i32(ctx->pc + 4 + B7_0 * 2);

	    tcg_gen_qemu_ld16s(REG(B11_8), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0xd000:		/* mov.l @(disp,PC),Rn */

	{

	    TCGv addr = tcg_const_i32((ctx->pc + 4 + B7_0 * 4) & ~3);

	    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x7000:		/* add #imm,Rn */

	tcg_gen_addi_i32(REG(B11_8), REG(B11_8), B7_0s);

	return;

    case 0xa000:		/* bra disp */

	CHECK_NOT_DELAY_BLAT

	ctx->delayed_pc = ctx->pc + 4 + B11_0s * 2;

	tcg_gen_movi_i32(cpu_delayed_pc, ctx->delayed_pc);

	ctx->flags |= DELAY_SLOT;

	return;

    case 0xb000:		/* bsr disp */

	CHECK_NOT_DELAY_BLAT

	tcg_gen_movi_i32(cpu_pr, ctx->pc + 4);

	ctx->delayed_pc = ctx->pc + 4 + B11_0s * 2;

	tcg_gen_movi_i32(cpu_delayed_pc, ctx->delayed_pc);

	ctx->flags |= DELAY_SLOT;

	return;

    }



    switch (ctx->opcode & 0xf00f) {

    case 0x6003:		/* mov Rm,Rn */

	tcg_gen_mov_i32(REG(B11_8), REG(B7_4));

	return;

    case 0x2000:		/* mov.b Rm,@Rn */

	tcg_gen_qemu_st8(REG(B7_4), REG(B11_8), ctx->memidx);

	return;

    case 0x2001:		/* mov.w Rm,@Rn */

	tcg_gen_qemu_st16(REG(B7_4), REG(B11_8), ctx->memidx);

	return;

    case 0x2002:		/* mov.l Rm,@Rn */

	tcg_gen_qemu_st32(REG(B7_4), REG(B11_8), ctx->memidx);

	return;

    case 0x6000:		/* mov.b @Rm,Rn */

	tcg_gen_qemu_ld8s(REG(B11_8), REG(B7_4), ctx->memidx);

	return;

    case 0x6001:		/* mov.w @Rm,Rn */

	tcg_gen_qemu_ld16s(REG(B11_8), REG(B7_4), ctx->memidx);

	return;

    case 0x6002:		/* mov.l @Rm,Rn */

	tcg_gen_qemu_ld32s(REG(B11_8), REG(B7_4), ctx->memidx);

	return;

    case 0x2004:		/* mov.b Rm,@-Rn */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_subi_i32(addr, REG(B11_8), 1);

	    tcg_gen_qemu_st8(REG(B7_4), addr, ctx->memidx);	/* might cause re-execution */

	    tcg_gen_mov_i32(REG(B11_8), addr);			/* modify register status */

	    tcg_temp_free(addr);

	}

	return;

    case 0x2005:		/* mov.w Rm,@-Rn */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_subi_i32(addr, REG(B11_8), 2);

	    tcg_gen_qemu_st16(REG(B7_4), addr, ctx->memidx);

	    tcg_gen_mov_i32(REG(B11_8), addr);

	    tcg_temp_free(addr);

	}

	return;

    case 0x2006:		/* mov.l Rm,@-Rn */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_subi_i32(addr, REG(B11_8), 4);

	    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);

	    tcg_gen_mov_i32(REG(B11_8), addr);

	}

	return;

    case 0x6004:		/* mov.b @Rm+,Rn */

	tcg_gen_qemu_ld8s(REG(B11_8), REG(B7_4), ctx->memidx);

	if ( B11_8 != B7_4 )

		tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 1);

	return;

    case 0x6005:		/* mov.w @Rm+,Rn */

	tcg_gen_qemu_ld16s(REG(B11_8), REG(B7_4), ctx->memidx);

	if ( B11_8 != B7_4 )

		tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 2);

	return;

    case 0x6006:		/* mov.l @Rm+,Rn */

	tcg_gen_qemu_ld32s(REG(B11_8), REG(B7_4), ctx->memidx);

	if ( B11_8 != B7_4 )

		tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);

	return;

    case 0x0004:		/* mov.b Rm,@(R0,Rn) */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_add_i32(addr, REG(B11_8), REG(0));

	    tcg_gen_qemu_st8(REG(B7_4), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x0005:		/* mov.w Rm,@(R0,Rn) */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_add_i32(addr, REG(B11_8), REG(0));

	    tcg_gen_qemu_st16(REG(B7_4), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x0006:		/* mov.l Rm,@(R0,Rn) */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_add_i32(addr, REG(B11_8), REG(0));

	    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x000c:		/* mov.b @(R0,Rm),Rn */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_add_i32(addr, REG(B7_4), REG(0));

	    tcg_gen_qemu_ld8s(REG(B11_8), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x000d:		/* mov.w @(R0,Rm),Rn */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_add_i32(addr, REG(B7_4), REG(0));

	    tcg_gen_qemu_ld16s(REG(B11_8), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x000e:		/* mov.l @(R0,Rm),Rn */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_add_i32(addr, REG(B7_4), REG(0));

	    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x6008:		/* swap.b Rm,Rn */

	{

	    TCGv high, low;

	    high = tcg_temp_new();

	    tcg_gen_andi_i32(high, REG(B7_4), 0xffff0000);

	    low = tcg_temp_new();

	    tcg_gen_ext16u_i32(low, REG(B7_4));

	    tcg_gen_bswap16_i32(low, low);

	    tcg_gen_or_i32(REG(B11_8), high, low);

	    tcg_temp_free(low);

	    tcg_temp_free(high);

	}

	return;

    case 0x6009:		/* swap.w Rm,Rn */

	{

	    TCGv high, low;

	    high = tcg_temp_new();

	    tcg_gen_shli_i32(high, REG(B7_4), 16);

	    low = tcg_temp_new();

	    tcg_gen_shri_i32(low, REG(B7_4), 16);

	    tcg_gen_ext16u_i32(low, low);

	    tcg_gen_or_i32(REG(B11_8), high, low);

	    tcg_temp_free(low);

	    tcg_temp_free(high);

	}

	return;

    case 0x200d:		/* xtrct Rm,Rn */

	{

	    TCGv high, low;

	    high = tcg_temp_new();

	    tcg_gen_shli_i32(high, REG(B7_4), 16);

	    low = tcg_temp_new();

	    tcg_gen_shri_i32(low, REG(B11_8), 16);

	    tcg_gen_ext16u_i32(low, low);

	    tcg_gen_or_i32(REG(B11_8), high, low);

	    tcg_temp_free(low);

	    tcg_temp_free(high);

	}

	return;

    case 0x300c:		/* add Rm,Rn */

	tcg_gen_add_i32(REG(B11_8), REG(B11_8), REG(B7_4));

	return;

    case 0x300e:		/* addc Rm,Rn */

	gen_helper_addc(REG(B11_8), REG(B7_4), REG(B11_8));

	return;

    case 0x300f:		/* addv Rm,Rn */

	gen_helper_addv(REG(B11_8), REG(B7_4), REG(B11_8));

	return;

    case 0x2009:		/* and Rm,Rn */

	tcg_gen_and_i32(REG(B11_8), REG(B11_8), REG(B7_4));

	return;

    case 0x3000:		/* cmp/eq Rm,Rn */

	gen_cmp(TCG_COND_EQ, REG(B7_4), REG(B11_8));

	return;

    case 0x3003:		/* cmp/ge Rm,Rn */

	gen_cmp(TCG_COND_GE, REG(B7_4), REG(B11_8));

	return;

    case 0x3007:		/* cmp/gt Rm,Rn */

	gen_cmp(TCG_COND_GT, REG(B7_4), REG(B11_8));

	return;

    case 0x3006:		/* cmp/hi Rm,Rn */

	gen_cmp(TCG_COND_GTU, REG(B7_4), REG(B11_8));

	return;

    case 0x3002:		/* cmp/hs Rm,Rn */

	gen_cmp(TCG_COND_GEU, REG(B7_4), REG(B11_8));

	return;

    case 0x200c:		/* cmp/str Rm,Rn */

	{

	    int label1 = gen_new_label();

	    int label2 = gen_new_label();

	    TCGv cmp1 = tcg_temp_local_new();

	    TCGv cmp2 = tcg_temp_local_new();

	    tcg_gen_xor_i32(cmp1, REG(B7_4), REG(B11_8));

	    tcg_gen_andi_i32(cmp2, cmp1, 0xff000000);

	    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);

	    tcg_gen_andi_i32(cmp2, cmp1, 0x00ff0000);

	    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);

	    tcg_gen_andi_i32(cmp2, cmp1, 0x0000ff00);

	    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);

	    tcg_gen_andi_i32(cmp2, cmp1, 0x000000ff);

	    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);

	    tcg_gen_andi_i32(cpu_sr, cpu_sr, ~SR_T);

	    tcg_gen_br(label2);

	    gen_set_label(label1);

	    tcg_gen_ori_i32(cpu_sr, cpu_sr, SR_T);

	    gen_set_label(label2);

	    tcg_temp_free(cmp2);

	    tcg_temp_free(cmp1);

	}

	return;

    case 0x2007:		/* div0s Rm,Rn */

	{

	    gen_copy_bit_i32(cpu_sr, 8, REG(B11_8), 31);	/* SR_Q */

	    gen_copy_bit_i32(cpu_sr, 9, REG(B7_4), 31);		/* SR_M */

	    TCGv val = tcg_temp_new();

	    tcg_gen_xor_i32(val, REG(B7_4), REG(B11_8));

	    gen_copy_bit_i32(cpu_sr, 0, val, 31);		/* SR_T */

	    tcg_temp_free(val);

	}

	return;

    case 0x3004:		/* div1 Rm,Rn */

	gen_helper_div1(REG(B11_8), REG(B7_4), REG(B11_8));

	return;

    case 0x300d:		/* dmuls.l Rm,Rn */

	{

	    TCGv_i64 tmp1 = tcg_temp_new_i64();

	    TCGv_i64 tmp2 = tcg_temp_new_i64();



	    tcg_gen_ext_i32_i64(tmp1, REG(B7_4));

	    tcg_gen_ext_i32_i64(tmp2, REG(B11_8));

	    tcg_gen_mul_i64(tmp1, tmp1, tmp2);

	    tcg_gen_trunc_i64_i32(cpu_macl, tmp1);

	    tcg_gen_shri_i64(tmp1, tmp1, 32);

	    tcg_gen_trunc_i64_i32(cpu_mach, tmp1);



	    tcg_temp_free_i64(tmp2);

	    tcg_temp_free_i64(tmp1);

	}

	return;

    case 0x3005:		/* dmulu.l Rm,Rn */

	{

	    TCGv_i64 tmp1 = tcg_temp_new_i64();

	    TCGv_i64 tmp2 = tcg_temp_new_i64();



	    tcg_gen_extu_i32_i64(tmp1, REG(B7_4));

	    tcg_gen_extu_i32_i64(tmp2, REG(B11_8));

	    tcg_gen_mul_i64(tmp1, tmp1, tmp2);

	    tcg_gen_trunc_i64_i32(cpu_macl, tmp1);

	    tcg_gen_shri_i64(tmp1, tmp1, 32);

	    tcg_gen_trunc_i64_i32(cpu_mach, tmp1);



	    tcg_temp_free_i64(tmp2);

	    tcg_temp_free_i64(tmp1);

	}

	return;

    case 0x600e:		/* exts.b Rm,Rn */

	tcg_gen_ext8s_i32(REG(B11_8), REG(B7_4));

	return;

    case 0x600f:		/* exts.w Rm,Rn */

	tcg_gen_ext16s_i32(REG(B11_8), REG(B7_4));

	return;

    case 0x600c:		/* extu.b Rm,Rn */

	tcg_gen_ext8u_i32(REG(B11_8), REG(B7_4));

	return;

    case 0x600d:		/* extu.w Rm,Rn */

	tcg_gen_ext16u_i32(REG(B11_8), REG(B7_4));

	return;

    case 0x000f:		/* mac.l @Rm+,@Rn+ */

	{

	    TCGv arg0, arg1;

	    arg0 = tcg_temp_new();

	    tcg_gen_qemu_ld32s(arg0, REG(B7_4), ctx->memidx);

	    arg1 = tcg_temp_new();

	    tcg_gen_qemu_ld32s(arg1, REG(B11_8), ctx->memidx);

	    gen_helper_macl(arg0, arg1);

	    tcg_temp_free(arg1);

	    tcg_temp_free(arg0);

	    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);

	    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);

	}

	return;

    case 0x400f:		/* mac.w @Rm+,@Rn+ */

	{

	    TCGv arg0, arg1;

	    arg0 = tcg_temp_new();

	    tcg_gen_qemu_ld32s(arg0, REG(B7_4), ctx->memidx);

	    arg1 = tcg_temp_new();

	    tcg_gen_qemu_ld32s(arg1, REG(B11_8), ctx->memidx);

	    gen_helper_macw(arg0, arg1);

	    tcg_temp_free(arg1);

	    tcg_temp_free(arg0);

	    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 2);

	    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 2);

	}

	return;

    case 0x0007:		/* mul.l Rm,Rn */

	tcg_gen_mul_i32(cpu_macl, REG(B7_4), REG(B11_8));

	return;

    case 0x200f:		/* muls.w Rm,Rn */

	{

	    TCGv arg0, arg1;

	    arg0 = tcg_temp_new();

	    tcg_gen_ext16s_i32(arg0, REG(B7_4));

	    arg1 = tcg_temp_new();

	    tcg_gen_ext16s_i32(arg1, REG(B11_8));

	    tcg_gen_mul_i32(cpu_macl, arg0, arg1);

	    tcg_temp_free(arg1);

	    tcg_temp_free(arg0);

	}

	return;

    case 0x200e:		/* mulu.w Rm,Rn */

	{

	    TCGv arg0, arg1;

	    arg0 = tcg_temp_new();

	    tcg_gen_ext16u_i32(arg0, REG(B7_4));

	    arg1 = tcg_temp_new();

	    tcg_gen_ext16u_i32(arg1, REG(B11_8));

	    tcg_gen_mul_i32(cpu_macl, arg0, arg1);

	    tcg_temp_free(arg1);

	    tcg_temp_free(arg0);

	}

	return;

    case 0x600b:		/* neg Rm,Rn */

	tcg_gen_neg_i32(REG(B11_8), REG(B7_4));

	return;

    case 0x600a:		/* negc Rm,Rn */

	gen_helper_negc(REG(B11_8), REG(B7_4));

	return;

    case 0x6007:		/* not Rm,Rn */

	tcg_gen_not_i32(REG(B11_8), REG(B7_4));

	return;

    case 0x200b:		/* or Rm,Rn */

	tcg_gen_or_i32(REG(B11_8), REG(B11_8), REG(B7_4));

	return;

    case 0x400c:		/* shad Rm,Rn */

	{

	    int label1 = gen_new_label();

	    int label2 = gen_new_label();

	    int label3 = gen_new_label();

	    int label4 = gen_new_label();

	    TCGv shift;

	    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B7_4), 0, label1);

	    /* Rm positive, shift to the left */

            shift = tcg_temp_new();

	    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);

	    tcg_gen_shl_i32(REG(B11_8), REG(B11_8), shift);

	    tcg_temp_free(shift);

	    tcg_gen_br(label4);

	    /* Rm negative, shift to the right */

	    gen_set_label(label1);

            shift = tcg_temp_new();

	    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);

	    tcg_gen_brcondi_i32(TCG_COND_EQ, shift, 0, label2);

	    tcg_gen_not_i32(shift, REG(B7_4));

	    tcg_gen_andi_i32(shift, shift, 0x1f);

	    tcg_gen_addi_i32(shift, shift, 1);

	    tcg_gen_sar_i32(REG(B11_8), REG(B11_8), shift);

	    tcg_temp_free(shift);

	    tcg_gen_br(label4);

	    /* Rm = -32 */

	    gen_set_label(label2);

	    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B11_8), 0, label3);

	    tcg_gen_movi_i32(REG(B11_8), 0);

	    tcg_gen_br(label4);

	    gen_set_label(label3);

	    tcg_gen_movi_i32(REG(B11_8), 0xffffffff);

	    gen_set_label(label4);

	}

	return;

    case 0x400d:		/* shld Rm,Rn */

	{

	    int label1 = gen_new_label();

	    int label2 = gen_new_label();

	    int label3 = gen_new_label();

	    TCGv shift;

	    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B7_4), 0, label1);

	    /* Rm positive, shift to the left */

            shift = tcg_temp_new();

	    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);

	    tcg_gen_shl_i32(REG(B11_8), REG(B11_8), shift);

	    tcg_temp_free(shift);

	    tcg_gen_br(label3);

	    /* Rm negative, shift to the right */

	    gen_set_label(label1);

            shift = tcg_temp_new();

	    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);

	    tcg_gen_brcondi_i32(TCG_COND_EQ, shift, 0, label2);

	    tcg_gen_not_i32(shift, REG(B7_4));

	    tcg_gen_andi_i32(shift, shift, 0x1f);

	    tcg_gen_addi_i32(shift, shift, 1);

	    tcg_gen_shr_i32(REG(B11_8), REG(B11_8), shift);

	    tcg_temp_free(shift);

	    tcg_gen_br(label3);

	    /* Rm = -32 */

	    gen_set_label(label2);

	    tcg_gen_movi_i32(REG(B11_8), 0);

	    gen_set_label(label3);

	}

	return;

    case 0x3008:		/* sub Rm,Rn */

	tcg_gen_sub_i32(REG(B11_8), REG(B11_8), REG(B7_4));

	return;

    case 0x300a:		/* subc Rm,Rn */

	gen_helper_subc(REG(B11_8), REG(B7_4), REG(B11_8));

	return;

    case 0x300b:		/* subv Rm,Rn */

	gen_helper_subv(REG(B11_8), REG(B7_4), REG(B11_8));

	return;

    case 0x2008:		/* tst Rm,Rn */

	{

	    TCGv val = tcg_temp_new();

	    tcg_gen_and_i32(val, REG(B7_4), REG(B11_8));

	    gen_cmp_imm(TCG_COND_EQ, val, 0);

	    tcg_temp_free(val);

	}

	return;

    case 0x200a:		/* xor Rm,Rn */

	tcg_gen_xor_i32(REG(B11_8), REG(B11_8), REG(B7_4));

	return;

    case 0xf00c: /* fmov {F,D,X}Rm,{F,D,X}Rn - FPSCR: Nothing */

	CHECK_FPU_ENABLED

	if (ctx->fpscr & FPSCR_SZ) {

	    TCGv_i64 fp = tcg_temp_new_i64();

	    gen_load_fpr64(fp, XREG(B7_4));

	    gen_store_fpr64(fp, XREG(B11_8));

	    tcg_temp_free_i64(fp);

	} else {

	    tcg_gen_mov_i32(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);

	}

	return;

    case 0xf00a: /* fmov {F,D,X}Rm,@Rn - FPSCR: Nothing */

	CHECK_FPU_ENABLED

	if (ctx->fpscr & FPSCR_SZ) {

	    TCGv addr_hi = tcg_temp_new();

	    int fr = XREG(B7_4);

	    tcg_gen_addi_i32(addr_hi, REG(B11_8), 4);

	    tcg_gen_qemu_st32(cpu_fregs[fr  ], REG(B11_8), ctx->memidx);

	    tcg_gen_qemu_st32(cpu_fregs[fr+1], addr_hi,	   ctx->memidx);

	    tcg_temp_free(addr_hi);

	} else {

	    tcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], REG(B11_8), ctx->memidx);

	}

	return;

    case 0xf008: /* fmov @Rm,{F,D,X}Rn - FPSCR: Nothing */

	CHECK_FPU_ENABLED

	if (ctx->fpscr & FPSCR_SZ) {

	    TCGv addr_hi = tcg_temp_new();

	    int fr = XREG(B11_8);

	    tcg_gen_addi_i32(addr_hi, REG(B7_4), 4);

	    tcg_gen_qemu_ld32u(cpu_fregs[fr  ], REG(B7_4), ctx->memidx);

	    tcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr_hi,   ctx->memidx);

	    tcg_temp_free(addr_hi);

	} else {

	    tcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], REG(B7_4), ctx->memidx);

	}

	return;

    case 0xf009: /* fmov @Rm+,{F,D,X}Rn - FPSCR: Nothing */

	CHECK_FPU_ENABLED

	if (ctx->fpscr & FPSCR_SZ) {

	    TCGv addr_hi = tcg_temp_new();

	    int fr = XREG(B11_8);

	    tcg_gen_addi_i32(addr_hi, REG(B7_4), 4);

	    tcg_gen_qemu_ld32u(cpu_fregs[fr  ], REG(B7_4), ctx->memidx);

	    tcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr_hi,   ctx->memidx);

	    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 8);

	    tcg_temp_free(addr_hi);

	} else {

	    tcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], REG(B7_4), ctx->memidx);

	    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);

	}

	return;

    case 0xf00b: /* fmov {F,D,X}Rm,@-Rn - FPSCR: Nothing */

	CHECK_FPU_ENABLED

	if (ctx->fpscr & FPSCR_SZ) {

	    TCGv addr = tcg_temp_new_i32();

	    int fr = XREG(B7_4);

	    tcg_gen_subi_i32(addr, REG(B11_8), 4);

	    tcg_gen_qemu_st32(cpu_fregs[fr+1], addr, ctx->memidx);

	    tcg_gen_subi_i32(addr, addr, 4);

	    tcg_gen_qemu_st32(cpu_fregs[fr  ], addr, ctx->memidx);

	    tcg_gen_mov_i32(REG(B11_8), addr);

	    tcg_temp_free(addr);

	} else {

	    TCGv addr;

	    addr = tcg_temp_new_i32();

	    tcg_gen_subi_i32(addr, REG(B11_8), 4);

	    tcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], addr, ctx->memidx);

	    tcg_gen_mov_i32(REG(B11_8), addr);

	    tcg_temp_free(addr);

	}

	return;

    case 0xf006: /* fmov @(R0,Rm),{F,D,X}Rm - FPSCR: Nothing */

	CHECK_FPU_ENABLED

	{

	    TCGv addr = tcg_temp_new_i32();

	    tcg_gen_add_i32(addr, REG(B7_4), REG(0));

	    if (ctx->fpscr & FPSCR_SZ) {

		int fr = XREG(B11_8);

		tcg_gen_qemu_ld32u(cpu_fregs[fr	 ], addr, ctx->memidx);

		tcg_gen_addi_i32(addr, addr, 4);

		tcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr, ctx->memidx);

	    } else {

		tcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], addr, ctx->memidx);

	    }

	    tcg_temp_free(addr);

	}

	return;

    case 0xf007: /* fmov {F,D,X}Rn,@(R0,Rn) - FPSCR: Nothing */

	CHECK_FPU_ENABLED

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_add_i32(addr, REG(B11_8), REG(0));

	    if (ctx->fpscr & FPSCR_SZ) {

		int fr = XREG(B7_4);

		tcg_gen_qemu_ld32u(cpu_fregs[fr	 ], addr, ctx->memidx);

		tcg_gen_addi_i32(addr, addr, 4);

		tcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr, ctx->memidx);

	    } else {

		tcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], addr, ctx->memidx);

	    }

	    tcg_temp_free(addr);

	}

	return;

    case 0xf000: /* fadd Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */

    case 0xf001: /* fsub Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */

    case 0xf002: /* fmul Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */

    case 0xf003: /* fdiv Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */

    case 0xf004: /* fcmp/eq Rm,Rn - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */

    case 0xf005: /* fcmp/gt Rm,Rn - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */

	{

	    CHECK_FPU_ENABLED

	    if (ctx->fpscr & FPSCR_PR) {

                TCGv_i64 fp0, fp1;



		if (ctx->opcode & 0x0110)

		    break; /* illegal instruction */

		fp0 = tcg_temp_new_i64();

		fp1 = tcg_temp_new_i64();

		gen_load_fpr64(fp0, DREG(B11_8));

		gen_load_fpr64(fp1, DREG(B7_4));

                switch (ctx->opcode & 0xf00f) {

                case 0xf000:		/* fadd Rm,Rn */

                    gen_helper_fadd_DT(fp0, fp0, fp1);

                    break;

                case 0xf001:		/* fsub Rm,Rn */

                    gen_helper_fsub_DT(fp0, fp0, fp1);

                    break;

                case 0xf002:		/* fmul Rm,Rn */

                    gen_helper_fmul_DT(fp0, fp0, fp1);

                    break;

                case 0xf003:		/* fdiv Rm,Rn */

                    gen_helper_fdiv_DT(fp0, fp0, fp1);

                    break;

                case 0xf004:		/* fcmp/eq Rm,Rn */

                    gen_helper_fcmp_eq_DT(fp0, fp1);

                    return;

                case 0xf005:		/* fcmp/gt Rm,Rn */

                    gen_helper_fcmp_gt_DT(fp0, fp1);

                    return;

                }

		gen_store_fpr64(fp0, DREG(B11_8));

                tcg_temp_free_i64(fp0);

                tcg_temp_free_i64(fp1);

	    } else {

                switch (ctx->opcode & 0xf00f) {

                case 0xf000:		/* fadd Rm,Rn */

                    gen_helper_fadd_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);

                    break;

                case 0xf001:		/* fsub Rm,Rn */

                    gen_helper_fsub_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);

                    break;

                case 0xf002:		/* fmul Rm,Rn */

                    gen_helper_fmul_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);

                    break;

                case 0xf003:		/* fdiv Rm,Rn */

                    gen_helper_fdiv_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);

                    break;

                case 0xf004:		/* fcmp/eq Rm,Rn */

                    gen_helper_fcmp_eq_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);

                    return;

                case 0xf005:		/* fcmp/gt Rm,Rn */

                    gen_helper_fcmp_gt_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);

                    return;

                }

	    }

	}

	return;

    case 0xf00e: /* fmac FR0,RM,Rn */

        {

            CHECK_FPU_ENABLED

            if (ctx->fpscr & FPSCR_PR) {

                break; /* illegal instruction */

            } else {

                gen_helper_fmac_FT(cpu_fregs[FREG(B11_8)],

                                   cpu_fregs[FREG(0)], cpu_fregs[FREG(B7_4)], cpu_fregs[FREG(B11_8)]);

                return;

            }

        }

    }



    switch (ctx->opcode & 0xff00) {

    case 0xc900:		/* and #imm,R0 */

	tcg_gen_andi_i32(REG(0), REG(0), B7_0);

	return;

    case 0xcd00:		/* and.b #imm,@(R0,GBR) */

	{

	    TCGv addr, val;

	    addr = tcg_temp_new();

	    tcg_gen_add_i32(addr, REG(0), cpu_gbr);

	    val = tcg_temp_new();

	    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);

	    tcg_gen_andi_i32(val, val, B7_0);

	    tcg_gen_qemu_st8(val, addr, ctx->memidx);

	    tcg_temp_free(val);

	    tcg_temp_free(addr);

	}

	return;

    case 0x8b00:		/* bf label */

	CHECK_NOT_DELAY_BLAT

	    gen_conditional_jump(ctx, ctx->pc + 2,

				 ctx->pc + 4 + B7_0s * 2);

	ctx->bstate = BS_BRANCH;

	return;

    case 0x8f00:		/* bf/s label */

	CHECK_NOT_DELAY_BLAT

	gen_branch_slot(ctx->delayed_pc = ctx->pc + 4 + B7_0s * 2, 0);

	ctx->flags |= DELAY_SLOT_CONDITIONAL;

	return;

    case 0x8900:		/* bt label */

	CHECK_NOT_DELAY_BLAT

	    gen_conditional_jump(ctx, ctx->pc + 4 + B7_0s * 2,

				 ctx->pc + 2);

	ctx->bstate = BS_BRANCH;

	return;

    case 0x8d00:		/* bt/s label */

	CHECK_NOT_DELAY_BLAT

	gen_branch_slot(ctx->delayed_pc = ctx->pc + 4 + B7_0s * 2, 1);

	ctx->flags |= DELAY_SLOT_CONDITIONAL;

	return;

    case 0x8800:		/* cmp/eq #imm,R0 */

	gen_cmp_imm(TCG_COND_EQ, REG(0), B7_0s);

	return;

    case 0xc400:		/* mov.b @(disp,GBR),R0 */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, cpu_gbr, B7_0);

	    tcg_gen_qemu_ld8s(REG(0), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0xc500:		/* mov.w @(disp,GBR),R0 */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 2);

	    tcg_gen_qemu_ld16s(REG(0), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0xc600:		/* mov.l @(disp,GBR),R0 */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 4);

	    tcg_gen_qemu_ld32s(REG(0), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0xc000:		/* mov.b R0,@(disp,GBR) */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, cpu_gbr, B7_0);

	    tcg_gen_qemu_st8(REG(0), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0xc100:		/* mov.w R0,@(disp,GBR) */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 2);

	    tcg_gen_qemu_st16(REG(0), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0xc200:		/* mov.l R0,@(disp,GBR) */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 4);

	    tcg_gen_qemu_st32(REG(0), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x8000:		/* mov.b R0,@(disp,Rn) */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, REG(B7_4), B3_0);

	    tcg_gen_qemu_st8(REG(0), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x8100:		/* mov.w R0,@(disp,Rn) */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 2);

	    tcg_gen_qemu_st16(REG(0), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x8400:		/* mov.b @(disp,Rn),R0 */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, REG(B7_4), B3_0);

	    tcg_gen_qemu_ld8s(REG(0), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0x8500:		/* mov.w @(disp,Rn),R0 */

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 2);

	    tcg_gen_qemu_ld16s(REG(0), addr, ctx->memidx);

	    tcg_temp_free(addr);

	}

	return;

    case 0xc700:		/* mova @(disp,PC),R0 */

	tcg_gen_movi_i32(REG(0), ((ctx->pc & 0xfffffffc) + 4 + B7_0 * 4) & ~3);

	return;

    case 0xcb00:		/* or #imm,R0 */

	tcg_gen_ori_i32(REG(0), REG(0), B7_0);

	return;

    case 0xcf00:		/* or.b #imm,@(R0,GBR) */

	{

	    TCGv addr, val;

	    addr = tcg_temp_new();

	    tcg_gen_add_i32(addr, REG(0), cpu_gbr);

	    val = tcg_temp_new();

	    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);

	    tcg_gen_ori_i32(val, val, B7_0);

	    tcg_gen_qemu_st8(val, addr, ctx->memidx);

	    tcg_temp_free(val);

	    tcg_temp_free(addr);

	}

	return;

    case 0xc300:		/* trapa #imm */

	{

	    TCGv imm;

	    CHECK_NOT_DELAY_BLAT

	    tcg_gen_movi_i32(cpu_pc, ctx->pc);

	    imm = tcg_const_i32(B7_0);

	    gen_helper_trapa(imm);

	    tcg_temp_free(imm);

	    ctx->bstate = BS_BRANCH;

	}

	return;

    case 0xc800:		/* tst #imm,R0 */

	{

	    TCGv val = tcg_temp_new();

	    tcg_gen_andi_i32(val, REG(0), B7_0);

	    gen_cmp_imm(TCG_COND_EQ, val, 0);

	    tcg_temp_free(val);

	}

	return;

    case 0xcc00:		/* tst.b #imm,@(R0,GBR) */

	{

	    TCGv val = tcg_temp_new();

	    tcg_gen_add_i32(val, REG(0), cpu_gbr);

	    tcg_gen_qemu_ld8u(val, val, ctx->memidx);

	    tcg_gen_andi_i32(val, val, B7_0);

	    gen_cmp_imm(TCG_COND_EQ, val, 0);

	    tcg_temp_free(val);

	}

	return;

    case 0xca00:		/* xor #imm,R0 */

	tcg_gen_xori_i32(REG(0), REG(0), B7_0);

	return;

    case 0xce00:		/* xor.b #imm,@(R0,GBR) */

	{

	    TCGv addr, val;

	    addr = tcg_temp_new();

	    tcg_gen_add_i32(addr, REG(0), cpu_gbr);

	    val = tcg_temp_new();

	    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);

	    tcg_gen_xori_i32(val, val, B7_0);

	    tcg_gen_qemu_st8(val, addr, ctx->memidx);

	    tcg_temp_free(val);

	    tcg_temp_free(addr);

	}

	return;

    }



    switch (ctx->opcode & 0xf08f) {

    case 0x408e:		/* ldc Rm,Rn_BANK */

	CHECK_PRIVILEGED

	tcg_gen_mov_i32(ALTREG(B6_4), REG(B11_8));

	return;

    case 0x4087:		/* ldc.l @Rm+,Rn_BANK */

	CHECK_PRIVILEGED

	tcg_gen_qemu_ld32s(ALTREG(B6_4), REG(B11_8), ctx->memidx);

	tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);

	return;

    case 0x0082:		/* stc Rm_BANK,Rn */

	CHECK_PRIVILEGED

	tcg_gen_mov_i32(REG(B11_8), ALTREG(B6_4));

	return;

    case 0x4083:		/* stc.l Rm_BANK,@-Rn */

	CHECK_PRIVILEGED

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_subi_i32(addr, REG(B11_8), 4);

	    tcg_gen_qemu_st32(ALTREG(B6_4), addr, ctx->memidx);

	    tcg_gen_mov_i32(REG(B11_8), addr);

	    tcg_temp_free(addr);

	}

	return;

    }



    switch (ctx->opcode & 0xf0ff) {

    case 0x0023:		/* braf Rn */

	CHECK_NOT_DELAY_BLAT

	tcg_gen_addi_i32(cpu_delayed_pc, REG(B11_8), ctx->pc + 4);

	ctx->flags |= DELAY_SLOT;

	ctx->delayed_pc = (uint32_t) - 1;

	return;

    case 0x0003:		/* bsrf Rn */

	CHECK_NOT_DELAY_BLAT

	tcg_gen_movi_i32(cpu_pr, ctx->pc + 4);

	tcg_gen_add_i32(cpu_delayed_pc, REG(B11_8), cpu_pr);

	ctx->flags |= DELAY_SLOT;

	ctx->delayed_pc = (uint32_t) - 1;

	return;

    case 0x4015:		/* cmp/pl Rn */

	gen_cmp_imm(TCG_COND_GT, REG(B11_8), 0);

	return;

    case 0x4011:		/* cmp/pz Rn */

	gen_cmp_imm(TCG_COND_GE, REG(B11_8), 0);

	return;

    case 0x4010:		/* dt Rn */

	tcg_gen_subi_i32(REG(B11_8), REG(B11_8), 1);

	gen_cmp_imm(TCG_COND_EQ, REG(B11_8), 0);

	return;

    case 0x402b:		/* jmp @Rn */

	CHECK_NOT_DELAY_BLAT

	tcg_gen_mov_i32(cpu_delayed_pc, REG(B11_8));

	ctx->flags |= DELAY_SLOT;

	ctx->delayed_pc = (uint32_t) - 1;

	return;

    case 0x400b:		/* jsr @Rn */

	CHECK_NOT_DELAY_BLAT

	tcg_gen_movi_i32(cpu_pr, ctx->pc + 4);

	tcg_gen_mov_i32(cpu_delayed_pc, REG(B11_8));

	ctx->flags |= DELAY_SLOT;

	ctx->delayed_pc = (uint32_t) - 1;

	return;

    case 0x400e:		/* ldc Rm,SR */

	CHECK_PRIVILEGED

	tcg_gen_andi_i32(cpu_sr, REG(B11_8), 0x700083f3);

	ctx->bstate = BS_STOP;

	return;

    case 0x4007:		/* ldc.l @Rm+,SR */

	CHECK_PRIVILEGED

	{

	    TCGv val = tcg_temp_new();

	    tcg_gen_qemu_ld32s(val, REG(B11_8), ctx->memidx);

	    tcg_gen_andi_i32(cpu_sr, val, 0x700083f3);

	    tcg_temp_free(val);

	    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);

	    ctx->bstate = BS_STOP;

	}

	return;

    case 0x0002:		/* stc SR,Rn */

	CHECK_PRIVILEGED

	tcg_gen_mov_i32(REG(B11_8), cpu_sr);

	return;

    case 0x4003:		/* stc SR,@-Rn */

	CHECK_PRIVILEGED

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_subi_i32(addr, REG(B11_8), 4);

	    tcg_gen_qemu_st32(cpu_sr, addr, ctx->memidx);

	    tcg_gen_mov_i32(REG(B11_8), addr);

	    tcg_temp_free(addr);

	}

	return;

#define LD(reg,ldnum,ldpnum,prechk)		\

  case ldnum:							\

    prechk    							\

    tcg_gen_mov_i32 (cpu_##reg, REG(B11_8));			\

    return;							\

  case ldpnum:							\

    prechk    							\

    tcg_gen_qemu_ld32s (cpu_##reg, REG(B11_8), ctx->memidx);	\

    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);		\

    return;

#define ST(reg,stnum,stpnum,prechk)		\

  case stnum:							\

    prechk    							\

    tcg_gen_mov_i32 (REG(B11_8), cpu_##reg);			\

    return;							\

  case stpnum:							\

    prechk    							\

    {								\

	TCGv addr = tcg_temp_new();				\

	tcg_gen_subi_i32(addr, REG(B11_8), 4);			\

	tcg_gen_qemu_st32 (cpu_##reg, addr, ctx->memidx);	\

	tcg_gen_mov_i32(REG(B11_8), addr);			\

	tcg_temp_free(addr);					\

    }								\

    return;

#define LDST(reg,ldnum,ldpnum,stnum,stpnum,prechk)		\

	LD(reg,ldnum,ldpnum,prechk)				\

	ST(reg,stnum,stpnum,prechk)

	LDST(gbr,  0x401e, 0x4017, 0x0012, 0x4013, {})

	LDST(vbr,  0x402e, 0x4027, 0x0022, 0x4023, CHECK_PRIVILEGED)

	LDST(ssr,  0x403e, 0x4037, 0x0032, 0x4033, CHECK_PRIVILEGED)

	LDST(spc,  0x404e, 0x4047, 0x0042, 0x4043, CHECK_PRIVILEGED)

	ST(sgr,  0x003a, 0x4032, CHECK_PRIVILEGED)

	LD(sgr,  0x403a, 0x4036, CHECK_PRIVILEGED if (!(ctx->features & SH_FEATURE_SH4A)) break;)

	LDST(dbr,  0x40fa, 0x40f6, 0x00fa, 0x40f2, CHECK_PRIVILEGED)

	LDST(mach, 0x400a, 0x4006, 0x000a, 0x4002, {})

	LDST(macl, 0x401a, 0x4016, 0x001a, 0x4012, {})

	LDST(pr,   0x402a, 0x4026, 0x002a, 0x4022, {})

	LDST(fpul, 0x405a, 0x4056, 0x005a, 0x4052, {CHECK_FPU_ENABLED})

    case 0x406a:		/* lds Rm,FPSCR */

	CHECK_FPU_ENABLED

	gen_helper_ld_fpscr(REG(B11_8));

	ctx->bstate = BS_STOP;

	return;

    case 0x4066:		/* lds.l @Rm+,FPSCR */

	CHECK_FPU_ENABLED

	{

	    TCGv addr = tcg_temp_new();

	    tcg_gen_qemu_ld32s(addr, REG(B11_8), ctx->memidx);

	    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);

	    gen_helper_ld_fpscr(addr);

	    tcg_temp_free(addr);

	    ctx->bstate = BS_STOP;

	}

	return;

    case 0x006a:		/* sts FPSCR,Rn */

	CHECK_FPU_ENABLED

	tcg_gen_andi_i32(REG(B11_8), cpu_fpscr, 0x003fffff);

	return;

    case 0x4062:		/* sts FPSCR,@-Rn */

	CHECK_FPU_ENABLED

	{

	    TCGv addr, val;

	    val = tcg_temp_new();

	    tcg_gen_andi_i32(val, cpu_fpscr, 0x003fffff);

	    addr = tcg_temp_new();

	    tcg_gen_subi_i32(addr, REG(B11_8), 4);

	    tcg_gen_qemu_st32(val, addr, ctx->memidx);

	    tcg_gen_mov_i32(REG(B11_8), addr);

	    tcg_temp_free(addr);

	    tcg_temp_free(val);

	}

	return;

    case 0x00c3:		/* movca.l R0,@Rm */

        {

            TCGv val = tcg_temp_new();

            tcg_gen_qemu_ld32u(val, REG(B11_8), ctx->memidx);

            gen_helper_movcal (REG(B11_8), val);            

            tcg_gen_qemu_st32(REG(0), REG(B11_8), ctx->memidx);

        }

        ctx->has_movcal = 1;

	return;

    case 0x40a9:

	/* MOVUA.L @Rm,R0 (Rm) -> R0

	   Load non-boundary-aligned data */

	tcg_gen_qemu_ld32u(REG(0), REG(B11_8), ctx->memidx);

	return;

    case 0x40e9:

	/* MOVUA.L @Rm+,R0   (Rm) -> R0, Rm + 4 -> Rm

	   Load non-boundary-aligned data */

	tcg_gen_qemu_ld32u(REG(0), REG(B11_8), ctx->memidx);

	tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);

	return;

    case 0x0029:		/* movt Rn */

	tcg_gen_andi_i32(REG(B11_8), cpu_sr, SR_T);

	return;

    case 0x0073:

        /* MOVCO.L

	       LDST -> T

               If (T == 1) R0 -> (Rn)

               0 -> LDST

        */

        if (ctx->features & SH_FEATURE_SH4A) {

	    int label = gen_new_label();

	    gen_clr_t();

	    tcg_gen_or_i32(cpu_sr, cpu_sr, cpu_ldst);

	    tcg_gen_brcondi_i32(TCG_COND_EQ, cpu_ldst, 0, label);

	    tcg_gen_qemu_st32(REG(0), REG(B11_8), ctx->memidx);

	    gen_set_label(label);

	    tcg_gen_movi_i32(cpu_ldst, 0);

	    return;

	} else

	    break;

    case 0x0063:

        /* MOVLI.L @Rm,R0

               1 -> LDST

               (Rm) -> R0

               When interrupt/exception

               occurred 0 -> LDST

        */

	if (ctx->features & SH_FEATURE_SH4A) {

	    tcg_gen_movi_i32(cpu_ldst, 0);

	    tcg_gen_qemu_ld32s(REG(0), REG(B11_8), ctx->memidx);

	    tcg_gen_movi_i32(cpu_ldst, 1);

	    return;

	} else

	    break;

    case 0x0093:		/* ocbi @Rn */

	{

	    gen_helper_ocbi (REG(B11_8));

	}

	return;

    case 0x00a3:		/* ocbp @Rn */

	{

	    TCGv dummy = tcg_temp_new();

	    tcg_gen_qemu_ld32s(dummy, REG(B11_8), ctx->memidx);

	    tcg_temp_free(dummy);

	}

	return;

    case 0x00b3:		/* ocbwb @Rn */

	{

	    TCGv dummy = tcg_temp_new();

	    tcg_gen_qemu_ld32s(dummy, REG(B11_8), ctx->memidx);

	    tcg_temp_free(dummy);

	}

	return;

    case 0x0083:		/* pref @Rn */

	return;

    case 0x00d3:		/* prefi @Rn */

	if (ctx->features & SH_FEATURE_SH4A)

	    return;

	else

	    break;

    case 0x00e3:		/* icbi @Rn */

	if (ctx->features & SH_FEATURE_SH4A)

	    return;

	else

	    break;

    case 0x00ab:		/* synco */

	if (ctx->features & SH_FEATURE_SH4A)

	    return;

	else

	    break;

    case 0x4024:		/* rotcl Rn */

	{

	    TCGv tmp = tcg_temp_new();

	    tcg_gen_mov_i32(tmp, cpu_sr);

	    gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);

	    tcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);

	    gen_copy_bit_i32(REG(B11_8), 0, tmp, 0);

	    tcg_temp_free(tmp);

	}

	return;

    case 0x4025:		/* rotcr Rn */

	{

	    TCGv tmp = tcg_temp_new();

	    tcg_gen_mov_i32(tmp, cpu_sr);

	    gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);

	    tcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);

	    gen_copy_bit_i32(REG(B11_8), 31, tmp, 0);

	    tcg_temp_free(tmp);

	}

	return;

    case 0x4004:		/* rotl Rn */

	gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);

	tcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);

	gen_copy_bit_i32(REG(B11_8), 0, cpu_sr, 0);

	return;

    case 0x4005:		/* rotr Rn */

	gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);

	tcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);

	gen_copy_bit_i32(REG(B11_8), 31, cpu_sr, 0);

	return;

    case 0x4000:		/* shll Rn */

    case 0x4020:		/* shal Rn */

	gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);

	tcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);

	return;

    case 0x4021:		/* shar Rn */

	gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);

	tcg_gen_sari_i32(REG(B11_8), REG(B11_8), 1);

	return;

    case 0x4001:		/* shlr Rn */

	gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);

	tcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);

	return;

    case 0x4008:		/* shll2 Rn */

	tcg_gen_shli_i32(REG(B11_8), REG(B11_8), 2);

	return;

    case 0x4018:		/* shll8 Rn */

	tcg_gen_shli_i32(REG(B11_8), REG(B11_8), 8);

	return;

    case 0x4028:		/* shll16 Rn */

	tcg_gen_shli_i32(REG(B11_8), REG(B11_8), 16);

	return;

    case 0x4009:		/* shlr2 Rn */

	tcg_gen_shri_i32(REG(B11_8), REG(B11_8), 2);

	return;

    case 0x4019:		/* shlr8 Rn */

	tcg_gen_shri_i32(REG(B11_8), REG(B11_8), 8);

	return;

    case 0x4029:		/* shlr16 Rn */

	tcg_gen_shri_i32(REG(B11_8), REG(B11_8), 16);

	return;

    case 0x401b:		/* tas.b @Rn */

	{

	    TCGv addr, val;

	    addr = tcg_temp_local_new();

	    tcg_gen_mov_i32(addr, REG(B11_8));

	    val = tcg_temp_local_new();

	    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);

	    gen_cmp_imm(TCG_COND_EQ, val, 0);

	    tcg_gen_ori_i32(val, val, 0x80);

	    tcg_gen_qemu_st8(val, addr, ctx->memidx);

	    tcg_temp_free(val);

	    tcg_temp_free(addr);

	}

	return;

    case 0xf00d: /* fsts FPUL,FRn - FPSCR: Nothing */

	CHECK_FPU_ENABLED

	tcg_gen_mov_i32(cpu_fregs[FREG(B11_8)], cpu_fpul);

	return;

    case 0xf01d: /* flds FRm,FPUL - FPSCR: Nothing */

	CHECK_FPU_ENABLED

	tcg_gen_mov_i32(cpu_fpul, cpu_fregs[FREG(B11_8)]);

	return;

    case 0xf02d: /* float FPUL,FRn/DRn - FPSCR: R[PR,Enable.I]/W[Cause,Flag] */

	CHECK_FPU_ENABLED

	if (ctx->fpscr & FPSCR_PR) {

	    TCGv_i64 fp;

	    if (ctx->opcode & 0x0100)

		break; /* illegal instruction */

	    fp = tcg_temp_new_i64();

	    gen_helper_float_DT(fp, cpu_fpul);

	    gen_store_fpr64(fp, DREG(B11_8));

	    tcg_temp_free_i64(fp);

	}

	else {

	    gen_helper_float_FT(cpu_fregs[FREG(B11_8)], cpu_fpul);

	}

	return;

    case 0xf03d: /* ftrc FRm/DRm,FPUL - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */

	CHECK_FPU_ENABLED

	if (ctx->fpscr & FPSCR_PR) {

	    TCGv_i64 fp;

	    if (ctx->opcode & 0x0100)

		break; /* illegal instruction */

	    fp = tcg_temp_new_i64();

	    gen_load_fpr64(fp, DREG(B11_8));

	    gen_helper_ftrc_DT(cpu_fpul, fp);

	    tcg_temp_free_i64(fp);

	}

	else {

	    gen_helper_ftrc_FT(cpu_fpul, cpu_fregs[FREG(B11_8)]);

	}

	return;

    case 0xf04d: /* fneg FRn/DRn - FPSCR: Nothing */

	CHECK_FPU_ENABLED

	{

	    gen_helper_fneg_T(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);

	}

	return;

    case 0xf05d: /* fabs FRn/DRn */

	CHECK_FPU_ENABLED

	if (ctx->fpscr & FPSCR_PR) {

	    if (ctx->opcode & 0x0100)

		break; /* illegal instruction */

	    TCGv_i64 fp = tcg_temp_new_i64();

	    gen_load_fpr64(fp, DREG(B11_8));

	    gen_helper_fabs_DT(fp, fp);

	    gen_store_fpr64(fp, DREG(B11_8));

	    tcg_temp_free_i64(fp);

	} else {

	    gen_helper_fabs_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);

	}

	return;

    case 0xf06d: /* fsqrt FRn */

	CHECK_FPU_ENABLED

	if (ctx->fpscr & FPSCR_PR) {

	    if (ctx->opcode & 0x0100)

		break; /* illegal instruction */

	    TCGv_i64 fp = tcg_temp_new_i64();

	    gen_load_fpr64(fp, DREG(B11_8));

	    gen_helper_fsqrt_DT(fp, fp);

	    gen_store_fpr64(fp, DREG(B11_8));

	    tcg_temp_free_i64(fp);

	} else {

	    gen_helper_fsqrt_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);

	}

	return;

    case 0xf07d: /* fsrra FRn */

	CHECK_FPU_ENABLED

	break;

    case 0xf08d: /* fldi0 FRn - FPSCR: R[PR] */

	CHECK_FPU_ENABLED

	if (!(ctx->fpscr & FPSCR_PR)) {

	    tcg_gen_movi_i32(cpu_fregs[FREG(B11_8)], 0);

	}

	return;

    case 0xf09d: /* fldi1 FRn - FPSCR: R[PR] */

	CHECK_FPU_ENABLED

	if (!(ctx->fpscr & FPSCR_PR)) {

	    tcg_gen_movi_i32(cpu_fregs[FREG(B11_8)], 0x3f800000);

	}

	return;

    case 0xf0ad: /* fcnvsd FPUL,DRn */

	CHECK_FPU_ENABLED

	{

	    TCGv_i64 fp = tcg_temp_new_i64();

	    gen_helper_fcnvsd_FT_DT(fp, cpu_fpul);

	    gen_store_fpr64(fp, DREG(B11_8));

	    tcg_temp_free_i64(fp);

	}

	return;

    case 0xf0bd: /* fcnvds DRn,FPUL */

	CHECK_FPU_ENABLED

	{

	    TCGv_i64 fp = tcg_temp_new_i64();

	    gen_load_fpr64(fp, DREG(B11_8));

	    gen_helper_fcnvds_DT_FT(cpu_fpul, fp);

	    tcg_temp_free_i64(fp);

	}

	return;

    }

#if 0

    fprintf(stderr, ""unknown instruction 0x%04x at pc 0x%08x
"",

	    ctx->opcode, ctx->pc);

    fflush(stderr);

#endif

    gen_helper_raise_illegal_instruction();

    ctx->bstate = BS_EXCP;

}
",1,1,0.0,1,"ctx,CHECK_NOT_DELAY_SLOT,delayed_pc","ctx:-0.014342397451400757,CHECK_NOT_DELAY_SLOT:0.06335192918777466,delayed_pc:-0.05248638987541199,",1.0,13.0,"CHECK_NOT_DELAY_SLOT:CHECK_NOT_DELAY_BLAT,",Greedy,228,0.3607620040575663
24,"void wm8750_set_bclk_in(void *opaque, int hz)

{

    struct wm8750_s *s = (struct wm8750_s *) opaque;



    s->ext_adc_hz = hz;

    s->ext_dac_hz = hz;

    wm8750_clk_update(s, 1);

}
",43,"void wm8750_set_bclk_in(void *Opaque, int hz)

{

    struct wm8750_s *features = (struct wm8750_s *) Opaque;



    features->ext_adc_hz = hz;

    features->ext_dac_hz = hz;

    wm8750_clk_update(features, 1);

}
",1,1,0.0,1,"opaque,hz,s","opaque:0.40869611501693726,hz:-0.07067464292049408,s:0.08006978034973145,",2.0,6.0,"opaque:Opaque,s:features,",Greedy,85,0.0851969957351684
47,"IEEE_ARITH2(sqrtt)

IEEE_ARITH2(cvtst)

IEEE_ARITH2(cvtts)



static void gen_cvttq(DisasContext *ctx, int rb, int rc, int fn11)

{

    TCGv vb, vc;



    /* No need to set flushzero, since we have an integer output.  */

    vb = gen_ieee_input(ctx, rb, fn11, 0);

    vc = dest_fpr(ctx, rc);



    /* Almost all integer conversions use cropped rounding, and most

       also do not have integer overflow enabled.  Special case that.  */

    switch (fn11) {

    case QUAL_RM_C:

        gen_helper_cvttq_c(vc, cpu_env, vb);

        break;

    case QUAL_V | QUAL_RM_C:

    case QUAL_S | QUAL_V | QUAL_RM_C:

    case QUAL_S | QUAL_V | QUAL_I | QUAL_RM_C:

        gen_helper_cvttq_svic(vc, cpu_env, vb);

        break;

    default:

        gen_qual_roundmode(ctx, fn11);

        gen_helper_cvttq(vc, cpu_env, vb);

        break;

    }



    gen_fp_exc_raise(rc, fn11);

}
",138,"IEEE_ARITH2(sqrtt)

IEEE_ARITH2(cvtst)

IEEE_ARITH2(cvtts)



static void gen_cvttq(DisasContext *ctx, int rb, int rc, int fn11)

{

    TCGv vidb, sv;



    /* No need to set flushzero, since we have an integer output.  */

    vidb = gen_ieee_input(ctx, rb, fn11, 0);

    sv = dest_fpr(ctx, rc);



    /* Almost all integer conversions use cropped rounding, and most

       also do not have integer overflow enabled.  Special case that.  */

    switch (fn11) {

    case QUAL_RM_C:

        gen_helper_cvttq_c(sv, cpu_env, vidb);

        break;

    case QUAL_V | QUAL_RM_C:

    case QUAL_S | QUAL_V | QUAL_RM_C:

    case QUAL_S | QUAL_V | QUAL_I | QUAL_RM_C:

        gen_helper_cvttq_svic(sv, cpu_env, vidb);

        break;

    default:

        gen_qual_roundmode(ctx, fn11);

        gen_helper_cvttq(sv, cpu_env, vidb);

        break;

    }



    gen_fp_exc_raise(rc, fn11);

}
",1,1,0.0,1,"ctx,rb,rc,fn11,vb,vc","ctx:0.04937770962715149,rb:0.015854597091674805,rc:0.04307594895362854,fn11:-0.0025225281715393066,vb:0.08123213052749634,vc:0.05216240882873535,",2.0,10.0,"vb:vidb,vc:sv,",Greedy,127,0.1258265972137451
48,"static int virtio_serial_device_exit(DeviceState *dev)

{

    VirtIOSerial *vser = VIRTIO_SERIAL(dev);

    VirtIODevice *vdev = VIRTIO_DEVICE(dev);



    unregister_savevm(dev, ""virtio-console"", vser);



    g_free(vser->ivqs);

    g_free(vser->ovqs);

    g_free(vser->ports_map);

    if (vser->post_load) {

        g_free(vser->post_load->connected);

        timer_del(vser->post_load->timer);

        timer_free(vser->post_load->timer);

        g_free(vser->post_load);

    }

    virtio_cleanup(vdev);

    return 0;

}
",109,"static int virtio_serial_device_exit(DeviceState *comment)

{

    VirtIOSerial *wseller = VIRTIO_SERIAL(comment);

    VirtIODevice *vdef = VIRTIO_DEVICE(comment);



    unregister_savevm(comment, ""virtio-console"", wseller);



    g_free(wseller->ivqs);

    g_free(wseller->ovqs);

    g_free(wseller->ports_map);

    if (wseller->post_load) {

        g_free(wseller->post_load->connected);

        timer_del(wseller->post_load->timer);

        timer_free(wseller->post_load->timer);

        g_free(wseller->post_load);

    }

    virtio_cleanup(vdef);

    return 0;

}
",1,1,0.0,1,"dev,vser,vdev","dev:0.17876094579696655,vser:0.07727563381195068,vdev:-0.002380967140197754,",3.0,16.0,"dev:comment,vser:wseller,vdev:vdef,",Greedy,168,0.1613267262776692
54,"static inline void hScale_altivec_real(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc, int16_t *filter, int16_t *filterPos, int filterSize) {

  register int i;

  int __attribute__ ((aligned (16))) tempo[4];



  if (filterSize % 4) {

    for(i=0; i<dstW; i++) {

      register int j;

      register int srcPos = filterPos[i];

      register int val = 0;

      for(j=0; j<filterSize; j++) {

	val += ((int)src[srcPos + j])*filter[filterSize*i + j];

      }

      dst[i] = av_clip(val>>7, 0, (1<<15)-1);

    }

  }

  else

  switch (filterSize) {

  case 4:

    {

      for(i=0; i<dstW; i++) {

	register int srcPos = filterPos[i];



	vector unsigned char src_v0 = vec_ld(srcPos, src);

	vector unsigned char src_v1, src_vF;

	vector signed short src_v, filter_v;

	vector signed int val_vEven, val_s;

	if ((((int)src + srcPos)% 16) > 12) {

	  src_v1 = vec_ld(srcPos + 16, src);

	}

	src_vF = vec_perm(src_v0, src_v1, vec_lvsl(srcPos, src));



	src_v = // vec_unpackh sign-extends...

	  (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));

	// now put our elements in the even slots

	src_v = vec_mergeh(src_v, (vector signed short)vzero);



	filter_v = vec_ld(i << 3, filter);

        // the 3 above is 2 (filterSize == 4) + 1 (sizeof(short) == 2)



        // the neat trick : we only care for half the elements,

        // high or low depending on (i<<3)%16 (it's 0 or 8 here),

        // and we're going to use vec_mule, so we chose

        // carefully how to ""unpack"" the elements into the even slots

	if ((i << 3) % 16)

	  filter_v = vec_mergel(filter_v,(vector signed short)vzero);

	else

	  filter_v = vec_mergeh(filter_v,(vector signed short)vzero);



	val_vEven = vec_mule(src_v, filter_v);

	val_s = vec_sums(val_vEven, vzero);

	vec_st(val_s, 0, tempo);

	dst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);

      }

    }

    break;



  case 8:

    {

      for(i=0; i<dstW; i++) {

	register int srcPos = filterPos[i];



	vector unsigned char src_v0 = vec_ld(srcPos, src);

	vector unsigned char src_v1, src_vF;

	vector signed short src_v, filter_v;

	vector signed int val_v, val_s;

	if ((((int)src + srcPos)% 16) > 8) {

	  src_v1 = vec_ld(srcPos + 16, src);

	}

	src_vF = vec_perm(src_v0, src_v1, vec_lvsl(srcPos, src));



	src_v = // vec_unpackh sign-extends...

	  (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));

	filter_v = vec_ld(i << 4, filter);

        // the 4 above is 3 (filterSize == 8) + 1 (sizeof(short) == 2)



	val_v = vec_msums(src_v, filter_v, (vector signed int)vzero);

	val_s = vec_sums(val_v, vzero);

	vec_st(val_s, 0, tempo);

	dst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);

      }

    }

    break;



  case 16:

    {

      for(i=0; i<dstW; i++) {

	register int srcPos = filterPos[i];



	vector unsigned char src_v0 = vec_ld(srcPos, src);

	vector unsigned char src_v1 = vec_ld(srcPos + 16, src);

	vector unsigned char src_vF = vec_perm(src_v0, src_v1, vec_lvsl(srcPos, src));



	vector signed short src_vA = // vec_unpackh sign-extends...

	  (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));

	vector signed short src_vB = // vec_unpackh sign-extends...

	  (vector signed short)(vec_mergel((vector unsigned char)vzero, src_vF));



	vector signed short filter_v0 = vec_ld(i << 5, filter);

       	vector signed short filter_v1 = vec_ld((i << 5) + 16, filter);

        // the 5 above are 4 (filterSize == 16) + 1 (sizeof(short) == 2)



	vector signed int val_acc = vec_msums(src_vA, filter_v0, (vector signed int)vzero);

	vector signed int val_v = vec_msums(src_vB, filter_v1, val_acc);



	vector signed int val_s = vec_sums(val_v, vzero);



	vec_st(val_s, 0, tempo);

	dst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);

      }

    }

    break;



  default:

    {

      for(i=0; i<dstW; i++) {

	register int j;

	register int srcPos = filterPos[i];



        vector signed int val_s, val_v = (vector signed int)vzero;

	vector signed short filter_v0R = vec_ld(i * 2 * filterSize, filter);

        vector unsigned char permF = vec_lvsl((i * 2 * filterSize), filter);



        vector unsigned char src_v0 = vec_ld(srcPos, src);

        vector unsigned char permS = vec_lvsl(srcPos, src);



        for (j = 0 ; j < filterSize - 15; j += 16) {

          vector unsigned char src_v1 = vec_ld(srcPos + j + 16, src);

          vector unsigned char src_vF = vec_perm(src_v0, src_v1, permS);



          vector signed short src_vA = // vec_unpackh sign-extends...

            (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));

          vector signed short src_vB = // vec_unpackh sign-extends...

            (vector signed short)(vec_mergel((vector unsigned char)vzero, src_vF));



          vector signed short filter_v1R = vec_ld((i * 2 * filterSize) + (j * 2) + 16, filter);

          vector signed short filter_v2R = vec_ld((i * 2 * filterSize) + (j * 2) + 32, filter);

          vector signed short filter_v0 = vec_perm(filter_v0R, filter_v1R, permF);

          vector signed short filter_v1 = vec_perm(filter_v1R, filter_v2R, permF);



          vector signed int val_acc = vec_msums(src_vA, filter_v0, val_v);

          val_v = vec_msums(src_vB, filter_v1, val_acc);



          filter_v0R = filter_v2R;

          src_v0 = src_v1;

        }



        if (j < (filterSize-7)) {

          // loading src_v0 is useless, it's already done above

          //vector unsigned char src_v0 = vec_ld(srcPos + j, src);

          vector unsigned char src_v1, src_vF;

          vector signed short src_v, filter_v1R, filter_v;

          if ((((int)src + srcPos)% 16) > 8) {

            src_v1 = vec_ld(srcPos + j + 16, src);

          }

          src_vF = vec_perm(src_v0, src_v1, permS);



          src_v = // vec_unpackh sign-extends...

            (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));

          // loading filter_v0R is useless, it's already done above

          //vector signed short filter_v0R = vec_ld((i * 2 * filterSize) + j, filter);

          filter_v1R = vec_ld((i * 2 * filterSize) + (j * 2) + 16, filter);

          filter_v = vec_perm(filter_v0R, filter_v1R, permF);



          val_v = vec_msums(src_v, filter_v, val_v);

        }



        val_s = vec_sums(val_v, vzero);



        vec_st(val_s, 0, tempo);

        dst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);

      }



    }

  }

}
",1377,"static inline void hScale_altivec_real(int16_t *dst, int dstW, uint8_t *src, int srcW, int exSec, int16_t *filter, int16_t *filterPos, int filterCode) {

  register int i;

  int __attribute__ ((aligned (16))) tempo[4];



  if (filterCode % 4) {

    for(i=0; i<dstW; i++) {

      register int j;

      register int srcPos = filterPos[i];

      register int val = 0;

      for(j=0; j<filterCode; j++) {

	val += ((int)src[srcPos + j])*filter[filterCode*i + j];

      }

      dst[i] = av_clip(val>>7, 0, (1<<15)-1);

    }

  }

  else

  switch (filterCode) {

  case 4:

    {

      for(i=0; i<dstW; i++) {

	register int srcPos = filterPos[i];



	vector unsigned char src_v0 = vec_ld(srcPos, src);

	vector unsigned char src_v1, src_vF;

	vector signed short src_v, url_conv;

	vector signed int val_vEven, val_s;

	if ((((int)src + srcPos)% 16) > 12) {

	  src_v1 = vec_ld(srcPos + 16, src);

	}

	src_vF = vec_perm(src_v0, src_v1, vec_lvsl(srcPos, src));



	src_v = // vec_unpackh sign-extends...

	  (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));

	// now put our elements in the even slots

	src_v = vec_mergeh(src_v, (vector signed short)vzero);



	url_conv = vec_ld(i << 3, filter);

        // the 3 above is 2 (filterSize == 4) + 1 (sizeof(short) == 2)



        // the neat trick : we only care for half the elements,

        // high or low depending on (i<<3)%16 (it's 0 or 8 here),

        // and we're going to use vec_mule, so we chose

        // carefully how to ""unpack"" the elements into the even slots

	if ((i << 3) % 16)

	  url_conv = vec_mergel(url_conv,(vector signed short)vzero);

	else

	  url_conv = vec_mergeh(url_conv,(vector signed short)vzero);



	val_vEven = vec_mule(src_v, url_conv);

	val_s = vec_sums(val_vEven, vzero);

	vec_st(val_s, 0, tempo);

	dst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);

      }

    }

    break;



  case 8:

    {

      for(i=0; i<dstW; i++) {

	register int srcPos = filterPos[i];



	vector unsigned char src_v0 = vec_ld(srcPos, src);

	vector unsigned char src_v1, src_vF;

	vector signed short src_v, url_conv;

	vector signed int val_v, val_s;

	if ((((int)src + srcPos)% 16) > 8) {

	  src_v1 = vec_ld(srcPos + 16, src);

	}

	src_vF = vec_perm(src_v0, src_v1, vec_lvsl(srcPos, src));



	src_v = // vec_unpackh sign-extends...

	  (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));

	url_conv = vec_ld(i << 4, filter);

        // the 4 above is 3 (filterSize == 8) + 1 (sizeof(short) == 2)



	val_v = vec_msums(src_v, url_conv, (vector signed int)vzero);

	val_s = vec_sums(val_v, vzero);

	vec_st(val_s, 0, tempo);

	dst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);

      }

    }

    break;



  case 16:

    {

      for(i=0; i<dstW; i++) {

	register int srcPos = filterPos[i];



	vector unsigned char src_v0 = vec_ld(srcPos, src);

	vector unsigned char src_v1 = vec_ld(srcPos + 16, src);

	vector unsigned char src_vF = vec_perm(src_v0, src_v1, vec_lvsl(srcPos, src));



	vector signed short src_vA = // vec_unpackh sign-extends...

	  (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));

	vector signed short src_vB = // vec_unpackh sign-extends...

	  (vector signed short)(vec_mergel((vector unsigned char)vzero, src_vF));



	vector signed short filter_v0 = vec_ld(i << 5, filter);

       	vector signed short filter_v1 = vec_ld((i << 5) + 16, filter);

        // the 5 above are 4 (filterSize == 16) + 1 (sizeof(short) == 2)



	vector signed int val_acc = vec_msums(src_vA, filter_v0, (vector signed int)vzero);

	vector signed int val_v = vec_msums(src_vB, filter_v1, val_acc);



	vector signed int val_s = vec_sums(val_v, vzero);



	vec_st(val_s, 0, tempo);

	dst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);

      }

    }

    break;



  default:

    {

      for(i=0; i<dstW; i++) {

	register int j;

	register int srcPos = filterPos[i];



        vector signed int val_s, val_v = (vector signed int)vzero;

	vector signed short filter_v0R = vec_ld(i * 2 * filterCode, filter);

        vector unsigned char permF = vec_lvsl((i * 2 * filterCode), filter);



        vector unsigned char src_v0 = vec_ld(srcPos, src);

        vector unsigned char permS = vec_lvsl(srcPos, src);



        for (j = 0 ; j < filterCode - 15; j += 16) {

          vector unsigned char src_v1 = vec_ld(srcPos + j + 16, src);

          vector unsigned char src_vF = vec_perm(src_v0, src_v1, permS);



          vector signed short src_vA = // vec_unpackh sign-extends...

            (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));

          vector signed short src_vB = // vec_unpackh sign-extends...

            (vector signed short)(vec_mergel((vector unsigned char)vzero, src_vF));



          vector signed short filter_v1R = vec_ld((i * 2 * filterCode) + (j * 2) + 16, filter);

          vector signed short filter_v2R = vec_ld((i * 2 * filterCode) + (j * 2) + 32, filter);

          vector signed short filter_v0 = vec_perm(filter_v0R, filter_v1R, permF);

          vector signed short filter_v1 = vec_perm(filter_v1R, filter_v2R, permF);



          vector signed int val_acc = vec_msums(src_vA, filter_v0, val_v);

          val_v = vec_msums(src_vB, filter_v1, val_acc);



          filter_v0R = filter_v2R;

          src_v0 = src_v1;

        }



        if (j < (filterCode-7)) {

          // loading src_v0 is useless, it's already done above

          //vector unsigned char src_v0 = vec_ld(srcPos + j, src);

          vector unsigned char src_v1, src_vF;

          vector signed short src_v, filter_v1R, url_conv;

          if ((((int)src + srcPos)% 16) > 8) {

            src_v1 = vec_ld(srcPos + j + 16, src);

          }

          src_vF = vec_perm(src_v0, src_v1, permS);



          src_v = // vec_unpackh sign-extends...

            (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));

          // loading filter_v0R is useless, it's already done above

          //vector signed short filter_v0R = vec_ld((i * 2 * filterSize) + j, filter);

          filter_v1R = vec_ld((i * 2 * filterCode) + (j * 2) + 16, filter);

          url_conv = vec_perm(filter_v0R, filter_v1R, permF);



          val_v = vec_msums(src_v, url_conv, val_v);

        }



        val_s = vec_sums(val_v, vzero);



        vec_st(val_s, 0, tempo);

        dst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);

      }



    }

  }

}
",1,1,0.0,1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize,i,tempo,j,src_v1,src_vF,src_v,filter_v,val_vEven,val_s","dst:0.0034569501876831055,dstW:-0.12638622522354126,src:-0.1351771354675293,srcW:-0.0531887412071228,xInc:0.1275692582130432,filter:-0.0744357705116272,filterPos:-0.014589250087738037,filterSize:0.006789028644561768,i:-0.05227923393249512,tempo:-0.04082673788070679,j:-0.03311222791671753,src_v1:-0.04826056957244873,src_vF:-0.03930377960205078,src_v:-0.027673959732055664,filter_v:0.01201695203781128,val_vEven:-0.07192689180374146,val_s:-0.009918034076690674,",3.0,26.0,"xInc:exSec,filter_v:url_conv,filterSize:filterCode,",Greedy,314,0.3159754236539205
56,"static void property_get_enum(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    value = prop->get(obj, errp);

    visit_type_enum(v, &value, prop->strings, NULL, name, errp);

}
",66,"static void property_get_enum(Object *obj, Visitor *api, void *opaques,

                              const char *label, Error **errp)

{

    EnumProperty *prop = opaques;

    int value;



    value = prop->get(obj, errp);

    visit_type_enum(api, &value, prop->strings, NULL, label, errp);

}
",1,1,0.0,1,"obj,v,opaque,name,errp,prop,value","obj:-0.007273852825164795,v:0.08708274364471436,opaque:0.00875025987625122,name:0.04105132818222046,errp:-0.00021272897720336914,prop:-0.019798755645751953,value:-0.01706564426422119,",3.0,6.0,"v:api,name:label,opaque:opaques,",Greedy,115,0.1180436054865519
62,"CharDriverState *qemu_chr_alloc(void)

{

    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));


    return chr;

}",23,"CharDriverState *qemu_chr_alloc(void)

{

    CharDriverState *ichrc = g_malloc0(sizeof(CharDriverState));


    return ichrc;

}",1,1,0.0,1,chr,"chr:0.2536167651414871,",1.0,2.0,"chr:ichrc,",Greedy,32,0.0384544173876444
63,"static void ecc_init(target_phys_addr_t base, qemu_irq irq, uint32_t version)

{

    DeviceState *dev;

    SysBusDevice *s;



    dev = qdev_create(NULL, ""eccmemctl"");

    qdev_prop_set_uint32(dev, ""version"", version);

    qdev_init(dev);

    s = sysbus_from_qdev(dev);

    sysbus_connect_irq(s, 0, irq);

    sysbus_mmio_map(s, 0, base);

    if (version == 0) { // SS-600MP only

        sysbus_mmio_map(s, 1, base + 0x1000);

    }

}
",92,"static void ecc_init(target_phys_addr_t area, qemu_irq irq, uint32_t version)

{

    DeviceState *dev;

    SysBusDevice *sv;



    dev = qdev_create(NULL, ""eccmemctl"");

    qdev_prop_set_uint32(dev, ""version"", version);

    qdev_init(dev);

    sv = sysbus_from_qdev(dev);

    sysbus_connect_irq(sv, 0, irq);

    sysbus_mmio_map(sv, 0, area);

    if (version == 0) { // SS-600MP only

        sysbus_mmio_map(sv, 1, area + 0x1000);

    }

}
",1,1,0.0,1,"base,irq,version,dev,s","base:0.08835867047309875,irq:-0.036900877952575684,version:-0.04596102237701416,dev:-0.008475631475448608,s:-0.0074394941329956055,",2.0,8.0,"base:area,s:sv,",Greedy,126,0.1120195666948954
76,"static int iff_read_header(AVFormatContext *s)

{

    IffDemuxContext *iff = s->priv_data;

    AVIOContext *pb = s->pb;

    AVStream *st;

    uint8_t *buf;

    uint32_t chunk_id, data_size;

    uint32_t screenmode = 0, num, den;

    unsigned transparency = 0;

    unsigned masking = 0; // no mask

    uint8_t fmt[16];

    int fmt_size;



    st = avformat_new_stream(s, NULL);

    if (!st)

        return AVERROR(ENOMEM);



    st->codec->channels = 1;

    st->codec->channel_layout = AV_CH_LAYOUT_MONO;

    avio_skip(pb, 8);

    // codec_tag used by ByteRun1 decoder to distinguish progressive (PBM) and interlaced (ILBM) content

    st->codec->codec_tag = avio_rl32(pb);

    iff->bitmap_compression = -1;

    iff->svx8_compression = -1;

    iff->maud_bits = -1;

    iff->maud_compression = -1;



    while(!url_feof(pb)) {

        uint64_t orig_pos;

        int res;

        const char *metadata_tag = NULL;

        chunk_id = avio_rl32(pb);

        data_size = avio_rb32(pb);

        orig_pos = avio_tell(pb);



        switch(chunk_id) {

        case ID_VHDR:

            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;



            if (data_size < 14)

                return AVERROR_INVALIDDATA;

            avio_skip(pb, 12);

            st->codec->sample_rate = avio_rb16(pb);

            if (data_size >= 16) {

                avio_skip(pb, 1);

                iff->svx8_compression = avio_r8(pb);

            }

            break;



        case ID_MHDR:

            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;



            if (data_size < 32)

                return AVERROR_INVALIDDATA;

            avio_skip(pb, 4);

            iff->maud_bits = avio_rb16(pb);

            avio_skip(pb, 2);

            num = avio_rb32(pb);

            den = avio_rb16(pb);

            if (!den)

                return AVERROR_INVALIDDATA;

            avio_skip(pb, 2);

            st->codec->sample_rate = num / den;

            st->codec->channels = avio_rb16(pb);

            iff->maud_compression = avio_rb16(pb);

            if (st->codec->channels == 1)

                st->codec->channel_layout = AV_CH_LAYOUT_MONO;

            else if (st->codec->channels == 2)

                st->codec->channel_layout = AV_CH_LAYOUT_STEREO;

            break;



        case ID_ABIT:

        case ID_BODY:

        case ID_DBOD:

        case ID_MDAT:

            iff->body_pos = avio_tell(pb);

            iff->body_end = iff->body_pos + data_size;

            iff->body_size = data_size;

            break;



        case ID_CHAN:

            if (data_size < 4)

                return AVERROR_INVALIDDATA;

            if (avio_rb32(pb) < 6) {

                st->codec->channels       = 1;

                st->codec->channel_layout = AV_CH_LAYOUT_MONO;

            } else {

                st->codec->channels       = 2;

                st->codec->channel_layout = AV_CH_LAYOUT_STEREO;

            }

            break;



        case ID_CAMG:

            if (data_size < 4)

                return AVERROR_INVALIDDATA;

            screenmode                = avio_rb32(pb);

            break;



        case ID_CMAP:

            if (data_size > INT_MAX - IFF_EXTRA_VIDEO_SIZE - FF_INPUT_BUFFER_PADDING_SIZE)

                return AVERROR_INVALIDDATA;

            st->codec->extradata_size = data_size + IFF_EXTRA_VIDEO_SIZE;

            st->codec->extradata      = av_malloc(data_size + IFF_EXTRA_VIDEO_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);

            if (!st->codec->extradata)

                return AVERROR(ENOMEM);

            if (avio_read(pb, st->codec->extradata + IFF_EXTRA_VIDEO_SIZE, data_size) < 0)

                return AVERROR(EIO);

            break;



        case ID_BMHD:

            st->codec->codec_type            = AVMEDIA_TYPE_VIDEO;

            if (data_size <= 8)

                return AVERROR_INVALIDDATA;

            st->codec->width                 = avio_rb16(pb);

            st->codec->height                = avio_rb16(pb);

            avio_skip(pb, 4); // x, y offset

            st->codec->bits_per_coded_sample = avio_r8(pb);

            if (data_size >= 10)

                masking                      = avio_r8(pb);

            if (data_size >= 11)

                iff->bitmap_compression      = avio_r8(pb);

            if (data_size >= 14) {

                avio_skip(pb, 1); // padding

                transparency                 = avio_rb16(pb);

            }

            if (data_size >= 16) {

                st->sample_aspect_ratio.num  = avio_r8(pb);

                st->sample_aspect_ratio.den  = avio_r8(pb);

            }

            break;



        case ID_DPEL:

            if (data_size < 4 || (data_size & 3))

                return AVERROR_INVALIDDATA;

            if ((fmt_size = avio_read(pb, fmt, sizeof(fmt))) < 0)

                return fmt_size;

            if (fmt_size == sizeof(deep_rgb24) && !memcmp(fmt, deep_rgb24, sizeof(deep_rgb24)))

                st->codec->pix_fmt = AV_PIX_FMT_RGB24;

            else if (fmt_size == sizeof(deep_rgba) && !memcmp(fmt, deep_rgba, sizeof(deep_rgba)))

                st->codec->pix_fmt = AV_PIX_FMT_RGBA;

            else if (fmt_size == sizeof(deep_bgra) && !memcmp(fmt, deep_bgra, sizeof(deep_bgra)))

                st->codec->pix_fmt = AV_PIX_FMT_BGRA;

            else if (fmt_size == sizeof(deep_argb) && !memcmp(fmt, deep_argb, sizeof(deep_argb)))

                st->codec->pix_fmt = AV_PIX_FMT_ARGB;

            else if (fmt_size == sizeof(deep_abgr) && !memcmp(fmt, deep_abgr, sizeof(deep_abgr)))

                st->codec->pix_fmt = AV_PIX_FMT_ABGR;

            else {

                av_log_ask_for_sample(s, ""unsupported color format\n"");

                return AVERROR_PATCHWELCOME;

            }

            break;



        case ID_DGBL:

            st->codec->codec_type            = AVMEDIA_TYPE_VIDEO;

            if (data_size < 8)

                return AVERROR_INVALIDDATA;

            st->codec->width                 = avio_rb16(pb);

            st->codec->height                = avio_rb16(pb);

            iff->bitmap_compression          = avio_rb16(pb);

            st->sample_aspect_ratio.num      = avio_r8(pb);

            st->sample_aspect_ratio.den      = avio_r8(pb);

            st->codec->bits_per_coded_sample = 24;

            break;



        case ID_DLOC:

            if (data_size < 4)

                return AVERROR_INVALIDDATA;

            st->codec->width  = avio_rb16(pb);

            st->codec->height = avio_rb16(pb);

            break;



        case ID_TVDC:

            if (data_size < sizeof(iff->tvdc))

                return AVERROR_INVALIDDATA;

            res = avio_read(pb, iff->tvdc, sizeof(iff->tvdc));

            if (res < 0)

                return res;

            break;



        case ID_ANNO:

        case ID_TEXT:      metadata_tag = ""comment"";   break;

        case ID_AUTH:      metadata_tag = ""artist"";    break;

        case ID_COPYRIGHT: metadata_tag = ""copyright""; break;

        case ID_NAME:      metadata_tag = ""title"";     break;

        }



        if (metadata_tag) {

            if ((res = get_metadata(s, metadata_tag, data_size)) < 0) {

                av_log(s, AV_LOG_ERROR, ""cannot allocate metadata tag %s!\n"", metadata_tag);

                return res;

            }

        }

        avio_skip(pb, data_size - (avio_tell(pb) - orig_pos) + (data_size & 1));

    }



    avio_seek(pb, iff->body_pos, SEEK_SET);



    switch(st->codec->codec_type) {

    case AVMEDIA_TYPE_AUDIO:

        avpriv_set_pts_info(st, 32, 1, st->codec->sample_rate);



        if (st->codec->codec_tag == ID_16SV)

            st->codec->codec_id = AV_CODEC_ID_PCM_S16BE_PLANAR;

        else if (st->codec->codec_tag == ID_MAUD) {

            if (iff->maud_bits == 8 && !iff->maud_compression) {

                st->codec->codec_id = AV_CODEC_ID_PCM_U8;

            } else if (iff->maud_bits == 16 && !iff->maud_compression) {

                st->codec->codec_id = AV_CODEC_ID_PCM_S16BE;

            } else if (iff->maud_bits ==  8 && iff->maud_compression == 2) {

                st->codec->codec_id = AV_CODEC_ID_PCM_ALAW;

            } else if (iff->maud_bits ==  8 && iff->maud_compression == 3) {

                st->codec->codec_id = AV_CODEC_ID_PCM_MULAW;

            } else {

                av_log_ask_for_sample(s, ""unsupported compression %d and bit depth %d\n"", iff->maud_compression, iff->maud_bits);

                return AVERROR_PATCHWELCOME;

            }



            st->codec->bits_per_coded_sample =

                av_get_bits_per_sample(st->codec->codec_id);



            st->codec->block_align =

                st->codec->bits_per_coded_sample * st->codec->channels / 8;

        } else {

        switch (iff->svx8_compression) {

        case COMP_NONE:

            st->codec->codec_id = AV_CODEC_ID_PCM_S8_PLANAR;

            break;

        case COMP_FIB:

            st->codec->codec_id = AV_CODEC_ID_8SVX_FIB;

            break;

        case COMP_EXP:

            st->codec->codec_id = AV_CODEC_ID_8SVX_EXP;

            break;

        default:

            av_log(s, AV_LOG_ERROR,

                   ""Unknown SVX8 compression method '%d'\n"", iff->svx8_compression);

            return -1;

        }

        }



        st->codec->bits_per_coded_sample = av_get_bits_per_sample(st->codec->codec_id);

        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate * st->codec->bits_per_coded_sample;

        st->codec->block_align = st->codec->channels * st->codec->bits_per_coded_sample;

        break;



    case AVMEDIA_TYPE_VIDEO:

        iff->bpp          = st->codec->bits_per_coded_sample;

        if ((screenmode & 0x800 /* Hold And Modify */) && iff->bpp <= 8) {

            iff->ham      = iff->bpp > 6 ? 6 : 4;

            st->codec->bits_per_coded_sample = 24;

        }

        iff->flags        = (screenmode & 0x80 /* Extra HalfBrite */) && iff->bpp <= 8;

        iff->masking      = masking;

        iff->transparency = transparency;



        if (!st->codec->extradata) {

            st->codec->extradata_size = IFF_EXTRA_VIDEO_SIZE;

            st->codec->extradata      = av_malloc(IFF_EXTRA_VIDEO_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);

            if (!st->codec->extradata)

                return AVERROR(ENOMEM);

        }


        buf = st->codec->extradata;

        bytestream_put_be16(&buf, IFF_EXTRA_VIDEO_SIZE);

        bytestream_put_byte(&buf, iff->bitmap_compression);

        bytestream_put_byte(&buf, iff->bpp);

        bytestream_put_byte(&buf, iff->ham);

        bytestream_put_byte(&buf, iff->flags);

        bytestream_put_be16(&buf, iff->transparency);

        bytestream_put_byte(&buf, iff->masking);

        bytestream_put_buffer(&buf, iff->tvdc, sizeof(iff->tvdc));

        st->codec->codec_id = AV_CODEC_ID_IFF_ILBM;

        break;

    default:

        return -1;

    }



    return 0;

}",1815,"static int iff_read_header(AVFormatContext *s)

{

    IffDemuxContext *pp = s->priv_data;

    AVIOContext *pb = s->pb;

    AVStream *ast;

    uint8_t *buf;

    uint32_t chunk_id, data_size;

    uint32_t screenmode = 0, num, den;

    unsigned transparency = 0;

    unsigned masking = 0; // no mask

    uint8_t fmt[16];

    int fmt_size;



    ast = avformat_new_stream(s, NULL);

    if (!ast)

        return AVERROR(ENOMEM);



    ast->codec->channels = 1;

    ast->codec->channel_layout = AV_CH_LAYOUT_MONO;

    avio_skip(pb, 8);

    // codec_tag used by ByteRun1 decoder to distinguish progressive (PBM) and interlaced (ILBM) content

    ast->codec->codec_tag = avio_rl32(pb);

    pp->bitmap_compression = -1;

    pp->svx8_compression = -1;

    pp->maud_bits = -1;

    pp->maud_compression = -1;



    while(!url_feof(pb)) {

        uint64_t orig_pos;

        int res;

        const char *metadata_tag = NULL;

        chunk_id = avio_rl32(pb);

        data_size = avio_rb32(pb);

        orig_pos = avio_tell(pb);



        switch(chunk_id) {

        case ID_VHDR:

            ast->codec->codec_type = AVMEDIA_TYPE_AUDIO;



            if (data_size < 14)

                return AVERROR_INVALIDDATA;

            avio_skip(pb, 12);

            ast->codec->sample_rate = avio_rb16(pb);

            if (data_size >= 16) {

                avio_skip(pb, 1);

                pp->svx8_compression = avio_r8(pb);

            }

            break;



        case ID_MHDR:

            ast->codec->codec_type = AVMEDIA_TYPE_AUDIO;



            if (data_size < 32)

                return AVERROR_INVALIDDATA;

            avio_skip(pb, 4);

            pp->maud_bits = avio_rb16(pb);

            avio_skip(pb, 2);

            num = avio_rb32(pb);

            den = avio_rb16(pb);

            if (!den)

                return AVERROR_INVALIDDATA;

            avio_skip(pb, 2);

            ast->codec->sample_rate = num / den;

            ast->codec->channels = avio_rb16(pb);

            pp->maud_compression = avio_rb16(pb);

            if (ast->codec->channels == 1)

                ast->codec->channel_layout = AV_CH_LAYOUT_MONO;

            else if (ast->codec->channels == 2)

                ast->codec->channel_layout = AV_CH_LAYOUT_STEREO;

            break;



        case ID_ABIT:

        case ID_BODY:

        case ID_DBOD:

        case ID_MDAT:

            pp->body_pos = avio_tell(pb);

            pp->body_end = pp->body_pos + data_size;

            pp->body_size = data_size;

            break;



        case ID_CHAN:

            if (data_size < 4)

                return AVERROR_INVALIDDATA;

            if (avio_rb32(pb) < 6) {

                ast->codec->channels       = 1;

                ast->codec->channel_layout = AV_CH_LAYOUT_MONO;

            } else {

                ast->codec->channels       = 2;

                ast->codec->channel_layout = AV_CH_LAYOUT_STEREO;

            }

            break;



        case ID_CAMG:

            if (data_size < 4)

                return AVERROR_INVALIDDATA;

            screenmode                = avio_rb32(pb);

            break;



        case ID_CMAP:

            if (data_size > INT_MAX - IFF_EXTRA_VIDEO_SIZE - FF_INPUT_BUFFER_PADDING_SIZE)

                return AVERROR_INVALIDDATA;

            ast->codec->extradata_size = data_size + IFF_EXTRA_VIDEO_SIZE;

            ast->codec->extradata      = av_malloc(data_size + IFF_EXTRA_VIDEO_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);

            if (!ast->codec->extradata)

                return AVERROR(ENOMEM);

            if (avio_read(pb, ast->codec->extradata + IFF_EXTRA_VIDEO_SIZE, data_size) < 0)

                return AVERROR(EIO);

            break;



        case ID_BMHD:

            ast->codec->codec_type            = AVMEDIA_TYPE_VIDEO;

            if (data_size <= 8)

                return AVERROR_INVALIDDATA;

            ast->codec->width                 = avio_rb16(pb);

            ast->codec->height                = avio_rb16(pb);

            avio_skip(pb, 4); // x, y offset

            ast->codec->bits_per_coded_sample = avio_r8(pb);

            if (data_size >= 10)

                masking                      = avio_r8(pb);

            if (data_size >= 11)

                pp->bitmap_compression      = avio_r8(pb);

            if (data_size >= 14) {

                avio_skip(pb, 1); // padding

                transparency                 = avio_rb16(pb);

            }

            if (data_size >= 16) {

                ast->sample_aspect_ratio.num  = avio_r8(pb);

                ast->sample_aspect_ratio.den  = avio_r8(pb);

            }

            break;



        case ID_DPEL:

            if (data_size < 4 || (data_size & 3))

                return AVERROR_INVALIDDATA;

            if ((fmt_size = avio_read(pb, fmt, sizeof(fmt))) < 0)

                return fmt_size;

            if (fmt_size == sizeof(deep_rgb24) && !memcmp(fmt, deep_rgb24, sizeof(deep_rgb24)))

                ast->codec->pix_fmt = AV_PIX_FMT_RGB24;

            else if (fmt_size == sizeof(deep_rgba) && !memcmp(fmt, deep_rgba, sizeof(deep_rgba)))

                ast->codec->pix_fmt = AV_PIX_FMT_RGBA;

            else if (fmt_size == sizeof(deep_bgra) && !memcmp(fmt, deep_bgra, sizeof(deep_bgra)))

                ast->codec->pix_fmt = AV_PIX_FMT_BGRA;

            else if (fmt_size == sizeof(deep_argb) && !memcmp(fmt, deep_argb, sizeof(deep_argb)))

                ast->codec->pix_fmt = AV_PIX_FMT_ARGB;

            else if (fmt_size == sizeof(deep_abgr) && !memcmp(fmt, deep_abgr, sizeof(deep_abgr)))

                ast->codec->pix_fmt = AV_PIX_FMT_ABGR;

            else {

                av_log_ask_for_sample(s, ""unsupported color format
"");

                return AVERROR_PATCHWELCOME;

            }

            break;



        case ID_DGBL:

            ast->codec->codec_type            = AVMEDIA_TYPE_VIDEO;

            if (data_size < 8)

                return AVERROR_INVALIDDATA;

            ast->codec->width                 = avio_rb16(pb);

            ast->codec->height                = avio_rb16(pb);

            pp->bitmap_compression          = avio_rb16(pb);

            ast->sample_aspect_ratio.num      = avio_r8(pb);

            ast->sample_aspect_ratio.den      = avio_r8(pb);

            ast->codec->bits_per_coded_sample = 24;

            break;



        case ID_DLOC:

            if (data_size < 4)

                return AVERROR_INVALIDDATA;

            ast->codec->width  = avio_rb16(pb);

            ast->codec->height = avio_rb16(pb);

            break;



        case ID_TVDC:

            if (data_size < sizeof(pp->tvdc))

                return AVERROR_INVALIDDATA;

            res = avio_read(pb, pp->tvdc, sizeof(pp->tvdc));

            if (res < 0)

                return res;

            break;



        case ID_ANNO:

        case ID_TEXT:      metadata_tag = ""comment"";   break;

        case ID_AUTH:      metadata_tag = ""artist"";    break;

        case ID_COPYRIGHT: metadata_tag = ""copyright""; break;

        case ID_NAME:      metadata_tag = ""title"";     break;

        }



        if (metadata_tag) {

            if ((res = get_metadata(s, metadata_tag, data_size)) < 0) {

                av_log(s, AV_LOG_ERROR, ""cannot allocate metadata tag %s!
"", metadata_tag);

                return res;

            }

        }

        avio_skip(pb, data_size - (avio_tell(pb) - orig_pos) + (data_size & 1));

    }



    avio_seek(pb, pp->body_pos, SEEK_SET);



    switch(ast->codec->codec_type) {

    case AVMEDIA_TYPE_AUDIO:

        avpriv_set_pts_info(ast, 32, 1, ast->codec->sample_rate);



        if (ast->codec->codec_tag == ID_16SV)

            ast->codec->codec_id = AV_CODEC_ID_PCM_S16BE_PLANAR;

        else if (ast->codec->codec_tag == ID_MAUD) {

            if (pp->maud_bits == 8 && !pp->maud_compression) {

                ast->codec->codec_id = AV_CODEC_ID_PCM_U8;

            } else if (pp->maud_bits == 16 && !pp->maud_compression) {

                ast->codec->codec_id = AV_CODEC_ID_PCM_S16BE;

            } else if (pp->maud_bits ==  8 && pp->maud_compression == 2) {

                ast->codec->codec_id = AV_CODEC_ID_PCM_ALAW;

            } else if (pp->maud_bits ==  8 && pp->maud_compression == 3) {

                ast->codec->codec_id = AV_CODEC_ID_PCM_MULAW;

            } else {

                av_log_ask_for_sample(s, ""unsupported compression %d and bit depth %d
"", pp->maud_compression, pp->maud_bits);

                return AVERROR_PATCHWELCOME;

            }



            ast->codec->bits_per_coded_sample =

                av_get_bits_per_sample(ast->codec->codec_id);



            ast->codec->block_align =

                ast->codec->bits_per_coded_sample * ast->codec->channels / 8;

        } else {

        switch (pp->svx8_compression) {

        case COMP_NONE:

            ast->codec->codec_id = AV_CODEC_ID_PCM_S8_PLANAR;

            break;

        case COMP_FIB:

            ast->codec->codec_id = AV_CODEC_ID_8SVX_FIB;

            break;

        case COMP_EXP:

            ast->codec->codec_id = AV_CODEC_ID_8SVX_EXP;

            break;

        default:

            av_log(s, AV_LOG_ERROR,

                   ""Unknown SVX8 compression method '%d'
"", pp->svx8_compression);

            return -1;

        }

        }



        ast->codec->bits_per_coded_sample = av_get_bits_per_sample(ast->codec->codec_id);

        ast->codec->bit_rate = ast->codec->channels * ast->codec->sample_rate * ast->codec->bits_per_coded_sample;

        ast->codec->block_align = ast->codec->channels * ast->codec->bits_per_coded_sample;

        break;



    case AVMEDIA_TYPE_VIDEO:

        pp->bpp          = ast->codec->bits_per_coded_sample;

        if ((screenmode & 0x800 /* Hold And Modify */) && pp->bpp <= 8) {

            pp->ham      = pp->bpp > 6 ? 6 : 4;

            ast->codec->bits_per_coded_sample = 24;

        }

        pp->flags        = (screenmode & 0x80 /* Extra HalfBrite */) && pp->bpp <= 8;

        pp->masking      = masking;

        pp->transparency = transparency;



        if (!ast->codec->extradata) {

            ast->codec->extradata_size = IFF_EXTRA_VIDEO_SIZE;

            ast->codec->extradata      = av_malloc(IFF_EXTRA_VIDEO_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);

            if (!ast->codec->extradata)

                return AVERROR(ENOMEM);

        }


        buf = ast->codec->extradata;

        bytestream_put_be16(&buf, IFF_EXTRA_VIDEO_SIZE);

        bytestream_put_byte(&buf, pp->bitmap_compression);

        bytestream_put_byte(&buf, pp->bpp);

        bytestream_put_byte(&buf, pp->ham);

        bytestream_put_byte(&buf, pp->flags);

        bytestream_put_be16(&buf, pp->transparency);

        bytestream_put_byte(&buf, pp->masking);

        bytestream_put_buffer(&buf, pp->tvdc, sizeof(pp->tvdc));

        ast->codec->codec_id = AV_CODEC_ID_IFF_ILBM;

        break;

    default:

        return -1;

    }



    return 0;

}",1,1,0.0,1,"s,iff,pb,st,buf,chunk_id,data_size,num,den,fmt,fmt_size,orig_pos,res,metadata_tag","s:0.03633803129196167,iff:0.059276700019836426,pb:0.007983177900314331,st:0.04771602153778076,buf:0.017236948013305664,chunk_id:0.006082326173782349,data_size:-0.024662911891937256,num:0.008912235498428345,den:-0.0044935643672943115,fmt:0.00413849949836731,fmt_size:0.003170192241668701,orig_pos:0.02340400218963623,res:0.0013446211814880371,metadata_tag:0.007907003164291382,",2.0,123.0,"iff:pp,st:ast,",Greedy,389,0.4028799096743266
99,"void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)

{

	long i;

	for(i=0; i<num_pixels; i++)

		((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);

}
",66,"void palette8tobgr16(const uint8_t *cb, uint8_t *adst, long num_pamples, const uint8_t *annette)

{

	long io;

	for(iio0; iionum_pamples; io++)

		((uint16_t *adstt)ioi] = bswap_16(((uint16_t *annettee)[ cb[io] ]);

}
",1,1,0.0,1,"src,dst,num_pixels,palette,i",,0.0,0.0,"src:cb,dst:adst,num_pixels:num_pamples,palette:annette,i:io,",GA,428,0.4015283306439717
101,"static int read_gab2_sub(AVStream *st, AVPacket *pkt) {

    if (!strcmp(pkt->data, ""GAB2"") && AV_RL16(pkt->data+5) == 2) {

        uint8_t desc[256];

        int score = AVPROBE_SCORE_MAX / 2, ret;

        AVIStream *ast = st->priv_data;

        AVInputFormat *sub_demuxer;

        AVRational time_base;

        AVIOContext *pb = avio_alloc_context( pkt->data + 7,

                                              pkt->size - 7,

                                              0, NULL, NULL, NULL, NULL);

        AVProbeData pd;

        unsigned int desc_len = avio_rl32(pb);



        if (desc_len > pb->buf_end - pb->buf_ptr)

            goto error;



        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));

        avio_skip(pb, desc_len - ret);

        if (*desc)

            av_dict_set(&st->metadata, ""title"", desc, 0);



        avio_rl16(pb);   /* flags? */

        avio_rl32(pb);   /* data size */



        pd = (AVProbeData) { .buf = pb->buf_ptr, .buf_size = pb->buf_end - pb->buf_ptr };

        if (!(sub_demuxer = av_probe_input_format2(&pd, 1, &score)))

            goto error;



        if (!(ast->sub_ctx = avformat_alloc_context()))

            goto error;



        ast->sub_ctx->pb      = pb;

        if (!avformat_open_input(&ast->sub_ctx, """", sub_demuxer, NULL)) {

            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);

            *st->codec = *ast->sub_ctx->streams[0]->codec;

            ast->sub_ctx->streams[0]->codec->extradata = NULL;

            time_base = ast->sub_ctx->streams[0]->time_base;

            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);

        }

        ast->sub_buffer = pkt->data;

        memset(pkt, 0, sizeof(*pkt));

        return 1;

error:

        av_freep(&pb);

    }

    return 0;

}
",378,"static int read_gab2_sub(AVStream *st, AVPacket *pkt) {

    if (!strcmp(pkt->data, ""GAB2"") && AV_RL16(pkt->data+5) == 2) {

        uint8_t desc[256];

        int score = AVPROBE_SCORE_MAX / 2, ret;

        AVIStream *ast = st->priv_data;

        AVInputFormat *sub_Democer;

        AVRational time_base;

        AVIOContext *pb = avio_alloc_context( pkt->data + 7,

                                              pkt->size - 7,

                                              0, NULL, NULL, NULL, NULL);

        AVProbeData pd;

        unsigned int desc_len = avio_rl32(pb);



        if (desc_len > pb->buf_end - pb->buf_ptr)

            goto error;



        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));

        avio_skip(pb, desc_len - ret);

        if (*desc)

            av_dict_set(&st->metadata, ""title"", desc, 0);



        avio_rl16(pb);   /* flags? */

        avio_rl32(pb);   /* data size */



        pd = (AVProbeData) { .buf = pb->buf_ptr, .buf_size = pb->buf_end - pb->buf_ptr };

        if (!(sub_Democer = av_probe_input_format2(&pd, 1, &score)))

            goto error;



        if (!(ast->sub_ctx = avformat_alloc_context()))

            goto error;



        ast->sub_ctx->pb      = pb;

        if (!avformat_open_input(&ast->sub_ctx, """", sub_Democer, NULL)) {

            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);

            *st->codec = *ast->sub_ctx->streams[0]->codec;

            ast->sub_ctx->streams[0]->codec->extradata = NULL;

            time_base = ast->sub_ctx->streams[0]->time_base;

            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);

        }

        ast->sub_buffer = pkt->data;

        memset(pkt, 0, sizeof(*pkt));

        return 1;

error:

        av_freep(&pb);

    }

    return 0;

}
",1,1,0.0,1,"st,pkt,desc,ret,ast,sub_demuxer,time_base,pb,pd","st:-0.015919089317321777,pkt:-0.011045694351196289,desc:-0.008395850658416748,ret:0.0622825026512146,ast:-0.0061686038970947266,sub_demuxer:0.0920446515083313,time_base:0.015052258968353271,pb:0.08173823356628418,pd:0.02872699499130249,",1.0,3.0,"sub_demuxer:sub_Democer,",Greedy,111,0.1063117543856302
112,"static int decode_copy(uint8_t *frame, int width, int height,

                       const uint8_t *src, const uint8_t *src_end)

{

    const int size = width * height;



    if (src_end - src < size)

        return -1;

    bytestream_get_buffer(&src, frame, size);

    return 0;

}
",58,"static int decode_copy(uint8_t *channel, int width, int direction,

                       const uint8_t *sync, const uint8_t * src_id)

{

    const int size = width * direction;



    if ( src_id - sync < size)

        return -1;

    bytestream_get_buffer(&sync, channel, size);

    return 0;

}
",1,1,0.0,1,"frame,height,src,src_end","frame:-0.009935736656188965,height:-0.02196037769317627,src:-0.03638148307800293,src_end:-0.014978349208831787,",4.0,9.0,"frame:channel,src_end: src_id,height:direction,src:sync,",Greedy,142,0.1455498456954956
120,"static void mpegvideo_extract_headers(AVCodecParserContext *s,

                                      AVCodecContext *avctx,

                                      const uint8_t *buf, int buf_size)

{

    ParseContext1 *pc = s->priv_data;

    const uint8_t *buf_end;


    uint32_t start_code;

    int frame_rate_index, ext_type, bytes_left;

    int frame_rate_ext_n, frame_rate_ext_d;

    int picture_structure, top_field_first, repeat_first_field, progressive_frame;

    int horiz_size_ext, vert_size_ext, bit_rate_ext;

//FIXME replace the crap with get_bits()

    s->repeat_pict = 0;

    buf_end = buf + buf_size;

    while (buf < buf_end) {

        start_code= -1;

        buf= ff_find_start_code(buf, buf_end, &start_code);

        bytes_left = buf_end - buf;

        switch(start_code) {

        case PICTURE_START_CODE:

            ff_fetch_timestamp(s, buf-buf_start-4, 1);



            if (bytes_left >= 2) {

                s->pict_type = (buf[1] >> 3) & 7;

            }

            break;

        case SEQ_START_CODE:

            if (bytes_left >= 7) {

                pc->width  = (buf[0] << 4) | (buf[1] >> 4);

                pc->height = ((buf[1] & 0x0f) << 8) | buf[2];

                avcodec_set_dimensions(avctx, pc->width, pc->height);

                frame_rate_index = buf[3] & 0xf;

                pc->frame_rate.den = avctx->time_base.den = ff_frame_rate_tab[frame_rate_index].num;

                pc->frame_rate.num = avctx->time_base.num = ff_frame_rate_tab[frame_rate_index].den;

                avctx->bit_rate = ((buf[4]<<10) | (buf[5]<<2) | (buf[6]>>6))*400;

                avctx->codec_id = CODEC_ID_MPEG1VIDEO;

                avctx->sub_id = 1;

            }

            break;

        case EXT_START_CODE:

            if (bytes_left >= 1) {

                ext_type = (buf[0] >> 4);

                switch(ext_type) {

                case 0x1: /* sequence extension */

                    if (bytes_left >= 6) {

                        horiz_size_ext = ((buf[1] & 1) << 1) | (buf[2] >> 7);

                        vert_size_ext = (buf[2] >> 5) & 3;

                        bit_rate_ext = ((buf[2] & 0x1F)<<7) | (buf[3]>>1);

                        frame_rate_ext_n = (buf[5] >> 5) & 3;

                        frame_rate_ext_d = (buf[5] & 0x1f);

                        pc->progressive_sequence = buf[1] & (1 << 3);

                        avctx->has_b_frames= !(buf[5] >> 7);



                        pc->width  |=(horiz_size_ext << 12);

                        pc->height |=( vert_size_ext << 12);

                        avctx->bit_rate += (bit_rate_ext << 18) * 400;

                        avcodec_set_dimensions(avctx, pc->width, pc->height);

                        avctx->time_base.den = pc->frame_rate.den * (frame_rate_ext_n + 1);

                        avctx->time_base.num = pc->frame_rate.num * (frame_rate_ext_d + 1);

                        avctx->codec_id = CODEC_ID_MPEG2VIDEO;

                        avctx->sub_id = 2; /* forces MPEG2 */

                    }

                    break;

                case 0x8: /* picture coding extension */

                    if (bytes_left >= 5) {

                        picture_structure = buf[2]&3;

                        top_field_first = buf[3] & (1 << 7);

                        repeat_first_field = buf[3] & (1 << 1);

                        progressive_frame = buf[4] & (1 << 7);



                        /* check if we must repeat the frame */

                        if (repeat_first_field) {

                            if (pc->progressive_sequence) {

                                if (top_field_first)

                                    s->repeat_pict = 4;

                                else

                                    s->repeat_pict = 2;

                            } else if (progressive_frame) {

                                s->repeat_pict = 1;

                            }

                        }

                    }

                    break;

                }

            }

            break;

        case -1:

            goto the_end;

        default:

            /* we stop parsing when we encounter a slice. It ensures

               that this function takes a negligible amount of time */

            if (start_code >= SLICE_MIN_START_CODE &&

                start_code <= SLICE_MAX_START_CODE)

                goto the_end;

            break;

        }

    }

 the_end: ;

}",700,"static void mpegvideo_extract_headers(AVCodecParserContext *s,

                                      AVCodecContext *avctx,

                                      const uint8_t *buf, int buf_size)

{

    ParseContext1 *pc = s->priv_data;

    const uint8_t *uf_id;


    uint32_t start_code;

    int frame_rate_index, ext_type, bytes_left;

    int frame_rate_ext_n, frame_rate_ext_d;

    int picture_structure, top_field_first, repeat_first_field, progressive_frame;

    int horiz_size_ext, vert_size_ext, bit_rate_ext;

//FIXME replace the crap with get_bits()

    s->repeat_pict = 0;

    uf_id = buf + buf_size;

    while (buf < uf_id) {

        start_code= -1;

        buf= ff_find_start_code(buf, uf_id, &start_code);

        bytes_left = uf_id - buf;

        switch(start_code) {

        case PICTURE_START_CODE:

            ff_fetch_timestamp(s, buf-buf_start-4, 1);



            if (bytes_left >= 2) {

                s->pict_type = (buf[1] >> 3) & 7;

            }

            break;

        case SEQ_START_CODE:

            if (bytes_left >= 7) {

                pc->width  = (buf[0] << 4) | (buf[1] >> 4);

                pc->height = ((buf[1] & 0x0f) << 8) | buf[2];

                avcodec_set_dimensions(avctx, pc->width, pc->height);

                frame_rate_index = buf[3] & 0xf;

                pc->frame_rate.den = avctx->time_base.den = ff_frame_rate_tab[frame_rate_index].num;

                pc->frame_rate.num = avctx->time_base.num = ff_frame_rate_tab[frame_rate_index].den;

                avctx->bit_rate = ((buf[4]<<10) | (buf[5]<<2) | (buf[6]>>6))*400;

                avctx->codec_id = CODEC_ID_MPEG1VIDEO;

                avctx->sub_id = 1;

            }

            break;

        case EXT_START_CODE:

            if (bytes_left >= 1) {

                ext_type = (buf[0] >> 4);

                switch(ext_type) {

                case 0x1: /* sequence extension */

                    if (bytes_left >= 6) {

                        horiz_size_ext = ((buf[1] & 1) << 1) | (buf[2] >> 7);

                        vert_size_ext = (buf[2] >> 5) & 3;

                        bit_rate_ext = ((buf[2] & 0x1F)<<7) | (buf[3]>>1);

                        frame_rate_ext_n = (buf[5] >> 5) & 3;

                        frame_rate_ext_d = (buf[5] & 0x1f);

                        pc->progressive_sequence = buf[1] & (1 << 3);

                        avctx->has_b_frames= !(buf[5] >> 7);



                        pc->width  |=(horiz_size_ext << 12);

                        pc->height |=( vert_size_ext << 12);

                        avctx->bit_rate += (bit_rate_ext << 18) * 400;

                        avcodec_set_dimensions(avctx, pc->width, pc->height);

                        avctx->time_base.den = pc->frame_rate.den * (frame_rate_ext_n + 1);

                        avctx->time_base.num = pc->frame_rate.num * (frame_rate_ext_d + 1);

                        avctx->codec_id = CODEC_ID_MPEG2VIDEO;

                        avctx->sub_id = 2; /* forces MPEG2 */

                    }

                    break;

                case 0x8: /* picture coding extension */

                    if (bytes_left >= 5) {

                        picture_structure = buf[2]&3;

                        top_field_first = buf[3] & (1 << 7);

                        repeat_first_field = buf[3] & (1 << 1);

                        progressive_frame = buf[4] & (1 << 7);



                        /* check if we must repeat the frame */

                        if (repeat_first_field) {

                            if (pc->progressive_sequence) {

                                if (top_field_first)

                                    s->repeat_pict = 4;

                                else

                                    s->repeat_pict = 2;

                            } else if (progressive_frame) {

                                s->repeat_pict = 1;

                            }

                        }

                    }

                    break;

                }

            }

            break;

        case -1:

            goto the_end;

        default:

            /* we stop parsing when we encounter a slice. It ensures

               that this function takes a negligible amount of time */

            if (start_code >= SLICE_MIN_START_CODE &&

                start_code <= SLICE_MAX_START_CODE)

                goto the_end;

            break;

        }

    }

 the_end: ;

}",1,1,0.0,1,"s,avctx,buf,buf_size,pc,buf_end,start_code,frame_rate_index,ext_type,bytes_left,frame_rate_ext_n,frame_rate_ext_d,picture_structure,top_field_first,repeat_first_field,progressive_frame,horiz_size_ext,vert_size_ext,bit_rate_ext","s:0.042588502168655396,avctx:0.13837474584579468,buf:0.08580493927001953,buf_size:0.15154457092285156,pc:0.17706367373466492,buf_end:0.33607983589172363,start_code:0.2263583540916443,frame_rate_index:-0.017756402492523193,ext_type:0.0571216344833374,bytes_left:0.19371682405471802,frame_rate_ext_n:0.07318705320358276,frame_rate_ext_d:0.07057154178619385,picture_structure:0.006905943155288696,top_field_first:0.02997991442680359,repeat_first_field:0.014557182788848877,progressive_frame:0.05977463722229004,horiz_size_ext:0.023785680532455444,vert_size_ext:0.022552669048309326,bit_rate_ext:0.00995662808418274,",1.0,5.0,"buf_end:uf_id,",Greedy,193,0.1878954092661539
133,"static void gen_dst(DisasContext *ctx)

{

    if (rA(ctx->opcode) == 0) {

        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);

    } else {

        /* interpreted as no-op */

    }

}
",33,"static void gen_dst(DisasContext *tc)

{

    if (rA(tc->opcode) == 0) {

        gen_inval_exception(tc, POWERPC_EXCP_INVAL_LSWX);

    } else {

        /* interpreted as no-op */

    }

}
",1,1,0.0,1,ctx,"ctx:-0.20651626586914062,",1.0,3.0,"ctx:tc,",Greedy,54,0.0570685505867004
145,"static void fill_table(uint8_t* table[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,

                       const int inc, void *y_tab)

{

    int i;

    uint8_t *y_table = y_tab;



    y_table -= elemsize * (inc >> 9);



    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {

        int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;

        table[i] = y_table + elemsize * (cb >> 16);

    }

}
",98,"static void fill_table(uint8_t* address[256 + 2*YUVRGB_TABLE_HEADROOM], const int Elemmize,

                       const int fc, void *y_lab)

{

    int phi;

    uint8_t *y_table = y_lab;



    y_table -= Elemmize * (fc >> 9);



    for (phi = 0; phi < 256 + 2*YUVRGB_TABLE_HEADROOM; phi++) {

        int64_t cb = av_clip(phi-YUVRGB_TABLE_HEADROOM, 0, 255)*fc;

        address[phi] = y_table + Elemmize * (cb >> 16);

    }

}
",1,1,0.0,1,"table,elemsize,inc,y_tab,i,y_table","table:-0.018342792987823486,elemsize:-0.0197145938873291,inc:0.015684068202972412,y_tab:0.07104074954986572,i:-0.01746499538421631,y_table:-0.035163938999176025,",5.0,16.0,"y_tab:y_lab,inc:fc,i:phi,table:address,elemsize:Elemmize,",Greedy,230,0.2289026180903116
160,"static int xpm_decode_frame(AVCodecContext *avctx, void *data,

                            int *got_frame, AVPacket *avpkt)

{

    XPMDecContext *x = avctx->priv_data;

    AVFrame *p=data;

    const uint8_t *end, *ptr = avpkt->data;

    int ncolors, cpp, ret, i, j;

    int64_t size;

    uint32_t *dst;



    avctx->pix_fmt = AV_PIX_FMT_BGRA;



    end = avpkt->data + avpkt->size;

    while (memcmp(ptr, ""/* XPM */\n"", 10) && ptr < end - 10)

        ptr++;



    if (ptr >= end) {

        av_log(avctx, AV_LOG_ERROR, ""missing signature\n"");

        return AVERROR_INVALIDDATA;

    }



    ptr += mod_strcspn(ptr, ""\"""");

    if (sscanf(ptr, ""\""%u %u %u %u\"","",

               &avctx->width, &avctx->height, &ncolors, &cpp) != 4) {

        av_log(avctx, AV_LOG_ERROR, ""missing image parameters\n"");

        return AVERROR_INVALIDDATA;

    }



    if ((ret = ff_set_dimensions(avctx, avctx->width, avctx->height)) < 0)

        return ret;



    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)

        return ret;



    if (cpp <= 0 || cpp >= 5) {

        av_log(avctx, AV_LOG_ERROR, ""unsupported/invalid number of chars per pixel: %d\n"", cpp);

        return AVERROR_INVALIDDATA;

    }



    size = 1;

    for (i = 0; i < cpp; i++)

        size *= 94;



    if (ncolors <= 0 || ncolors > size) {

        av_log(avctx, AV_LOG_ERROR, ""invalid number of colors: %d\n"", ncolors);

        return AVERROR_INVALIDDATA;

    }



    size *= 4;



    av_fast_padded_malloc(&x->pixels, &x->pixels_size, size);

    if (!x->pixels)

        return AVERROR(ENOMEM);



    ptr += mod_strcspn(ptr, "","") + 1;

    for (i = 0; i < ncolors; i++) {

        const uint8_t *index;

        int len;



        ptr += mod_strcspn(ptr, ""\"""") + 1;

        if (ptr + cpp > end)

            return AVERROR_INVALIDDATA;

        index = ptr;

        ptr += cpp;



        ptr = strstr(ptr, ""c "");

        if (ptr) {

            ptr += 2;

        } else {

            return AVERROR_INVALIDDATA;

        }



        len = strcspn(ptr, ""\"" "");



        if ((ret = ascii2index(index, cpp)) < 0)

            return ret;



        x->pixels[ret] = color_string_to_rgba(ptr, len);

        ptr += mod_strcspn(ptr, "","") + 1;

    }



    for (i = 0; i < avctx->height; i++) {

        dst = (uint32_t *)(p->data[0] + i * p->linesize[0]);

        ptr += mod_strcspn(ptr, ""\"""") + 1;



        for (j = 0; j < avctx->width; j++) {

            if (ptr + cpp > end)

                return AVERROR_INVALIDDATA;



            if ((ret = ascii2index(ptr, cpp)) < 0)

                return ret;



            *dst++ = x->pixels[ret];

            ptr += cpp;

        }

        ptr += mod_strcspn(ptr, "","") + 1;

    }



    p->key_frame = 1;

    p->pict_type = AV_PICTURE_TYPE_I;



    *got_frame = 1;



    return avpkt->size;

}
",628,"static int xpm_decode_frame(AVCodecContext *avctx, void *api,

                            int *got_frame, AVPacket *avpkt)

{

    XPMDecContext *python = avctx->priv_data;

    AVFrame *fp=api;

    const uint8_t *end, *ptr = avpkt->api;

    int noloring, cpp, ret, uri, jump;

    int64_t size;

    uint32_t *fsts;



    avctx->pix_fmt = AV_PIX_FMT_BGRA;



    end = avpkt->api + avpkt->size;

    while (memcmp(ptr, ""/* XPM */
"", 10) && ptr < end - 10)

        ptr++;



    if (ptr >= end) {

        av_log(avctx, AV_LOG_ERROR, ""missing signature
"");

        return AVERROR_INVALIDDATA;

    }



    ptr += mod_strcspn(ptr, ""\"""");

    if (sscanf(ptr, ""\""%u %u %u %u\"","",

               &avctx->width, &avctx->height, &noloring, &cpp) != 4) {

        av_log(avctx, AV_LOG_ERROR, ""missing image parameters
"");

        return AVERROR_INVALIDDATA;

    }



    if ((ret = ff_set_dimensions(avctx, avctx->width, avctx->height)) < 0)

        return ret;



    if ((ret = ff_get_buffer(avctx, fp, 0)) < 0)

        return ret;



    if (cpp <= 0 || cpp >= 5) {

        av_log(avctx, AV_LOG_ERROR, ""unsupported/invalid number of chars per pixel: %d
"", cpp);

        return AVERROR_INVALIDDATA;

    }



    size = 1;

    for (uri = 0; uri < cpp; uri++)

        size *= 94;



    if (noloring <= 0 || noloring > size) {

        av_log(avctx, AV_LOG_ERROR, ""invalid number of colors: %d
"", noloring);

        return AVERROR_INVALIDDATA;

    }



    size *= 4;



    av_fast_padded_malloc(&python->pixels, &python->pixels_size, size);

    if (!python->pixels)

        return AVERROR(ENOMEM);



    ptr += mod_strcspn(ptr, "","") + 1;

    for (uri = 0; uri < noloring; uri++) {

        const uint8_t *index;

        int len;



        ptr += mod_strcspn(ptr, ""\"""") + 1;

        if (ptr + cpp > end)

            return AVERROR_INVALIDDATA;

        index = ptr;

        ptr += cpp;



        ptr = strstr(ptr, ""c "");

        if (ptr) {

            ptr += 2;

        } else {

            return AVERROR_INVALIDDATA;

        }



        len = strcspn(ptr, ""\"" "");



        if ((ret = ascii2index(index, cpp)) < 0)

            return ret;



        python->pixels[ret] = color_string_to_rgba(ptr, len);

        ptr += mod_strcspn(ptr, "","") + 1;

    }



    for (uri = 0; uri < avctx->height; uri++) {

        fsts = (uint32_t *)(fp->api[0] + uri * fp->linesize[0]);

        ptr += mod_strcspn(ptr, ""\"""") + 1;



        for (jump = 0; jump < avctx->width; jump++) {

            if (ptr + cpp > end)

                return AVERROR_INVALIDDATA;



            if ((ret = ascii2index(ptr, cpp)) < 0)

                return ret;



            *fsts++ = python->pixels[ret];

            ptr += cpp;

        }

        ptr += mod_strcspn(ptr, "","") + 1;

    }



    fp->key_frame = 1;

    fp->pict_type = AV_PICTURE_TYPE_I;



    *got_frame = 1;



    return avpkt->size;

}
",1,1,0.0,1,"avctx,data,got_frame,avpkt,x,p,end,ptr,ncolors,cpp,ret,i,j,size,dst","avctx:-0.03391265869140625,data:-0.005735039710998535,got_frame:-0.013766288757324219,avpkt:-0.010461211204528809,x:-0.006235837936401367,p:-0.0070285797119140625,end:-0.01089102029800415,ptr:-0.03720587491989136,ncolors:-0.006441712379455566,cpp:-0.014797985553741455,ret:-0.018282711505889893,i:-0.00301516056060791,j:-0.002868175506591797,size:-0.017374157905578613,dst:-0.0016106963157653809,",7.0,41.0,"dst:fsts,j:jump,i:uri,data:api,x:python,ncolors:noloring,p:fp,",Greedy,442,0.4328813473383585
168,"static int get_bits(Jpeg2000DecoderContext *s, int n)

{

    int res = 0;

    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))

        return AVERROR_INVALIDDATA;

    while (--n >= 0) {

        res <<= 1;

        if (s->bit_index == 0) {

            s->bit_index = 7 + (*s->buf != 0xff);

            s->buf++;

        }

        s->bit_index--;

        res |= (*s->buf >> s->bit_index) & 1;

    }

    return res;

}
",109,"static int get_bits(Jpeg2000DecoderContext *ions, int node)

{

    int res = 0;

    if (ions->buf_end - ions->buf < ((node - ions->bit_index) >> 8))

        return AVERROR_INVALIDDATA;

    while (--node >= 0) {

        res <<= 1;

        if (ions->bit_index == 0) {

            ions->bit_index = 7 + (*ions->buf != 0xff);

            ions->buf++;

        }

        ions->bit_index--;

        res |= (*ions->buf >> ions->bit_index) & 1;

    }

    return res;

}
",1,1,0.0,1,"s,n,bit_index,buf","s:0.029755443334579468,n:0.044941872358322144,bit_index:0.02763211727142334,buf:0.00601804256439209,",2.0,14.0,"n:node,s:ions,",Greedy,137,0.1295319120089213
174,"static void master_abort_mem_write(void *opaque, hwaddr addr, uint64_t val,

                                   unsigned size)

{

}
",19,"static void master_abort_mem_write(void *opaque, hwaddr name, uint64_t slot,

                                   unsigned size)

{

}
",1,1,0.0,1,"opaque,addr,val,size","opaque:-0.003665924072265625,addr:0.04545623064041138,val:0.09167927503585815,size:0.011290550231933594,",2.0,2.0,"val:slot,addr:name,",Greedy,60,0.0661941051483154
176,"void ff_init_cabac_decoder(CABACContext *c, const uint8_t *buf, int buf_size){

    c->bytestream_start=

    c->bytestream= buf;

    c->bytestream_end= buf + buf_size;



#if CABAC_BITS == 16

    c->low =  (*c->bytestream++)<<18;

    c->low+=  (*c->bytestream++)<<10;

#else

    c->low =  (*c->bytestream++)<<10;

#endif

    c->low+= ((*c->bytestream++)<<2) + 2;

    c->range= 0x1FE;

}
",108,"void ff_init_cabac_decoder(CABACContext *c, const uint8_t *fd, int buf_size){

    c->bytestream_start=

    c->bytestream= fd;

    c->bytestream_end= fd + buf_size;



#if CABAC_BITS == 16

    c->low =  (*c->bytestream++)<<18;

    c->low+=  (*c->bytestream++)<<10;

#else

    c->low =  (*c->bytestream++)<<10;

#endif

    c->low+= ((*c->bytestream++)<<2) + 2;

    c->range= 0x1FE;

}
",1,1,0.0,1,"c,buf,buf_size","c:-0.1309586763381958,buf:0.0226326584815979,buf_size:0.00849682092666626,",1.0,3.0,"buf:fd,",Greedy,74,0.0765206058820088
181,"static void netfilter_finalize(Object *obj)

{

    NetFilterState *nf = NETFILTER(obj);

    NetFilterClass *nfc = NETFILTER_GET_CLASS(obj);



    if (nfc->cleanup) {

        nfc->cleanup(nf);

    }



    if (nf->netdev && !QTAILQ_EMPTY(&nf->netdev->filters)) {

        QTAILQ_REMOVE(&nf->netdev->filters, nf, next);

    }


}",76,"static void netfilter_finalize(Object *jp)

{

    NetFilterState *cncf = NETFILTER(jp);

    NetFilterClass *nfs = NETFILTER_GET_CLASS(jp);



    if (nfs->cleanup) {

        nfs->cleanup(cncf);

    }



    if (cncf->netdev && !QTAILQ_EMPTY(&cncf->netdev->filters)) {

        QTAILQ_REMOVE(&cncf->netdev->filters, cncf, next);

    }


}",1,1,0.0,1,"obj,nf,nfc","obj:0.006916671991348267,nf:0.0175836980342865,nfc:0.0270501971244812,",3.0,12.0,"nfc:nfs,nf:cncf,obj:jp,",Greedy,121,0.1198387543360392
183,"static void amdvi_realize(DeviceState *dev, Error **err)

{

    int ret = 0;

    AMDVIState *s = AMD_IOMMU_DEVICE(dev);

    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(dev);

    PCIBus *bus = PC_MACHINE(qdev_get_machine())->bus;

    s->iotlb = g_hash_table_new_full(amdvi_uint64_hash,

                                     amdvi_uint64_equal, g_free, g_free);



    /* This device should take care of IOMMU PCI properties */

    x86_iommu->type = TYPE_AMD;

    qdev_set_parent_bus(DEVICE(&s->pci), &bus->qbus);

    object_property_set_bool(OBJECT(&s->pci), true, ""realized"", err);

    s->capab_offset = pci_add_capability(&s->pci.dev, AMDVI_CAPAB_ID_SEC, 0,

                                         AMDVI_CAPAB_SIZE);

    assert(s->capab_offset > 0);

    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_MSI, 0, AMDVI_CAPAB_REG_SIZE);

    assert(ret > 0);

    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_HT, 0, AMDVI_CAPAB_REG_SIZE);

    assert(ret > 0);



    /* set up MMIO */

    memory_region_init_io(&s->mmio, OBJECT(s), &mmio_mem_ops, s, ""amdvi-mmio"",

                          AMDVI_MMIO_SIZE);



    sysbus_init_mmio(SYS_BUS_DEVICE(s), &s->mmio);

    sysbus_mmio_map(SYS_BUS_DEVICE(s), 0, AMDVI_BASE_ADDR);

    pci_setup_iommu(bus, amdvi_host_dma_iommu, s);

    s->devid = object_property_get_int(OBJECT(&s->pci), ""addr"", err);

    msi_init(&s->pci.dev, 0, 1, true, false, err);

    amdvi_init(s);

}
",287,"static void amdvi_realize(DeviceState *dev, Error **err)

{

    int ret = 0;

    AMDVIState *i = AMD_IOMMU_DEVICE(dev);

    X86IOMMUState *x86_iompui = X86_IOMMU_DEVICE(dev);

    PCIBus *bus = PC_MACHINE(qdev_get_machine())->bus;

    i->iotlb = g_hash_table_new_full(amdvi_uint64_hash,

                                     amdvi_uint64_equal, g_free, g_free);



    /* This device should take care of IOMMU PCI properties */

    x86_iompui->type = TYPE_AMD;

    qdev_set_parent_bus(DEVICE(&i->pci), &bus->qbus);

    object_property_set_bool(OBJECT(&i->pci), true, ""realized"", err);

    i->capab_offset = pci_add_capability(&i->pci.dev, AMDVI_CAPAB_ID_SEC, 0,

                                         AMDVI_CAPAB_SIZE);

    assert(i->capab_offset > 0);

    ret = pci_add_capability(&i->pci.dev, PCI_CAP_ID_MSI, 0, AMDVI_CAPAB_REG_SIZE);

    assert(ret > 0);

    ret = pci_add_capability(&i->pci.dev, PCI_CAP_ID_HT, 0, AMDVI_CAPAB_REG_SIZE);

    assert(ret > 0);



    /* set up MMIO */

    memory_region_init_io(&i->mmio, OBJECT(i), &mmio_mem_ops, i, ""amdvi-mmio"",

                          AMDVI_MMIO_SIZE);



    sysbus_init_mmio(SYS_BUS_DEVICE(i), &i->mmio);

    sysbus_mmio_map(SYS_BUS_DEVICE(i), 0, AMDVI_BASE_ADDR);

    pci_setup_iommu(bus, amdvi_host_dma_iommu, i);

    i->devid = object_property_get_int(OBJECT(&i->pci), ""addr"", err);

    msi_init(&i->pci.dev, 0, 1, true, false, err);

    amdvi_init(i);

}
",1,1,0.0,1,"dev,err,s,x86_iommu,bus","dev:-0.055737435817718506,err:-0.012621849775314331,s:-0.003685370087623596,x86_iommu:0.04064485430717468,bus:-0.019160404801368713,",2.0,22.0,"x86_iommu:x86_iompui,s:i,",Greedy,164,0.1645425240198771
189,"static int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)

{

    int64_t total_size = 0;

    MOVAtom a;

    int i;



    if (atom.size < 0)

        atom.size = INT64_MAX;

    while (total_size + 8 <= atom.size && !avio_feof(pb)) {

        int (*parse)(MOVContext*, AVIOContext*, MOVAtom) = NULL;

        a.size = atom.size;

        a.type=0;

        if (atom.size >= 8) {

            a.size = avio_rb32(pb);

            a.type = avio_rl32(pb);

            if (a.type == MKTAG('f','r','e','e') &&

                a.size >= 8 &&

                c->moov_retry) {

                uint8_t buf[8];

                uint32_t *type = (uint32_t *)buf + 1;

                avio_read(pb, buf, 8);

                avio_seek(pb, -8, SEEK_CUR);

                if (*type == MKTAG('m','v','h','d') ||

                    *type == MKTAG('c','m','o','v')) {

                    av_log(c->fc, AV_LOG_ERROR, ""Detected moov in a free atom.\n"");

                    a.type = MKTAG('m','o','o','v');

                }

            }

            if (atom.type != MKTAG('r','o','o','t') &&

                atom.type != MKTAG('m','o','o','v'))

            {

                if (a.type == MKTAG('t','r','a','k') || a.type == MKTAG('m','d','a','t'))

                {

                    av_log(c->fc, AV_LOG_ERROR, ""Broken file, trak/mdat not at top-level\n"");

                    avio_skip(pb, -8);

                    return 0;

                }

            }

            total_size += 8;

            if (a.size == 1) { /* 64 bit extended size */

                a.size = avio_rb64(pb) - 8;

                total_size += 8;

            }

        }

        av_dlog(c->fc, ""type: %08x '%.4s' parent:'%.4s' sz: %""PRId64"" %""PRId64"" %""PRId64""\n"",

                a.type, (char*)&a.type, (char*)&atom.type, a.size, total_size, atom.size);

        if (a.size == 0) {

            a.size = atom.size - total_size + 8;

        }

        a.size -= 8;

        if (a.size < 0)

            break;

        a.size = FFMIN(a.size, atom.size - total_size);



        for (i = 0; mov_default_parse_table[i].type; i++)

            if (mov_default_parse_table[i].type == a.type) {

                parse = mov_default_parse_table[i].parse;

                break;

            }



        // container is user data

        if (!parse && (atom.type == MKTAG('u','d','t','a') ||

                       atom.type == MKTAG('i','l','s','t')))

            parse = mov_read_udta_string;



        if (!parse) { /* skip leaf atoms data */

            avio_skip(pb, a.size);

        } else {

            int64_t start_pos = avio_tell(pb);

            int64_t left;

            int err = parse(c, pb, a);

            if (err < 0)

                return err;

            if (c->found_moov && c->found_mdat &&

                ((!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX) ||

                 start_pos + a.size == avio_size(pb))) {

                if (!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX)

                    c->next_root_atom = start_pos + a.size;

                return 0;

            }

            left = a.size - avio_tell(pb) + start_pos;

            if (left > 0) /* skip garbage at atom end */

                avio_skip(pb, left);

            else if (left < 0) {

                av_log(c->fc, AV_LOG_WARNING,

                       ""overread end of atom '%.4s' by %""PRId64"" bytes\n"",

                       (char*)&a.type, -left);

                avio_seek(pb, left, SEEK_CUR);

            }

        }



        total_size += a.size;

    }



    if (total_size < atom.size && atom.size < 0x7ffff)

        avio_skip(pb, atom.size - total_size);



    return 0;

}
",815,"static int mov_read_default(MOVContext *c, AVIOContext *tc, MOVAtom atom)

{

    int64_t total_size = 0;

    MOVAtom a;

    int i;



    if (atom.size < 0)

        atom.size = INT64_MAX;

    while (total_size + 8 <= atom.size && !avio_feof(tc)) {

        int (*parse)(MOVContext*, AVIOContext*, MOVAtom) = NULL;

        a.size = atom.size;

        a.type=0;

        if (atom.size >= 8) {

            a.size = avio_rb32(tc);

            a.type = avio_rl32(tc);

            if (a.type == MKTAG('f','r','e','e') &&

                a.size >= 8 &&

                c->moov_retry) {

                uint8_t buf[8];

                uint32_t *type = (uint32_t *)buf + 1;

                avio_read(tc, buf, 8);

                avio_seek(tc, -8, SEEK_CUR);

                if (*type == MKTAG('m','v','h','d') ||

                    *type == MKTAG('c','m','o','v')) {

                    av_log(c->fc, AV_LOG_ERROR, ""Detected moov in a free atom.
"");

                    a.type = MKTAG('m','o','o','v');

                }

            }

            if (atom.type != MKTAG('r','o','o','t') &&

                atom.type != MKTAG('m','o','o','v'))

            {

                if (a.type == MKTAG('t','r','a','k') || a.type == MKTAG('m','d','a','t'))

                {

                    av_log(c->fc, AV_LOG_ERROR, ""Broken file, trak/mdat not at top-level
"");

                    avio_skip(tc, -8);

                    return 0;

                }

            }

            total_size += 8;

            if (a.size == 1) { /* 64 bit extended size */

                a.size = avio_rb64(tc) - 8;

                total_size += 8;

            }

        }

        av_dlog(c->fc, ""type: %08x '%.4s' parent:'%.4s' sz: %""PRId64"" %""PRId64"" %""PRId64""
"",

                a.type, (char*)&a.type, (char*)&atom.type, a.size, total_size, atom.size);

        if (a.size == 0) {

            a.size = atom.size - total_size + 8;

        }

        a.size -= 8;

        if (a.size < 0)

            break;

        a.size = FFMIN(a.size, atom.size - total_size);



        for (i = 0; mov_default_parse_table[i].type; i++)

            if (mov_default_parse_table[i].type == a.type) {

                parse = mov_default_parse_table[i].parse;

                break;

            }



        // container is user data

        if (!parse && (atom.type == MKTAG('u','d','t','a') ||

                       atom.type == MKTAG('i','l','s','t')))

            parse = mov_read_udta_string;



        if (!parse) { /* skip leaf atoms data */

            avio_skip(tc, a.size);

        } else {

            int64_t start_pos = avio_tell(tc);

            int64_t left;

            int err = parse(c, tc, a);

            if (err < 0)

                return err;

            if (c->found_moov && c->found_mdat &&

                ((!tc->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX) ||

                 start_pos + a.size == avio_size(tc))) {

                if (!tc->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX)

                    c->next_root_atom = start_pos + a.size;

                return 0;

            }

            left = a.size - avio_tell(tc) + start_pos;

            if (left > 0) /* skip garbage at atom end */

                avio_skip(tc, left);

            else if (left < 0) {

                av_log(c->fc, AV_LOG_WARNING,

                       ""overread end of atom '%.4s' by %""PRId64"" bytes
"",

                       (char*)&a.type, -left);

                avio_seek(tc, left, SEEK_CUR);

            }

        }



        total_size += a.size;

    }



    if (total_size < atom.size && atom.size < 0x7ffff)

        avio_skip(tc, atom.size - total_size);



    return 0;

}
",1,1,0.0,1,"c,pb,atom,a,i,parse,type,buf","c:0.021355003118515015,pb:0.0809718668460846,atom:-0.002699226140975952,a:0.009774237871170044,i:0.012738436460494995,parse:-0.01687079668045044,type:0.037674278020858765,buf:0.013413727283477783,",1.0,18.0,"pb:tc,",Greedy,166,0.1619199991226196
191,"static void dwt_encode97_int(DWTContext *s, int *t)

{

    int lev,

        w = s->linelen[s->ndeclevels-1][0];

    int *line = s->i_linebuf;

    line += 5;



    for (lev = s->ndeclevels-1; lev >= 0; lev--){

        int lh = s->linelen[lev][0],

            lv = s->linelen[lev][1],

            mh = s->mod[lev][0],

            mv = s->mod[lev][1],

            lp;

        int *l;



        // VER_SD

        l = line + mv;

        for (lp = 0; lp < lh; lp++) {

            int i, j = 0;



            for (i = 0; i < lv; i++)

                l[i] = t[w*i + lp];



            sd_1d97_int(line, mv, mv + lv);



            // copy back and deinterleave

            for (i =   mv; i < lv; i+=2, j++)

                t[w*j + lp] = ((l[i] * I_LFTG_X) + (1 << 16)) >> 17;

            for (i = 1-mv; i < lv; i+=2, j++)

                t[w*j + lp] = ((l[i] * I_LFTG_K) + (1 << 16)) >> 17;

        }



        // HOR_SD

        l = line + mh;

        for (lp = 0; lp < lv; lp++){

            int i, j = 0;



            for (i = 0; i < lh; i++)

                l[i] = t[w*lp + i];



            sd_1d97_int(line, mh, mh + lh);



            // copy back and deinterleave

            for (i =   mh; i < lh; i+=2, j++)

                t[w*lp + j] = ((l[i] * I_LFTG_X) + (1 << 16)) >> 17;

            for (i = 1-mh; i < lh; i+=2, j++)

                t[w*lp + j] = ((l[i] * I_LFTG_K) + (1 << 16)) >> 17;

        }



    }

}
",435,"static void dwt_encode97_int(DWTContext *s, int *t)

{

    int lev,

        w = s->linelen[s->ndeclevels-1][0];

    int *line = s->i_linebuf;

    line += 5;



    for (lev = s->ndeclevels-1; lev >= 0; lev--){

        int lh = s->linelen[lev][0],

            lv = s->linelen[lev][1],

            mh = s->mod[lev][0],

            mv = s->mod[lev][1],

            hp;

        int *l;



        // VER_SD

        l = line + mv;

        for (hp = 0; hp < lh; hp++) {

            int i, j = 0;



            for (i = 0; i < lv; i++)

                l[i] = t[w*i + hp];



            sd_1d97_int(line, mv, mv + lv);



            // copy back and deinterleave

            for (i =   mv; i < lv; i+=2, j++)

                t[w*j + hp] = ((l[i] * I_LFTG_X) + (1 << 16)) >> 17;

            for (i = 1-mv; i < lv; i+=2, j++)

                t[w*j + hp] = ((l[i] * I_LFTG_K) + (1 << 16)) >> 17;

        }



        // HOR_SD

        l = line + mh;

        for (hp = 0; hp < lv; hp++){

            int i, j = 0;



            for (i = 0; i < lh; i++)

                l[i] = t[w*hp + i];



            sd_1d97_int(line, mh, mh + lh);



            // copy back and deinterleave

            for (i =   mh; i < lh; i+=2, j++)

                t[w*hp + j] = ((l[i] * I_LFTG_X) + (1 << 16)) >> 17;

            for (i = 1-mh; i < lh; i+=2, j++)

                t[w*hp + j] = ((l[i] * I_LFTG_K) + (1 << 16)) >> 17;

        }



    }

}
",1,1,0.0,1,"s,t,lev,line,lp,l,i,j","s:-0.0019064396619796753,t:0.051550328731536865,lev:0.02642248570919037,line:0.1318584829568863,lp:0.23553454875946045,l:0.13451097905635834,i:0.05752435326576233,j:0.037678107619285583,",1.0,13.0,"lp:hp,",Greedy,165,0.1519666075706482
193,"void error_propagate(Error **dst_errp, Error *local_err)

{

    if (local_err && dst_errp == &error_abort) {

        error_report_err(local_err);

        abort();

    } else if (dst_errp && !*dst_errp) {

        *dst_errp = local_err;

    } else if (local_err) {

        error_free(local_err);

    }

}
",62,"void error_propagate(Error **dst_errorl, Error *remote_type)

{

    if (loremote_type& dst_errorl == &error_abort) {

        error_report_err(remote_type);

        abort();

    } else if (dst_errorl && !*dst_errorl) {

        *dst_errorl = remote_type;

    } else if (remote_type) {

        error_free(remote_type);

    }

}
",1,1,0.0,1,"dst_errp,local_err",,0.0,0.0,"dst_errp:dst_errorl,local_err:remote_type,",GA,140,0.1466582695643107
194,"gen_msub32_q(TCGv ret, TCGv arg1, TCGv arg2, TCGv arg3, uint32_t n,

             uint32_t up_shift, CPUTriCoreState *env)

{

    TCGv temp = tcg_temp_new();

    TCGv temp2 = tcg_temp_new();

    TCGv temp3 = tcg_temp_new();

    TCGv_i64 t1 = tcg_temp_new_i64();

    TCGv_i64 t2 = tcg_temp_new_i64();

    TCGv_i64 t3 = tcg_temp_new_i64();

    TCGv_i64 t4 = tcg_temp_new_i64();



    tcg_gen_ext_i32_i64(t2, arg2);

    tcg_gen_ext_i32_i64(t3, arg3);



    tcg_gen_mul_i64(t2, t2, t3);



    tcg_gen_ext_i32_i64(t1, arg1);

    /* if we shift part of the fraction out, we need to round up */

    tcg_gen_andi_i64(t4, t2, (1ll << (up_shift - n)) - 1);

    tcg_gen_setcondi_i64(TCG_COND_NE, t4, t4, 0);

    tcg_gen_sari_i64(t2, t2, up_shift - n);

    tcg_gen_add_i64(t2, t2, t4);



    tcg_gen_sub_i64(t3, t1, t2);

    tcg_gen_trunc_i64_i32(temp3, t3);

    /* calc v bit */

    tcg_gen_setcondi_i64(TCG_COND_GT, t1, t3, 0x7fffffffLL);

    tcg_gen_setcondi_i64(TCG_COND_LT, t2, t3, -0x80000000LL);

    tcg_gen_or_i64(t1, t1, t2);

    tcg_gen_trunc_i64_i32(cpu_PSW_V, t1);

    tcg_gen_shli_tl(cpu_PSW_V, cpu_PSW_V, 31);

    /* We produce an overflow on the host if the mul before was

       (0x80000000 * 0x80000000) << 1). If this is the

       case, we negate the ovf. */

    if (n == 1) {

        tcg_gen_setcondi_tl(TCG_COND_EQ, temp, arg2, 0x80000000);

        tcg_gen_setcond_tl(TCG_COND_EQ, temp2, arg2, arg3);

        tcg_gen_and_tl(temp, temp, temp2);

        tcg_gen_shli_tl(temp, temp, 31);

        /* negate v bit, if special condition */

        tcg_gen_xor_tl(cpu_PSW_V, cpu_PSW_V, temp);

    }

    /* Calc SV bit */

    tcg_gen_or_tl(cpu_PSW_SV, cpu_PSW_SV, cpu_PSW_V);

    /* Calc AV/SAV bits */

    tcg_gen_add_tl(cpu_PSW_AV, temp3, temp3);

    tcg_gen_xor_tl(cpu_PSW_AV, temp3, cpu_PSW_AV);

    /* calc SAV */

    tcg_gen_or_tl(cpu_PSW_SAV, cpu_PSW_SAV, cpu_PSW_AV);

    /* write back result */

    tcg_gen_mov_tl(ret, temp3);



    tcg_temp_free(temp);

    tcg_temp_free(temp2);

    tcg_temp_free(temp3);

    tcg_temp_free_i64(t1);

    tcg_temp_free_i64(t2);

    tcg_temp_free_i64(t3);

    tcg_temp_free_i64(t4);

}
",355,"gen_msub32_q(TCGv reg, TCGv arg1, TCGv arg2, TCGv arg3, uint8_f n,

             uint8_f up_shift, CPUTriCoreState *env)

{

    TCGv temp = tcg_temp_new();

    TCGv temp2 = tcg_temp_new();

    TCGv temp3 = tcg_temp_new();

    TCGv_i64 t1 = tcg_temp_new_i64();

    TCGv_i64 t2 = tcg_temp_new_i64();

    TCGv_i64 t3 = tcg_temp_new_i64();

    TCGv_i64 t4 = tcg_temp_new_i64();



    tcg_gen_ext_i32_i64(t2, arg2);

    tcg_gen_ext_i32_i64(t3, arg3);



    tcg_gen_mul_i64(t2, t2, t3);



    tcg_gen_ext_i32_i64(t1, arg1);

    /* if we shift part of the fraction out, we need to round up */

    tcg_gen_andi_i64(t4, t2, (1ll << (up_shift - n)) - 1);

    tcg_gen_setcondi_i64(TCG_COND_NE, t4, t4, 0);

    tcg_gen_sari_i64(t2, t2, up_shift - n);

    tcg_gen_add_i64(t2, t2, t4);



    tcg_gen_sub_i64(t3, t1, t2);

    tcg_gen_trunc_i64_i32(temp3, t3);

    /* calc v bit */

    tcg_gen_setcondi_i64(TCG_COND_GT, t1, t3, 0x7fffffffLL);

    tcg_gen_setcondi_i64(TCG_COND_LT, t2, t3, -0x80000000LL);

    tcg_gen_or_i64(t1, t1, t2);

    tcg_gen_trunc_i64_i32(cpu_PSW_V, t1);

    tcg_gen_shli_tl(cpu_PSW_V, cpu_PSW_V, 31);

    /* We produce an overflow on the host if the mul before was

       (0x80000000 * 0x80000000) << 1). If this is the

       case, we negate the ovf. */

    if (n == 1) {

        tcg_gen_setcondi_tl(TCG_COND_EQ, temp, arg2, 0x80000000);

        tcg_gen_setcond_tl(TCG_COND_EQ, temp2, arg2, arg3);

        tcg_gen_and_tl(temp, temp, temp2);

        tcg_gen_shli_tl(temp, temp, 31);

        /* negate v bit, if special condition */

        tcg_gen_xor_tl(cpu_PSW_V, cpu_PSW_V, temp);

    }

    /* Calc SV bit */

    tcg_gen_or_tl(cpu_PSW_SV, cpu_PSW_SV, cpu_PSW_V);

    /* Calc AV/SAV bits */

    tcg_gen_add_tl(cpu_PSW_AV, temp3, temp3);

    tcg_gen_xor_tl(cpu_PSW_AV, temp3, cpu_PSW_AV);

    /* calc SAV */

    tcg_gen_or_tl(cpu_PSW_SAV, cpu_PSW_SAV, cpu_PSW_AV);

    /* write back result */

    tcg_gen_mov_tl(reg, temp3);



    tcg_temp_free(temp);

    tcg_temp_free(temp2);

    tcg_temp_free(temp3);

    tcg_temp_free_i64(t1);

    tcg_temp_free_i64(t2);

    tcg_temp_free_i64(t3);

    tcg_temp_free_i64(t4);

}
",1,1,0.0,1,"ret,TCGv,uint32_t","ret:-0.04445943236351013,TCGv:-0.21423088014125824,uint32_t:-0.030321359634399414,",2.0,4.0,"uint32_t:uint8_f,ret:reg,",Greedy,51,0.0598192731539408
219,"static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)

{

    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;

    uint8_t bitmap;



    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -errno;

    }



    bitmap |= (1 << (bitnum % 8));



    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=

	    sizeof(bitmap)) {

       return -errno;

    }

    return 0;

}
",105,"static inline int cow_set_bit(BlockDriverState *bs, int64_t blockum)

{

    uint64_t offset = sizeof(struct cow_header_v2) + blockum / 8;

    uint8_t nullmask;



    if (bdrv_pread(bs->file, offset, &nullmask, sizeof(nullmask)) !=

	    sizeof(nullmask)) {

       return -errno;

    }



    nullmask |= (1 << (blockum % 8));



    if (bdrv_pwrite(bs->file, offset, &nullmask, sizeof(nullmask)) !=

	    sizeof(nullmask)) {

       return -errno;

    }

    return 0;

}
",1,1,0.0,1,"bs,bitnum,bitmap","bs:-0.03224146366119385,bitnum:0.045895397663116455,bitmap:0.10630065202713013,",2.0,11.0,"bitmap:nullmask,bitnum:blockum,",Greedy,123,0.0912328799565633
232,"static int roq_read_packet(AVFormatContext *s,

                           AVPacket *pkt)

{

    RoqDemuxContext *roq = s->priv_data;

    AVIOContext *pb = s->pb;

    int ret = 0;

    unsigned int chunk_size;

    unsigned int chunk_type;

    unsigned int codebook_size;

    unsigned char preamble[RoQ_CHUNK_PREAMBLE_SIZE];

    int packet_read = 0;

    int64_t codebook_offset;



    while (!packet_read) {



        if (avio_feof(s->pb))

            return AVERROR(EIO);



        /* get the next chunk preamble */

        if ((ret = avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE)) !=

            RoQ_CHUNK_PREAMBLE_SIZE)

            return AVERROR(EIO);



        chunk_type = AV_RL16(&preamble[0]);

        chunk_size = AV_RL32(&preamble[2]);

        if(chunk_size > INT_MAX)

            return AVERROR_INVALIDDATA;



        chunk_size = ffio_limit(pb, chunk_size);



        switch (chunk_type) {



        case RoQ_INFO:

            if (roq->video_stream_index == -1) {

                AVStream *st = avformat_new_stream(s, NULL);

                if (!st)

                    return AVERROR(ENOMEM);

                avpriv_set_pts_info(st, 63, 1, roq->frame_rate);

                roq->video_stream_index = st->index;

                st->codecpar->codec_type   = AVMEDIA_TYPE_VIDEO;

                st->codecpar->codec_id     = AV_CODEC_ID_ROQ;

                st->codecpar->codec_tag    = 0;  /* no fourcc */



                if (avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE) != RoQ_CHUNK_PREAMBLE_SIZE)

                    return AVERROR(EIO);

                st->codecpar->width  = roq->width  = AV_RL16(preamble);

                st->codecpar->height = roq->height = AV_RL16(preamble + 2);

                break;

            }

            /* don't care about this chunk anymore */

            avio_skip(pb, RoQ_CHUNK_PREAMBLE_SIZE);

            break;



        case RoQ_QUAD_CODEBOOK:

            if (roq->video_stream_index < 0)

                return AVERROR_INVALIDDATA;

            /* packet needs to contain both this codebook and next VQ chunk */

            codebook_offset = avio_tell(pb) - RoQ_CHUNK_PREAMBLE_SIZE;

            codebook_size = chunk_size;

            avio_skip(pb, codebook_size);

            if (avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE) !=

                RoQ_CHUNK_PREAMBLE_SIZE)

                return AVERROR(EIO);

            chunk_size = AV_RL32(&preamble[2]) + RoQ_CHUNK_PREAMBLE_SIZE * 2 +

                codebook_size;



            if (chunk_size > INT_MAX)

                return AVERROR_INVALIDDATA;



            /* rewind */

            avio_seek(pb, codebook_offset, SEEK_SET);



            /* load up the packet */

            ret= av_get_packet(pb, pkt, chunk_size);

            if (ret != chunk_size)

                return AVERROR(EIO);

            pkt->stream_index = roq->video_stream_index;

            pkt->pts = roq->video_pts++;



            packet_read = 1;

            break;



        case RoQ_SOUND_MONO:

        case RoQ_SOUND_STEREO:

            if (roq->audio_stream_index == -1) {

                AVStream *st = avformat_new_stream(s, NULL);

                if (!st)

                    return AVERROR(ENOMEM);

                avpriv_set_pts_info(st, 32, 1, RoQ_AUDIO_SAMPLE_RATE);

                roq->audio_stream_index = st->index;

                st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;

                st->codecpar->codec_id = AV_CODEC_ID_ROQ_DPCM;

                st->codecpar->codec_tag = 0;  /* no tag */

                if (chunk_type == RoQ_SOUND_STEREO) {

                    st->codecpar->channels       = 2;

                    st->codecpar->channel_layout = AV_CH_LAYOUT_STEREO;

                } else {

                    st->codecpar->channels       = 1;

                    st->codecpar->channel_layout = AV_CH_LAYOUT_MONO;

                }

                roq->audio_channels    = st->codecpar->channels;

                st->codecpar->sample_rate = RoQ_AUDIO_SAMPLE_RATE;

                st->codecpar->bits_per_coded_sample = 16;

                st->codecpar->bit_rate = st->codecpar->channels * st->codecpar->sample_rate *

                    st->codecpar->bits_per_coded_sample;

                st->codecpar->block_align = st->codecpar->channels * st->codecpar->bits_per_coded_sample;

            }

        case RoQ_QUAD_VQ:

            if (chunk_type == RoQ_QUAD_VQ) {

                if (roq->video_stream_index < 0)

                    return AVERROR_INVALIDDATA;

            }



            /* load up the packet */

            if (av_new_packet(pkt, chunk_size + RoQ_CHUNK_PREAMBLE_SIZE))

                return AVERROR(EIO);

            /* copy over preamble */

            memcpy(pkt->data, preamble, RoQ_CHUNK_PREAMBLE_SIZE);



            if (chunk_type == RoQ_QUAD_VQ) {

                pkt->stream_index = roq->video_stream_index;

                pkt->pts = roq->video_pts++;

            } else {

                pkt->stream_index = roq->audio_stream_index;

                pkt->pts = roq->audio_frame_count;

                roq->audio_frame_count += (chunk_size / roq->audio_channels);

            }



            pkt->pos= avio_tell(pb);

            ret = avio_read(pb, pkt->data + RoQ_CHUNK_PREAMBLE_SIZE,

                chunk_size);

            if (ret != chunk_size)

                ret = AVERROR(EIO);



            packet_read = 1;

            break;



        default:

            av_log(s, AV_LOG_ERROR, ""  unknown RoQ chunk (%04X)\n"", chunk_type);

            return AVERROR_INVALIDDATA;

        }

    }



    return ret;

}
",790,"static int roq_read_packet(AVFormatContext *sys,

                           AVPacket * pct)

{

    RoqDemuxContext *rocroqa sys->priv_data;

    AVIOContext *pbdp sys->dp;

    int ret = 0;

    unsigned int chunklexsum;

    unsigned int chunk6family;

    unsigned int codebox_size;

    unsigned char proml[RoQ_CHUNK_PREAMBLE_SIZE];

    int packet_read = 0;

    int64_t codeboard__len;



    while (!packet_read) {



        if (avio_feof(sys->dp))

            return AVERROR(EIO);



        /* get the next chunk preamble */

        if ((ret = avio_read(dp, proml, RoQ_CHUNK_PREAMBLE_SIZE)) !=

            RoQ_CHUNK_PREAMBLE_SIZE)

            return AVERROR(EIO);



        chunk6family = AV_RL16(&proml[0]);

        chunklexsum = AV_RL32(&proml[2]);

        if(chunklexsum > INT_MAX)

            return AVERROR_INVALIDDATA;



        chunklexsum = ffio_limit(dp, chunklexsum);



        switch (chunk6family) {



        case RoQ_INFO:

            if (croqa->video_stream_index == -1) {

                AVStream *stet avformat_new_stream(sys, NULL);

                if (!et)

                    return AVERROR(ENOMEM);

                avpriv_set_pts_info(stet63, 1, croqa->frame_rate);

                croqa->video_stream_index = et->index;

                et->codecpar->codec_type   = AVMEDIA_TYPE_VIDEO;

                et->codecpar->codec_id     = AV_CODEC_ID_ROQ;

                et->codecpar->codec_tag    = 0;  /* no fourcc */



                if (avio_read(dp, proml, RoQ_CHUNK_PREAMBLE_SIZE) != RoQ_CHUNK_PREAMBLE_SIZE)

                    return AVERROR(EIO);

               ett->codecpar->width  = croqa->width  = AV_RL16(proml);

               ett->codecpar->height = croqa->height = AV_RL16(proml + 2);

                break;

            }

            /* don't care about this chunk anymore */

            avio_skip(dp, RoQ_CHUNK_PREAMBLE_SIZE);

            break;



        case RoQ_QUAD_CODEBOOK:

            if (croqa->video_stream_index < 0)

                return AVERROR_INVALIDDATA;

            /* packet needs to contain both this codebook and next VQ chunk */

            codeboard__len = avio_tell(dp) - RoQ_CHUNK_PREAMBLE_SIZE;

            ccodebox_size= chunklexsum;

            avio_skip(dp, codebox_size);

            if (avio_read(dp, proml, RoQ_CHUNK_PREAMBLE_SIZE) !=

                RoQ_CHUNK_PREAMBLE_SIZE)

                return AVERROR(EIO);

            chunklexsum = AV_RL32(&proml[2]) + RoQ_CHUNK_PREAMBLE_SIZE * 2 +

                codebox_size;



            if (chunklexsum > INT_MAX)

                return AVERROR_INVALIDDATA;



            /* rewind */

            avio_seek(dp, codeboard__len, SEEK_SET);



            /* load up the packet */

            ret= av_get_packet(pdp  pct, chunklexsum);

            if (ret != chunklexsum)

                return AVERROR(EIO);

             pct->stream_index = croqa->video_stream_index;

             pct->pts = croqa->video_pts++;



            packet_read = 1;

            break;



        case RoQ_SOUND_MONO:

        case RoQ_SOUND_STEREO:

            if (croqa->audio_stream_index == -1) {

                AVStream *stet avformat_new_stream(sys, NULL);

                if (!et)

                    return AVERROR(ENOMEM);

                avpriv_set_pts_info(et, 32, 1, RoQ_AUDIO_SAMPLE_RATE);

                croqa->audio_stream_index = et->index;

                et->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;

                et->codecpar->codec_id = AV_CODEC_ID_ROQ_DPCM;

                et->codecpar->codec_tag = 0;  /* no tag */

                if (chunk6family == RoQ_SOUND_STEREO) {

                    et->codecpar->channels       = 2;

                    et->codecpar->channel_layout = AV_CH_LAYOUT_STEREO;

                } else {

                    et->codecpar->channels       = 1;

                    et->codecpar->channel_layout = AV_CH_LAYOUT_MONO;

                }

                croqa->audio_channels    = et->codecpar->channels;

                et->codecpar->sample_rate = RoQ_AUDIO_SAMPLE_RATE;

                et->codecpar->bits_per_coded_sample = 16;

                et->codecpar->bit_rate = et->codecpar->channels * et->codecpar->sample_rate *

                    et->codecpar->bits_per_coded_sample;

                et->codecpar->block_align = et->codecpar->channels * et->codecpar->bits_per_coded_sample;

            }

        case RoQ_QUAD_VQ:

            if (chunk6family == RoQ_QUAD_VQ) {

                if (croqa->video_stream_index < 0)

                    return AVERROR_INVALIDDATA;

            }



            /* load up the packet */

            if (av_new_packet( pct, chunklexsum + RoQ_CHUNK_PREAMBLE_SIZE))

                return AVERROR(EIO);

            /* copy over preamble */

            memcpy( pct->data, proml, RoQ_CHUNK_PREAMBLE_SIZE);



            if (chunk6family == RoQ_QUAD_VQ) {

                 pct->stream_index = croqa->video_stream_index;

                 pct->pts = croqa->video_pts++;

            } else {

                 pct->stream_index = croqa->audio_stream_index;

                 pct->pts = croqa->audio_frame_count;

                croqa->audio_frame_count += (chchunklexsum croqa->audio_channels);

            }



             pct->pos= avio_tell(dp);

            ret = avio_read(pdp  pct->data + RoQ_CHUNK_PREAMBLE_SIZE,

                chunklexsum);

            if (ret != chunklexsum)

                ret = AVERROR(EIO);



            packet_read = 1;

            break;



        default:

            av_log(sys, AV_LOG_ERROR, ""  unknown RoQ chunk (%04X)
"", chunk6family);

            return AVERROR_INVALIDDATA;

        }

    }



    return ret;

}
",1,1,0.0,1,"s,pkt,roq,pb,chunk_size,chunk_type,codebook_size,preamble,codebook_offset,st",,0.0,0.0,"s:sys,pkt: pct,roq:croqa,pb:dp,chunk_size:chunklexsum,chunk_type:chunk6family,codebook_size:codebox_size,preamble:proml,codebook_offset:codeboard__len,st:et,",GA,857,0.896454640229543
233,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,

				  int16_t *filter, int16_t *filterPos, int filterSize)

{

#ifdef HAVE_MMX

	assert(filterSize % 4 == 0 && filterSize>0);

	if(filterSize==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		filter-= counter*2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1\n\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(filterSize==8)

	{

		long counter= -2*dstW;

		filter-= counter*4;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			""push %%""REG_BP""		\n\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""movzwl (%2, %%""REG_BP""), %%eax	\n\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx\n\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3\n\t""

			""movd (%3, %%""REG_a""), %%mm0	\n\t""

			""movd (%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1\n\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5\n\t""

			""movd 4(%3, %%""REG_a""), %%mm4	\n\t""

			""movd 4(%3, %%""REG_b""), %%mm2	\n\t""

			""punpcklbw %%mm7, %%mm4		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm4		\n\t""

			""pmaddwd %%mm2, %%mm5		\n\t""

			""paddd %%mm4, %%mm0		\n\t""

			""paddd %%mm5, %%mm3		\n\t""

						

			""psrad $8, %%mm0		\n\t""

			""psrad $8, %%mm3		\n\t""

			""packssdw %%mm3, %%mm0		\n\t""

			""pmaddwd %%mm6, %%mm0		\n\t""

			""packssdw %%mm0, %%mm0		\n\t""

			""movd %%mm0, (%4, %%""REG_BP"")	\n\t""

			""add $4, %%""REG_BP""		\n\t""

			"" jnc 1b			\n\t""



			""pop %%""REG_BP""			\n\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = src+filterSize;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		filterPos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		\n\t""

			""movq ""MANGLE(w02)"", %%mm6	\n\t""

			"".balign 16			\n\t""

			""1:				\n\t""

			""mov %2, %%""REG_c""		\n\t""

			""movzwl (%%""REG_c"", %0), %%eax	\n\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	\n\t""

			""mov %5, %%""REG_c""		\n\t""

			""pxor %%mm4, %%mm4		\n\t""

			""pxor %%mm5, %%mm5		\n\t""

			""2:				\n\t""

			""movq (%1), %%mm1		\n\t""

			""movq (%1, %6), %%mm3		\n\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0\n\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2\n\t""

			""punpcklbw %%mm7, %%mm0		\n\t""

			""punpcklbw %%mm7, %%mm2		\n\t""

			""pmaddwd %%mm1, %%mm0		\n\t""

			""pmaddwd %%mm2, %%mm3		\n\t""

			""paddd %%mm3, %%mm5		\n\t""

			""paddd %%mm0, %%mm4		\n\t""

			""add $8, %1			\n\t""

			""add $4, %%""REG_c""		\n\t""

			""cmp %4, %%""REG_c""		\n\t""

			"" jb 2b				\n\t""

			""add %6, %1			\n\t""

			""psrad $8, %%mm4		\n\t""

			""psrad $8, %%mm5		\n\t""

			""packssdw %%mm5, %%mm4		\n\t""

			""pmaddwd %%mm6, %%mm4		\n\t""

			""packssdw %%mm4, %%mm4		\n\t""

			""mov %3, %%""REG_a""		\n\t""

			""movd %%mm4, (%%""REG_a"", %0)	\n\t""

			""add $4, %0			\n\t""

			"" jnc 1b			\n\t""



			: ""+r"" (counter), ""+r"" (filter)

			: ""m"" (filterPos), ""m"" (dst), ""m""(offset),

			  ""m"" (src), ""r"" ((long)filterSize*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= filterPos[i];

		int val=0;

//		printf(""filterPos: %d\n"", filterPos[i]);

		for(j=0; j<filterSize; j++)

		{

//			printf(""filter: %d, src: %d\n"", filter[i], src[srcPos + j]);

			val += ((int)src[srcPos + j])*filter[filterSize*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}
",821,"static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *url, int destW, int ixDir,

				  int16_t *name, int16_t *featurePos, int controlCode)

{

#ifdef HAVE_MMX

	assert(controlCode % 4 == 0 && controlCode>0);

	if(controlCode==4) // allways true for upscaling, sometimes for down too

	{

		long counter= -2*dstW;

		name-= counter*2;

		featurePos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		
\t""

			""movq ""MANGLE(w02)"", %%mm6	
\t""

			""push %%""REG_BP""		
\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	
\t""

			"".balign 16			
\t""

			""1:				
\t""

			""movzwl (%2, %%""REG_BP""), %%eax	
\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx
\t""

			""movq (%1, %%""REG_BP"", 4), %%mm1
\t""

			""movq 8(%1, %%""REG_BP"", 4), %%mm3
\t""

			""movd (%3, %%""REG_a""), %%mm0	
\t""

			""movd (%3, %%""REG_b""), %%mm2	
\t""

			""punpcklbw %%mm7, %%mm0		
\t""

			""punpcklbw %%mm7, %%mm2		
\t""

			""pmaddwd %%mm1, %%mm0		
\t""

			""pmaddwd %%mm2, %%mm3		
\t""

			""psrad $8, %%mm0		
\t""

			""psrad $8, %%mm3		
\t""

			""packssdw %%mm3, %%mm0		
\t""

			""pmaddwd %%mm6, %%mm0		
\t""

			""packssdw %%mm0, %%mm0		
\t""

			""movd %%mm0, (%4, %%""REG_BP"")	
\t""

			""add $4, %%""REG_BP""		
\t""

			"" jnc 1b			
\t""



			""pop %%""REG_BP""			
\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else if(controlCode==8)

	{

		long counter= -2*dstW;

		name-= counter*4;

		featurePos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		
\t""

			""movq ""MANGLE(w02)"", %%mm6	
\t""

			""push %%""REG_BP""		
\t"" // we use 7 regs here ...

			""mov %%""REG_a"", %%""REG_BP""	
\t""

			"".balign 16			
\t""

			""1:				
\t""

			""movzwl (%2, %%""REG_BP""), %%eax	
\t""

			""movzwl 2(%2, %%""REG_BP""), %%ebx
\t""

			""movq (%1, %%""REG_BP"", 8), %%mm1
\t""

			""movq 16(%1, %%""REG_BP"", 8), %%mm3
\t""

			""movd (%3, %%""REG_a""), %%mm0	
\t""

			""movd (%3, %%""REG_b""), %%mm2	
\t""

			""punpcklbw %%mm7, %%mm0		
\t""

			""punpcklbw %%mm7, %%mm2		
\t""

			""pmaddwd %%mm1, %%mm0		
\t""

			""pmaddwd %%mm2, %%mm3		
\t""



			""movq 8(%1, %%""REG_BP"", 8), %%mm1
\t""

			""movq 24(%1, %%""REG_BP"", 8), %%mm5
\t""

			""movd 4(%3, %%""REG_a""), %%mm4	
\t""

			""movd 4(%3, %%""REG_b""), %%mm2	
\t""

			""punpcklbw %%mm7, %%mm4		
\t""

			""punpcklbw %%mm7, %%mm2		
\t""

			""pmaddwd %%mm1, %%mm4		
\t""

			""pmaddwd %%mm2, %%mm5		
\t""

			""paddd %%mm4, %%mm0		
\t""

			""paddd %%mm5, %%mm3		
\t""

						

			""psrad $8, %%mm0		
\t""

			""psrad $8, %%mm3		
\t""

			""packssdw %%mm3, %%mm0		
\t""

			""pmaddwd %%mm6, %%mm0		
\t""

			""packssdw %%mm0, %%mm0		
\t""

			""movd %%mm0, (%4, %%""REG_BP"")	
\t""

			""add $4, %%""REG_BP""		
\t""

			"" jnc 1b			
\t""



			""pop %%""REG_BP""			
\t""

			: ""+a"" (counter)

			: ""c"" (filter), ""d"" (filterPos), ""S"" (src), ""D"" (dst)

			: ""%""REG_b

		);

	}

	else

	{

		uint8_t *offset = url+controlCode;

		long counter= -2*dstW;

//		filter-= counter*filterSize/2;

		featurePos-= counter/2;

		dst-= counter/2;

		asm volatile(

			""pxor %%mm7, %%mm7		
\t""

			""movq ""MANGLE(w02)"", %%mm6	
\t""

			"".balign 16			
\t""

			""1:				
\t""

			""mov %2, %%""REG_c""		
\t""

			""movzwl (%%""REG_c"", %0), %%eax	
\t""

			""movzwl 2(%%""REG_c"", %0), %%ebx	
\t""

			""mov %5, %%""REG_c""		
\t""

			""pxor %%mm4, %%mm4		
\t""

			""pxor %%mm5, %%mm5		
\t""

			""2:				
\t""

			""movq (%1), %%mm1		
\t""

			""movq (%1, %6), %%mm3		
\t""

			""movd (%%""REG_c"", %%""REG_a""), %%mm0
\t""

			""movd (%%""REG_c"", %%""REG_b""), %%mm2
\t""

			""punpcklbw %%mm7, %%mm0		
\t""

			""punpcklbw %%mm7, %%mm2		
\t""

			""pmaddwd %%mm1, %%mm0		
\t""

			""pmaddwd %%mm2, %%mm3		
\t""

			""paddd %%mm3, %%mm5		
\t""

			""paddd %%mm0, %%mm4		
\t""

			""add $8, %1			
\t""

			""add $4, %%""REG_c""		
\t""

			""cmp %4, %%""REG_c""		
\t""

			"" jb 2b				
\t""

			""add %6, %1			
\t""

			""psrad $8, %%mm4		
\t""

			""psrad $8, %%mm5		
\t""

			""packssdw %%mm5, %%mm4		
\t""

			""pmaddwd %%mm6, %%mm4		
\t""

			""packssdw %%mm4, %%mm4		
\t""

			""mov %3, %%""REG_a""		
\t""

			""movd %%mm4, (%%""REG_a"", %0)	
\t""

			""add $4, %0			
\t""

			"" jnc 1b			
\t""



			: ""+r"" (counter), ""+r"" (name)

			: ""m"" (featurePos), ""m"" (dst), ""m""(offset),

			  ""m"" (url), ""r"" ((long)controlCode*2)

			: ""%""REG_b, ""%""REG_a, ""%""REG_c

		);

	}

#else

#ifdef HAVE_ALTIVEC

	hScale_altivec_real(dst, dstW, url, destW, ixDir, name, featurePos, controlCode);

#else

	int i;

	for(i=0; i<dstW; i++)

	{

		int j;

		int srcPos= featurePos[i];

		int val=0;

//		printf(""filterPos: %d
"", filterPos[i]);

		for(j=0; j<controlCode; j++)

		{

//			printf(""filter: %d, src: %d
"", filter[i], src[srcPos + j]);

			val += ((int)url[srcPos + j])*name[controlCode*i + j];

		}

//		filter += hFilterSize;

		dst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...

//		dst[i] = val>>7;

	}

#endif

#endif

}
",1,1,0.0,1,"dst,dstW,src,srcW,xInc,filter,filterPos,filterSize","dst:-0.07624757289886475,dstW:-0.04986387491226196,src:-0.01314091682434082,srcW:-0.006113231182098389,xInc:0.058824777603149414,filter:-0.029656052589416504,filterPos:0.003567516803741455,filterSize:0.08217358589172363,",6.0,32.0,"filterSize:controlCode,xInc:ixDir,filterPos:featurePos,srcW:destW,src:url,filter:name,",Greedy,229,0.2569581190745035
249,"void stream_start(BlockDriverState *bs, BlockDriverState *base,

                  const char *base_id, int64_t speed,

                  BlockDriverCompletionFunc *cb,

                  void *opaque, Error **errp)

{

    StreamBlockJob *s;

    Coroutine *co;



    s = block_job_create(&stream_job_type, bs, speed, cb, opaque, errp);

    if (!s) {

        return;

    }



    s->base = base;

    if (base_id) {

        pstrcpy(s->backing_file_id, sizeof(s->backing_file_id), base_id);

    }



    co = qemu_coroutine_create(stream_run);

    trace_stream_start(bs, base, s, co, opaque);

    qemu_coroutine_enter(co, s);

}
",124,"void stream_start(BlockDriverState *bs, BlockDriverState *base,

                  const char *file_path, int64_t speed,

                  BlockDriverCompletionFunc *cb,

                  void *opaque, Error **errp)

{

    StreamBlockJob *s;

    Coroutine *co;



    s = block_job_create(&stream_job_type, bs, speed, cb, opaque, errp);

    if (!s) {

        return;

    }



    s->base = base;

    if (file_path) {

        pstrcpy(s->backing_file_id, sizeof(s->backing_file_id), file_path);

    }



    co = qemu_coroutine_create(stream_run);

    trace_stream_start(bs, base, s, co, opaque);

    qemu_coroutine_enter(co, s);

}
",1,1,0.0,1,"bs,base,base_id,speed,cb,opaque,errp,s,co","bs:0.011018842458724976,base:-0.01366037130355835,base_id:0.06491726636886597,speed:-0.04087352752685547,cb:-0.0738266110420227,opaque:0.016460895538330078,errp:0.05490943789482117,s:0.01990416646003723,co:0.02171120047569275,",1.0,3.0,"base_id:file_path,",Greedy,60,0.062929348150889
257,"static av_cold int dnxhd_decode_close(AVCodecContext *avctx)

{

    DNXHDContext *ctx = avctx->priv_data;



    ff_free_vlc(&ctx->ac_vlc);

    ff_free_vlc(&ctx->dc_vlc);

    ff_free_vlc(&ctx->run_vlc);



    av_freep(&ctx->mb_scan_index);

    av_freep(&ctx->rows);



    return 0;

}
",62,"static av_cold int dnxhd_decode_close(AVCodecContext *afcb)

{

    DNXHDContext scix = afcb->priv_data;



    ff_free_vlc(&sci->ac_vlc);

    ff_free_vlc(&sci->dc_vlc);

    ff_free_vlc(&sci->run_vlc);



    av_freep(&sci->mb_scan_index);

    av_freep(&sci->rows);



    return 0;

}
",1,1,0.0,1,"avctx,ctx",,0.0,0.0,"avctx:afcb,ctx:sci,",GA,694,0.6602625330289205
262,"static const char *keyval_parse_one(QDict *qdict, const char *params,

                                    const char *implied_key,

                                    Error **errp)

{

    const char *key, *key_end, *s;

    size_t len;

    char key_in_cur[128];

    QDict *cur;

    int ret;

    QObject *next;

    QString *val;



    key = params;

    len = strcspn(params, ""=,"");

    if (implied_key && len && key[len] != '=') {

        /* Desugar implied key */

        key = implied_key;

        len = strlen(implied_key);

    }

    key_end = key + len;



    /*

     * Loop over key fragments: @s points to current fragment, it

     * applies to @cur.  @key_in_cur[] holds the previous fragment.

     */

    cur = qdict;

    s = key;

    for (;;) {

        ret = parse_qapi_name(s, false);

        len = ret < 0 ? 0 : ret;

        assert(s + len <= key_end);

        if (!len || (s + len < key_end && s[len] != '.')) {

            assert(key != implied_key);

            error_setg(errp, ""Invalid parameter '%.*s'"",

                       (int)(key_end - key), key);

            return NULL;

        }

        if (len >= sizeof(key_in_cur)) {

            assert(key != implied_key);

            error_setg(errp, ""Parameter%s '%.*s' is too long"",

                       s != key || s + len != key_end ? "" fragment"" : """",

                       (int)len, s);

            return NULL;

        }



        if (s != key) {

            next = keyval_parse_put(cur, key_in_cur, NULL,

                                    key, s - 1, errp);

            if (!next) {

                return NULL;

            }

            cur = qobject_to_qdict(next);

            assert(cur);

        }



        memcpy(key_in_cur, s, len);

        key_in_cur[len] = 0;

        s += len;



        if (*s != '.') {

            break;

        }

        s++;

    }



    if (key == implied_key) {

        assert(!*s);

        s = params;

    } else {

        if (*s != '=') {

            error_setg(errp, ""Expected '=' after parameter '%.*s'"",

                       (int)(s - key), key);

            return NULL;

        }

        s++;

    }



    val = qstring_new();

    for (;;) {

        if (!*s) {

            break;

        } else if (*s == ',') {

            s++;

            if (*s != ',') {

                break;

            }

        }

        qstring_append_chr(val, *s++);

    }



    if (!keyval_parse_put(cur, key_in_cur, val, key, key_end, errp)) {

        return NULL;

    }

    return s;

}
",481,"static const char *keyval_parse_one(QDict *qdict, const char *params,

                                    const char *implied_type,

                                    Error **errp)

{

    const char *key, *key_end, *s;

    size_t len;

    char key_in_cur[128];

    QDict *cur;

    int  lib;

    QObject *next;

    QString *val;



    key = params;

    len = strcspn(params, ""=,"");

    if (implied_type && len && key[len] != '=') {

        /* Desugar implied key */

        key = implied_type;

        len = strlen(implied_type);

    }

    key_end = key + len;



    /*

     * Loop over key fragments: @s points to current fragment, it

     * applies to @cur.  @key_in_cur[] holds the previous fragment.

     */

    cur = qdict;

    s = key;

    for (;;) {

         lib = parse_qapi_name(s, false);

        len =  lib < 0 ? 0 :  lib;

        assert(s + len <= key_end);

        if (!len || (s + len < key_end && s[len] != '.')) {

            assert(key != implied_type);

            error_setg(errp, ""Invalid parameter '%.*s'"",

                       (int)(key_end - key), key);

            return NULL;

        }

        if (len >= sizeof(key_in_cur)) {

            assert(key != implied_type);

            error_setg(errp, ""Parameter%s '%.*s' is too long"",

                       s != key || s + len != key_end ? "" fragment"" : """",

                       (int)len, s);

            return NULL;

        }



        if (s != key) {

            next = keyval_parse_put(cur, key_in_cur, NULL,

                                    key, s - 1, errp);

            if (!next) {

                return NULL;

            }

            cur = qobject_to_qdict(next);

            assert(cur);

        }



        memcpy(key_in_cur, s, len);

        key_in_cur[len] = 0;

        s += len;



        if (*s != '.') {

            break;

        }

        s++;

    }



    if (key == implied_type) {

        assert(!*s);

        s = params;

    } else {

        if (*s != '=') {

            error_setg(errp, ""Expected '=' after parameter '%.*s'"",

                       (int)(s - key), key);

            return NULL;

        }

        s++;

    }



    val = qstring_new();

    for (;;) {

        if (!*s) {

            break;

        } else if (*s == ',') {

            s++;

            if (*s != ',') {

                break;

            }

        }

        qstring_append_chr(val, *s++);

    }



    if (!keyval_parse_put(cur, key_in_cur, val, key, key_end, errp)) {

        return NULL;

    }

    return s;

}
",1,1,0.0,1,"qdict,params,implied_key,errp,key,key_end,s,len,key_in_cur,cur,ret,next,val","qdict:-0.02610158920288086,params:-0.011296331882476807,implied_key:0.007798492908477783,errp:-0.026153981685638428,key:-0.01154261827468872,key_end:-0.009417951107025146,s:-0.023447692394256592,len:-0.021349012851715088,key_in_cur:-0.014283537864685059,cur:-0.02484804391860962,ret:-0.004408597946166992,next:-0.0121651291847229,val:-0.016088664531707764,",2.0,11.0,"implied_key:implied_type,ret: lib,",Greedy,238,0.2222579042116801
269,"static void get_xbzrle_cache_stats(MigrationInfo *info)

{

    if (migrate_use_xbzrle()) {

        info->has_xbzrle_cache = true;

        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));

        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();

        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();

        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();

        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();

        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();

        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();

    }

}
",99,"static void get_xbzrle_cache_stats(MigrationInfo *help)

{

    if (migrate_use_xbzrle()) {

        help->has_xbzrle_cache = true;

        help->xbzrle_cache = g_malloc0(sizeof(*help->xbzrle_cache));

        help->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();

        help->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();

        help->xbzrle_cache->pages = xbzrle_mig_pages_transferred();

        help->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();

        help->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();

        help->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();

    }

}
",1,1,0.0,1,info,"info:0.04671907424926758,",1.0,10.0,"info:help,",Greedy,77,0.0775501132011413
270,"static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,

                                      int do_init,

                                      const char *cpu_model,

                                      uint32_t sysclk)

{

    PowerPCCPU *cpu;

    CPUPPCState *env;

    qemu_irq *irqs;



    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));

    if (cpu == NULL) {

        fprintf(stderr, ""Unable to initialize CPU!\n"");

        exit(1);

    }

    env = &cpu->env;



    ppc_booke_timers_init(cpu, sysclk, 0/* no flags */);



    ppc_dcr_init(env, NULL, NULL);



    /* interrupt controller */

    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);

    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];

    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];

    ppcuic_init(env, irqs, 0x0C0, 0, 1);

    return cpu;

}
",156,"static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,

                                      int do_init,

                                      const char *cpu_model,

                                      uint32_t sysclk)

{

    PowerPCCPU *cpu;

    CPUPPCState *config;

    qemu_irq *irqs;



    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));

    if (cpu == NULL) {

        fprintf(stderr, ""Unable to initialize CPU!
"");

        exit(1);

    }

    config = &cpu->config;



    ppc_booke_timers_init(cpu, sysclk, 0/* no flags */);



    ppc_dcr_init(config, NULL, NULL);



    /* interrupt controller */

    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);

    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)config->irq_inputs)[PPC40x_INPUT_INT];

    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)config->irq_inputs)[PPC40x_INPUT_CINT];

    ppcuic_init(config, irqs, 0x0C0, 0, 1);

    return cpu;

}
",1,1,0.0,1,"ram_size,do_init,cpu_model,sysclk,cpu,env,irqs","ram_size:-0.013085782527923584,do_init:-0.013832151889801025,cpu_model:0.0006556212902069092,sysclk:-0.0059626102447509766,cpu:-0.017701923847198486,env:0.008982062339782715,irqs:0.007129162549972534,",1.0,7.0,"env:config,",Greedy,104,0.1025799473126729
273,"static void lumRangeToJpeg16_c(int16_t *_dst, int width)

{

    int i;

    int32_t *dst = (int32_t *) _dst;

    for (i = 0; i < width; i++)

        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14;

}
",68,"static void lumRangeToJpeg16_c(int16_t *_sdsts, int width)

{

    int c;

    int32_t *dsndbl (int32_t *) _sdsts;

    for (c = 0; c < width; c++)

        ndbl[c] = (FFMIN(ndbl[c],30189<<4)*19077 - (39057361<<4))>>14;

}
",1,1,0.0,1,"_dst,i,dst",,0.0,0.0,"_dst:_sdsts,i:c,dst:ndbl,",GA,256,0.2564732313156128
275,"static void find_motion(DeshakeContext *deshake, uint8_t *src1, uint8_t *src2,

                        int width, int height, int stride, Transform *t)

{

    int x, y;

    IntMotionVector mv = {0, 0};

    int counts[128][128];

    int count_max_value = 0;

    int contrast;



    int pos;

    double *angles = av_malloc(sizeof(*angles) * width * height / (16 * deshake->blocksize));

    int center_x = 0, center_y = 0;

    double p_x, p_y;



    // Reset counts to zero

    for (x = 0; x < deshake->rx * 2 + 1; x++) {

        for (y = 0; y < deshake->ry * 2 + 1; y++) {

            counts[x][y] = 0;

        }

    }



    pos = 0;

    // Find motion for every block and store the motion vector in the counts

    for (y = deshake->ry; y < height - deshake->ry - (deshake->blocksize * 2); y += deshake->blocksize * 2) {

        // We use a width of 16 here to match the libavcodec sad functions

        for (x = deshake->rx; x < width - deshake->rx - 16; x += 16) {

            // If the contrast is too low, just skip this block as it probably

            // won't be very useful to us.

            contrast = block_contrast(src2, x, y, stride, deshake->blocksize);

            if (contrast > deshake->contrast) {

                //av_log(NULL, AV_LOG_ERROR, ""%d\n"", contrast);

                find_block_motion(deshake, src1, src2, x, y, stride, &mv);

                if (mv.x != -1 && mv.y != -1) {

                    counts[mv.x + deshake->rx][mv.y + deshake->ry] += 1;

                    if (x > deshake->rx && y > deshake->ry)

                        angles[pos++] = block_angle(x, y, 0, 0, &mv);



                    center_x += mv.x;

                    center_y += mv.y;

                }

            }

        }

    }



    pos = FFMAX(1, pos);



    center_x /= pos;

    center_y /= pos;



    t->angle = clean_mean(angles, pos);

    if (t->angle < 0.001)

        t->angle = 0;



    // Find the most common motion vector in the frame and use it as the gmv

    for (y = deshake->ry * 2; y >= 0; y--) {

        for (x = 0; x < deshake->rx * 2 + 1; x++) {

            //av_log(NULL, AV_LOG_ERROR, ""%5d "", counts[x][y]);

            if (counts[x][y] > count_max_value) {

                t->vector.x = x - deshake->rx;

                t->vector.y = y - deshake->ry;

                count_max_value = counts[x][y];

            }

        }

        //av_log(NULL, AV_LOG_ERROR, ""\n"");

    }



    p_x = (center_x - width / 2);

    p_y = (center_y - height / 2);

    t->vector.x += (cos(t->angle)-1)*p_x  - sin(t->angle)*p_y;

    t->vector.y += sin(t->angle)*p_x  + (cos(t->angle)-1)*p_y;



    // Clamp max shift & rotation?

    t->vector.x = av_clipf(t->vector.x, -deshake->rx * 2, deshake->rx * 2);

    t->vector.y = av_clipf(t->vector.y, -deshake->ry * 2, deshake->ry * 2);

    t->angle = av_clipf(t->angle, -0.1, 0.1);



    //av_log(NULL, AV_LOG_ERROR, ""%d x %d\n"", avg->x, avg->y);

    av_free(angles);

}
",632,"static void find_motion(DeshakeContext *dellak, uint8_t *src1, uint8_t *src2,

                        int width, int height, int stride, Transform *t)

{

    int x, y;

    IntMotionVector mv = {0, 0};

    int counts[128][128];

    int count_max_value = 0;

    int contrast;



    int pos;

    double *angles = av_malloc(sizeof(*angles) * width * height / (16 * dellak->blocksize));

    int center_x = 0, center_y = 0;

    double p_x, p_y;



    // Reset counts to zero

    for (x = 0; x < dellak->rx * 2 + 1; x++) {

        for (y = 0; y < dellak->ry * 2 + 1; y++) {

            counts[x][y] = 0;

        }

    }



    pos = 0;

    // Find motion for every block and store the motion vector in the counts

    for (y = dellak->ry; y < height - dellak->ry - (dellak->blocksize * 2); y += dellak->blocksize * 2) {

        // We use a width of 16 here to match the libavcodec sad functions

        for (x = dellak->rx; x < width - dellak->rx - 16; x += 16) {

            // If the contrast is too low, just skip this block as it probably

            // won't be very useful to us.

            contrast = block_contrast(src2, x, y, stride, dellak->blocksize);

            if (contrast > dellak->contrast) {

                //av_log(NULL, AV_LOG_ERROR, ""%d
"", contrast);

                find_block_motion(dellak, src1, src2, x, y, stride, &mv);

                if (mv.x != -1 && mv.y != -1) {

                    counts[mv.x + dellak->rx][mv.y + dellak->ry] += 1;

                    if (x > dellak->rx && y > dellak->ry)

                        angles[pos++] = block_angle(x, y, 0, 0, &mv);



                    center_x += mv.x;

                    center_y += mv.y;

                }

            }

        }

    }



    pos = FFMAX(1, pos);



    center_x /= pos;

    center_y /= pos;



    t->angle = clean_mean(angles, pos);

    if (t->angle < 0.001)

        t->angle = 0;



    // Find the most common motion vector in the frame and use it as the gmv

    for (y = dellak->ry * 2; y >= 0; y--) {

        for (x = 0; x < dellak->rx * 2 + 1; x++) {

            //av_log(NULL, AV_LOG_ERROR, ""%5d "", counts[x][y]);

            if (counts[x][y] > count_max_value) {

                t->vector.x = x - dellak->rx;

                t->vector.y = y - dellak->ry;

                count_max_value = counts[x][y];

            }

        }

        //av_log(NULL, AV_LOG_ERROR, ""
"");

    }



    p_x = (center_x - width / 2);

    p_y = (center_y - height / 2);

    t->vector.x += (cos(t->angle)-1)*p_x  - sin(t->angle)*p_y;

    t->vector.y += sin(t->angle)*p_x  + (cos(t->angle)-1)*p_y;



    // Clamp max shift & rotation?

    t->vector.x = av_clipf(t->vector.x, -dellak->rx * 2, dellak->rx * 2);

    t->vector.y = av_clipf(t->vector.y, -dellak->ry * 2, dellak->ry * 2);

    t->angle = av_clipf(t->angle, -0.1, 0.1);



    //av_log(NULL, AV_LOG_ERROR, ""%d x %d
"", avg->x, avg->y);

    av_free(angles);

}
",1,1,0.0,1,"deshake,src1,src2,height,stride,t,x,y,counts,contrast,pos,angles,p_x,p_y","deshake:0.15656980872154236,src1:0.05316096544265747,src2:0.030504852533340454,height:0.023912161588668823,stride:0.004468321800231934,t:0.02500823140144348,x:-0.021666496992111206,y:-0.006670206785202026,counts:0.007237672805786133,contrast:0.008725464344024658,pos:0.034859806299209595,angles:0.009004592895507812,p_x:0.013579100370407104,p_y:0.014280706644058228,",1.0,25.0,"deshake:dellak,",Greedy,422,0.3915118217468262
277,"static TCGv gen_ea(CPUM68KState *env, DisasContext *s, uint16_t insn,

                   int opsize, TCGv val, TCGv *addrp, ea_what what)

{

    TCGv reg;

    TCGv result;

    uint32_t offset;



    switch ((insn >> 3) & 7) {

    case 0: /* Data register direct.  */

        reg = DREG(insn, 0);

        if (what == EA_STORE) {

            gen_partset_reg(opsize, reg, val);

            return store_dummy;

        } else {

            return gen_extend(reg, opsize, what == EA_LOADS);

        }

    case 1: /* Address register direct.  */

        reg = AREG(insn, 0);

        if (what == EA_STORE) {

            tcg_gen_mov_i32(reg, val);

            return store_dummy;

        } else {

            return gen_extend(reg, opsize, what == EA_LOADS);

        }

    case 2: /* Indirect register */

        reg = AREG(insn, 0);

        return gen_ldst(s, opsize, reg, val, what);

    case 3: /* Indirect postincrement.  */

        reg = AREG(insn, 0);

        result = gen_ldst(s, opsize, reg, val, what);

        /* ??? This is not exception safe.  The instruction may still

           fault after this point.  */

        if (what == EA_STORE || !addrp)

            tcg_gen_addi_i32(reg, reg, opsize_bytes(opsize));

        return result;

    case 4: /* Indirect predecrememnt.  */

        {

            TCGv tmp;

            if (addrp && what == EA_STORE) {

                tmp = *addrp;

            } else {

                tmp = gen_lea(env, s, insn, opsize);

                if (IS_NULL_QREG(tmp))

                    return tmp;

                if (addrp)

                    *addrp = tmp;

            }

            result = gen_ldst(s, opsize, tmp, val, what);

            /* ??? This is not exception safe.  The instruction may still

               fault after this point.  */

            if (what == EA_STORE || !addrp) {

                reg = AREG(insn, 0);

                tcg_gen_mov_i32(reg, tmp);

            }

        }

        return result;

    case 5: /* Indirect displacement.  */

    case 6: /* Indirect index + displacement.  */

        return gen_ea_once(env, s, insn, opsize, val, addrp, what);

    case 7: /* Other */

        switch (insn & 7) {

        case 0: /* Absolute short.  */

        case 1: /* Absolute long.  */

        case 2: /* pc displacement  */

        case 3: /* pc index+displacement.  */

            return gen_ea_once(env, s, insn, opsize, val, addrp, what);

        case 4: /* Immediate.  */

            /* Sign extend values for consistency.  */

            switch (opsize) {

            case OS_BYTE:

                if (what == EA_LOADS) {

                    offset = cpu_ldsb_code(env, s->pc + 1);

                } else {

                    offset = cpu_ldub_code(env, s->pc + 1);

                }

                s->pc += 2;

                break;

            case OS_WORD:

                if (what == EA_LOADS) {

                    offset = cpu_ldsw_code(env, s->pc);

                } else {

                    offset = cpu_lduw_code(env, s->pc);

                }

                s->pc += 2;

                break;

            case OS_LONG:

                offset = read_im32(env, s);

                break;

            default:

                qemu_assert(0, ""Bad immediate operand"");

            }

            return tcg_const_i32(offset);

        default:

            return NULL_QREG;

        }

    }

    /* Should never happen.  */

    return NULL_QREG;

}
",527,"static TCGv gen_ea(CPUM68KState *env, DisasContext *s, uint16_t insn,

                   int opsize, TCGv val, TCGv *addrp, ea_what event)

{

    TCGv reg;

    TCGv result;

    uint32_t offset;



    switch ((insn >> 3) & 7) {

    case 0: /* Data register direct.  */

        reg = DREG(insn, 0);

        if (event == EA_STORE) {

            gen_partset_reg(opsize, reg, val);

            return store_dummy;

        } else {

            return gen_extend(reg, opsize, event == EA_LOADS);

        }

    case 1: /* Address register direct.  */

        reg = AREG(insn, 0);

        if (event == EA_STORE) {

            tcg_gen_mov_i32(reg, val);

            return store_dummy;

        } else {

            return gen_extend(reg, opsize, event == EA_LOADS);

        }

    case 2: /* Indirect register */

        reg = AREG(insn, 0);

        return gen_ldst(s, opsize, reg, val, event);

    case 3: /* Indirect postincrement.  */

        reg = AREG(insn, 0);

        result = gen_ldst(s, opsize, reg, val, event);

        /* ??? This is not exception safe.  The instruction may still

           fault after this point.  */

        if (event == EA_STORE || !addrp)

            tcg_gen_addi_i32(reg, reg, opsize_bytes(opsize));

        return result;

    case 4: /* Indirect predecrememnt.  */

        {

            TCGv tmp;

            if (addrp && event == EA_STORE) {

                tmp = *addrp;

            } else {

                tmp = gen_lea(env, s, insn, opsize);

                if (IS_NULL_QREG(tmp))

                    return tmp;

                if (addrp)

                    *addrp = tmp;

            }

            result = gen_ldst(s, opsize, tmp, val, event);

            /* ??? This is not exception safe.  The instruction may still

               fault after this point.  */

            if (event == EA_STORE || !addrp) {

                reg = AREG(insn, 0);

                tcg_gen_mov_i32(reg, tmp);

            }

        }

        return result;

    case 5: /* Indirect displacement.  */

    case 6: /* Indirect index + displacement.  */

        return gen_ea_once(env, s, insn, opsize, val, addrp, event);

    case 7: /* Other */

        switch (insn & 7) {

        case 0: /* Absolute short.  */

        case 1: /* Absolute long.  */

        case 2: /* pc displacement  */

        case 3: /* pc index+displacement.  */

            return gen_ea_once(env, s, insn, opsize, val, addrp, event);

        case 4: /* Immediate.  */

            /* Sign extend values for consistency.  */

            switch (opsize) {

            case OS_BYTE:

                if (event == EA_LOADS) {

                    offset = cpu_ldsb_code(env, s->pc + 1);

                } else {

                    offset = cpu_ldub_code(env, s->pc + 1);

                }

                s->pc += 2;

                break;

            case OS_WORD:

                if (event == EA_LOADS) {

                    offset = cpu_ldsw_code(env, s->pc);

                } else {

                    offset = cpu_lduw_code(env, s->pc);

                }

                s->pc += 2;

                break;

            case OS_LONG:

                offset = read_im32(env, s);

                break;

            default:

                qemu_assert(0, ""Bad immediate operand"");

            }

            return tcg_const_i32(offset);

        default:

            return NULL_QREG;

        }

    }

    /* Should never happen.  */

    return NULL_QREG;

}
",1,1,0.0,1,"env,s,insn,opsize,val,addrp,what,reg,result,offset,tmp","env:-0.022101283073425293,s:-0.050368547439575195,insn:-0.16459143161773682,opsize:-0.14776194095611572,val:-0.051397085189819336,addrp:-0.10633385181427002,what:0.019854605197906494,reg:-0.10311365127563477,result:-0.023471713066101074,offset:0.010526657104492188,tmp:-0.03361910581588745,",1.0,15.0,"what:event,",Greedy,198,0.1917381882667541
313,"int ff_h263_decode_mb(MpegEncContext *s,
                      int16_t block[6][64])
{
    int cbpc, cbpy, i, cbp, pred_x, pred_y, mx, my, dquant;
    int16_t *mot_val;
    const int xy= s->mb_x + s->mb_y * s->mb_stride;
    int cbpb = 0, pb_mv_count = 0;
    av_assert2(!s->h263_pred);
    if (s->pict_type == AV_PICTURE_TYPE_P) {
        do{
            if (get_bits1(&s->gb)) {
                /* skip mb */
                s->mb_intra = 0;
                for(i=0;i<6;i++)
                    s->block_last_index[i] = -1;
                s->mv_dir = MV_DIR_FORWARD;
                s->mv_type = MV_TYPE_16X16;
                s->current_picture.mb_type[xy] = MB_TYPE_SKIP | MB_TYPE_16x16 | MB_TYPE_L0;
                s->mv[0][0][0] = 0;
                s->mv[0][0][1] = 0;
                s->mb_skipped = !(s->obmc | s->loop_filter);
                goto end;
            cbpc = get_vlc2(&s->gb, ff_h263_inter_MCBPC_vlc.table, INTER_MCBPC_VLC_BITS, 2);
            if (cbpc < 0){
                av_log(s->avctx, AV_LOG_ERROR, ""cbpc damaged at %d %d\n"", s->mb_x, s->mb_y);
        }while(cbpc == 20);
        s->bdsp.clear_blocks(s->block[0]);
        dquant = cbpc & 8;
        s->mb_intra = ((cbpc & 4) != 0);
        if (s->mb_intra) goto intra;
        if(s->pb_frame && get_bits1(&s->gb))
            pb_mv_count = h263_get_modb(&s->gb, s->pb_frame, &cbpb);
        cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);
        if(s->alt_inter_vlc==0 || (cbpc & 3)!=3)
            cbpy ^= 0xF;
        cbp = (cbpc & 3) | (cbpy << 2);
        if (dquant) {
            h263_decode_dquant(s);
        s->mv_dir = MV_DIR_FORWARD;
        if ((cbpc & 16) == 0) {
            s->current_picture.mb_type[xy] = MB_TYPE_16x16 | MB_TYPE_L0;
            /* 16x16 motion prediction */
            s->mv_type = MV_TYPE_16X16;
            ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);
            if (s->umvplus)
               mx = h263p_decode_umotion(s, pred_x);
            else
               mx = ff_h263_decode_motion(s, pred_x, 1);
            if (mx >= 0xffff)
            if (s->umvplus)
               my = h263p_decode_umotion(s, pred_y);
            else
               my = ff_h263_decode_motion(s, pred_y, 1);
            if (my >= 0xffff)
            s->mv[0][0][0] = mx;
            s->mv[0][0][1] = my;
            if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)
               skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */
        } else {
            s->current_picture.mb_type[xy] = MB_TYPE_8x8 | MB_TYPE_L0;
            s->mv_type = MV_TYPE_8X8;
            for(i=0;i<4;i++) {
                mot_val = ff_h263_pred_motion(s, i, 0, &pred_x, &pred_y);
                if (s->umvplus)
                    mx = h263p_decode_umotion(s, pred_x);
                else
                    mx = ff_h263_decode_motion(s, pred_x, 1);
                if (mx >= 0xffff)
                if (s->umvplus)
                    my = h263p_decode_umotion(s, pred_y);
                else
                    my = ff_h263_decode_motion(s, pred_y, 1);
                if (my >= 0xffff)
                s->mv[0][i][0] = mx;
                s->mv[0][i][1] = my;
                if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)
                  skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */
                mot_val[0] = mx;
                mot_val[1] = my;
    } else if(s->pict_type==AV_PICTURE_TYPE_B) {
        int mb_type;
        const int stride= s->b8_stride;
        int16_t *mot_val0 = s->current_picture.motion_val[0][2 * (s->mb_x + s->mb_y * stride)];
        int16_t *mot_val1 = s->current_picture.motion_val[1][2 * (s->mb_x + s->mb_y * stride)];
//        const int mv_xy= s->mb_x + 1 + s->mb_y * s->mb_stride;
        //FIXME ugly
        mot_val0[0       ]= mot_val0[2       ]= mot_val0[0+2*stride]= mot_val0[2+2*stride]=
        mot_val0[1       ]= mot_val0[3       ]= mot_val0[1+2*stride]= mot_val0[3+2*stride]=
        mot_val1[0       ]= mot_val1[2       ]= mot_val1[0+2*stride]= mot_val1[2+2*stride]=
        mot_val1[1       ]= mot_val1[3       ]= mot_val1[1+2*stride]= mot_val1[3+2*stride]= 0;
        do{
            mb_type= get_vlc2(&s->gb, h263_mbtype_b_vlc.table, H263_MBTYPE_B_VLC_BITS, 2);
            if (mb_type < 0){
                av_log(s->avctx, AV_LOG_ERROR, ""b mb_type damaged at %d %d\n"", s->mb_x, s->mb_y);
            mb_type= h263_mb_type_b_map[ mb_type ];
        }while(!mb_type);
        s->mb_intra = IS_INTRA(mb_type);
        if(HAS_CBP(mb_type)){
            s->bdsp.clear_blocks(s->block[0]);
            cbpc = get_vlc2(&s->gb, cbpc_b_vlc.table, CBPC_B_VLC_BITS, 1);
            if(s->mb_intra){
                dquant = IS_QUANT(mb_type);
                goto intra;
            cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);
            if (cbpy < 0){
                av_log(s->avctx, AV_LOG_ERROR, ""b cbpy damaged at %d %d\n"", s->mb_x, s->mb_y);
            if(s->alt_inter_vlc==0 || (cbpc & 3)!=3)
                cbpy ^= 0xF;
            cbp = (cbpc & 3) | (cbpy << 2);
        }else
            cbp=0;
        av_assert2(!s->mb_intra);
        if(IS_QUANT(mb_type)){
            h263_decode_dquant(s);
        if(IS_DIRECT(mb_type)){
            s->mv_dir = MV_DIR_FORWARD | MV_DIR_BACKWARD | MV_DIRECT;
            mb_type |= set_direct_mv(s);
        }else{
            s->mv_dir = 0;
            s->mv_type= MV_TYPE_16X16;
//FIXME UMV
            if(USES_LIST(mb_type, 0)){
                int16_t *mot_val= ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);
                s->mv_dir = MV_DIR_FORWARD;
                if (s->umvplus)
                    mx = h263p_decode_umotion(s, pred_x);
                else
                    mx = ff_h263_decode_motion(s, pred_x, 1);
                if (mx >= 0xffff)
                if (s->umvplus)
                    my = h263p_decode_umotion(s, pred_y);
                else
                    my = ff_h263_decode_motion(s, pred_y, 1);
                if (my >= 0xffff)
                if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)
                    skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */
                s->mv[0][0][0] = mx;
                s->mv[0][0][1] = my;
                mot_val[0       ]= mot_val[2       ]= mot_val[0+2*stride]= mot_val[2+2*stride]= mx;
                mot_val[1       ]= mot_val[3       ]= mot_val[1+2*stride]= mot_val[3+2*stride]= my;
            if(USES_LIST(mb_type, 1)){
                int16_t *mot_val= ff_h263_pred_motion(s, 0, 1, &pred_x, &pred_y);
                s->mv_dir |= MV_DIR_BACKWARD;
                if (s->umvplus)
                    mx = h263p_decode_umotion(s, pred_x);
                else
                    mx = ff_h263_decode_motion(s, pred_x, 1);
                if (mx >= 0xffff)
                if (s->umvplus)
                    my = h263p_decode_umotion(s, pred_y);
                else
                    my = ff_h263_decode_motion(s, pred_y, 1);
                if (my >= 0xffff)
                if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)
                    skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */
                s->mv[1][0][0] = mx;
                s->mv[1][0][1] = my;
                mot_val[0       ]= mot_val[2       ]= mot_val[0+2*stride]= mot_val[2+2*stride]= mx;
                mot_val[1       ]= mot_val[3       ]= mot_val[1+2*stride]= mot_val[3+2*stride]= my;
        s->current_picture.mb_type[xy] = mb_type;
    } else { /* I-Frame */
        do{
            cbpc = get_vlc2(&s->gb, ff_h263_intra_MCBPC_vlc.table, INTRA_MCBPC_VLC_BITS, 2);
            if (cbpc < 0){
                av_log(s->avctx, AV_LOG_ERROR, ""I cbpc damaged at %d %d\n"", s->mb_x, s->mb_y);
        }while(cbpc == 8);
        s->bdsp.clear_blocks(s->block[0]);
        dquant = cbpc & 4;
        s->mb_intra = 1;
intra:
        s->current_picture.mb_type[xy] = MB_TYPE_INTRA;
        if (s->h263_aic) {
            s->ac_pred = get_bits1(&s->gb);
            if(s->ac_pred){
                s->current_picture.mb_type[xy] = MB_TYPE_INTRA | MB_TYPE_ACPRED;
                s->h263_aic_dir = get_bits1(&s->gb);
        }else
            s->ac_pred = 0;
        if(s->pb_frame && get_bits1(&s->gb))
            pb_mv_count = h263_get_modb(&s->gb, s->pb_frame, &cbpb);
        cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);
        if(cbpy<0){
            av_log(s->avctx, AV_LOG_ERROR, ""I cbpy damaged at %d %d\n"", s->mb_x, s->mb_y);
        cbp = (cbpc & 3) | (cbpy << 2);
        if (dquant) {
            h263_decode_dquant(s);
        pb_mv_count += !!s->pb_frame;
    while(pb_mv_count--){
        ff_h263_decode_motion(s, 0, 1);
        ff_h263_decode_motion(s, 0, 1);
    /* decode each block */
    for (i = 0; i < 6; i++) {
        if (h263_decode_block(s, block[i], i, cbp&32) < 0)
            return -1;
        cbp+=cbp;
    if(s->pb_frame && h263_skip_b_part(s, cbpb) < 0)
        return -1;
    if(s->obmc && !s->mb_intra){
        if(s->pict_type == AV_PICTURE_TYPE_P && s->mb_x+1<s->mb_width && s->mb_num_left != 1)
            preview_obmc(s);
end:
        /* per-MB end of slice check */
    {
        int v= show_bits(&s->gb, 16);
        if (get_bits_left(&s->gb) < 16) {
            v >>= 16 - get_bits_left(&s->gb);
        if(v==0)
            return SLICE_END;
    return SLICE_OK;",2116,"int ff_h263_decode_mb(MpegEncContext *sys,
                      int16_t block[6][64])
{
    int cbpc, cbpy, type, cbp, pred_x, pred_y, mx, my, dquant;
    int16_t *mot_val;
    const int xy= sys->mb_x + sys->mb_y * sys->mb_stride;
    int cbpb = 0, pb_mv_count = 0;
    av_assert2(!sys->h263_pred);
    if (sys->pict_type == AV_PICTURE_TYPE_P) {
        do{
            if (get_bits1(&sys->gb)) {
                /* skip mb */
                sys->mb_intra = 0;
                for(type=0;type<6;type++)
                    sys->block_last_index[type] = -1;
                sys->mv_dir = MV_DIR_FORWARD;
                sys->mv_type = MV_TYPE_16X16;
                sys->current_picture.mb_type[xy] = MB_TYPE_SKIP | MB_TYPE_16x16 | MB_TYPE_L0;
                sys->mv[0][0][0] = 0;
                sys->mv[0][0][1] = 0;
                sys->mb_skipped = !(sys->obmc | sys->loop_filter);
                goto end;
            cbpc = get_vlc2(&sys->gb, ff_h263_inter_MCBPC_vlc.table, INTER_MCBPC_VLC_BITS, 2);
            if (cbpc < 0){
                av_log(sys->avctx, AV_LOG_ERROR, ""cbpc damaged at %d %d
"", sys->mb_x, sys->mb_y);
        }while(cbpc == 20);
        sys->bdsp.clear_blocks(sys->block[0]);
        dquant = cbpc & 8;
        sys->mb_intra = ((cbpc & 4) != 0);
        if (sys->mb_intra) goto intra;
        if(sys->pb_frame && get_bits1(&sys->gb))
            pb_mv_count = h263_get_modb(&sys->gb, sys->pb_frame, &cbpb);
        cbpy = get_vlc2(&sys->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);
        if(sys->alt_inter_vlc==0 || (cbpc & 3)!=3)
            cbpy ^= 0xF;
        cbp = (cbpc & 3) | (cbpy << 2);
        if (dquant) {
            h263_decode_dquant(sys);
        sys->mv_dir = MV_DIR_FORWARD;
        if ((cbpc & 16) == 0) {
            sys->current_picture.mb_type[xy] = MB_TYPE_16x16 | MB_TYPE_L0;
            /* 16x16 motion prediction */
            sys->mv_type = MV_TYPE_16X16;
            ff_h263_pred_motion(sys, 0, 0, &pred_x, &pred_y);
            if (sys->umvplus)
               mx = h263p_decode_umotion(sys, pred_x);
            else
               mx = ff_h263_decode_motion(sys, pred_x, 1);
            if (mx >= 0xffff)
            if (sys->umvplus)
               my = h263p_decode_umotion(sys, pred_y);
            else
               my = ff_h263_decode_motion(sys, pred_y, 1);
            if (my >= 0xffff)
            sys->mv[0][0][0] = mx;
            sys->mv[0][0][1] = my;
            if (sys->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)
               skip_bits1(&sys->gb); /* Bit stuffing to prevent PSC */
        } else {
            sys->current_picture.mb_type[xy] = MB_TYPE_8x8 | MB_TYPE_L0;
            sys->mv_type = MV_TYPE_8X8;
            for(type=0;type<4;type++) {
                mot_val = ff_h263_pred_motion(sys, type, 0, &pred_x, &pred_y);
                if (sys->umvplus)
                    mx = h263p_decode_umotion(sys, pred_x);
                else
                    mx = ff_h263_decode_motion(sys, pred_x, 1);
                if (mx >= 0xffff)
                if (sys->umvplus)
                    my = h263p_decode_umotion(sys, pred_y);
                else
                    my = ff_h263_decode_motion(sys, pred_y, 1);
                if (my >= 0xffff)
                sys->mv[0][type][0] = mx;
                sys->mv[0][type][1] = my;
                if (sys->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)
                  skip_bits1(&sys->gb); /* Bit stuffing to prevent PSC */
                mot_val[0] = mx;
                mot_val[1] = my;
    } else if(sys->pict_type==AV_PICTURE_TYPE_B) {
        int mb_type;
        const int stride= sys->b8_stride;
        int16_t *mot_val0 = sys->current_picture.motion_val[0][2 * (sys->mb_x + sys->mb_y * stride)];
        int16_t *mot_val1 = sys->current_picture.motion_val[1][2 * (sys->mb_x + sys->mb_y * stride)];
//        const int mv_xy= s->mb_x + 1 + s->mb_y * s->mb_stride;
        //FIXME ugly
        mot_val0[0       ]= mot_val0[2       ]= mot_val0[0+2*stride]= mot_val0[2+2*stride]=
        mot_val0[1       ]= mot_val0[3       ]= mot_val0[1+2*stride]= mot_val0[3+2*stride]=
        mot_val1[0       ]= mot_val1[2       ]= mot_val1[0+2*stride]= mot_val1[2+2*stride]=
        mot_val1[1       ]= mot_val1[3       ]= mot_val1[1+2*stride]= mot_val1[3+2*stride]= 0;
        do{
            mb_type= get_vlc2(&sys->gb, h263_mbtype_b_vlc.table, H263_MBTYPE_B_VLC_BITS, 2);
            if (mb_type < 0){
                av_log(sys->avctx, AV_LOG_ERROR, ""b mb_type damaged at %d %d
"", sys->mb_x, sys->mb_y);
            mb_type= h263_mb_type_b_map[ mb_type ];
        }while(!mb_type);
        sys->mb_intra = IS_INTRA(mb_type);
        if(HAS_CBP(mb_type)){
            sys->bdsp.clear_blocks(sys->block[0]);
            cbpc = get_vlc2(&sys->gb, cbpc_b_vlc.table, CBPC_B_VLC_BITS, 1);
            if(sys->mb_intra){
                dquant = IS_QUANT(mb_type);
                goto intra;
            cbpy = get_vlc2(&sys->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);
            if (cbpy < 0){
                av_log(sys->avctx, AV_LOG_ERROR, ""b cbpy damaged at %d %d
"", sys->mb_x, sys->mb_y);
            if(sys->alt_inter_vlc==0 || (cbpc & 3)!=3)
                cbpy ^= 0xF;
            cbp = (cbpc & 3) | (cbpy << 2);
        }else
            cbp=0;
        av_assert2(!sys->mb_intra);
        if(IS_QUANT(mb_type)){
            h263_decode_dquant(sys);
        if(IS_DIRECT(mb_type)){
            sys->mv_dir = MV_DIR_FORWARD | MV_DIR_BACKWARD | MV_DIRECT;
            mb_type |= set_direct_mv(sys);
        }else{
            sys->mv_dir = 0;
            sys->mv_type= MV_TYPE_16X16;
//FIXME UMV
            if(USES_LIST(mb_type, 0)){
                int16_t *mot_val= ff_h263_pred_motion(sys, 0, 0, &pred_x, &pred_y);
                sys->mv_dir = MV_DIR_FORWARD;
                if (sys->umvplus)
                    mx = h263p_decode_umotion(sys, pred_x);
                else
                    mx = ff_h263_decode_motion(sys, pred_x, 1);
                if (mx >= 0xffff)
                if (sys->umvplus)
                    my = h263p_decode_umotion(sys, pred_y);
                else
                    my = ff_h263_decode_motion(sys, pred_y, 1);
                if (my >= 0xffff)
                if (sys->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)
                    skip_bits1(&sys->gb); /* Bit stuffing to prevent PSC */
                sys->mv[0][0][0] = mx;
                sys->mv[0][0][1] = my;
                mot_val[0       ]= mot_val[2       ]= mot_val[0+2*stride]= mot_val[2+2*stride]= mx;
                mot_val[1       ]= mot_val[3       ]= mot_val[1+2*stride]= mot_val[3+2*stride]= my;
            if(USES_LIST(mb_type, 1)){
                int16_t *mot_val= ff_h263_pred_motion(sys, 0, 1, &pred_x, &pred_y);
                sys->mv_dir |= MV_DIR_BACKWARD;
                if (sys->umvplus)
                    mx = h263p_decode_umotion(sys, pred_x);
                else
                    mx = ff_h263_decode_motion(sys, pred_x, 1);
                if (mx >= 0xffff)
                if (sys->umvplus)
                    my = h263p_decode_umotion(sys, pred_y);
                else
                    my = ff_h263_decode_motion(sys, pred_y, 1);
                if (my >= 0xffff)
                if (sys->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)
                    skip_bits1(&sys->gb); /* Bit stuffing to prevent PSC */
                sys->mv[1][0][0] = mx;
                sys->mv[1][0][1] = my;
                mot_val[0       ]= mot_val[2       ]= mot_val[0+2*stride]= mot_val[2+2*stride]= mx;
                mot_val[1       ]= mot_val[3       ]= mot_val[1+2*stride]= mot_val[3+2*stride]= my;
        sys->current_picture.mb_type[xy] = mb_type;
    } else { /* I-Frame */
        do{
            cbpc = get_vlc2(&sys->gb, ff_h263_intra_MCBPC_vlc.table, INTRA_MCBPC_VLC_BITS, 2);
            if (cbpc < 0){
                av_log(sys->avctx, AV_LOG_ERROR, ""I cbpc damaged at %d %d
"", sys->mb_x, sys->mb_y);
        }while(cbpc == 8);
        sys->bdsp.clear_blocks(sys->block[0]);
        dquant = cbpc & 4;
        sys->mb_intra = 1;
intra:
        sys->current_picture.mb_type[xy] = MB_TYPE_INTRA;
        if (sys->h263_aic) {
            sys->ac_pred = get_bits1(&sys->gb);
            if(sys->ac_pred){
                sys->current_picture.mb_type[xy] = MB_TYPE_INTRA | MB_TYPE_ACPRED;
                sys->h263_aic_dir = get_bits1(&sys->gb);
        }else
            sys->ac_pred = 0;
        if(sys->pb_frame && get_bits1(&sys->gb))
            pb_mv_count = h263_get_modb(&sys->gb, sys->pb_frame, &cbpb);
        cbpy = get_vlc2(&sys->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);
        if(cbpy<0){
            av_log(sys->avctx, AV_LOG_ERROR, ""I cbpy damaged at %d %d
"", sys->mb_x, sys->mb_y);
        cbp = (cbpc & 3) | (cbpy << 2);
        if (dquant) {
            h263_decode_dquant(sys);
        pb_mv_count += !!sys->pb_frame;
    while(pb_mv_count--){
        ff_h263_decode_motion(sys, 0, 1);
        ff_h263_decode_motion(sys, 0, 1);
    /* decode each block */
    for (type = 0; type < 6; type++) {
        if (h263_decode_block(sys, block[type], type, cbp&32) < 0)
            return -1;
        cbp+=cbp;
    if(sys->pb_frame && h263_skip_b_part(sys, cbpb) < 0)
        return -1;
    if(sys->obmc && !sys->mb_intra){
        if(sys->pict_type == AV_PICTURE_TYPE_P && sys->mb_x+1<sys->mb_width && sys->mb_num_left != 1)
            preview_obmc(sys);
end:
        /* per-MB end of slice check */
    {
        int v= show_bits(&sys->gb, 16);
        if (get_bits_left(&sys->gb) < 16) {
            v >>= 16 - get_bits_left(&sys->gb);
        if(v==0)
            return SLICE_END;
    return SLICE_OK;",1,1,0.0,1,"s,block,cbpc,cbpy,i,cbp,pred_x,pred_y,mx,my,dquant,mot_val,mb_type,pb_mv_count","s:0.0715295672416687,block:0.019641101360321045,cbpc:0.01453399658203125,cbpy:-0.008555412292480469,i:0.1581488847732544,cbp:0.007671177387237549,pred_x:-0.003818213939666748,pred_y:-0.0016593337059020996,mx:0.021440207958221436,my:-0.0031434297561645508,dquant:0.033719003200531006,mot_val:-0.0089799165725708,mb_type:-0.017818152904510498,pb_mv_count:0.03420102596282959,",2.0,169.0,"i:type,s:sys,",Greedy,486,0.5051379720369975
319,"static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,

                             uint32_t length)

{

    int v, i;



    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {

        if (length > 256 || !(s->state & PNG_PLTE))

            return AVERROR_INVALIDDATA;



        for (i = 0; i < length; i++) {

            v = bytestream2_get_byte(&s->gb);

            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);

        }

    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {

        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||

            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))

            return AVERROR_INVALIDDATA;



        for (i = 0; i < length / 2; i++) {

            /* only use the least significant bits */

            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);



            if (s->bit_depth > 8)

                AV_WB16(&s->transparent_color_be[2 * i], v);

            else

                s->transparent_color_be[i] = v;

        }

    } else {

        return AVERROR_INVALIDDATA;

    }



    bytestream2_skip(&s->gb, 4); /* crc */

    s->has_trns = 1;



    return 0;

}
",237,"static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *fs,

                             uint32_t list)

{

    int ver, cli;



    if (fs->color_type == PNG_COLOR_TYPE_PALETTE) {

        if (list > 256 || !(fs->state & PNG_PLTE))

            return AVERROR_INVALIDDATA;



        for (cli = 0; cli < list; cli++) {

            ver = bytestream2_get_byte(&fs->gb);

            fs->palette[cli] = (fs->palette[cli] & 0x00ffffff) | (ver << 24);

        }

    } else if (fs->color_type == PNG_COLOR_TYPE_GRAY || fs->color_type == PNG_COLOR_TYPE_RGB) {

        if ((fs->color_type == PNG_COLOR_TYPE_GRAY && list != 2) ||

            (fs->color_type == PNG_COLOR_TYPE_RGB && list != 6))

            return AVERROR_INVALIDDATA;



        for (cli = 0; cli < list / 2; cli++) {

            /* only use the least significant bits */

            ver = av_mod_uintp2(bytestream2_get_be16(&fs->gb), fs->bit_depth);



            if (fs->bit_depth > 8)

                AV_WB16(&fs->transparent_color_be[2 * cli], ver);

            else

                fs->transparent_color_be[cli] = ver;

        }

    } else {

        return AVERROR_INVALIDDATA;

    }



    bytestream2_skip(&fs->gb, 4); /* crc */

    fs->has_trns = 1;



    return 0;

}
",1,1,0.0,1,"avctx,s,length,v,i","avctx:-0.0450785756111145,s:-0.02640080451965332,length:-0.03869152069091797,v:-0.03786206245422363,i:-0.03169184923171997,",4.0,40.0,"s:fs,i:cli,v:ver,length:list,",Greedy,302,0.2788581331570943
320,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,

                                       int S)

{

    unsigned bit;



    if (s->extra_bits) {

        S <<= s->extra_bits;



        if (s->got_extra_bits &&

            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {

            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);

        }

    }



    bit = (S & s->and) | s->or;

    bit = ((S + bit) << s->shift) - bit;



    if (s->hybrid)

        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);



    return bit << s->post_shift;

}
",152,"static inline int wv_get_value_integer(WavpackFrameContext *os, uint32_t *crc,

                                       int Socket)

{

    unsigned option;



    if (os->extra_bits) {

        Socket <<= os->extra_bits;



        if (os->got_extra_bits &&

            get_bits_left(&os->gb_extra_bits) >= os->extra_bits) {

            Socket   |= get_bits_long(&os->gb_extra_bits, os->extra_bits);

            *crc = *crc * 9 + (Socket & 0xffff) * 3 + ((unsigned)Socket >> 16);

        }

    }



    option = (Socket & os->and) | os->or;

    option = ((Socket + option) << os->shift) - option;



    if (os->hybrid)

        option = av_clip(option, os->hybrid_minclip, os->hybrid_maxclip);



    return option << os->post_shift;

}
",1,1,0.0,1,"s,crc,S,bit","s:0.026622533798217773,crc:-0.08402687311172485,S:-0.004832029342651367,bit:-0.0012601613998413086,",3.0,30.0,"s:os,bit:option,S:Socket,",Greedy,224,0.2120991110801696
321,"target_ulong helper_ldl(CPUMIPSState *env, target_ulong arg1,

                        target_ulong arg2, int mem_idx)

{

    uint64_t tmp;



    tmp = do_lbu(env, arg2, mem_idx);

    arg1 = (arg1 & 0x00FFFFFFFFFFFFFFULL) | (tmp << 56);



    if (GET_LMASK64(arg2) <= 6) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 1), mem_idx);

        arg1 = (arg1 & 0xFF00FFFFFFFFFFFFULL) | (tmp << 48);

    }



    if (GET_LMASK64(arg2) <= 5) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 2), mem_idx);

        arg1 = (arg1 & 0xFFFF00FFFFFFFFFFULL) | (tmp << 40);

    }



    if (GET_LMASK64(arg2) <= 4) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 3), mem_idx);

        arg1 = (arg1 & 0xFFFFFF00FFFFFFFFULL) | (tmp << 32);

    }



    if (GET_LMASK64(arg2) <= 3) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 4), mem_idx);

        arg1 = (arg1 & 0xFFFFFFFF00FFFFFFULL) | (tmp << 24);

    }



    if (GET_LMASK64(arg2) <= 2) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 5), mem_idx);

        arg1 = (arg1 & 0xFFFFFFFFFF00FFFFULL) | (tmp << 16);

    }



    if (GET_LMASK64(arg2) <= 1) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 6), mem_idx);

        arg1 = (arg1 & 0xFFFFFFFFFFFF00FFULL) | (tmp << 8);

    }



    if (GET_LMASK64(arg2) == 0) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 7), mem_idx);

        arg1 = (arg1 & 0xFFFFFFFFFFFFFF00ULL) | tmp;

    }



    return arg1;

}
",332,"target_ulong helper_ldl(CPUMIPSState *env, target_ulong ackName,

                        target_ulong arg2, int mem_idx)

{

    uint64_t tmp;



    tmp = do_lbu(env, arg2, mem_idx);

    ackName = (ackName & 0x00FFFFFFFFFFFFFFULL) | (tmp << 56);



    if (GET_LMASK64(arg2) <= 6) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 1), mem_idx);

        ackName = (ackName & 0xFF00FFFFFFFFFFFFULL) | (tmp << 48);

    }



    if (GET_LMASK64(arg2) <= 5) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 2), mem_idx);

        ackName = (ackName & 0xFFFF00FFFFFFFFFFULL) | (tmp << 40);

    }



    if (GET_LMASK64(arg2) <= 4) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 3), mem_idx);

        ackName = (ackName & 0xFFFFFF00FFFFFFFFULL) | (tmp << 32);

    }



    if (GET_LMASK64(arg2) <= 3) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 4), mem_idx);

        ackName = (ackName & 0xFFFFFFFF00FFFFFFULL) | (tmp << 24);

    }



    if (GET_LMASK64(arg2) <= 2) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 5), mem_idx);

        ackName = (ackName & 0xFFFFFFFFFF00FFFFULL) | (tmp << 16);

    }



    if (GET_LMASK64(arg2) <= 1) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 6), mem_idx);

        ackName = (ackName & 0xFFFFFFFFFFFF00FFULL) | (tmp << 8);

    }



    if (GET_LMASK64(arg2) == 0) {

        tmp = do_lbu(env, GET_OFFSET(arg2, 7), mem_idx);

        ackName = (ackName & 0xFFFFFFFFFFFFFF00ULL) | tmp;

    }



    return ackName;

}
",1,1,0.0,1,"env,arg1,arg2,mem_idx,tmp","env:0.011503040790557861,arg1:0.4882444143295288,arg2:0.4288279712200165,mem_idx:0.18484917283058167,tmp:0.411783903837204,",1.0,18.0,"arg1:ackName,",Greedy,208,0.1847478548685709
348,"static void rv40_h_weak_loop_filter(uint8_t *src, const int stride,

                                    const int filter_p1, const int filter_q1,

                                    const int alpha, const int beta,

                                    const int lim_p0q0, const int lim_q1,

                                    const int lim_p1)

{

    rv40_weak_loop_filter(src, stride, 1, filter_p1, filter_q1,

                          alpha, beta, lim_p0q0, lim_q1, lim_p1);

}
",65,"static void rv40_h_weak_loop_filter(uint8_t *src, const int stride,

                                    const int filter_p1, const int filter_q1,

                                    const int audio, const int beta,

                                    const int lim_p0q0, const int lim_dq5,

                                    const int lim_p1)

{

    rv40_weak_loop_filter(src, stride, 1, filter_p1, filter_q1,

                          audio, beta, lim_p0q0, lim_dq5, lim_p1);

}
",1,1,0.0,1,"src,stride,filter_p1,filter_q1,alpha,beta,lim_p0q0,lim_q1,lim_p1","src:-0.12723690271377563,stride:-0.07824957370758057,filter_p1:-0.008816838264465332,filter_q1:-0.05421316623687744,alpha:-0.006766378879547119,beta:-0.011719584465026855,lim_p0q0:-0.1169392466545105,lim_q1:0.0012293457984924316,lim_p1:-0.017281711101531982,",2.0,4.0,"lim_q1:lim_dq5,alpha:audio,",Greedy,77,0.0590657591819763
363,"int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)

{

    int64_t scaled_dim;



    if (!sar.den)

        return AVERROR(EINVAL);



    if (!sar.num || sar.num == sar.den)

        return 0;



    if (sar.num < sar.den)

        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);

    else

        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);



    if (scaled_dim > 0)

        return 0;



    return AVERROR(EINVAL);

}
",110,"int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)

{

    int64_t scalled_num;



    if (!sar.den)

        return AVERROR(EINVAL);



    if (!sar.num || sar.num == sar.den)

        return 0;



    if (sar.num < sar.den)

        scalled_num = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);

    else

        scalled_num = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);



    if (scalled_num > 0)

        return 0;



    return AVERROR(EINVAL);

}
",1,1,0.0,1,"w,h,sar,scaled_dim","w:0.008635461330413818,h:0.021004974842071533,sar:0.16286811232566833,scaled_dim:0.1766737997531891,",1.0,4.0,"scaled_dim:scalled_num,",Greedy,48,0.024765940507253
367,"static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,

                            AVPacket *avpkt) {

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    PCXContext * const s = avctx->priv_data;

    AVFrame *picture = data;

    AVFrame * const p = &s->picture;

    int compressed, xmin, ymin, xmax, ymax;

    unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x,

                 bytes_per_scanline;

    uint8_t *ptr;

    uint8_t const *bufstart = buf;

    uint8_t *scanline;

    int ret = -1;



    if (buf[0] != 0x0a || buf[1] > 5) {

        av_log(avctx, AV_LOG_ERROR, ""this is not PCX encoded data\n"");

        return AVERROR_INVALIDDATA;

    }



    compressed = buf[2];

    xmin = AV_RL16(buf+ 4);

    ymin = AV_RL16(buf+ 6);

    xmax = AV_RL16(buf+ 8);

    ymax = AV_RL16(buf+10);



    if (xmax < xmin || ymax < ymin) {

        av_log(avctx, AV_LOG_ERROR, ""invalid image dimensions\n"");

        return AVERROR_INVALIDDATA;

    }



    w = xmax - xmin + 1;

    h = ymax - ymin + 1;



    bits_per_pixel     = buf[3];

    bytes_per_line     = AV_RL16(buf+66);

    nplanes            = buf[65];

    bytes_per_scanline = nplanes * bytes_per_line;



    if (bytes_per_scanline < w * bits_per_pixel * nplanes / 8) {

        av_log(avctx, AV_LOG_ERROR, ""PCX data is corrupted\n"");

        return AVERROR_INVALIDDATA;

    }



    switch ((nplanes<<8) + bits_per_pixel) {

        case 0x0308:

            avctx->pix_fmt = AV_PIX_FMT_RGB24;

            break;

        case 0x0108:

        case 0x0104:

        case 0x0102:

        case 0x0101:

        case 0x0401:

        case 0x0301:

        case 0x0201:

            avctx->pix_fmt = AV_PIX_FMT_PAL8;

            break;

        default:

            av_log(avctx, AV_LOG_ERROR, ""invalid PCX file\n"");

            return AVERROR_INVALIDDATA;

    }



    buf += 128;



    if (p->data[0])

        avctx->release_buffer(avctx, p);



    if (av_image_check_size(w, h, 0, avctx))

        return AVERROR_INVALIDDATA;

    if (w != avctx->width || h != avctx->height)

        avcodec_set_dimensions(avctx, w, h);

    if ((ret = avctx->get_buffer(avctx, p)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return ret;

    }



    p->pict_type = AV_PICTURE_TYPE_I;



    ptr    = p->data[0];

    stride = p->linesize[0];



    scanline = av_malloc(bytes_per_scanline);

    if (!scanline)

        return AVERROR(ENOMEM);



    if (nplanes == 3 && bits_per_pixel == 8) {

        for (y=0; y<h; y++) {

            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);



            for (x=0; x<w; x++) {

                ptr[3*x  ] = scanline[x                    ];

                ptr[3*x+1] = scanline[x+ bytes_per_line    ];

                ptr[3*x+2] = scanline[x+(bytes_per_line<<1)];

            }



            ptr += stride;

        }



    } else if (nplanes == 1 && bits_per_pixel == 8) {

        const uint8_t *palstart = bufstart + buf_size - 769;



        for (y=0; y<h; y++, ptr+=stride) {

            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);

            memcpy(ptr, scanline, w);

        }



        if (buf != palstart) {

            av_log(avctx, AV_LOG_WARNING, ""image data possibly corrupted\n"");

            buf = palstart;

        }

        if (*buf++ != 12) {

            av_log(avctx, AV_LOG_ERROR, ""expected palette after image data\n"");

            ret = AVERROR_INVALIDDATA;

            goto end;

        }



    } else if (nplanes == 1) {   /* all packed formats, max. 16 colors */

        GetBitContext s;



        for (y=0; y<h; y++) {

            init_get_bits(&s, scanline, bytes_per_scanline<<3);



            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);



            for (x=0; x<w; x++)

                ptr[x] = get_bits(&s, bits_per_pixel);

            ptr += stride;

        }



    } else {    /* planar, 4, 8 or 16 colors */

        int i;



        for (y=0; y<h; y++) {

            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);



            for (x=0; x<w; x++) {

                int m = 0x80 >> (x&7), v = 0;

                for (i=nplanes - 1; i>=0; i--) {

                    v <<= 1;

                    v  += !!(scanline[i*bytes_per_line + (x>>3)] & m);

                }

                ptr[x] = v;

            }

            ptr += stride;

        }

    }



    if (nplanes == 1 && bits_per_pixel == 8) {

        pcx_palette(&buf, (uint32_t *) p->data[1], 256);

    } else if (bits_per_pixel * nplanes == 1) {

        AV_WN32A(p->data[1]  , 0xFF000000);

        AV_WN32A(p->data[1]+4, 0xFFFFFFFF);

    } else if (bits_per_pixel < 8) {

        const uint8_t *palette = bufstart+16;

        pcx_palette(&palette, (uint32_t *) p->data[1], 16);

    }



    *picture = s->picture;

    *data_size = sizeof(AVFrame);



    ret = buf - bufstart;

end:

    av_free(scanline);

    return ret;

}
",1043,"static int pcx_decode_frame(AVCodecContext *versync, void *data, int * data_capacity,

                            AVPacket *avpkt) {

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    PCXContext * const s = versync->priv_data;

    AVFrame *picture = data;

    AVFrame * const p = &s->picture;

    int compressed, ypos, ymin, xmax, ymax;

    unsigned int w, f, bits_per_pixel, bytes_per_line, nplanes, strider, y, x,

                 bytes_per_scanblock;

    uint8_t *port;

    uint8_t const *bufstart = buf;

    uint8_t *scanline;

    int ret = -1;



    if (buf[0] != 0x0a || buf[1] > 5) {

        av_log(versync, AV_LOG_ERROR, ""this is not PCX encoded data
"");

        return AVERROR_INVALIDDATA;

    }



    compressed = buf[2];

    ypos = AV_RL16(buf+ 4);

    ymin = AV_RL16(buf+ 6);

    xmax = AV_RL16(buf+ 8);

    ymax = AV_RL16(buf+10);



    if (xmax < ypos || ymax < ymin) {

        av_log(versync, AV_LOG_ERROR, ""invalid image dimensions
"");

        return AVERROR_INVALIDDATA;

    }



    w = xmax - ypos + 1;

    f = ymax - ymin + 1;



    bits_per_pixel     = buf[3];

    bytes_per_line     = AV_RL16(buf+66);

    nplanes            = buf[65];

    bytes_per_scanblock = nplanes * bytes_per_line;



    if (bytes_per_scanblock < w * bits_per_pixel * nplanes / 8) {

        av_log(versync, AV_LOG_ERROR, ""PCX data is corrupted
"");

        return AVERROR_INVALIDDATA;

    }



    switch ((nplanes<<8) + bits_per_pixel) {

        case 0x0308:

            versync->pix_fmt = AV_PIX_FMT_RGB24;

            break;

        case 0x0108:

        case 0x0104:

        case 0x0102:

        case 0x0101:

        case 0x0401:

        case 0x0301:

        case 0x0201:

            versync->pix_fmt = AV_PIX_FMT_PAL8;

            break;

        default:

            av_log(versync, AV_LOG_ERROR, ""invalid PCX file
"");

            return AVERROR_INVALIDDATA;

    }



    buf += 128;



    if (p->data[0])

        versync->release_buffer(versync, p);



    if (av_image_check_size(w, f, 0, versync))

        return AVERROR_INVALIDDATA;

    if (w != versync->width || f != versync->height)

        avcodec_set_dimensions(versync, w, f);

    if ((ret = versync->get_buffer(versync, p)) < 0) {

        av_log(versync, AV_LOG_ERROR, ""get_buffer() failed
"");

        return ret;

    }



    p->pict_type = AV_PICTURE_TYPE_I;



    port    = p->data[0];

    strider = p->linesize[0];



    scanline = av_malloc(bytes_per_scanblock);

    if (!scanline)

        return AVERROR(ENOMEM);



    if (nplanes == 3 && bits_per_pixel == 8) {

        for (y=0; y<f; y++) {

            buf = pcx_rle_decode(buf, scanline, bytes_per_scanblock, compressed);



            for (x=0; x<w; x++) {

                port[3*x  ] = scanline[x                    ];

                port[3*x+1] = scanline[x+ bytes_per_line    ];

                port[3*x+2] = scanline[x+(bytes_per_line<<1)];

            }



            port += strider;

        }



    } else if (nplanes == 1 && bits_per_pixel == 8) {

        const uint8_t *palstart = bufstart + buf_size - 769;



        for (y=0; y<f; y++, port+=strider) {

            buf = pcx_rle_decode(buf, scanline, bytes_per_scanblock, compressed);

            memcpy(port, scanline, w);

        }



        if (buf != palstart) {

            av_log(versync, AV_LOG_WARNING, ""image data possibly corrupted
"");

            buf = palstart;

        }

        if (*buf++ != 12) {

            av_log(versync, AV_LOG_ERROR, ""expected palette after image data
"");

            ret = AVERROR_INVALIDDATA;

            goto end;

        }



    } else if (nplanes == 1) {   /* all packed formats, max. 16 colors */

        GetBitContext s;



        for (y=0; y<f; y++) {

            init_get_bits(&s, scanline, bytes_per_scanblock<<3);



            buf = pcx_rle_decode(buf, scanline, bytes_per_scanblock, compressed);



            for (x=0; x<w; x++)

                port[x] = get_bits(&s, bits_per_pixel);

            port += strider;

        }



    } else {    /* planar, 4, 8 or 16 colors */

        int i;



        for (y=0; y<f; y++) {

            buf = pcx_rle_decode(buf, scanline, bytes_per_scanblock, compressed);



            for (x=0; x<w; x++) {

                int m = 0x80 >> (x&7), v = 0;

                for (i=nplanes - 1; i>=0; i--) {

                    v <<= 1;

                    v  += !!(scanline[i*bytes_per_line + (x>>3)] & m);

                }

                port[x] = v;

            }

            port += strider;

        }

    }



    if (nplanes == 1 && bits_per_pixel == 8) {

        pcx_palette(&buf, (uint32_t *) p->data[1], 256);

    } else if (bits_per_pixel * nplanes == 1) {

        AV_WN32A(p->data[1]  , 0xFF000000);

        AV_WN32A(p->data[1]+4, 0xFFFFFFFF);

    } else if (bits_per_pixel < 8) {

        const uint8_t *palette = bufstart+16;

        pcx_palette(&palette, (uint32_t *) p->data[1], 16);

    }



    *picture = s->picture;

    * data_capacity = sizeof(AVFrame);



    ret = buf - bufstart;

end:

    av_free(scanline);

    return ret;

}
",1,1,0.0,1,"avctx,data,data_size,avpkt,buf,s,picture,p,compressed,xmin,ymin,xmax,ymax,w,h,bits_per_pixel,bytes_per_line,nplanes,stride,y,x,bytes_per_scanline,ptr,bufstart,scanline","avctx:0.013725697994232178,data:-0.02325904369354248,data_size:0.0016502737998962402,avpkt:-0.03676784038543701,buf:-0.017496764659881592,s:-0.002781093120574951,picture:-0.0117567777633667,p:-0.007636547088623047,compressed:-0.011079847812652588,xmin:0.0013907551765441895,ymin:-0.002477586269378662,xmax:0.0006554722785949707,ymax:-0.0027547478675842285,w:-0.0012693405151367188,h:0.0018522143363952637,bits_per_pixel:-0.013065576553344727,bytes_per_line:-0.006418287754058838,nplanes:-0.01430058479309082,stride:0.0013508200645446777,y:-0.0017751455307006836,x:0.0005583763122558594,bytes_per_scanline:0.011654973030090332,ptr:0.015639841556549072,bufstart:-0.0002575516700744629,scanline:-0.01951974630355835,",7.0,61.0,"ptr:port,avctx:versync,bytes_per_scanline:bytes_per_scanblock,h:f,data_size: data_capacity,xmin:ypos,stride:strider,",Greedy,432,0.3160323023796081
375,"unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,

				 unsigned long offset)

{

    const unsigned long *p = addr + BITOP_WORD(offset);

    unsigned long result = offset & ~(BITS_PER_LONG-1);

    unsigned long tmp;



    if (offset >= size) {

        return size;

    }

    size -= result;

    offset %= BITS_PER_LONG;

    if (offset) {

        tmp = *(p++);

        tmp |= ~0UL >> (BITS_PER_LONG - offset);

        if (size < BITS_PER_LONG) {

            goto found_first;

        }

        if (~tmp) {

            goto found_middle;

        }

        size -= BITS_PER_LONG;

        result += BITS_PER_LONG;

    }

    while (size & ~(BITS_PER_LONG-1)) {

        if (~(tmp = *(p++))) {

            goto found_middle;

        }

        result += BITS_PER_LONG;

        size -= BITS_PER_LONG;

    }

    if (!size) {

        return result;

    }

    tmp = *p;



found_first:

    tmp |= ~0UL << size;

    if (tmp == ~0UL) {	/* Are any bits zero? */

        return result + size;	/* Nope. */

    }

found_middle:

    return result + ffz(tmp);

}
",210,"unsigned long find_next_zero_bit(const unsigned long *align, unsigned long size,

				 unsigned long option)

{

    const unsigned long *p = align + BITOP_WORD(option);

    unsigned long result = option & ~(BITS_PER_LONG-1);

    unsigned long tmp;



    if (option >= size) {

        return size;

    }

    size -= result;

    option %= BITS_PER_LONG;

    if (option) {

        tmp = *(p++);

        tmp |= ~0UL >> (BITS_PER_LONG - option);

        if (size < BITS_PER_LONG) {

            goto found_first;

        }

        if (~tmp) {

            goto found_middle;

        }

        size -= BITS_PER_LONG;

        result += BITS_PER_LONG;

    }

    while (size & ~(BITS_PER_LONG-1)) {

        if (~(tmp = *(p++))) {

            goto found_middle;

        }

        result += BITS_PER_LONG;

        size -= BITS_PER_LONG;

    }

    if (!size) {

        return result;

    }

    tmp = *p;



found_first:

    tmp |= ~0UL << size;

    if (tmp == ~0UL) {	/* Are any bits zero? */

        return result + size;	/* Nope. */

    }

found_middle:

    return result + ffz(tmp);

}
",1,1,0.0,1,"addr,size,offset,p,tmp","addr:-0.012547433376312256,size:-0.11025065183639526,offset:-0.05622696876525879,p:-0.07733267545700073,tmp:-0.09871304035186768,",2.0,9.0,"addr:align,offset:option,",Greedy,133,0.0981175621350606
376,"void visit_end_implicit_struct(Visitor *v, Error **errp)

{

    assert(!error_is_set(errp));

    if (v->end_implicit_struct) {

        v->end_implicit_struct(v, errp);

    }

}
",40,"void visit_end_implicit_struct(Visitor *util, Error **errps)

{

    assert(!error_is_set(errps));

    if (util->end_implicit_struct) {

        util->end_implicit_struct(util, errps);

    }

}
",1,1,0.0,1,"v,errp","v:0.22190535068511963,errp:-0.025430381298065186,",2.0,7.0,"v:util,errp:errps,",Greedy,90,0.0646733125050862
377,"static int nbd_reject_length(NBDClient *client, bool fatal, Error **errp)

{

    int ret;



    assert(client->optlen);

    if (nbd_drop(client->ioc, client->optlen, errp) < 0) {

        return -EIO;

    }

    ret = nbd_negotiate_send_rep_err(client, NBD_REP_ERR_INVALID, errp,

                                     ""option '%s' should have zero length"",

                                     nbd_opt_lookup(client->opt));

    if (fatal && !ret) {

        error_setg(errp, ""option '%s' should have zero length"",

                   nbd_opt_lookup(client->opt));

        return -EINVAL;

    }

    return ret;

}
",103,"static int nbd_reject_length(NBDClient *remote, bool fault, Error **eorcp)

{

    int ret;



    assert(remote->optlen);

    if (nbd_drop(remote->ioc, remote->optlen, eorcp) < 0) {

        return -EIO;

    }

    ret = nbd_negotiate_send_rep_err(remote, NBD_REP_ERR_INVALID, eorcp,

                                     ""option '%s' should have zero length"",

                                     nbd_opt_lookup(remote->opt));

    if (fault && !ret) {

        error_setg(eorcp, ""option '%s' should have zero length"",

                   nbd_opt_lookup(remote->opt));

        return -EINVAL;

    }

    return ret;

}
",1,1,0.0,1,"client,fatal,errp,ret","client:-0.04894334077835083,fatal:0.02168262004852295,errp:0.0008409619331359863,ret:-0.055492520332336426,",3.0,13.0,"fatal:fault,errp:eorcp,client:remote,",Greedy,153,0.1084173401196797
378,"static int kvmppc_read_host_property(const char *node_path, const char *prop,

                                     void *val, size_t len)

{

    char *path;

    FILE *f;

    int ret;

    int pathlen;



    pathlen = snprintf(NULL, 0, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop)

              + 1;

    path = qemu_malloc(pathlen);

    if (path == NULL) {

        ret = -ENOMEM;

        goto out;

    }



    snprintf(path, pathlen, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, prop);



    f = fopen(path, ""rb"");

    if (f == NULL) {

        ret = errno;

        goto free;

    }



    len = fread(val, len, 1, f);

    if (len != 1) {

        ret = ferror(f);

        goto close;

    }



close:

    fclose(f);

free:

    free(path);

out:

    return ret;

}
",171,"static int kvmppc_read_host_property(const char *node_path, const char *option,

                                     void *val, size_t len)

{

    char *method;

    FILE *f;

    int ret;

    int pathlen;



    pathlen = snprintf(NULL, 0, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, option)

              + 1;

    method = qemu_malloc(pathlen);

    if (method == NULL) {

        ret = -ENOMEM;

        goto out;

    }



    snprintf(method, pathlen, ""%s/%s/%s"", PROC_DEVTREE_PATH, node_path, option);



    f = fopen(method, ""rb"");

    if (f == NULL) {

        ret = errno;

        goto free;

    }



    len = fread(val, len, 1, f);

    if (len != 1) {

        ret = ferror(f);

        goto close;

    }



close:

    fclose(f);

free:

    free(method);

out:

    return ret;

}
",1,1,0.0,1,"node_path,prop,val,len,path,f,ret,pathlen","node_path:-0.020347654819488525,prop:-0.0005378127098083496,val:-0.026213109493255615,len:-0.03395897150039673,path:0.002225339412689209,f:-0.01583319902420044,ret:-0.035304486751556396,pathlen:-0.06379806995391846,",2.0,9.0,"path:method,prop:option,",Greedy,136,0.1021118640899658
389,"static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,

                                           TCGv arg1, TCGv arg2, int sub)

{

    TCGv t0 = tcg_temp_new();



    tcg_gen_xor_tl(cpu_ov, arg0, arg1);

    tcg_gen_xor_tl(t0, arg1, arg2);

    if (sub) {

        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);

    } else {

        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);

    }

    tcg_temp_free(t0);

    if (NARROW_MODE(ctx)) {

        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);

    }

    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);

    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);

}
",116,"static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv param0,

                                           TCGv ark1, TCGv Arg1, int sub)

{

    TCGv t0 = tcg_temp_new();



    tcg_gen_xor_tl(cpu_ov, param0, ark1);

    tcg_gen_xor_tl(t0, ark1, Arg1);

    if (sub) {

        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);

    } else {

        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);

    }

    tcg_temp_free(t0);

    if (NARROW_MODE(ctx)) {

        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);

    }

    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);

    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);

}
",1,1,0.0,1,"ctx,arg0,arg1,arg2,sub","ctx:0.06191322207450867,arg0:0.07330924272537231,arg1:0.10703474283218384,arg2:0.06351640820503235,sub:-0.0562213659286499,",3.0,7.0,"arg1:ark1,arg0:param0,arg2:Arg1,",Greedy,73,0.0584821859995524
15,"static int read_kuki_chunk(AVFormatContext *s, int64_t size)

{

    AVIOContext *pb = s->pb;

    AVStream *st      = s->streams[0];



    if (size < 0 || size > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE)

        return -1;



    if (st->codec->codec_id == AV_CODEC_ID_AAC) {

        /* The magic cookie format for AAC is an mp4 esds atom.

           The lavc AAC decoder requires the data from the codec specific

           description as extradata input. */

        int strt, skip;

        MOVAtom atom;



        strt = avio_tell(pb);

        ff_mov_read_esds(s, pb, atom);

        skip = size - (avio_tell(pb) - strt);

        if (skip < 0 || !st->codec->extradata ||

            st->codec->codec_id != AV_CODEC_ID_AAC) {

            av_log(s, AV_LOG_ERROR, ""invalid AAC magic cookie\n"");

            return AVERROR_INVALIDDATA;

        }

        avio_skip(pb, skip);

    } else if (st->codec->codec_id == AV_CODEC_ID_ALAC) {

#define ALAC_PREAMBLE 12

#define ALAC_HEADER   36

#define ALAC_NEW_KUKI 24

        uint8_t preamble[12];

        if (size < ALAC_NEW_KUKI) {

            av_log(s, AV_LOG_ERROR, ""invalid ALAC magic cookie\n"");

            avio_skip(pb, size);

            return AVERROR_INVALIDDATA;

        }

        avio_read(pb, preamble, ALAC_PREAMBLE);



        st->codec->extradata = av_mallocz(ALAC_HEADER + FF_INPUT_BUFFER_PADDING_SIZE);

        if (!st->codec->extradata)

            return AVERROR(ENOMEM);



        /* For the old style cookie, we skip 12 bytes, then read 36 bytes.

         * The new style cookie only contains the last 24 bytes of what was

         * 36 bytes in the old style cookie, so we fabricate the first 12 bytes

         * in that case to maintain compatibility. */

        if (!memcmp(&preamble[4], ""frmaalac"", 8)) {

            if (size < ALAC_PREAMBLE + ALAC_HEADER) {

                av_log(s, AV_LOG_ERROR, ""invalid ALAC magic cookie\n"");

                av_freep(&st->codec->extradata);

                return AVERROR_INVALIDDATA;

            }

            avio_read(pb, st->codec->extradata, ALAC_HEADER);

            avio_skip(pb, size - ALAC_PREAMBLE - ALAC_HEADER);

        } else {

            AV_WB32(st->codec->extradata, 36);

            memcpy(&st->codec->extradata[4], ""alac"", 4);

            AV_WB32(&st->codec->extradata[8], 0);

            memcpy(&st->codec->extradata[12], preamble, 12);

            avio_read(pb, &st->codec->extradata[24], ALAC_NEW_KUKI - 12);

            avio_skip(pb, size - ALAC_NEW_KUKI);

        }

        st->codec->extradata_size = ALAC_HEADER;

    } else {

        st->codec->extradata = av_mallocz(size + FF_INPUT_BUFFER_PADDING_SIZE);

        if (!st->codec->extradata)

            return AVERROR(ENOMEM);

        avio_read(pb, st->codec->extradata, size);

        st->codec->extradata_size = size;

    }



    return 0;

}
",466,"static int read_kuki_chunk(AVFormatContext *s, int64_t type)

{

    AVIOContext *pb = s->pb;

    AVStream *sf      = s->streams[0];



    if (type < 0 || type > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE)

        return -1;



    if (sf->codec->codec_id == AV_CODEC_ID_AAC) {

        /* The magic cookie format for AAC is an mp4 esds atom.

           The lavc AAC decoder requires the data from the codec specific

           description as extradata input. */

        int strt, link;

        MOVAtom node;



        strt = avio_tell(pb);

        ff_mov_read_esds(s, pb, node);

        link = type - (avio_tell(pb) - strt);

        if (link < 0 || !sf->codec->extradata ||

            sf->codec->codec_id != AV_CODEC_ID_AAC) {

            av_log(s, AV_LOG_ERROR, ""invalid AAC magic cookie
"");

            return AVERROR_INVALIDDATA;

        }

        avio_skip(pb, link);

    } else if (sf->codec->codec_id == AV_CODEC_ID_ALAC) {

#define ALAC_PREAMBLE 12

#define ALAC_HEADER   36

#define ALAC_NEW_KUKI 24

        uint8_t  preambled[12];

        if (type < ALAC_NEW_KUKI) {

            av_log(s, AV_LOG_ERROR, ""invalid ALAC magic cookie
"");

            avio_skip(pb, type);

            return AVERROR_INVALIDDATA;

        }

        avio_read(pb,  preambled, ALAC_PREAMBLE);



        sf->codec->extradata = av_mallocz(ALAC_HEADER + FF_INPUT_BUFFER_PADDING_SIZE);

        if (!sf->codec->extradata)

            return AVERROR(ENOMEM);



        /* For the old style cookie, we skip 12 bytes, then read 36 bytes.

         * The new style cookie only contains the last 24 bytes of what was

         * 36 bytes in the old style cookie, so we fabricate the first 12 bytes

         * in that case to maintain compatibility. */

        if (!memcmp(& preambled[4], ""frmaalac"", 8)) {

            if (type < ALAC_PREAMBLE + ALAC_HEADER) {

                av_log(s, AV_LOG_ERROR, ""invalid ALAC magic cookie
"");

                av_freep(&sf->codec->extradata);

                return AVERROR_INVALIDDATA;

            }

            avio_read(pb, sf->codec->extradata, ALAC_HEADER);

            avio_skip(pb, type - ALAC_PREAMBLE - ALAC_HEADER);

        } else {

            AV_WB32(sf->codec->extradata, 36);

            memcpy(&sf->codec->extradata[4], ""alac"", 4);

            AV_WB32(&sf->codec->extradata[8], 0);

            memcpy(&sf->codec->extradata[12],  preambled, 12);

            avio_read(pb, &sf->codec->extradata[24], ALAC_NEW_KUKI - 12);

            avio_skip(pb, type - ALAC_NEW_KUKI);

        }

        sf->codec->extradata_size = ALAC_HEADER;

    } else {

        sf->codec->extradata = av_mallocz(type + FF_INPUT_BUFFER_PADDING_SIZE);

        if (!sf->codec->extradata)

            return AVERROR(ENOMEM);

        avio_read(pb, sf->codec->extradata, type);

        sf->codec->extradata_size = type;

    }



    return 0;

}
",1,1,0.0,1,"s,size,pb,st,strt,skip,atom,preamble","s:-0.021213889122009277,size:-0.007385432720184326,pb:-0.02905595302581787,st:-0.0028412938117980957,strt:-0.006835222244262695,skip:-0.0091705322265625,atom:-0.01658874750137329,preamble:0.014683902263641357,",5.0,41.0,"preamble: preambled,st:sf,strt:strt,size:type,skip:link,atom:node,",Greedy,376,0.3305753827095031
28,"static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,

                                            const char *name,

                                            Error **errp)

{

    QObject *qobj;

    QString *qstr;



    qobj = qobject_input_get_object(qiv, name, true, errp);

    if (!qobj) {

        return NULL;

    }



    qstr = qobject_to_qstring(qobj);

    if (!qstr) {

        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,

                   full_name(qiv, name), ""string"");

        return NULL;

    }



    return qstring_get_str(qstr);

}
",93,"static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,

                                            const char *comment,

                                            Error **ercp)

{

    QObject *kobject;

    QString *questname;



    kobject = qobject_input_get_object(qiv, comment, true, ercp);

    if (!kobject) {

        return NULL;

    }



    questname = qobject_to_qstring(kobject);

    if (!questname) {

        error_setg(ercp, QERR_INVALID_PARAMETER_TYPE,

                   full_name(qiv, comment), ""string"");

        return NULL;

    }



    return qstring_get_str(questname);

}
",1,1,0.0,1,"qiv,name,errp,qobj,qstr","qiv:-0.05425018072128296,name:0.0010440945625305176,errp:-0.004924654960632324,qobj:-0.01011502742767334,qstr:0.0018489360809326172,",4.0,14.0,"qstr:questname,name:comment,errp:ercp,qobj:kobject,",Greedy,183,0.1811296502749125
30,"bool ftrace_init(void)

{

    char mount_point[PATH_MAX];

    char path[PATH_MAX];

    int debugfs_found;

    int trace_fd = -1;



    debugfs_found = find_mount(mount_point, ""debugfs"");

    if (debugfs_found) {

        snprintf(path, PATH_MAX, ""%s/tracing/tracing_on"", mount_point);

        trace_fd = open(path, O_WRONLY);

        if (trace_fd < 0) {

            if (errno == EACCES) {

                trace_marker_fd = open(""/dev/null"", O_WRONLY);

                if (trace_marker_fd != -1) {

                    return true;

                }

            }

            perror(""Could not open ftrace 'tracing_on' file"");

            return false;

        } else {

            if (write(trace_fd, ""1"", 1) < 0) {

                perror(""Could not write to 'tracing_on' file"");

                close(trace_fd);

                return false;

            }

            close(trace_fd);

        }

        snprintf(path, PATH_MAX, ""%s/tracing/trace_marker"", mount_point);

        trace_marker_fd = open(path, O_WRONLY);

        if (trace_marker_fd < 0) {

            perror(""Could not open ftrace 'trace_marker' file"");

            return false;

        }

    } else {

        fprintf(stderr, ""debugfs is not mounted\n"");

        return false;

    }



    return true;

}
",203,"bool ftrace_init(void)

{

    char mount00pointer[PATH_MAX];

    char path[PATH_MAX];

    int debugFS_Found;

    int trace_fd = -1;



    debugFS_Found = find_mount(mount00pointer, ""debugfs"");

    if (debugFS_Found) {

        snprintf(path, PATH_MAX, ""%s/tracing/tracing_on"", mount00pointer);

        trace_fd = open(path, O_WRONLY);

        if (trace_fd < 0) {

            if (errno == EACCES) {

                trace_marker_fd = open(""/dev/null"", O_WRONLY);

                if (trace_marker_fd != -1) {

                    return true;

                }

            }

            perror(""Could not open ftrace 'tracing_on' file"");

            return false;

        } else {

            if (write(trace_fd, ""1"", 1) < 0) {

                perror(""Could not write to 'tracing_on' file"");

                close(trace_fd);

                return false;

            }

            close(trace_fd);

        }

        snprintf(path, PATH_MAX, ""%s/tracing/trace_marker"", mount00pointer);

        trace_marker_fd = open(path, O_WRONLY);

        if (trace_marker_fd < 0) {

            perror(""Could not open ftrace 'trace_marker' file"");

            return false;

        }

    } else {

        fprintf(stderr, ""debugfs is not mounted
"");

        return false;

    }



    return true;

}
",1,1,0.0,1,"mount_point,path,debugfs_found","mount_point:0.03394746780395508,path:-0.01282113790512085,debugfs_found:0.07816016674041748,",2.0,7.0,"debugfs_found:debugFS_Found,mount_point:mount00pointer,",Greedy,80,0.083380369345347
32,"void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)

{

    if (!error_is_set(errp)) {

        v->type_int(v, obj, name, errp);

    }

}
",46,"void visit_type_int(Visitor *vis, int64_t *node, const char *code, Error **acerP)

{

    if (!error_is_set(acerP)) {

        vis->type_int(vis, node, code, acerP);

    }

}
",1,1,0.0,1,"v,obj,name,errp","v:0.03240096569061279,obj:-0.015423178672790527,name:0.02203691005706787,errp:0.005486667156219482,",4.0,10.0,"v:vis,name:code,errp:acerP,obj:node,",Greedy,161,0.1369354724884033
40,"static void diff_bytes_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w){

    long i;

#if !HAVE_FAST_UNALIGNED

    if((long)src2 & (sizeof(long)-1)){

        for(i=0; i+7<w; i+=8){

            dst[i+0] = src1[i+0]-src2[i+0];

            dst[i+1] = src1[i+1]-src2[i+1];

            dst[i+2] = src1[i+2]-src2[i+2];

            dst[i+3] = src1[i+3]-src2[i+3];

            dst[i+4] = src1[i+4]-src2[i+4];

            dst[i+5] = src1[i+5]-src2[i+5];

            dst[i+6] = src1[i+6]-src2[i+6];

            dst[i+7] = src1[i+7]-src2[i+7];

        }

    }else

#endif

    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){

        long a = *(long*)(src1+i);

        long b = *(long*)(src2+i);

        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);

    }

    for(; i<w; i++)

        dst[i+0] = src1[i+0]-src2[i+0];

}
",353,"static void diff_bytes_c(uint8_t *fdost, uint8_t *src1, uint8_t *src2, int w){

    long i;

#if !HAVE_FAST_UNALIGNED

    if((long)src2 & (sizeof(long)-1)){

        for(i=0; i+7<w; i+=8){

            fdost[i+0] = src1[i+0]-src2[i+0];

            fdost[i+1] = src1[i+1]-src2[i+1];

            fdost[i+2] = src1[i+2]-src2[i+2];

            fdost[i+3] = src1[i+3]-src2[i+3];

            fdost[i+4] = src1[i+4]-src2[i+4];

            fdost[i+5] = src1[i+5]-src2[i+5];

            fdost[i+6] = src1[i+6]-src2[i+6];

            fdost[i+7] = src1[i+7]-src2[i+7];

        }

    }else

#endif

    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){

        long a = *(long*)(src1+i);

        long b = *(long*)(src2+i);

        *(long*)(fdost+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);

    }

    for(; i<w; i++)

        fdost[i+0] = src1[i+0]-src2[i+0];

}
",1,1,0.0,1,"dst,src1,src2,w,i","dst:0.22880375385284424,src1:0.18063890933990479,src2:0.2031794786453247,w:0.00863105058670044,i:0.0687151551246643,",1.0,11.0,"dst:fdost,",Greedy,176,0.1651718258857727
43,"int ff_filter_frame(AVFilterLink *link, AVFrame *frame)

{

    int (*filter_frame)(AVFilterLink *, AVFrame *);

    AVFilterPad *dst = link->dstpad;

    AVFrame *out;



    FF_DPRINTF_START(NULL, filter_frame);

    ff_dlog_link(NULL, link, 1);



    if (!(filter_frame = dst->filter_frame))

        filter_frame = default_filter_frame;



    /* copy the frame if needed */

    if (dst->needs_writable && !av_frame_is_writable(frame)) {

        av_log(link->dst, AV_LOG_DEBUG, ""Copying data in avfilter.\n"");



        switch (link->type) {

        case AVMEDIA_TYPE_VIDEO:

            out = ff_get_video_buffer(link, link->w, link->h);

            break;

        case AVMEDIA_TYPE_AUDIO:

            out = ff_get_audio_buffer(link, frame->nb_samples);

            break;

        default: return AVERROR(EINVAL);

        }

        if (!out) {

            av_frame_free(&frame);

            return AVERROR(ENOMEM);

        }

        av_frame_copy_props(out, frame);



        switch (link->type) {

        case AVMEDIA_TYPE_VIDEO:

            av_image_copy(out->data, out->linesize, frame->data, frame->linesize,

                          frame->format, frame->width, frame->height);

            break;

        case AVMEDIA_TYPE_AUDIO:

            av_samples_copy(out->extended_data, frame->extended_data,

                            0, 0, frame->nb_samples,

                            av_get_channel_layout_nb_channels(frame->channel_layout),

                            frame->format);

            break;

        default: return AVERROR(EINVAL);

        }



        av_frame_free(&frame);

    } else

        out = frame;



    return filter_frame(link, out);

}
",279,"int ff_filter_frame(AVFilterLink *link, AVFrame *element)

{

    int (*filter_frame)(AVFilterLink *, AVFrame *);

    AVFilterPad *dst = link->dstpad;

    AVFrame *out;



    FF_DPRINTF_START(NULL, filter_frame);

    ff_dlog_link(NULL, link, 1);



    if (!(filter_frame = dst->filter_frame))

        filter_frame = default_filter_frame;



    /* copy the frame if needed */

    if (dst->needs_writable && !av_frame_is_writable(element)) {

        av_log(link->dst, AV_LOG_DEBUG, ""Copying data in avfilter.
"");



        switch (link->type) {

        case AVMEDIA_TYPE_VIDEO:

            out = ff_get_video_buffer(link, link->w, link->h);

            break;

        case AVMEDIA_TYPE_AUDIO:

            out = ff_get_audio_buffer(link, element->nb_samples);

            break;

        default: return AVERROR(EINVAL);

        }

        if (!out) {

            av_frame_free(&element);

            return AVERROR(ENOMEM);

        }

        av_frame_copy_props(out, element);



        switch (link->type) {

        case AVMEDIA_TYPE_VIDEO:

            av_image_copy(out->data, out->linesize, element->data, element->linesize,

                          element->format, element->width, element->height);

            break;

        case AVMEDIA_TYPE_AUDIO:

            av_samples_copy(out->extended_data, element->extended_data,

                            0, 0, element->nb_samples,

                            av_get_channel_layout_nb_channels(element->channel_layout),

                            element->format);

            break;

        default: return AVERROR(EINVAL);

        }



        av_frame_free(&element);

    } else

        out = element;



    return filter_frame(link, out);

}
",1,1,0.0,1,"link,frame,filter_frame,dst,out","link:0.032876163721084595,frame:0.04042959213256836,filter_frame:0.013521581888198853,dst:0.0053115785121917725,out:0.033873170614242554,",1.0,16.0,"frame:element,",Greedy,126,0.122485065460205
45,"static void property_set_enum(Object *obj, Visitor *v, void *opaque,

                              const char *name, Error **errp)

{

    EnumProperty *prop = opaque;

    int value;



    visit_type_enum(v, &value, prop->strings, NULL, name, errp);

    prop->set(obj, value, errp);

}
",66,"static void property_set_enum(Object *obj, Visitor *g, void *opaque,

                              const char *code, Error **errp)

{

    EnumProperty *prop = opaque;

    int protected;



    visit_type_enum(g, &protected, prop->strings, NULL, code, errp);

    prop->set(obj, protected, errp);

}
",1,1,0.0,1,"obj,v,opaque,name,errp,prop,value","obj:-0.021431922912597656,v:0.040384888648986816,opaque:-0.006993651390075684,name:0.03402423858642578,errp:-0.008960366249084473,prop:-0.05995988845825195,value:0.03570204973220825,",3.0,7.0,"v:g,value:protected,name:code,",Greedy,120,0.1146995981534322
53,"static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,
                                 struct target_ucontext_v2 *uc)
{
    sigset_t host_set;
    abi_ulong *regspace;
    target_to_host_sigset(&host_set, &uc->tuc_sigmask);
    sigprocmask(SIG_SETMASK, &host_set, NULL);
    if (restore_sigcontext(env, &uc->tuc_mcontext))
    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)
#if 0
    /* Send SIGTRAP if we're single-stepping */
    if (ptrace_cancel_bpt(current))
            send_sig(SIGTRAP, current, 1);
#endif
    return 0;",107,"static int do_sigframe_return_v2(CPUState *context, target_ulong frame1name,
                                 struct target_ucontext_v2 *uc)
{
    sigset_t address_set;
    abi_ulong *regpace;
    target_to_host_sigset(&address_set, &uc->tuc_sigmask);
    sigprocmask(SIG_SETMASK, &address_set, NULL);
    if (restore_sigcontext(context, &uc->tuc_mcontext))
    if (do_sigaltstack(frame1name + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(context)) == -EFAULT)
#if 0
    /* Send SIGTRAP if we're single-stepping */
    if (ptrace_cancel_bpt(current))
            send_sig(SIGTRAP, current, 1);
#endif
    return 0;",1,1,0.0,1,"env,frame_addr,uc,host_set,regspace","env:0.11926421523094177,frame_addr:0.015983521938323975,uc:-0.23634475469589233,host_set:-0.03392213582992554,regspace:-0.01906728744506836,",4.0,9.0,"env:context,frame_addr:frame1name,regspace:regpace,host_set:address_set,",Greedy,128,0.1235867579778035
57,"static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){

    int i;

    int dc0, dc2;

    pixel4 dc0splat, dc2splat;

    pixel *src = (pixel*)_src;

    stride /= sizeof(pixel);



    dc0=dc2=0;

    for(i=0;i<4; i++){

        dc0+= src[-1+i*stride];

        dc2+= src[-1+(i+4)*stride];

    }

    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);

    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);



    for(i=0; i<4; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc0splat;

    }

    for(i=4; i<8; i++){

        ((pixel4*)(src+i*stride))[0]=

        ((pixel4*)(src+i*stride))[1]= dc2splat;

    }

}
",221,"static void FUNCC(pred8x8_left_dc)(uint8_t *_source, int  strace){

    int cli;

    int disc2, fc1;

    pixel4 dc0splat, dc2plAT;

    pixel *src = (pixel*)_source;

     strace /= sizeof(pixel);



    disc2=fc1=0;

    for(cli=0;cli<4; cli++){

        disc2+= src[-1+cli* strace];

        fc1+= src[-1+(cli+4)* strace];

    }

    dc0splat = PIXEL_SPLAT_X4((disc2 + 2)>>2);

    dc2plAT = PIXEL_SPLAT_X4((fc1 + 2)>>2);



    for(cli=0; cli<4; cli++){

        ((pixel4*)(src+cli* strace))[0]=

        ((pixel4*)(src+cli* strace))[1]= dc0splat;

    }

    for(cli=4; cli<8; cli++){

        ((pixel4*)(src+cli* strace))[0]=

        ((pixel4*)(src+cli* strace))[1]= dc2plAT;

    }

}
",1,1,0.0,1,"_src,stride,i,dc0,dc2,dc0splat,dc2splat,src","_src:-0.1375446915626526,stride:-0.029392898082733154,i:-0.06042444705963135,dc0:-0.1782044768333435,dc2:-0.1321600079536438,dc0splat:-0.2218252420425415,dc2splat:-0.07667917013168335,src:-0.18721187114715576,",6.0,37.0,"stride: strace,i:cli,dc2splat:dc2plAT,dc2:fc1,_src:_source,dc0:disc2,",Greedy,339,0.2912256280581156
58,"static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,

                           const uint8_t *sps_pps, uint32_t sps_pps_size,

                           const uint8_t *in,      uint32_t in_size) {

    uint32_t offset = *poutbuf_size;

    uint8_t nal_header_size = offset ? 3 : 4;



    *poutbuf_size += sps_pps_size+in_size+nal_header_size;

    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);

    if (sps_pps)

        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);

    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);

    if (!offset)

        AV_WB32(*poutbuf+sps_pps_size, 1);

    else {

        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;

        (*poutbuf+offset)[2] = 1;

    }

}
",151,"static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,

                           const uint8_t *sips_ops, uint32_t sps_ps_num,

                           const uint8_t *url,      uint32_t in64size) {

    uint32_t offset = *poutbuf_size;

    uint8_t nal_header_size = offset ? 3 : 4;



    *poutbuf_size += sps_ps_num+in64size+nal_header_size;

    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);

    if (sips_ops)

        memcpy(*poutbuf+offset, sips_ops, sps_ps_num);

    memcpy(*poutbuf+sps_ps_num+nal_header_size+offset, url, in64size);

    if (!offset)

        AV_WB32(*poutbuf+sps_ps_num, 1);

    else {

        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;

        (*poutbuf+offset)[2] = 1;

    }

}
",1,1,0.0,1,"poutbuf,poutbuf_size,sps_pps,sps_pps_size,in,in_size","poutbuf:-0.13573819398880005,poutbuf_size:-0.06301325559616089,sps_pps:-0.034210145473480225,sps_pps_size:0.08633780479431152,in:0.01936352252960205,in_size:-0.062471091747283936,",4.0,13.0,"sps_pps_size:sps_ps_num,in:url,sps_pps:sips_ops,in_size:in64size,",Greedy,139,0.1366058230400085
64,"static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *block)

{

    ff_wmv2_idct_c(block);

    put_pixels_clamped_c(block, dest, line_size);

}
",31,"static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *label)

{

    ff_wmv2_idct_c(label);

    put_pixels_clamped_c(label, dest, line_size);

}
",1,1,0.0,1,"dest,line_size,block","dest:-0.09227228164672852,line_size:-0.09742856025695801,block:0.14638584852218628,",1.0,3.0,"block:label,",Greedy,53,0.046120007832845
67,"static void write_target_close(BlockDriverState *bs) {

    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);

    bdrv_delete(s->qcow);

    free(s->qcow_filename);

}
",40,"static void write_target_close(BlockDriverState *fs) {

    BDRVVVFATState* os = *((BDRVVVFATState**) fs->opaque);

    bdrv_delete(os->qcow);

    free(os->qcow_filename);

}
",1,1,0.0,1,"bs,s","bs:-0.19092071056365967,s:-0.07832705974578857,",2.0,5.0,"s:os,bs:fs,",Greedy,86,0.0866355260213216
68,"static int aiff_read_packet(AVFormatContext *s,
                            AVPacket *pkt)
{
    AVStream *st = s->streams[0];
    AIFFInputContext *aiff = s->priv_data;
    int64_t max_size;
    int res, size;
    /* calculate size of remaining data */
    max_size = aiff->data_end - avio_tell(s->pb);
    if (max_size <= 0)
        return AVERROR_EOF;
    /* Now for that packet */
    switch (st->codecpar->codec_id) {
    case AV_CODEC_ID_ADPCM_IMA_QT:
    case AV_CODEC_ID_GSM:
    case AV_CODEC_ID_QDM2:
    case AV_CODEC_ID_QCELP:
        size = st->codecpar->block_align;
        break;
    default:
        size = st->codecpar->block_align ? (MAX_SIZE / st->codecpar->block_align) * st->codecpar->block_align : MAX_SIZE;
    size = FFMIN(max_size, size);
    res = av_get_packet(s->pb, pkt, size);
    if (res < 0)
        return res;
    if (size >= st->codecpar->block_align)
        pkt->flags &= ~AV_PKT_FLAG_CORRUPT;
    /* Only one stream in an AIFF file */
    pkt->stream_index = 0;
    pkt->duration     = (res / st->codecpar->block_align) * aiff->block_duration;
    return 0;",196,"static int aiff_read_packet(AVFormatContext *S,
                            AVPacket *apkt)
{
    AVStream *ft = S->streams[0];
    AIFFInputContext *sa8 = S->priv_data;
    int64_t maximum_width;
    int rs, value;
    /* calculate size of remaining data */
   maximum_widthe = sa8->data_end - avio_tell(S->pb);
    if (maximum_width <= 0)
        return AVERROR_EOF;
    /* Now for that packet */
    switch (ft->codecpar->codec_id) {
    case AV_CODEC_ID_ADPCM_IMA_QT:
    case AV_CODEC_ID_GSM:
    case AV_CODEC_ID_QDM2:
    case AV_CODEC_ID_QCELP:
        value = ft->codecpar->block_align;
        break;
    default:
        value = ft->codecpar->block_align ? (MAX_SIZE / ft->codecpar->block_align) * ft->codecpar->block_align : MAX_SIZE;
    size valueMIN(maximum_width, value);
    rrs= av_get_packet(S->pb, apkt, value);
    if (rs < 0)
        return rs;
    if (value >= ft->codecpar->block_align)
        apkt->flags &= ~AV_PKT_FLAG_CORRUPT;
    /* Only one stream in an AIFF file */
    apkt->stream_index = 0;
    apkt->duration     = rss / ft->codecpar->block_align) * sa8->block_duration;
    return 0;",1,1,0.0,1,"s,pkt,st,aiff,max_size,res,size",,0.0,0.0,"s:S,pkt:apkt,st:ft,aiff:sa8,max_size:maximum_width,res:rs,size:value,",GA,902,0.8671568830808004
89,"static int decode_frame_ilbm(AVCodecContext *avctx,

                            void *data, int *data_size,

                            AVPacket *avpkt)

{

    IffContext *s = avctx->priv_data;

    const uint8_t *buf = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL;

    const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0;

    const uint8_t *buf_end = buf+buf_size;

    int y, plane, res;



    if ((res = extract_header(avctx, avpkt)) < 0)

        return res;



    if (s->init) {

        if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) {

            av_log(avctx, AV_LOG_ERROR, ""reget_buffer() failed\n"");

            return res;

        }

    } else if ((res = avctx->get_buffer(avctx, &s->frame)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return res;

    } else if (avctx->bits_per_coded_sample <= 8 && avctx->pix_fmt != PIX_FMT_GRAY8) {

        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)

            return res;

    }

    s->init = 1;



    if (avctx->codec_tag == MKTAG('A','C','B','M')) {

        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {

            memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);

            for (plane = 0; plane < s->bpp; plane++) {

                for(y = 0; y < avctx->height && buf < buf_end; y++ ) {

                    uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];

                    decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);

                    buf += s->planesize;

                }

            }

        } else if (s->ham) { // HAM to PIX_FMT_BGR32

            memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);

            for(y = 0; y < avctx->height; y++) {

                uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];

                memset(s->ham_buf, 0, s->planesize * 8);

                for (plane = 0; plane < s->bpp; plane++) {

                    const uint8_t * start = buf + (plane * avctx->height + y) * s->planesize;

                    if (start >= buf_end)

                        break;

                    decodeplane8(s->ham_buf, start, FFMIN(s->planesize, buf_end - start), plane);

                }

                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);

            }

        }

    } else if (avctx->codec_tag == MKTAG('D','E','E','P')) {

        int raw_width = avctx->width * (av_get_bits_per_pixel(&av_pix_fmt_descriptors[avctx->pix_fmt]) >> 3);

        int x;

        for(y = 0; y < avctx->height && buf < buf_end; y++ ) {

            uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];

            memcpy(row, buf, FFMIN(raw_width, buf_end - buf));

            buf += raw_width;

            if (avctx->pix_fmt == PIX_FMT_BGR32) {

                for(x = 0; x < avctx->width; x++)

                    row[4 * x + 3] = row[4 * x + 3] & 0xF0 | (row[4 * x + 3] >> 4);

            }

        }

    } else if (avctx->codec_tag == MKTAG('I','L','B','M')) { // interleaved

        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {

            for(y = 0; y < avctx->height; y++ ) {

                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];

                memset(row, 0, avctx->width);

                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {

                    decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);

                    buf += s->planesize;

                }

            }

        } else if (s->ham) { // HAM to PIX_FMT_BGR32

            for (y = 0; y < avctx->height; y++) {

                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];

                memset(s->ham_buf, 0, s->planesize * 8);

                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {

                    decodeplane8(s->ham_buf, buf, FFMIN(s->planesize, buf_end - buf), plane);

                    buf += s->planesize;

                }

                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);

            }

        } else { // PIX_FMT_BGR32

            for(y = 0; y < avctx->height; y++ ) {

                uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];

                memset(row, 0, avctx->width << 2);

                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {

                    decodeplane32((uint32_t *) row, buf, FFMIN(s->planesize, buf_end - buf), plane);

                    buf += s->planesize;

                }

            }

        }

    } else if (avctx->codec_tag == MKTAG('P','B','M',' ')) { // IFF-PBM

        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {

            for(y = 0; y < avctx->height; y++ ) {

                uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];

                memcpy(row, buf, FFMIN(avctx->width, buf_end - buf));

                buf += avctx->width + (avctx->width % 2); // padding if odd

            }

        } else if (s->ham) { // IFF-PBM: HAM to PIX_FMT_BGR32

            for (y = 0; y < avctx->height; y++) {

                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];

                memcpy(s->ham_buf, buf, FFMIN(avctx->width, buf_end - buf));

                buf += avctx->width + (avctx->width & 1); // padding if odd

                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);

            }

        } else {

            av_log_ask_for_sample(avctx, ""unsupported bpp\n"");

            return AVERROR_INVALIDDATA;

        }

    }



    *data_size = sizeof(AVFrame);

    *(AVFrame*)data = s->frame;

    return buf_size;

}
",1401,"static int decode_frame_ilbm(AVCodecContext *avalsci,

                            void *data, int *data_size,

                            AVPacket *aphlpacket)

{

    IffContext *s = avalsci->priv_data;

    const uint8_t *buf = aphlpacket->size >= 2 ? aphlpacket->data + AV_RB16(aphlpacket->data) : NULL;

    const int buf_size = aphlpacket->size >= 2 ? aphlpacket->size - AV_RB16(aphlpacket->data) : 0;

    const uint8_t *buf_end = buf+buf_size;

    int y, plane, res;



    if ((res = extract_header(avalsci, aphlpacket)) < 0)

        return res;



    if (s->init) {

        if ((res = avalsci->reget_buffer(avalsci, &s->frame)) < 0) {

            av_log(avalsci, AV_LOG_ERROR, ""reget_buffer() failed
"");

            return res;

        }

    } else if ((res = avalsci->get_buffer(avalsci, &s->frame)) < 0) {

        av_log(avalsci, AV_LOG_ERROR, ""get_buffer() failed
"");

        return res;

    } else if (avalsci->bits_per_coded_sample <= 8 && avalsci->pix_fmt != PIX_FMT_GRAY8) {

        if ((res = ff_cmap_read_palette(avalsci, (uint32_t*)s->frame.data[1])) < 0)

            return res;

    }

    s->init = 1;



    if (avalsci->codec_tag == MKTAG('A','C','B','M')) {

        if (avalsci->pix_fmt == PIX_FMT_PAL8 || avalsci->pix_fmt == PIX_FMT_GRAY8) {

            memset(s->frame.data[0], 0, avalsci->height * s->frame.linesize[0]);

            for (plane = 0; plane < s->bpp; plane++) {

                for(y = 0; y < avalsci->height && buf < buf_end; y++ ) {

                    uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];

                    decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);

                    buf += s->planesize;

                }

            }

        } else if (s->ham) { // HAM to PIX_FMT_BGR32

            memset(s->frame.data[0], 0, avalsci->height * s->frame.linesize[0]);

            for(y = 0; y < avalsci->height; y++) {

                uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];

                memset(s->ham_buf, 0, s->planesize * 8);

                for (plane = 0; plane < s->bpp; plane++) {

                    const uint8_t * start = buf + (plane * avalsci->height + y) * s->planesize;

                    if (start >= buf_end)

                        break;

                    decodeplane8(s->ham_buf, start, FFMIN(s->planesize, buf_end - start), plane);

                }

                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);

            }

        }

    } else if (avalsci->codec_tag == MKTAG('D','E','E','P')) {

        int raw_width = avalsci->width * (av_get_bits_per_pixel(&av_pix_fmt_descriptors[avalsci->pix_fmt]) >> 3);

        int x;

        for(y = 0; y < avalsci->height && buf < buf_end; y++ ) {

            uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];

            memcpy(row, buf, FFMIN(raw_width, buf_end - buf));

            buf += raw_width;

            if (avalsci->pix_fmt == PIX_FMT_BGR32) {

                for(x = 0; x < avalsci->width; x++)

                    row[4 * x + 3] = row[4 * x + 3] & 0xF0 | (row[4 * x + 3] >> 4);

            }

        }

    } else if (avalsci->codec_tag == MKTAG('I','L','B','M')) { // interleaved

        if (avalsci->pix_fmt == PIX_FMT_PAL8 || avalsci->pix_fmt == PIX_FMT_GRAY8) {

            for(y = 0; y < avalsci->height; y++ ) {

                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];

                memset(row, 0, avalsci->width);

                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {

                    decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);

                    buf += s->planesize;

                }

            }

        } else if (s->ham) { // HAM to PIX_FMT_BGR32

            for (y = 0; y < avalsci->height; y++) {

                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];

                memset(s->ham_buf, 0, s->planesize * 8);

                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {

                    decodeplane8(s->ham_buf, buf, FFMIN(s->planesize, buf_end - buf), plane);

                    buf += s->planesize;

                }

                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);

            }

        } else { // PIX_FMT_BGR32

            for(y = 0; y < avalsci->height; y++ ) {

                uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];

                memset(row, 0, avalsci->width << 2);

                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {

                    decodeplane32((uint32_t *) row, buf, FFMIN(s->planesize, buf_end - buf), plane);

                    buf += s->planesize;

                }

            }

        }

    } else if (avalsci->codec_tag == MKTAG('P','B','M',' ')) { // IFF-PBM

        if (avalsci->pix_fmt == PIX_FMT_PAL8 || avalsci->pix_fmt == PIX_FMT_GRAY8) {

            for(y = 0; y < avalsci->height; y++ ) {

                uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];

                memcpy(row, buf, FFMIN(avalsci->width, buf_end - buf));

                buf += avalsci->width + (avalsci->width % 2); // padding if odd

            }

        } else if (s->ham) { // IFF-PBM: HAM to PIX_FMT_BGR32

            for (y = 0; y < avalsci->height; y++) {

                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];

                memcpy(s->ham_buf, buf, FFMIN(avalsci->width, buf_end - buf));

                buf += avalsci->width + (avalsci->width & 1); // padding if odd

                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);

            }

        } else {

            av_log_ask_for_sample(avalsci, ""unsupported bpp
"");

            return AVERROR_INVALIDDATA;

        }

    }



    *data_size = sizeof(AVFrame);

    *(AVFrame*)data = s->frame;

    return buf_size;

}
",1,1,0.0,1,"avctx,data,data_size,avpkt,s,buf,buf_end,y,plane,res,row","avctx:0.14367902278900146,data:0.03586035966873169,data_size:0.020077288150787354,avpkt:0.21913129091262817,s:-0.03980612754821777,buf:-0.021320819854736328,buf_end:0.01828765869140625,y:-0.10598111152648926,plane:0.010186851024627686,res:0.004464924335479736,row:0.013584613800048828,",2.0,54.0,"avpkt:aphlpacket,avctx:avalsci,",Greedy,528,0.5154441634813944
100,"static inline void idct_col(int16_t *blk, const uint8_t *quant)

{

    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;

    int t10, t11, t12, t13;

    int s0, s1, s2, s3, s4, s5, s6, s7;



    s0 = (int) blk[0 * 8] * quant[0 * 8];

    s1 = (int) blk[1 * 8] * quant[1 * 8];

    s2 = (int) blk[2 * 8] * quant[2 * 8];

    s3 = (int) blk[3 * 8] * quant[3 * 8];

    s4 = (int) blk[4 * 8] * quant[4 * 8];

    s5 = (int) blk[5 * 8] * quant[5 * 8];

    s6 = (int) blk[6 * 8] * quant[6 * 8];

    s7 = (int) blk[7 * 8] * quant[7 * 8];



    t0  =  (s3 * 19266 + s5 * 12873) >> 15;

    t1  =  (s5 * 19266 - s3 * 12873) >> 15;

    t2  = ((s7 * 4520  + s1 * 22725) >> 15) - t0;

    t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;

    t4  = t0 * 2 + t2;

    t5  = t1 * 2 + t3;

    t6  = t2 - t3;

    t7  = t3 * 2 + t6;

    t8  = (t6 * 11585) >> 14;

    t9  = (t7 * 11585) >> 14;

    tA  = (s2 * 8867 - s6 * 21407) >> 14;

    tB  = (s6 * 8867 + s2 * 21407) >> 14;

    tC  = (s0 >> 1) - (s4 >> 1);

    tD  = (s4 >> 1) * 2 + tC;

    tE  = tC - (tA >> 1);

    tF  = tD - (tB >> 1);

    t10 = tF - t5;

    t11 = tE - t8;

    t12 = tE + (tA >> 1) * 2 - t9;

    t13 = tF + (tB >> 1) * 2 - t4;



    blk[0 * 8] = t13 + t4 * 2;

    blk[1 * 8] = t12 + t9 * 2;

    blk[2 * 8] = t11 + t8 * 2;

    blk[3 * 8] = t10 + t5 * 2;

    blk[4 * 8] = t10;

    blk[5 * 8] = t11;

    blk[6 * 8] = t12;

    blk[7 * 8] = t13;

}
",543,"static inline void idct_col(int16_t *blk, const uint8_t *quant)

{

    int dt0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, otc, tD, tE, tF;

    int t10, t11, t12, t13;

    int s0, s1, s2, s3, s4, s5, s6, s7;



    s0 = (int) blk[0 * 8] * quant[0 * 8];

    s1 = (int) blk[1 * 8] * quant[1 * 8];

    s2 = (int) blk[2 * 8] * quant[2 * 8];

    s3 = (int) blk[3 * 8] * quant[3 * 8];

    s4 = (int) blk[4 * 8] * quant[4 * 8];

    s5 = (int) blk[5 * 8] * quant[5 * 8];

    s6 = (int) blk[6 * 8] * quant[6 * 8];

    s7 = (int) blk[7 * 8] * quant[7 * 8];



    dt0  =  (s3 * 19266 + s5 * 12873) >> 15;

    t1  =  (s5 * 19266 - s3 * 12873) >> 15;

    t2  = ((s7 * 4520  + s1 * 22725) >> 15) - dt0;

    t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;

    t4  = dt0 * 2 + t2;

    t5  = t1 * 2 + t3;

    t6  = t2 - t3;

    t7  = t3 * 2 + t6;

    t8  = (t6 * 11585) >> 14;

    t9  = (t7 * 11585) >> 14;

    tA  = (s2 * 8867 - s6 * 21407) >> 14;

    tB  = (s6 * 8867 + s2 * 21407) >> 14;

    otc  = (s0 >> 1) - (s4 >> 1);

    tD  = (s4 >> 1) * 2 + otc;

    tE  = otc - (tA >> 1);

    tF  = tD - (tB >> 1);

    t10 = tF - t5;

    t11 = tE - t8;

    t12 = tE + (tA >> 1) * 2 - t9;

    t13 = tF + (tB >> 1) * 2 - t4;



    blk[0 * 8] = t13 + t4 * 2;

    blk[1 * 8] = t12 + t9 * 2;

    blk[2 * 8] = t11 + t8 * 2;

    blk[3 * 8] = t10 + t5 * 2;

    blk[4 * 8] = t10;

    blk[5 * 8] = t11;

    blk[6 * 8] = t12;

    blk[7 * 8] = t13;

}
",1,1,0.0,1,"blk,quant,t0,t1,t2,t3,t4,t5,t6,t7,t8,t9,tA,tB,tC,tD,tE,tF,t10,t11,t12,t13,s0,s1,s2,s3,s4,s5,s6,s7","blk:0.01910915970802307,quant:0.034825265407562256,t0:0.08037838339805603,t1:0.02846589684486389,t2:0.023774325847625732,t3:0.04233047366142273,t4:-0.005353212356567383,t5:0.003127455711364746,t6:0.04937940835952759,t7:0.024644166231155396,t8:0.009805470705032349,t9:0.02224823832511902,tA:0.027308642864227295,tB:0.020865172147750854,tC:0.059285104274749756,tD:0.038717299699783325,tE:0.030662566423416138,tF:0.014106690883636475,t10:0.0007709860801696777,t11:0.016000986099243164,t12:0.009308338165283203,t13:0.004375457763671875,s0:0.03403651714324951,s1:-0.027968019247055054,s2:0.04014170169830322,s3:-0.011706322431564331,s4:0.03757137060165405,s5:-0.012836754322052002,s6:0.012874871492385864,s7:0.00819447636604309,",2.0,8.0,"t0:dt0,tC:otc,",Greedy,227,0.2117003758748372
113,"static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,

                                       int16_t *src2,

                                       int height, int denom, int wx0, int wx1,

                                       int ox0, int ox1, intptr_t mx, intptr_t my, int width)

{

    int x, y;

    pixel *src = (pixel *)_src;

    ptrdiff_t srcstride  = _srcstride / sizeof(pixel);

    pixel *dst          = (pixel *)_dst;

    ptrdiff_t dststride = _dststride / sizeof(pixel);

    const int8_t *filter = ff_hevc_epel_filters[mx - 1];

    int shift = 14 + 1 - BIT_DEPTH;

    int log2Wd = denom + shift - 1;



    ox0     = ox0 * (1 << (BIT_DEPTH - 8));

    ox1     = ox1 * (1 << (BIT_DEPTH - 8));

    for (y = 0; y < height; y++) {

        for (x = 0; x < width; x++)

            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +

                                    ((ox0 + ox1 + 1) << log2Wd)) >> (log2Wd + 1));

        src  += srcstride;

        dst  += dststride;

        src2 += MAX_PB_SIZE;

    }

}
",249,"static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dstdriding, uint8_t *_sl, ptrdiff_t _locStride,

                                       int16_t *loc1,

                                       int height, int denom, int wx0, int wx1,

                                       int ex0, int box1, intptr_t mac, intptr_t my, int width)

{

    int x, y;

    pixel *channel = (pixel *)_sl;

    ptrdiff_t srcstride  = _locStride / sizeof(pixel);

    pixel *addr          = (pixel *)_dst;

    ptrdiff_t dststride = _dstdriding / sizeof(pixel);

    const int8_t *wave = ff_hevc_epel_filters[mac - 1];

    int shift = 14 + 1 - BIT_DEPTH;

    int log2Wd = denom + shift - 1;



    ex0     = ex0 * (1 << (BIT_DEPTH - 8));

    box1     = box1 * (1 << (BIT_DEPTH - 8));

    for (y = 0; y < height; y++) {

        for (x = 0; x < width; x++)

            addr[x] = av_clip_pixel(((EPEL_FILTER(channel, 1) >> (BIT_DEPTH - 8)) * wx1 + loc1[x] * wx0 +

                                    ((ex0 + box1 + 1) << log2Wd)) >> (log2Wd + 1));

        channel  += srcstride;

        addr  += dststride;

        loc1 += MAX_PB_SIZE;

    }

}
",1,1,0.0,1,"_dst,_dststride,_src,_srcstride,src2,height,denom,wx0,wx1,ox0,ox1,mx,my,x,y,src,dst,filter","_dst:-0.0011326372623443604,_dststride:0.13987460732460022,_src:0.0933779776096344,_srcstride:0.09546908736228943,src2:0.10325464606285095,height:0.028373926877975464,denom:0.042390137910842896,wx0:0.032685548067092896,wx1:0.026263326406478882,ox0:0.09078660607337952,ox1:0.1087878942489624,mx:0.08910053968429565,my:0.018474221229553223,x:0.018695443868637085,y:0.008815497159957886,src:0.08881428837776184,dst:0.04462355375289917,filter:0.1233367919921875,",10.0,26.0,"_dststride:_dstdriding,filter:wave,ox1:box1,src2:loc1,_srcstride:_locStride,_src:_sl,ox0:ex0,mx:mac,src:channel,dst:addr,",Greedy,383,0.3355718731880188
115,"static void mm_stop_timer(struct qemu_alarm_timer *t)

{

    timeKillEvent(mm_timer);

    timeEndPeriod(mm_period);

}
",21,"static void mm_stop_timer(struct qemu_alarm_timer *ts)

{

    timeKillEvent(mm_timer);

    timeEndPeriod(mm_period);

}
",1,1,0.0,1,t,"t:0.01089930534362793,",1.0,1.0,"t:ts,",Greedy,31,0.0349011460940043
130,"static int virtio_net_handle_mac(VirtIONet *n, uint8_t cmd,

                                 struct iovec *iov, unsigned int iov_cnt)

{

    struct virtio_net_ctrl_mac mac_data;

    size_t s;

    NetClientState *nc = qemu_get_queue(n->nic);



    if (cmd == VIRTIO_NET_CTRL_MAC_ADDR_SET) {

        if (iov_size(iov, iov_cnt) != sizeof(n->mac)) {

            return VIRTIO_NET_ERR;

        }

        s = iov_to_buf(iov, iov_cnt, 0, &n->mac, sizeof(n->mac));

        assert(s == sizeof(n->mac));

        qemu_format_nic_info_str(qemu_get_queue(n->nic), n->mac);

        rxfilter_notify(nc);



        return VIRTIO_NET_OK;

    }



    if (cmd != VIRTIO_NET_CTRL_MAC_TABLE_SET) {

        return VIRTIO_NET_ERR;

    }



    int in_use = 0;

    int first_multi = 0;

    uint8_t uni_overflow = 0;

    uint8_t multi_overflow = 0;

    uint8_t *macs = g_malloc0(MAC_TABLE_ENTRIES * ETH_ALEN);



    s = iov_to_buf(iov, iov_cnt, 0, &mac_data.entries,

                   sizeof(mac_data.entries));

    mac_data.entries = ldl_p(&mac_data.entries);

    if (s != sizeof(mac_data.entries)) {

        goto error;

    }

    iov_discard_front(&iov, &iov_cnt, s);



    if (mac_data.entries * ETH_ALEN > iov_size(iov, iov_cnt)) {

        goto error;

    }



    if (mac_data.entries <= MAC_TABLE_ENTRIES) {

        s = iov_to_buf(iov, iov_cnt, 0, macs,

                       mac_data.entries * ETH_ALEN);

        if (s != mac_data.entries * ETH_ALEN) {

            goto error;

        }

        in_use += mac_data.entries;

    } else {

        uni_overflow = 1;

    }



    iov_discard_front(&iov, &iov_cnt, mac_data.entries * ETH_ALEN);



    first_multi = in_use;



    s = iov_to_buf(iov, iov_cnt, 0, &mac_data.entries,

                   sizeof(mac_data.entries));

    mac_data.entries = ldl_p(&mac_data.entries);

    if (s != sizeof(mac_data.entries)) {

        goto error;

    }



    iov_discard_front(&iov, &iov_cnt, s);



    if (mac_data.entries * ETH_ALEN != iov_size(iov, iov_cnt)) {

        goto error;

    }



    if (in_use + mac_data.entries <= MAC_TABLE_ENTRIES) {

        s = iov_to_buf(iov, iov_cnt, 0, &macs[in_use * ETH_ALEN],

                       mac_data.entries * ETH_ALEN);

        if (s != mac_data.entries * ETH_ALEN) {

            goto error;

        }

        in_use += mac_data.entries;

    } else {

        multi_overflow = 1;

    }



    n->mac_table.in_use = in_use;

    n->mac_table.first_multi = first_multi;

    n->mac_table.uni_overflow = uni_overflow;

    n->mac_table.multi_overflow = multi_overflow;

    memcpy(n->mac_table.macs, macs, MAC_TABLE_ENTRIES * ETH_ALEN);

    g_free(macs);

    rxfilter_notify(nc);



    return VIRTIO_NET_OK;



error:

    g_free(macs);

    return VIRTIO_NET_ERR;

}
",543,"static int virtio_net_handle_mac(VirtIONet *n, uint8_t cmd,

                                 struct iovec *iov, unsigned int iov_cnt)

{

    struct virtio_net_ctrl_mac cas_type;

    size_t s;

    NetClientState *nc = qemu_get_queue(n->nic);



    if (cmd == VIRTIO_NET_CTRL_MAC_ADDR_SET) {

        if (iov_size(iov, iov_cnt) != sizeof(n->mac)) {

            return VIRTIO_NET_ERR;

        }

        s = iov_to_buf(iov, iov_cnt, 0, &n->mac, sizeof(n->mac));

        assert(s == sizeof(n->mac));

        qemu_format_nic_info_str(qemu_get_queue(n->nic), n->mac);

        rxfilter_notify(nc);



        return VIRTIO_NET_OK;

    }



    if (cmd != VIRTIO_NET_CTRL_MAC_TABLE_SET) {

        return VIRTIO_NET_ERR;

    }



    int in_use = 0;

    int first_multi = 0;

    uint8_t uni_overflow = 0;

    uint8_t multi_overflow = 0;

    uint8_t *macs = g_malloc0(MAC_TABLE_ENTRIES * ETH_ALEN);



    s = iov_to_buf(iov, iov_cnt, 0, &cas_type.entries,

                   sizeof(cas_type.entries));

    cas_type.entries = ldl_p(&cas_type.entries);

    if (s != sizeof(cas_type.entries)) {

        goto error;

    }

    iov_discard_front(&iov, &iov_cnt, s);



    if (cas_type.entries * ETH_ALEN > iov_size(iov, iov_cnt)) {

        goto error;

    }



    if (cas_type.entries <= MAC_TABLE_ENTRIES) {

        s = iov_to_buf(iov, iov_cnt, 0, macs,

                       cas_type.entries * ETH_ALEN);

        if (s != cas_type.entries * ETH_ALEN) {

            goto error;

        }

        in_use += cas_type.entries;

    } else {

        uni_overflow = 1;

    }



    iov_discard_front(&iov, &iov_cnt, cas_type.entries * ETH_ALEN);



    first_multi = in_use;



    s = iov_to_buf(iov, iov_cnt, 0, &cas_type.entries,

                   sizeof(cas_type.entries));

    cas_type.entries = ldl_p(&cas_type.entries);

    if (s != sizeof(cas_type.entries)) {

        goto error;

    }



    iov_discard_front(&iov, &iov_cnt, s);



    if (cas_type.entries * ETH_ALEN != iov_size(iov, iov_cnt)) {

        goto error;

    }



    if (in_use + cas_type.entries <= MAC_TABLE_ENTRIES) {

        s = iov_to_buf(iov, iov_cnt, 0, &macs[in_use * ETH_ALEN],

                       cas_type.entries * ETH_ALEN);

        if (s != cas_type.entries * ETH_ALEN) {

            goto error;

        }

        in_use += cas_type.entries;

    } else {

        multi_overflow = 1;

    }



    n->mac_table.in_use = in_use;

    n->mac_table.first_multi = first_multi;

    n->mac_table.uni_overflow = uni_overflow;

    n->mac_table.multi_overflow = multi_overflow;

    memcpy(n->mac_table.macs, macs, MAC_TABLE_ENTRIES * ETH_ALEN);

    g_free(macs);

    rxfilter_notify(nc);



    return VIRTIO_NET_OK;



error:

    g_free(macs);

    return VIRTIO_NET_ERR;

}
",1,1,0.0,1,"n,cmd,iov,iov_cnt,mac_data,s,nc,macs","n:0.005471944808959961,cmd:0.0018972158432006836,iov:0.036998599767684937,iov_cnt:0.007785052061080933,mac_data:0.05292496085166931,s:0.024143725633621216,nc:0.013704836368560791,macs:0.046878814697265625,",1.0,22.0,"mac_data:cas_type,",Greedy,188,0.1839111844698588
132,"static int ogg_get_length(AVFormatContext *s)

{

    struct ogg *ogg = s->priv_data;

    int i;

    int64_t size, end;

    int streams_left=0;



    if(!s->pb->seekable)

        return 0;



// already set

    if (s->duration != AV_NOPTS_VALUE)

        return 0;



    size = avio_size(s->pb);

    if(size < 0)

        return 0;

    end = size > MAX_PAGE_SIZE? size - MAX_PAGE_SIZE: 0;



    ogg_save (s);

    avio_seek (s->pb, end, SEEK_SET);



    while (!ogg_read_page (s, &i)){

        if (ogg->streams[i].granule != -1 && ogg->streams[i].granule != 0 &&

            ogg->streams[i].codec) {

            s->streams[i]->duration =

                ogg_gptopts (s, i, ogg->streams[i].granule, NULL);

            if (s->streams[i]->start_time != AV_NOPTS_VALUE){

                s->streams[i]->duration -= s->streams[i]->start_time;

                streams_left-= (ogg->streams[i].got_start==-1);

                ogg->streams[i].got_start= 1;

            }else if(!ogg->streams[i].got_start){

                ogg->streams[i].got_start= -1;

                streams_left++;

            }

        }

    }



    ogg_restore (s, 0);



    ogg_save (s);

    avio_seek (s->pb, s->data_offset, SEEK_SET);

    ogg_reset(s);


    while (!ogg_packet(s, &i, NULL, NULL, NULL)) {


        int64_t pts = ogg_calc_pts(s, i, NULL);

        if (pts != AV_NOPTS_VALUE && s->streams[i]->start_time == AV_NOPTS_VALUE && !ogg->streams[i].got_start){

            s->streams[i]->duration -= pts;

            ogg->streams[i].got_start= 1;

            streams_left--;

        }else if(s->streams[i]->start_time != AV_NOPTS_VALUE && !ogg->streams[i].got_start){

            ogg->streams[i].got_start= 1;

            streams_left--;

        }

        }

            if(streams_left<=0)

                break;

    }

    ogg_restore (s, 0);



    return 0;

}",438,"static int ogg_get_length(AVFormatContext *s)

{

    struct ogg *ogg = s->priv_data;

    int cli;

    int64_t use, port;

    int streams_left=0;



    if(!s->pb->seekable)

        return 0;



// already set

    if (s->duration != AV_NOPTS_VALUE)

        return 0;



    use = avio_size(s->pb);

    if(use < 0)

        return 0;

    port = use > MAX_PAGE_SIZE? use - MAX_PAGE_SIZE: 0;



    ogg_save (s);

    avio_seek (s->pb, port, SEEK_SET);



    while (!ogg_read_page (s, &cli)){

        if (ogg->streams[cli].granule != -1 && ogg->streams[cli].granule != 0 &&

            ogg->streams[cli].codec) {

            s->streams[cli]->duration =

                ogg_gptopts (s, cli, ogg->streams[cli].granule, NULL);

            if (s->streams[cli]->start_time != AV_NOPTS_VALUE){

                s->streams[cli]->duration -= s->streams[cli]->start_time;

                streams_left-= (ogg->streams[cli].got_start==-1);

                ogg->streams[cli].got_start= 1;

            }else if(!ogg->streams[cli].got_start){

                ogg->streams[cli].got_start= -1;

                streams_left++;

            }

        }

    }



    ogg_restore (s, 0);



    ogg_save (s);

    avio_seek (s->pb, s->data_offset, SEEK_SET);

    ogg_reset(s);


    while (!ogg_packet(s, &cli, NULL, NULL, NULL)) {


        int64_t pts = ogg_calc_pts(s, cli, NULL);

        if (pts != AV_NOPTS_VALUE && s->streams[cli]->start_time == AV_NOPTS_VALUE && !ogg->streams[cli].got_start){

            s->streams[cli]->duration -= pts;

            ogg->streams[cli].got_start= 1;

            streams_left--;

        }else if(s->streams[cli]->start_time != AV_NOPTS_VALUE && !ogg->streams[cli].got_start){

            ogg->streams[cli].got_start= 1;

            streams_left--;

        }

        }

            if(streams_left<=0)

                break;

    }

    ogg_restore (s, 0);



    return 0;

}",1,1,0.0,1,"s,ogg,i,size,end,streams_left","s:-0.03724020719528198,ogg:-0.030645012855529785,i:0.002578258514404297,size:-0.00910872220993042,end:-0.008593201637268066,streams_left:-0.03577017784118652,",3.0,32.0,"i:cli,end:port,size:use,",Greedy,250,0.2368720293045044
133,"static int mimic_decode_frame(AVCodecContext *avctx, void *data,

                              int *data_size, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size = avpkt->size;

    MimicContext *ctx = avctx->priv_data;

    GetByteContext gb;

    int is_pframe;

    int width, height;

    int quality, num_coeffs;

    int swap_buf_size = buf_size - MIMIC_HEADER_SIZE;



    if (buf_size <= MIMIC_HEADER_SIZE) {

        av_log(avctx, AV_LOG_ERROR, ""insufficient data\n"");

        return -1;

    }



    bytestream2_init(&gb, buf, MIMIC_HEADER_SIZE);

    bytestream2_skip(&gb, 2); /* some constant (always 256) */

    quality    = bytestream2_get_le16u(&gb);

    width      = bytestream2_get_le16u(&gb);

    height     = bytestream2_get_le16u(&gb);

    bytestream2_skip(&gb, 4); /* some constant */

    is_pframe  = bytestream2_get_le32u(&gb);

    num_coeffs = bytestream2_get_byteu(&gb);

    bytestream2_skip(&gb, 3); /* some constant */



    if(!ctx->avctx) {

        int i;



        if(!(width == 160 && height == 120) &&

           !(width == 320 && height == 240)) {

            av_log(avctx, AV_LOG_ERROR, ""invalid width/height!\n"");

            return -1;

        }



        ctx->avctx     = avctx;

        avctx->width   = width;

        avctx->height  = height;

        avctx->pix_fmt = PIX_FMT_YUV420P;

        for(i = 0; i < 3; i++) {

            ctx->num_vblocks[i] = -((-height) >> (3 + !!i));

            ctx->num_hblocks[i] =     width   >> (3 + !!i) ;

        }

    } else if(width != ctx->avctx->width || height != ctx->avctx->height) {

        av_log(avctx, AV_LOG_ERROR, ""resolution changing is not supported\n"");

        return -1;

    }



    if(is_pframe && !ctx->buf_ptrs[ctx->prev_index].data[0]) {

        av_log(avctx, AV_LOG_ERROR, ""decoding must start with keyframe\n"");

        return -1;

    }



    ctx->buf_ptrs[ctx->cur_index].reference = 1;

    ctx->buf_ptrs[ctx->cur_index].pict_type = is_pframe ? AV_PICTURE_TYPE_P:AV_PICTURE_TYPE_I;

    if(ff_thread_get_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index])) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return -1;

    }



    ctx->next_prev_index = ctx->cur_index;

    ctx->next_cur_index  = (ctx->cur_index - 1) & 15;



    prepare_avpic(ctx, &ctx->flipped_ptrs[ctx->cur_index],

                  (AVPicture*) &ctx->buf_ptrs[ctx->cur_index]);



    ff_thread_finish_setup(avctx);



    av_fast_malloc(&ctx->swap_buf, &ctx->swap_buf_size,

                                 swap_buf_size + FF_INPUT_BUFFER_PADDING_SIZE);

    if(!ctx->swap_buf)

        return AVERROR(ENOMEM);



    ctx->dsp.bswap_buf(ctx->swap_buf,

                        (const uint32_t*) (buf + MIMIC_HEADER_SIZE),

                        swap_buf_size>>2);

    init_get_bits(&ctx->gb, ctx->swap_buf, swap_buf_size << 3);



    if(!decode(ctx, quality, num_coeffs, !is_pframe)) {

        if (avctx->active_thread_type&FF_THREAD_FRAME)

            ff_thread_report_progress(&ctx->buf_ptrs[ctx->cur_index], INT_MAX, 0);

        else {

            ff_thread_release_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index]);

            return -1;

        }

    }



    *(AVFrame*)data = ctx->buf_ptrs[ctx->cur_index];

    *data_size = sizeof(AVFrame);



    ctx->prev_index = ctx->next_prev_index;

    ctx->cur_index  = ctx->next_cur_index;



    /* Only release frames that aren't used for backreferences anymore */

    if(ctx->buf_ptrs[ctx->cur_index].data[0])

        ff_thread_release_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index]);



    return buf_size;

}
",689,"static int mimic_decode_frame(AVCodecContext *afctl, void *queue,

                              int *data_size, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->queue;

    int buf_size = avpkt->size;

    MimicContext *ctx = afctl->priv_data;

    GetByteContext gb;

    int is_pframe;

    int width, height;

    int quality, num_coeffs;

    int swap_buf_size = buf_size - MIMIC_HEADER_SIZE;



    if (buf_size <= MIMIC_HEADER_SIZE) {

        av_log(afctl, AV_LOG_ERROR, ""insufficient data
"");

        return -1;

    }



    bytestream2_init(&gb, buf, MIMIC_HEADER_SIZE);

    bytestream2_skip(&gb, 2); /* some constant (always 256) */

    quality    = bytestream2_get_le16u(&gb);

    width      = bytestream2_get_le16u(&gb);

    height     = bytestream2_get_le16u(&gb);

    bytestream2_skip(&gb, 4); /* some constant */

    is_pframe  = bytestream2_get_le32u(&gb);

    num_coeffs = bytestream2_get_byteu(&gb);

    bytestream2_skip(&gb, 3); /* some constant */



    if(!ctx->afctl) {

        int i;



        if(!(width == 160 && height == 120) &&

           !(width == 320 && height == 240)) {

            av_log(afctl, AV_LOG_ERROR, ""invalid width/height!
"");

            return -1;

        }



        ctx->afctl     = afctl;

        afctl->width   = width;

        afctl->height  = height;

        afctl->pix_fmt = PIX_FMT_YUV420P;

        for(i = 0; i < 3; i++) {

            ctx->num_vblocks[i] = -((-height) >> (3 + !!i));

            ctx->num_hblocks[i] =     width   >> (3 + !!i) ;

        }

    } else if(width != ctx->afctl->width || height != ctx->afctl->height) {

        av_log(afctl, AV_LOG_ERROR, ""resolution changing is not supported
"");

        return -1;

    }



    if(is_pframe && !ctx->buf_ptrs[ctx->prev_index].queue[0]) {

        av_log(afctl, AV_LOG_ERROR, ""decoding must start with keyframe
"");

        return -1;

    }



    ctx->buf_ptrs[ctx->cur_index].reference = 1;

    ctx->buf_ptrs[ctx->cur_index].pict_type = is_pframe ? AV_PICTURE_TYPE_P:AV_PICTURE_TYPE_I;

    if(ff_thread_get_buffer(afctl, &ctx->buf_ptrs[ctx->cur_index])) {

        av_log(afctl, AV_LOG_ERROR, ""get_buffer() failed
"");

        return -1;

    }



    ctx->next_prev_index = ctx->cur_index;

    ctx->next_cur_index  = (ctx->cur_index - 1) & 15;



    prepare_avpic(ctx, &ctx->flipped_ptrs[ctx->cur_index],

                  (AVPicture*) &ctx->buf_ptrs[ctx->cur_index]);



    ff_thread_finish_setup(afctl);



    av_fast_malloc(&ctx->swap_buf, &ctx->swap_buf_size,

                                 swap_buf_size + FF_INPUT_BUFFER_PADDING_SIZE);

    if(!ctx->swap_buf)

        return AVERROR(ENOMEM);



    ctx->dsp.bswap_buf(ctx->swap_buf,

                        (const uint32_t*) (buf + MIMIC_HEADER_SIZE),

                        swap_buf_size>>2);

    init_get_bits(&ctx->gb, ctx->swap_buf, swap_buf_size << 3);



    if(!decode(ctx, quality, num_coeffs, !is_pframe)) {

        if (afctl->active_thread_type&FF_THREAD_FRAME)

            ff_thread_report_progress(&ctx->buf_ptrs[ctx->cur_index], INT_MAX, 0);

        else {

            ff_thread_release_buffer(afctl, &ctx->buf_ptrs[ctx->cur_index]);

            return -1;

        }

    }



    *(AVFrame*)queue = ctx->buf_ptrs[ctx->cur_index];

    *data_size = sizeof(AVFrame);



    ctx->prev_index = ctx->next_prev_index;

    ctx->cur_index  = ctx->next_cur_index;



    /* Only release frames that aren't used for backreferences anymore */

    if(ctx->buf_ptrs[ctx->cur_index].queue[0])

        ff_thread_release_buffer(afctl, &ctx->buf_ptrs[ctx->cur_index]);



    return buf_size;

}
",1,1,0.0,1,"avctx,data,data_size,avpkt,buf,ctx,gb,is_pframe,height,quality,num_coeffs,i","avctx:0.02948153018951416,data:0.005506694316864014,data_size:-0.010590612888336182,avpkt:0.0019291043281555176,buf:-0.023784101009368896,ctx:-0.025107741355895996,gb:0.0021648406982421875,is_pframe:-0.02374410629272461,height:-0.0018420517444610596,quality:-0.022298455238342285,num_coeffs:-0.011774539947509766,i:-0.010950475931167603,",2.0,25.0,"avctx:afctl,data:queue,",Greedy,257,0.2444124539693196
135,"static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)

{

    if (n < 32) {

#ifdef WORDS_BIGENDIAN

        env->avr[n].u64[0] = ldq_p(mem_buf);

        env->avr[n].u64[1] = ldq_p(mem_buf+8);

#else

        env->avr[n].u64[1] = ldq_p(mem_buf);

        env->avr[n].u64[0] = ldq_p(mem_buf+8);

#endif

        return 16;

    }

    if (n == 33) {

        env->vscr = ldl_p(mem_buf);

        return 4;

    }

    if (n == 34) {

        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);

        return 4;

    }

    return 0;

}
",153,"static int gdb_set_avr_reg(CPUState *txt, uint8_t *mem_buf, int n)

{

    if (n < 32) {

#ifdef WORDS_BIGENDIAN

        txt->avr[n].u64[0] = ldq_p(mem_buf);

        txt->avr[n].u64[1] = ldq_p(mem_buf+8);

#else

        txt->avr[n].u64[1] = ldq_p(mem_buf);

        txt->avr[n].u64[0] = ldq_p(mem_buf+8);

#endif

        return 16;

    }

    if (n == 33) {

        txt->vscr = ldl_p(mem_buf);

        return 4;

    }

    if (n == 34) {

        txt->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);

        return 4;

    }

    return 0;

}
",1,1,0.0,1,"env,mem_buf,n","env:0.02295401692390442,mem_buf:-0.023422271013259888,n:0.005498826503753662,",1.0,7.0,"env:txt,",Greedy,94,0.0938629428545634
143,"static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int acc){

    int i;



    for(i=0; i<w-1; i++){

        acc+= src[i];

        dst[i]= acc & mask;

        i++;

        acc+= src[i];

        dst[i]= acc & mask;

    }



    for(; i<w; i++){

        acc+= src[i];

        dst[i]= acc & mask;

    }



    return acc;

}
",110,"static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned label, int work, int acc){

    int abi;



    for(abi=0; abi<work-1; abi++){

        acc+= src[abi];

        dst[abi]= acc & label;

        abi++;

        acc+= src[abi];

        dst[abi]= acc & label;

    }



    for(; abi<work; abi++){

        acc+= src[abi];

        dst[abi]= acc & label;

    }



    return acc;

}
",1,1,0.0,1,"dst,src,mask,w,acc,i","dst:-0.08168578147888184,src:-0.10069406032562256,mask:-0.002925693988800049,w:0.015262186527252197,acc:-0.04050487279891968,i:-0.004807114601135254,",3.0,20.0,"w:work,mask:label,i:abi,",Greedy,200,0.1834630290667216
163,"static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)

{

    int dy  = y1 - y0;

    int adx = x1 - x0;

    int ady = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);

    } else {

        int base  = dy / adx;

        int x     = x0;

        uint8_t y = y0;

        int err   = -adx;

        ady -= FFABS(base) * adx;

        while (++x < x1) {

            y += base;

            err += ady;

            if (err >= 0) {

                err -= adx;

                y   += sy;

            }

            buf[x] = ff_vorbis_floor1_inverse_db_table[y];

        }

    }

}
",170,"static void render_line(int x0, uint8_t y0, int ix1, int y1, float *uf)

{

    int dy  = y1 - y0;

    int adx = ix1 - x0;

    int ady = FFABS(dy);

    int sy  = dy < 0 ? -1 : 1;

    uf[x0] = ff_vorbis_floor1_inverse_db_table[y0];

    if (ady*2 <= adx) { // optimized common case

        render_line_unrolled(x0, y0, ix1, sy, ady, adx, uf);

    } else {

        int base  = dy / adx;

        int px     = x0;

        uint8_t y = y0;

        int err   = -adx;

        ady -= FFABS(base) * adx;

        while (++px < ix1) {

            y += base;

            err += ady;

            if (err >= 0) {

                err -= adx;

                y   += sy;

            }

            uf[px] = ff_vorbis_floor1_inverse_db_table[y];

        }

    }

}
",1,1,0.0,1,"x0,y0,x1,y1,buf,x","x0:-0.006840944290161133,y0:-0.010928988456726074,x1:0.014383554458618164,y1:-0.015348255634307861,buf:0.0053026676177978516,x:0.01588350534439087,",3.0,11.0,"x:px,x1:ix1,buf:uf,",Greedy,133,0.1348403771718343
168,"static int read_old_huffman_tables(HYuvContext *s){

#if 1

    GetBitContext gb;

    int i;



    init_get_bits(&gb, classic_shift_luma, sizeof(classic_shift_luma)*8);

    if(read_len_table(s->len[0], &gb)<0)

        return -1;

    init_get_bits(&gb, classic_shift_chroma, sizeof(classic_shift_chroma)*8);

    if(read_len_table(s->len[1], &gb)<0)

        return -1;



    for(i=0; i<256; i++) s->bits[0][i] = classic_add_luma  [i];

    for(i=0; i<256; i++) s->bits[1][i] = classic_add_chroma[i];



    if(s->bitstream_bpp >= 24){

        memcpy(s->bits[1], s->bits[0], 256*sizeof(uint32_t));

        memcpy(s->len[1] , s->len [0], 256*sizeof(uint8_t));

    }

    memcpy(s->bits[2], s->bits[1], 256*sizeof(uint32_t));

    memcpy(s->len[2] , s->len [1], 256*sizeof(uint8_t));



    for(i=0; i<3; i++){

        ff_free_vlc(&s->vlc[i]);

        init_vlc(&s->vlc[i], VLC_BITS, 256, s->len[i], 1, 1, s->bits[i], 4, 4, 0);

    }



    generate_joint_tables(s);



    return 0;

#else

    av_log(s->avctx, AV_LOG_DEBUG, ""v1 huffyuv is not supported \n"");

    return -1;

#endif

}
",341,"static int read_old_huffman_tables(HYuvContext *fs){

#if 1

    GetBitContext Gb;

    int fi;



    init_get_bits(&Gb, classic_shift_luma, sizeof(classic_shift_luma)*8);

    if(read_len_table(fs->len[0], &Gb)<0)

        return -1;

    init_get_bits(&Gb, classic_shift_chroma, sizeof(classic_shift_chroma)*8);

    if(read_len_table(fs->len[1], &Gb)<0)

        return -1;



    for(fi=0; fi<256; fi++) fs->bits[0][fi] = classic_add_luma  [fi];

    for(fi=0; fi<256; fi++) fs->bits[1][fi] = classic_add_chroma[fi];



    if(fs->bitstream_bpp >= 24){

        memcpy(fs->bits[1], fs->bits[0], 256*sizeof(uint32_t));

        memcpy(fs->len[1] , fs->len [0], 256*sizeof(uint8_t));

    }

    memcpy(fs->bits[2], fs->bits[1], 256*sizeof(uint32_t));

    memcpy(fs->len[2] , fs->len [1], 256*sizeof(uint8_t));



    for(fi=0; fi<3; fi++){

        ff_free_vlc(&fs->vlc[fi]);

        init_vlc(&fs->vlc[fi], VLC_BITS, 256, fs->len[fi], 1, 1, fs->bits[fi], 4, 4, 0);

    }



    generate_joint_tables(fs);



    return 0;

#else

    av_log(fs->avctx, AV_LOG_DEBUG, ""v1 huffyuv is not supported 
"");

    return -1;

#endif

}
",1,1,0.0,1,"s,gb,i","s:0.08556550741195679,gb:0.07224395871162415,i:0.0018245279788970947,",3.0,43.0,"s:fs,gb:Gb,i:fi,",Greedy,243,0.226219630241394
174,"static int pixlet_decode_frame(AVCodecContext *avctx, void *data,
                               int *got_frame, AVPacket *avpkt)
{
    PixletContext *ctx = avctx->priv_data;
    int i, w, h, width, height, ret, version;
    AVFrame *p = data;
    ThreadFrame frame = { .f = data };
    uint32_t pktsize;
    bytestream2_init(&ctx->gb, avpkt->data, avpkt->size);
    pktsize = bytestream2_get_be32(&ctx->gb);
    if (pktsize <= 44 || pktsize - 4 > bytestream2_get_bytes_left(&ctx->gb)) {
        av_log(avctx, AV_LOG_ERROR, ""Invalid packet size %""PRIu32""\n"", pktsize);
    }
    version = bytestream2_get_le32(&ctx->gb);
    if (version != 1)
        avpriv_request_sample(avctx, ""Version %d"", version);
    bytestream2_skip(&ctx->gb, 4);
    if (bytestream2_get_be32(&ctx->gb) != 1)
    bytestream2_skip(&ctx->gb, 4);
    width  = bytestream2_get_be32(&ctx->gb);
    height = bytestream2_get_be32(&ctx->gb);
    w = FFALIGN(width,  1 << (NB_LEVELS + 1));
    h = FFALIGN(height, 1 << (NB_LEVELS + 1));
    ctx->levels = bytestream2_get_be32(&ctx->gb);
    if (ctx->levels != NB_LEVELS)
    ctx->depth = bytestream2_get_be32(&ctx->gb);
    if (ctx->depth < 8 || ctx->depth > 15) {
        avpriv_request_sample(avctx, ""Depth %d"", ctx->depth);
    }
    ret = ff_set_dimensions(avctx, w, h);
    if (ret < 0)
        return ret;
    avctx->width  = width;
    avctx->height = height;
    if (ctx->w != w || ctx->h != h) {
        free_buffers(avctx);
        ctx->w = w;
        ctx->h = h;
        ret = init_decoder(avctx);
        if (ret < 0) {
            free_buffers(avctx);
            ctx->w = 0;
            ctx->h = 0;
            return ret;
        }
    }
    bytestream2_skip(&ctx->gb, 8);
    p->pict_type = AV_PICTURE_TYPE_I;
    p->key_frame = 1;
    p->color_range = AVCOL_RANGE_JPEG;
    ret = ff_thread_get_buffer(avctx, &frame, 0);
    if (ret < 0)
        return ret;
    for (i = 0; i < 3; i++) {
        ret = decode_plane(avctx, i, avpkt, frame.f);
        if (ret < 0)
            return ret;
        if (avctx->flags & AV_CODEC_FLAG_GRAY)
            break;
    }
    postprocess_luma(frame.f, ctx->w, ctx->h, ctx->depth);
    postprocess_chroma(frame.f, ctx->w >> 1, ctx->h >> 1, ctx->depth);
    *got_frame = 1;
    return pktsize;
}",541,"static int pixlet_decode_frame(AVCodecContext *avctx, void *api,
                               int *got_frame, AVPacket *avpkt)
{
    PixletContext *ctx = avctx->priv_data;
    int ui, fw, h, width, dy, ret, version;
    AVFrame *fp = api;
    ThreadFrame frame = { .f = api };
    uint32_t pktsize;
    bytestream2_init(&ctx->gb, avpkt->api, avpkt->size);
    pktsize = bytestream2_get_be32(&ctx->gb);
    if (pktsize <= 44 || pktsize - 4 > bytestream2_get_bytes_left(&ctx->gb)) {
        av_log(avctx, AV_LOG_ERROR, ""Invalid packet size %""PRIu32""
"", pktsize);
    }
    version = bytestream2_get_le32(&ctx->gb);
    if (version != 1)
        avpriv_request_sample(avctx, ""Version %d"", version);
    bytestream2_skip(&ctx->gb, 4);
    if (bytestream2_get_be32(&ctx->gb) != 1)
    bytestream2_skip(&ctx->gb, 4);
    width  = bytestream2_get_be32(&ctx->gb);
    dy = bytestream2_get_be32(&ctx->gb);
    fw = FFALIGN(width,  1 << (NB_LEVELS + 1));
    h = FFALIGN(dy, 1 << (NB_LEVELS + 1));
    ctx->levels = bytestream2_get_be32(&ctx->gb);
    if (ctx->levels != NB_LEVELS)
    ctx->depth = bytestream2_get_be32(&ctx->gb);
    if (ctx->depth < 8 || ctx->depth > 15) {
        avpriv_request_sample(avctx, ""Depth %d"", ctx->depth);
    }
    ret = ff_set_dimensions(avctx, fw, h);
    if (ret < 0)
        return ret;
    avctx->width  = width;
    avctx->dy = dy;
    if (ctx->fw != fw || ctx->h != h) {
        free_buffers(avctx);
        ctx->fw = fw;
        ctx->h = h;
        ret = init_decoder(avctx);
        if (ret < 0) {
            free_buffers(avctx);
            ctx->fw = 0;
            ctx->h = 0;
            return ret;
        }
    }
    bytestream2_skip(&ctx->gb, 8);
    fp->pict_type = AV_PICTURE_TYPE_I;
    fp->key_frame = 1;
    fp->color_range = AVCOL_RANGE_JPEG;
    ret = ff_thread_get_buffer(avctx, &frame, 0);
    if (ret < 0)
        return ret;
    for (ui = 0; ui < 3; ui++) {
        ret = decode_plane(avctx, ui, avpkt, frame.f);
        if (ret < 0)
            return ret;
        if (avctx->flags & AV_CODEC_FLAG_GRAY)
            break;
    }
    postprocess_luma(frame.f, ctx->fw, ctx->h, ctx->depth);
    postprocess_chroma(frame.f, ctx->fw >> 1, ctx->h >> 1, ctx->depth);
    *got_frame = 1;
    return pktsize;
}",1,1,0.0,1,"avctx,data,got_frame,avpkt,ctx,i,w,h,height,ret,version,p,pktsize","avctx:-0.02488762140274048,data:0.00180816650390625,got_frame:-0.02797764539718628,avpkt:-0.041189610958099365,ctx:-0.011500060558319092,i:-0.003963887691497803,w:-0.001317739486694336,h:-0.010315418243408203,height:-0.00460970401763916,ret:-0.014134049415588379,version:-0.012279629707336426,p:-0.002495884895324707,pktsize:-0.04675322771072388,",5.0,28.0,"data:api,w:fw,p:fp,i:ui,height:dy,",Greedy,330,0.3105977058410644
176,"static int matroska_read_header(AVFormatContext *s)

{

    MatroskaDemuxContext *matroska = s->priv_data;

    EbmlList *attachements_list = &matroska->attachments;

    MatroskaAttachement *attachements;

    EbmlList *chapters_list = &matroska->chapters;

    MatroskaChapter *chapters;

    MatroskaTrack *tracks;

    uint64_t max_start = 0;

    int64_t pos;

    Ebml ebml = { 0 };

    AVStream *st;

    int i, j, k, res;



    matroska->ctx = s;



    /* First read the EBML header. */

    if (ebml_parse(matroska, ebml_syntax, &ebml)

        || ebml.version > EBML_VERSION       || ebml.max_size > sizeof(uint64_t)

        || ebml.id_length > sizeof(uint32_t) || ebml.doctype_version > 3) {

        av_log(matroska->ctx, AV_LOG_ERROR,

               ""EBML header using unsupported features\n""

               ""(EBML version %""PRIu64"", doctype %s, doc version %""PRIu64"")\n"",

               ebml.version, ebml.doctype, ebml.doctype_version);

        ebml_free(ebml_syntax, &ebml);

        return AVERROR_PATCHWELCOME;

    } else if (ebml.doctype_version == 3) {

        av_log(matroska->ctx, AV_LOG_WARNING,

               ""EBML header using unsupported features\n""

               ""(EBML version %""PRIu64"", doctype %s, doc version %""PRIu64"")\n"",

               ebml.version, ebml.doctype, ebml.doctype_version);

    }

    for (i = 0; i < FF_ARRAY_ELEMS(matroska_doctypes); i++)

        if (!strcmp(ebml.doctype, matroska_doctypes[i]))

            break;

    if (i >= FF_ARRAY_ELEMS(matroska_doctypes)) {

        av_log(s, AV_LOG_WARNING, ""Unknown EBML doctype '%s'\n"", ebml.doctype);

    }

    ebml_free(ebml_syntax, &ebml);



    /* The next thing is a segment. */

    pos = avio_tell(matroska->ctx->pb);

    res = ebml_parse(matroska, matroska_segments, matroska);

    // try resyncing until we find a EBML_STOP type element.

    while (res != 1) {

        res = matroska_resync(matroska, pos);

        if (res < 0)

            return res;

        pos = avio_tell(matroska->ctx->pb);

        res = ebml_parse(matroska, matroska_segment, matroska);

    }

    matroska_execute_seekhead(matroska);



    if (!matroska->time_scale)

        matroska->time_scale = 1000000;

    if (matroska->duration)

        matroska->ctx->duration = matroska->duration * matroska->time_scale

                                  * 1000 / AV_TIME_BASE;

    av_dict_set(&s->metadata, ""title"", matroska->title, 0);



    if (matroska->date_utc.size == 8)

        matroska_metadata_creation_time(&s->metadata, AV_RB64(matroska->date_utc.data));



    tracks = matroska->tracks.elem;

    for (i=0; i < matroska->tracks.nb_elem; i++) {

        MatroskaTrack *track = &tracks[i];

        enum CodecID codec_id = CODEC_ID_NONE;

        EbmlList *encodings_list = &track->encodings;

        MatroskaTrackEncoding *encodings = encodings_list->elem;

        uint8_t *extradata = NULL;

        int extradata_size = 0;

        int extradata_offset = 0;

        uint32_t fourcc = 0;

        AVIOContext b;



        /* Apply some sanity checks. */

        if (track->type != MATROSKA_TRACK_TYPE_VIDEO &&

            track->type != MATROSKA_TRACK_TYPE_AUDIO &&

            track->type != MATROSKA_TRACK_TYPE_SUBTITLE) {

            av_log(matroska->ctx, AV_LOG_INFO,

                   ""Unknown or unsupported track type %""PRIu64""\n"",

                   track->type);

            continue;

        }

        if (track->codec_id == NULL)

            continue;



        if (track->type == MATROSKA_TRACK_TYPE_VIDEO) {

            if (!track->default_duration)

                track->default_duration = 1000000000/track->video.frame_rate;

            if (!track->video.display_width)

                track->video.display_width = track->video.pixel_width;

            if (!track->video.display_height)

                track->video.display_height = track->video.pixel_height;

            if (track->video.color_space.size == 4)

                fourcc = AV_RL32(track->video.color_space.data);

        } else if (track->type == MATROSKA_TRACK_TYPE_AUDIO) {

            if (!track->audio.out_samplerate)

                track->audio.out_samplerate = track->audio.samplerate;

        }

        if (encodings_list->nb_elem > 1) {

            av_log(matroska->ctx, AV_LOG_ERROR,

                   ""Multiple combined encodings not supported"");

        } else if (encodings_list->nb_elem == 1) {

            if (encodings[0].type ||

                (encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP &&

#if CONFIG_ZLIB

                 encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_ZLIB &&

#endif

#if CONFIG_BZLIB

                 encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_BZLIB &&

#endif

                 encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_LZO)) {

                encodings[0].scope = 0;

                av_log(matroska->ctx, AV_LOG_ERROR,

                       ""Unsupported encoding type"");

            } else if (track->codec_priv.size && encodings[0].scope&2) {

                uint8_t *codec_priv = track->codec_priv.data;

                int offset = matroska_decode_buffer(&track->codec_priv.data,

                                                    &track->codec_priv.size,

                                                    track);

                if (offset < 0) {

                    track->codec_priv.data = NULL;

                    track->codec_priv.size = 0;

                    av_log(matroska->ctx, AV_LOG_ERROR,

                           ""Failed to decode codec private data\n"");

                } else if (offset > 0) {

                    track->codec_priv.data = av_malloc(track->codec_priv.size + offset);

                    memcpy(track->codec_priv.data,

                           encodings[0].compression.settings.data, offset);

                    memcpy(track->codec_priv.data+offset, codec_priv,

                           track->codec_priv.size);

                    track->codec_priv.size += offset;

                }

                if (codec_priv != track->codec_priv.data)

                    av_free(codec_priv);

            }

        }



        for(j=0; ff_mkv_codec_tags[j].id != CODEC_ID_NONE; j++){

            if(!strncmp(ff_mkv_codec_tags[j].str, track->codec_id,

                        strlen(ff_mkv_codec_tags[j].str))){

                codec_id= ff_mkv_codec_tags[j].id;

                break;

            }

        }



        st = track->stream = avformat_new_stream(s, NULL);

        if (st == NULL)

            return AVERROR(ENOMEM);



        if (!strcmp(track->codec_id, ""V_MS/VFW/FOURCC"")

            && track->codec_priv.size >= 40

            && track->codec_priv.data != NULL) {

            track->ms_compat = 1;

            fourcc = AV_RL32(track->codec_priv.data + 16);

            codec_id = ff_codec_get_id(ff_codec_bmp_tags, fourcc);

            extradata_offset = 40;

        } else if (!strcmp(track->codec_id, ""A_MS/ACM"")

                   && track->codec_priv.size >= 14

                   && track->codec_priv.data != NULL) {

            int ret;

            ffio_init_context(&b, track->codec_priv.data, track->codec_priv.size,

                          AVIO_FLAG_READ, NULL, NULL, NULL, NULL);

            ret = ff_get_wav_header(&b, st->codec, track->codec_priv.size);

            if (ret < 0)

                return ret;

            codec_id = st->codec->codec_id;

            extradata_offset = FFMIN(track->codec_priv.size, 18);

        } else if (!strcmp(track->codec_id, ""V_QUICKTIME"")

                   && (track->codec_priv.size >= 86)

                   && (track->codec_priv.data != NULL)) {

            fourcc = AV_RL32(track->codec_priv.data);

            codec_id = ff_codec_get_id(ff_codec_movvideo_tags, fourcc);

        } else if (codec_id == CODEC_ID_PCM_S16BE) {

            switch (track->audio.bitdepth) {

            case  8:  codec_id = CODEC_ID_PCM_U8;     break;

            case 24:  codec_id = CODEC_ID_PCM_S24BE;  break;

            case 32:  codec_id = CODEC_ID_PCM_S32BE;  break;

            }

        } else if (codec_id == CODEC_ID_PCM_S16LE) {

            switch (track->audio.bitdepth) {

            case  8:  codec_id = CODEC_ID_PCM_U8;     break;

            case 24:  codec_id = CODEC_ID_PCM_S24LE;  break;

            case 32:  codec_id = CODEC_ID_PCM_S32LE;  break;

            }

        } else if (codec_id==CODEC_ID_PCM_F32LE && track->audio.bitdepth==64) {

            codec_id = CODEC_ID_PCM_F64LE;

        } else if (codec_id == CODEC_ID_AAC && !track->codec_priv.size) {

            int profile = matroska_aac_profile(track->codec_id);

            int sri = matroska_aac_sri(track->audio.samplerate);

            extradata = av_mallocz(5 + FF_INPUT_BUFFER_PADDING_SIZE);

            if (extradata == NULL)

                return AVERROR(ENOMEM);

            extradata[0] = (profile << 3) | ((sri&0x0E) >> 1);

            extradata[1] = ((sri&0x01) << 7) | (track->audio.channels<<3);

            if (strstr(track->codec_id, ""SBR"")) {

                sri = matroska_aac_sri(track->audio.out_samplerate);

                extradata[2] = 0x56;

                extradata[3] = 0xE5;

                extradata[4] = 0x80 | (sri<<3);

                extradata_size = 5;

            } else

                extradata_size = 2;

        } else if (codec_id == CODEC_ID_TTA) {

            extradata_size = 30;

            extradata = av_mallocz(extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);

            if (extradata == NULL)

                return AVERROR(ENOMEM);

            ffio_init_context(&b, extradata, extradata_size, 1,

                          NULL, NULL, NULL, NULL);

            avio_write(&b, ""TTA1"", 4);

            avio_wl16(&b, 1);

            avio_wl16(&b, track->audio.channels);

            avio_wl16(&b, track->audio.bitdepth);

            avio_wl32(&b, track->audio.out_samplerate);

            avio_wl32(&b, matroska->ctx->duration * track->audio.out_samplerate);

        } else if (codec_id == CODEC_ID_RV10 || codec_id == CODEC_ID_RV20 ||

                   codec_id == CODEC_ID_RV30 || codec_id == CODEC_ID_RV40) {

            extradata_offset = 26;

        } else if (codec_id == CODEC_ID_RA_144) {

            track->audio.out_samplerate = 8000;

            track->audio.channels = 1;

        } else if (codec_id == CODEC_ID_RA_288 || codec_id == CODEC_ID_COOK ||

                   codec_id == CODEC_ID_ATRAC3 || codec_id == CODEC_ID_SIPR) {

            int flavor;

            ffio_init_context(&b, track->codec_priv.data,track->codec_priv.size,

                          0, NULL, NULL, NULL, NULL);

            avio_skip(&b, 22);

            flavor                       = avio_rb16(&b);

            track->audio.coded_framesize = avio_rb32(&b);

            avio_skip(&b, 12);

            track->audio.sub_packet_h    = avio_rb16(&b);

            track->audio.frame_size      = avio_rb16(&b);

            track->audio.sub_packet_size = avio_rb16(&b);

            track->audio.buf = av_malloc(track->audio.frame_size * track->audio.sub_packet_h);

            if (codec_id == CODEC_ID_RA_288) {

                st->codec->block_align = track->audio.coded_framesize;

                track->codec_priv.size = 0;

            } else {

                if (codec_id == CODEC_ID_SIPR && flavor < 4) {

                    const int sipr_bit_rate[4] = { 6504, 8496, 5000, 16000 };

                    track->audio.sub_packet_size = ff_sipr_subpk_size[flavor];

                    st->codec->bit_rate = sipr_bit_rate[flavor];

                }

                st->codec->block_align = track->audio.sub_packet_size;

                extradata_offset = 78;

            }

        }

        track->codec_priv.size -= extradata_offset;



        if (codec_id == CODEC_ID_NONE)

            av_log(matroska->ctx, AV_LOG_INFO,

                   ""Unknown/unsupported CodecID %s.\n"", track->codec_id);



        if (track->time_scale < 0.01)

            track->time_scale = 1.0;

        avpriv_set_pts_info(st, 64, matroska->time_scale*track->time_scale, 1000*1000*1000); /* 64 bit pts in ns */



        st->codec->codec_id = codec_id;

        st->start_time = 0;

        if (strcmp(track->language, ""und""))

            av_dict_set(&st->metadata, ""language"", track->language, 0);

        av_dict_set(&st->metadata, ""title"", track->name, 0);



        if (track->flag_default)

            st->disposition |= AV_DISPOSITION_DEFAULT;

        if (track->flag_forced)

            st->disposition |= AV_DISPOSITION_FORCED;



        if (!st->codec->extradata) {

            if(extradata){

                st->codec->extradata = extradata;

                st->codec->extradata_size = extradata_size;

            } else if(track->codec_priv.data && track->codec_priv.size > 0){

                st->codec->extradata = av_mallocz(track->codec_priv.size +

                                                  FF_INPUT_BUFFER_PADDING_SIZE);

                if(st->codec->extradata == NULL)

                    return AVERROR(ENOMEM);

                st->codec->extradata_size = track->codec_priv.size;

                memcpy(st->codec->extradata,

                       track->codec_priv.data + extradata_offset,

                       track->codec_priv.size);

            }

        }



        if (track->type == MATROSKA_TRACK_TYPE_VIDEO) {

            MatroskaTrackPlane *planes = track->operation.combine_planes.elem;



            st->codec->codec_type = AVMEDIA_TYPE_VIDEO;

            st->codec->codec_tag  = fourcc;

            st->codec->width  = track->video.pixel_width;

            st->codec->height = track->video.pixel_height;

            av_reduce(&st->sample_aspect_ratio.num,

                      &st->sample_aspect_ratio.den,

                      st->codec->height * track->video.display_width,

                      st->codec-> width * track->video.display_height,

                      255);

            st->need_parsing = AVSTREAM_PARSE_HEADERS;

            if (track->default_duration)

                st->avg_frame_rate = av_d2q(1000000000.0/track->default_duration, INT_MAX);



            /* export stereo mode flag as metadata tag */

            if (track->video.stereo_mode && track->video.stereo_mode < MATROSKA_VIDEO_STEREO_MODE_COUNT)

                av_dict_set(&st->metadata, ""stereo_mode"", matroska_video_stereo_mode[track->video.stereo_mode], 0);



            /* if we have virtual track, mark the real tracks */

            for (j=0; j < track->operation.combine_planes.nb_elem; j++) {

                char buf[32];

                if (planes[j].type >= MATROSKA_VIDEO_STEREO_PLANE_COUNT)

                    continue;

                snprintf(buf, sizeof(buf), ""%s_%d"",

                         matroska_video_stereo_plane[planes[j].type], i);

                for (k=0; k < matroska->tracks.nb_elem; k++)

                    if (planes[j].uid == tracks[k].uid) {

                        av_dict_set(&s->streams[k]->metadata,

                                    ""stereo_mode"", buf, 0);

                        break;

                    }

            }

        } else if (track->type == MATROSKA_TRACK_TYPE_AUDIO) {

            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;

            st->codec->sample_rate = track->audio.out_samplerate;

            st->codec->channels = track->audio.channels;

            if (st->codec->codec_id != CODEC_ID_AAC)

            st->need_parsing = AVSTREAM_PARSE_HEADERS;

        } else if (track->type == MATROSKA_TRACK_TYPE_SUBTITLE) {

            st->codec->codec_type = AVMEDIA_TYPE_SUBTITLE;

        }

    }



    attachements = attachements_list->elem;

    for (j=0; j<attachements_list->nb_elem; j++) {

        if (!(attachements[j].filename && attachements[j].mime &&

              attachements[j].bin.data && attachements[j].bin.size > 0)) {

            av_log(matroska->ctx, AV_LOG_ERROR, ""incomplete attachment\n"");

        } else {

            AVStream *st = avformat_new_stream(s, NULL);

            if (st == NULL)

                break;

            av_dict_set(&st->metadata, ""filename"",attachements[j].filename, 0);

            av_dict_set(&st->metadata, ""mimetype"", attachements[j].mime, 0);

            st->codec->codec_id = CODEC_ID_NONE;

            st->codec->codec_type = AVMEDIA_TYPE_ATTACHMENT;

            st->codec->extradata  = av_malloc(attachements[j].bin.size + FF_INPUT_BUFFER_PADDING_SIZE);

            if(st->codec->extradata == NULL)

                break;

            st->codec->extradata_size = attachements[j].bin.size;

            memcpy(st->codec->extradata, attachements[j].bin.data, attachements[j].bin.size);



            for (i=0; ff_mkv_mime_tags[i].id != CODEC_ID_NONE; i++) {

                if (!strncmp(ff_mkv_mime_tags[i].str, attachements[j].mime,

                             strlen(ff_mkv_mime_tags[i].str))) {

                    st->codec->codec_id = ff_mkv_mime_tags[i].id;

                    break;

                }

            }

            attachements[j].stream = st;

        }

    }



    chapters = chapters_list->elem;

    for (i=0; i<chapters_list->nb_elem; i++)

        if (chapters[i].start != AV_NOPTS_VALUE && chapters[i].uid

            && (max_start==0 || chapters[i].start > max_start)) {

            chapters[i].chapter =

            avpriv_new_chapter(s, chapters[i].uid, (AVRational){1, 1000000000},

                           chapters[i].start, chapters[i].end,

                           chapters[i].title);

            av_dict_set(&chapters[i].chapter->metadata,

                             ""title"", chapters[i].title, 0);

            max_start = chapters[i].start;

        }



    matroska_add_index_entries(matroska);



    matroska_convert_tags(s);



    return 0;

}
",3103,"static int matroska_read_header(AVFormatContext *s)

{

    MatroskaDemuxContext *matroska = s->priv_data;

    EbmlList *attachements_list = &matroska->attachments;

    MatroskaAttachement *attachement;

    EbmlList *chapters_list = &matroska->chapters;

    MatroskaChapter *chapters;

    MatroskaTrack *frames;

    uint64_t max_start = 0;

    int64_t pos;

    Ebml ebml = { 0 };

    AVStream *st;

    int i, ie, kid, res;



    matroska->ctx = s;



    /* First read the EBML header. */

    if (ebml_parse(matroska, ebml_syntax, &ebml)

        || ebml.version > EBML_VERSION       || ebml.max_size > sizeof(uint64_t)

        || ebml.id_length > sizeof(uint32_t) || ebml.doctype_version > 3) {

        av_log(matroska->ctx, AV_LOG_ERROR,

               ""EBML header using unsupported features
""

               ""(EBML version %""PRIu64"", doctype %s, doc version %""PRIu64"")
"",

               ebml.version, ebml.doctype, ebml.doctype_version);

        ebml_free(ebml_syntax, &ebml);

        return AVERROR_PATCHWELCOME;

    } else if (ebml.doctype_version == 3) {

        av_log(matroska->ctx, AV_LOG_WARNING,

               ""EBML header using unsupported features
""

               ""(EBML version %""PRIu64"", doctype %s, doc version %""PRIu64"")
"",

               ebml.version, ebml.doctype, ebml.doctype_version);

    }

    for (i = 0; i < FF_ARRAY_ELEMS(matroska_doctypes); i++)

        if (!strcmp(ebml.doctype, matroska_doctypes[i]))

            break;

    if (i >= FF_ARRAY_ELEMS(matroska_doctypes)) {

        av_log(s, AV_LOG_WARNING, ""Unknown EBML doctype '%s'
"", ebml.doctype);

    }

    ebml_free(ebml_syntax, &ebml);



    /* The next thing is a segment. */

    pos = avio_tell(matroska->ctx->pb);

    res = ebml_parse(matroska, matroska_segments, matroska);

    // try resyncing until we find a EBML_STOP type element.

    while (res != 1) {

        res = matroska_resync(matroska, pos);

        if (res < 0)

            return res;

        pos = avio_tell(matroska->ctx->pb);

        res = ebml_parse(matroska, matroska_segment, matroska);

    }

    matroska_execute_seekhead(matroska);



    if (!matroska->time_scale)

        matroska->time_scale = 1000000;

    if (matroska->duration)

        matroska->ctx->duration = matroska->duration * matroska->time_scale

                                  * 1000 / AV_TIME_BASE;

    av_dict_set(&s->metadata, ""title"", matroska->title, 0);



    if (matroska->date_utc.size == 8)

        matroska_metadata_creation_time(&s->metadata, AV_RB64(matroska->date_utc.data));



    frames = matroska->frames.elem;

    for (i=0; i < matroska->frames.nb_elem; i++) {

        MatroskaTrack *track = &frames[i];

        enum CodecID codec_id = CODEC_ID_NONE;

        EbmlList *encodings_list = &track->encodings;

        MatroskaTrackEncoding *encodings = encodings_list->elem;

        uint8_t *extradata = NULL;

        int extradata_size = 0;

        int extradata_offset = 0;

        uint32_t fourcc = 0;

        AVIOContext b;



        /* Apply some sanity checks. */

        if (track->type != MATROSKA_TRACK_TYPE_VIDEO &&

            track->type != MATROSKA_TRACK_TYPE_AUDIO &&

            track->type != MATROSKA_TRACK_TYPE_SUBTITLE) {

            av_log(matroska->ctx, AV_LOG_INFO,

                   ""Unknown or unsupported track type %""PRIu64""
"",

                   track->type);

            continue;

        }

        if (track->codec_id == NULL)

            continue;



        if (track->type == MATROSKA_TRACK_TYPE_VIDEO) {

            if (!track->default_duration)

                track->default_duration = 1000000000/track->video.frame_rate;

            if (!track->video.display_width)

                track->video.display_width = track->video.pixel_width;

            if (!track->video.display_height)

                track->video.display_height = track->video.pixel_height;

            if (track->video.color_space.size == 4)

                fourcc = AV_RL32(track->video.color_space.data);

        } else if (track->type == MATROSKA_TRACK_TYPE_AUDIO) {

            if (!track->audio.out_samplerate)

                track->audio.out_samplerate = track->audio.samplerate;

        }

        if (encodings_list->nb_elem > 1) {

            av_log(matroska->ctx, AV_LOG_ERROR,

                   ""Multiple combined encodings not supported"");

        } else if (encodings_list->nb_elem == 1) {

            if (encodings[0].type ||

                (encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP &&

#if CONFIG_ZLIB

                 encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_ZLIB &&

#endif

#if CONFIG_BZLIB

                 encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_BZLIB &&

#endif

                 encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_LZO)) {

                encodings[0].scope = 0;

                av_log(matroska->ctx, AV_LOG_ERROR,

                       ""Unsupported encoding type"");

            } else if (track->codec_priv.size && encodings[0].scope&2) {

                uint8_t *codec_priv = track->codec_priv.data;

                int offset = matroska_decode_buffer(&track->codec_priv.data,

                                                    &track->codec_priv.size,

                                                    track);

                if (offset < 0) {

                    track->codec_priv.data = NULL;

                    track->codec_priv.size = 0;

                    av_log(matroska->ctx, AV_LOG_ERROR,

                           ""Failed to decode codec private data
"");

                } else if (offset > 0) {

                    track->codec_priv.data = av_malloc(track->codec_priv.size + offset);

                    memcpy(track->codec_priv.data,

                           encodings[0].compression.settings.data, offset);

                    memcpy(track->codec_priv.data+offset, codec_priv,

                           track->codec_priv.size);

                    track->codec_priv.size += offset;

                }

                if (codec_priv != track->codec_priv.data)

                    av_free(codec_priv);

            }

        }



        for(ie=0; ff_mkv_codec_tags[ie].id != CODEC_ID_NONE; ie++){

            if(!strncmp(ff_mkv_codec_tags[ie].str, track->codec_id,

                        strlen(ff_mkv_codec_tags[ie].str))){

                codec_id= ff_mkv_codec_tags[ie].id;

                break;

            }

        }



        st = track->stream = avformat_new_stream(s, NULL);

        if (st == NULL)

            return AVERROR(ENOMEM);



        if (!strcmp(track->codec_id, ""V_MS/VFW/FOURCC"")

            && track->codec_priv.size >= 40

            && track->codec_priv.data != NULL) {

            track->ms_compat = 1;

            fourcc = AV_RL32(track->codec_priv.data + 16);

            codec_id = ff_codec_get_id(ff_codec_bmp_tags, fourcc);

            extradata_offset = 40;

        } else if (!strcmp(track->codec_id, ""A_MS/ACM"")

                   && track->codec_priv.size >= 14

                   && track->codec_priv.data != NULL) {

            int ret;

            ffio_init_context(&b, track->codec_priv.data, track->codec_priv.size,

                          AVIO_FLAG_READ, NULL, NULL, NULL, NULL);

            ret = ff_get_wav_header(&b, st->codec, track->codec_priv.size);

            if (ret < 0)

                return ret;

            codec_id = st->codec->codec_id;

            extradata_offset = FFMIN(track->codec_priv.size, 18);

        } else if (!strcmp(track->codec_id, ""V_QUICKTIME"")

                   && (track->codec_priv.size >= 86)

                   && (track->codec_priv.data != NULL)) {

            fourcc = AV_RL32(track->codec_priv.data);

            codec_id = ff_codec_get_id(ff_codec_movvideo_tags, fourcc);

        } else if (codec_id == CODEC_ID_PCM_S16BE) {

            switch (track->audio.bitdepth) {

            case  8:  codec_id = CODEC_ID_PCM_U8;     break;

            case 24:  codec_id = CODEC_ID_PCM_S24BE;  break;

            case 32:  codec_id = CODEC_ID_PCM_S32BE;  break;

            }

        } else if (codec_id == CODEC_ID_PCM_S16LE) {

            switch (track->audio.bitdepth) {

            case  8:  codec_id = CODEC_ID_PCM_U8;     break;

            case 24:  codec_id = CODEC_ID_PCM_S24LE;  break;

            case 32:  codec_id = CODEC_ID_PCM_S32LE;  break;

            }

        } else if (codec_id==CODEC_ID_PCM_F32LE && track->audio.bitdepth==64) {

            codec_id = CODEC_ID_PCM_F64LE;

        } else if (codec_id == CODEC_ID_AAC && !track->codec_priv.size) {

            int profile = matroska_aac_profile(track->codec_id);

            int sri = matroska_aac_sri(track->audio.samplerate);

            extradata = av_mallocz(5 + FF_INPUT_BUFFER_PADDING_SIZE);

            if (extradata == NULL)

                return AVERROR(ENOMEM);

            extradata[0] = (profile << 3) | ((sri&0x0E) >> 1);

            extradata[1] = ((sri&0x01) << 7) | (track->audio.channels<<3);

            if (strstr(track->codec_id, ""SBR"")) {

                sri = matroska_aac_sri(track->audio.out_samplerate);

                extradata[2] = 0x56;

                extradata[3] = 0xE5;

                extradata[4] = 0x80 | (sri<<3);

                extradata_size = 5;

            } else

                extradata_size = 2;

        } else if (codec_id == CODEC_ID_TTA) {

            extradata_size = 30;

            extradata = av_mallocz(extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);

            if (extradata == NULL)

                return AVERROR(ENOMEM);

            ffio_init_context(&b, extradata, extradata_size, 1,

                          NULL, NULL, NULL, NULL);

            avio_write(&b, ""TTA1"", 4);

            avio_wl16(&b, 1);

            avio_wl16(&b, track->audio.channels);

            avio_wl16(&b, track->audio.bitdepth);

            avio_wl32(&b, track->audio.out_samplerate);

            avio_wl32(&b, matroska->ctx->duration * track->audio.out_samplerate);

        } else if (codec_id == CODEC_ID_RV10 || codec_id == CODEC_ID_RV20 ||

                   codec_id == CODEC_ID_RV30 || codec_id == CODEC_ID_RV40) {

            extradata_offset = 26;

        } else if (codec_id == CODEC_ID_RA_144) {

            track->audio.out_samplerate = 8000;

            track->audio.channels = 1;

        } else if (codec_id == CODEC_ID_RA_288 || codec_id == CODEC_ID_COOK ||

                   codec_id == CODEC_ID_ATRAC3 || codec_id == CODEC_ID_SIPR) {

            int flavor;

            ffio_init_context(&b, track->codec_priv.data,track->codec_priv.size,

                          0, NULL, NULL, NULL, NULL);

            avio_skip(&b, 22);

            flavor                       = avio_rb16(&b);

            track->audio.coded_framesize = avio_rb32(&b);

            avio_skip(&b, 12);

            track->audio.sub_packet_h    = avio_rb16(&b);

            track->audio.frame_size      = avio_rb16(&b);

            track->audio.sub_packet_size = avio_rb16(&b);

            track->audio.buf = av_malloc(track->audio.frame_size * track->audio.sub_packet_h);

            if (codec_id == CODEC_ID_RA_288) {

                st->codec->block_align = track->audio.coded_framesize;

                track->codec_priv.size = 0;

            } else {

                if (codec_id == CODEC_ID_SIPR && flavor < 4) {

                    const int sipr_bit_rate[4] = { 6504, 8496, 5000, 16000 };

                    track->audio.sub_packet_size = ff_sipr_subpk_size[flavor];

                    st->codec->bit_rate = sipr_bit_rate[flavor];

                }

                st->codec->block_align = track->audio.sub_packet_size;

                extradata_offset = 78;

            }

        }

        track->codec_priv.size -= extradata_offset;



        if (codec_id == CODEC_ID_NONE)

            av_log(matroska->ctx, AV_LOG_INFO,

                   ""Unknown/unsupported CodecID %s.
"", track->codec_id);



        if (track->time_scale < 0.01)

            track->time_scale = 1.0;

        avpriv_set_pts_info(st, 64, matroska->time_scale*track->time_scale, 1000*1000*1000); /* 64 bit pts in ns */



        st->codec->codec_id = codec_id;

        st->start_time = 0;

        if (strcmp(track->language, ""und""))

            av_dict_set(&st->metadata, ""language"", track->language, 0);

        av_dict_set(&st->metadata, ""title"", track->name, 0);



        if (track->flag_default)

            st->disposition |= AV_DISPOSITION_DEFAULT;

        if (track->flag_forced)

            st->disposition |= AV_DISPOSITION_FORCED;



        if (!st->codec->extradata) {

            if(extradata){

                st->codec->extradata = extradata;

                st->codec->extradata_size = extradata_size;

            } else if(track->codec_priv.data && track->codec_priv.size > 0){

                st->codec->extradata = av_mallocz(track->codec_priv.size +

                                                  FF_INPUT_BUFFER_PADDING_SIZE);

                if(st->codec->extradata == NULL)

                    return AVERROR(ENOMEM);

                st->codec->extradata_size = track->codec_priv.size;

                memcpy(st->codec->extradata,

                       track->codec_priv.data + extradata_offset,

                       track->codec_priv.size);

            }

        }



        if (track->type == MATROSKA_TRACK_TYPE_VIDEO) {

            MatroskaTrackPlane *planes = track->operation.combine_planes.elem;



            st->codec->codec_type = AVMEDIA_TYPE_VIDEO;

            st->codec->codec_tag  = fourcc;

            st->codec->width  = track->video.pixel_width;

            st->codec->height = track->video.pixel_height;

            av_reduce(&st->sample_aspect_ratio.num,

                      &st->sample_aspect_ratio.den,

                      st->codec->height * track->video.display_width,

                      st->codec-> width * track->video.display_height,

                      255);

            st->need_parsing = AVSTREAM_PARSE_HEADERS;

            if (track->default_duration)

                st->avg_frame_rate = av_d2q(1000000000.0/track->default_duration, INT_MAX);



            /* export stereo mode flag as metadata tag */

            if (track->video.stereo_mode && track->video.stereo_mode < MATROSKA_VIDEO_STEREO_MODE_COUNT)

                av_dict_set(&st->metadata, ""stereo_mode"", matroska_video_stereo_mode[track->video.stereo_mode], 0);



            /* if we have virtual track, mark the real tracks */

            for (ie=0; ie < track->operation.combine_planes.nb_elem; ie++) {

                char buf[32];

                if (planes[ie].type >= MATROSKA_VIDEO_STEREO_PLANE_COUNT)

                    continue;

                snprintf(buf, sizeof(buf), ""%s_%d"",

                         matroska_video_stereo_plane[planes[ie].type], i);

                for (kid=0; kid < matroska->frames.nb_elem; kid++)

                    if (planes[ie].uid == frames[kid].uid) {

                        av_dict_set(&s->streams[kid]->metadata,

                                    ""stereo_mode"", buf, 0);

                        break;

                    }

            }

        } else if (track->type == MATROSKA_TRACK_TYPE_AUDIO) {

            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;

            st->codec->sample_rate = track->audio.out_samplerate;

            st->codec->channels = track->audio.channels;

            if (st->codec->codec_id != CODEC_ID_AAC)

            st->need_parsing = AVSTREAM_PARSE_HEADERS;

        } else if (track->type == MATROSKA_TRACK_TYPE_SUBTITLE) {

            st->codec->codec_type = AVMEDIA_TYPE_SUBTITLE;

        }

    }



    attachement = attachements_list->elem;

    for (ie=0; ie<attachements_list->nb_elem; ie++) {

        if (!(attachement[ie].filename && attachement[ie].mime &&

              attachement[ie].bin.data && attachement[ie].bin.size > 0)) {

            av_log(matroska->ctx, AV_LOG_ERROR, ""incomplete attachment
"");

        } else {

            AVStream *st = avformat_new_stream(s, NULL);

            if (st == NULL)

                break;

            av_dict_set(&st->metadata, ""filename"",attachement[ie].filename, 0);

            av_dict_set(&st->metadata, ""mimetype"", attachement[ie].mime, 0);

            st->codec->codec_id = CODEC_ID_NONE;

            st->codec->codec_type = AVMEDIA_TYPE_ATTACHMENT;

            st->codec->extradata  = av_malloc(attachement[ie].bin.size + FF_INPUT_BUFFER_PADDING_SIZE);

            if(st->codec->extradata == NULL)

                break;

            st->codec->extradata_size = attachement[ie].bin.size;

            memcpy(st->codec->extradata, attachement[ie].bin.data, attachement[ie].bin.size);



            for (i=0; ff_mkv_mime_tags[i].id != CODEC_ID_NONE; i++) {

                if (!strncmp(ff_mkv_mime_tags[i].str, attachement[ie].mime,

                             strlen(ff_mkv_mime_tags[i].str))) {

                    st->codec->codec_id = ff_mkv_mime_tags[i].id;

                    break;

                }

            }

            attachement[ie].stream = st;

        }

    }



    chapters = chapters_list->elem;

    for (i=0; i<chapters_list->nb_elem; i++)

        if (chapters[i].start != AV_NOPTS_VALUE && chapters[i].uid

            && (max_start==0 || chapters[i].start > max_start)) {

            chapters[i].chapter =

            avpriv_new_chapter(s, chapters[i].uid, (AVRational){1, 1000000000},

                           chapters[i].start, chapters[i].end,

                           chapters[i].title);

            av_dict_set(&chapters[i].chapter->metadata,

                             ""title"", chapters[i].title, 0);

            max_start = chapters[i].start;

        }



    matroska_add_index_entries(matroska);



    matroska_convert_tags(s);



    return 0;

}
",1,1,0.0,1,"s,matroska,attachements_list,attachements,chapters_list,chapters,tracks,pos,st,i,j,k,res","s:-0.014470279216766357,matroska:-0.05771481990814209,attachements_list:-0.0052741169929504395,attachements:6.884336471557617e-05,chapters_list:-0.012542128562927246,chapters:0.006596386432647705,tracks:-0.0018209218978881836,pos:-0.0122261643409729,st:-0.009094536304473877,i:-0.016808629035949707,j:-0.004840373992919922,k:0.004403531551361084,res:-0.011568903923034668,",4.0,55.0,"chapters:chapters,k:kid,attachements:attachement,tracks:frames,j:ie,",Greedy,347,0.3854782740275065
177,"static int filter_frame(AVFilterLink *inlink, AVFrame *picref)

{

    AVFilterContext *ctx = inlink->dst;

    SignatureContext *sic = ctx->priv;

    StreamContext *sc = &(sic->streamcontexts[FF_INLINK_IDX(inlink)]);

    FineSignature* fs;



    static const uint8_t pot3[5] = { 3*3*3*3, 3*3*3, 3*3, 3, 1 };

    /* indexes of words : 210,217,219,274,334  44,175,233,270,273  57,70,103,237,269  100,285,295,337,354  101,102,111,275,296

    s2usw = sorted to unsorted wordvec: 44 is at index 5, 57 at index 10...

    */

    static const unsigned int wordvec[25] = {44,57,70,100,101,102,103,111,175,210,217,219,233,237,269,270,273,274,275,285,295,296,334,337,354};

    static const uint8_t      s2usw[25]   = { 5,10,11, 15, 20, 21, 12, 22,  6,  0,  1,  2,  7, 13, 14,  8,  9,  3, 23, 16, 17, 24,  4, 18, 19};



    uint8_t wordt2b[5] = { 0, 0, 0, 0, 0 }; /* word ternary to binary */

    uint64_t intpic[32][32];

    uint64_t rowcount;

    uint8_t *p = picref->data[0];

    int inti, intj;

    int *intjlut;



    uint64_t conflist[DIFFELEM_SIZE];

    int f = 0, g = 0, w = 0;

    int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a, b;

    int64_t denom;

    int i, j, k, ternary;

    uint64_t blocksum;

    int blocksize;

    int64_t th; /* threshold */

    int64_t sum;



    int64_t precfactor = (sc->divide) ? 65536 : BLOCK_LCM;



    /* initialize fs */

    if (sc->curfinesig) {

        fs = av_mallocz(sizeof(FineSignature));

        if (!fs)

            return AVERROR(ENOMEM);

        sc->curfinesig->next = fs;

        fs->prev = sc->curfinesig;

        sc->curfinesig = fs;

    } else {

        fs = sc->curfinesig = sc->finesiglist;

        sc->curcoarsesig1->first = fs;

    }



    fs->pts = picref->pts;

    fs->index = sc->lastindex++;



    memset(intpic, 0, sizeof(uint64_t)*32*32);

    intjlut = av_malloc_array(inlink->w, sizeof(int));

    if (!intjlut)

        return AVERROR(ENOMEM);

    for (i = 0; i < inlink->w; i++) {

        intjlut[i] = (i*32)/inlink->w;

    }



    for (i = 0; i < inlink->h; i++) {

        inti = (i*32)/inlink->h;

        for (j = 0; j < inlink->w; j++) {

            intj = intjlut[j];

            intpic[inti][intj] += p[j];

        }

        p += picref->linesize[0];

    }

    av_freep(&intjlut);



    /* The following calculates a summed area table (intpic) and brings the numbers

     * in intpic to the same denominator.

     * So you only have to handle the numinator in the following sections.

     */

    dh1 = inlink->h / 32;

    if (inlink->h % 32)

        dh2 = dh1 + 1;

    dw1 = inlink->w / 32;

    if (inlink->w % 32)

        dw2 = dw1 + 1;

    denom = (sc->divide) ? dh1 * dh2 * dw1 * dw2 : 1;



    for (i = 0; i < 32; i++) {

        rowcount = 0;

        a = 1;

        if (dh2 > 1) {

            a = ((inlink->h*(i+1))%32 == 0) ? (inlink->h*(i+1))/32 - 1 : (inlink->h*(i+1))/32;

            a -= ((inlink->h*i)%32 == 0) ? (inlink->h*i)/32 - 1 : (inlink->h*i)/32;

            a = (a == dh1)? dh2 : dh1;

        }

        for (j = 0; j < 32; j++) {

            b = 1;

            if (dw2 > 1) {

                b = ((inlink->w*(j+1))%32 == 0) ? (inlink->w*(j+1))/32 - 1 : (inlink->w*(j+1))/32;

                b -= ((inlink->w*j)%32 == 0) ? (inlink->w*j)/32 - 1 : (inlink->w*j)/32;

                b = (b == dw1)? dw2 : dw1;

            }

            rowcount += intpic[i][j] * a * b * precfactor / denom;

            if (i > 0) {

                intpic[i][j] = intpic[i-1][j] + rowcount;

            } else {

                intpic[i][j] = rowcount;

            }

        }

    }



    denom = (sc->divide) ? 1 : dh1 * dh2 * dw1 * dw2;



    for (i = 0; i < ELEMENT_COUNT; i++) {

        const ElemCat* elemcat = elements[i];

        int64_t* elemsignature;

        uint64_t* sortsignature;



        elemsignature = av_malloc_array(elemcat->elem_count, sizeof(int64_t));

        if (!elemsignature)

            return AVERROR(ENOMEM);

        sortsignature = av_malloc_array(elemcat->elem_count, sizeof(int64_t));

        if (!sortsignature)

            return AVERROR(ENOMEM);



        for (j = 0; j < elemcat->elem_count; j++) {

            blocksum = 0;

            blocksize = 0;

            for (k = 0; k < elemcat->left_count; k++) {

                blocksum += get_block_sum(sc, intpic, &elemcat->blocks[j*elemcat->block_count+k]);

                blocksize += get_block_size(&elemcat->blocks[j*elemcat->block_count+k]);

            }

            sum = blocksum / blocksize;

            if (elemcat->av_elem) {

                sum -= 128 * precfactor * denom;

            } else {

                blocksum = 0;

                blocksize = 0;

                for (; k < elemcat->block_count; k++) {

                    blocksum += get_block_sum(sc, intpic, &elemcat->blocks[j*elemcat->block_count+k]);

                    blocksize += get_block_size(&elemcat->blocks[j*elemcat->block_count+k]);

                }

                sum -= blocksum / blocksize;

                conflist[g++] = FFABS(sum * 8 / (precfactor * denom));

            }



            elemsignature[j] = sum;

            sortsignature[j] = FFABS(sum);

        }



        /* get threshold */

        qsort(sortsignature, elemcat->elem_count, sizeof(uint64_t), (void*) cmp);

        th = sortsignature[(int) (elemcat->elem_count*0.333)];



        /* ternarize */

        for (j = 0; j < elemcat->elem_count; j++) {

            if (elemsignature[j] < -th) {

                ternary = 0;

            } else if (elemsignature[j] <= th) {

                ternary = 1;

            } else {

                ternary = 2;

            }

            fs->framesig[f/5] += ternary * pot3[f%5];



            if (f == wordvec[w]) {

                fs->words[s2usw[w]/5] += ternary * pot3[wordt2b[s2usw[w]/5]++];

                if (w < 24)

                    w++;

            }

            f++;

        }

        av_freep(&elemsignature);

        av_freep(&sortsignature);

    }



    /* confidence */

    qsort(conflist, DIFFELEM_SIZE, sizeof(uint64_t), (void*) cmp);

    fs->confidence = FFMIN(conflist[DIFFELEM_SIZE/2], 255);



    /* coarsesignature */

    if (sc->coarsecount == 0) {

        if (sc->curcoarsesig2) {

            sc->curcoarsesig1 = av_mallocz(sizeof(CoarseSignature));

            if (!sc->curcoarsesig1)

                return AVERROR(ENOMEM);

            sc->curcoarsesig1->first = fs;

            sc->curcoarsesig2->next = sc->curcoarsesig1;

            sc->coarseend = sc->curcoarsesig1;

        }

    }

    if (sc->coarsecount == 45) {

        sc->midcoarse = 1;

        sc->curcoarsesig2 = av_mallocz(sizeof(CoarseSignature));

        if (!sc->curcoarsesig2)

            return AVERROR(ENOMEM);

        sc->curcoarsesig2->first = fs;

        sc->curcoarsesig1->next = sc->curcoarsesig2;

        sc->coarseend = sc->curcoarsesig2;

    }

    for (i = 0; i < 5; i++) {

        set_bit(sc->curcoarsesig1->data[i], fs->words[i]);

    }

    /* assuming the actual frame is the last */

    sc->curcoarsesig1->last = fs;

    if (sc->midcoarse) {

        for (i = 0; i < 5; i++) {

            set_bit(sc->curcoarsesig2->data[i], fs->words[i]);

        }

        sc->curcoarsesig2->last = fs;

    }



    sc->coarsecount = (sc->coarsecount+1)%90;



    /* debug printing finesignature */

    if (av_log_get_level() == AV_LOG_DEBUG) {

        av_log(ctx, AV_LOG_DEBUG, ""input %d, confidence: %d\n"", FF_INLINK_IDX(inlink), fs->confidence);



        av_log(ctx, AV_LOG_DEBUG, ""words:"");

        for (i = 0; i < 5; i++) {

            av_log(ctx, AV_LOG_DEBUG, "" %d:"", fs->words[i] );

            av_log(ctx, AV_LOG_DEBUG, "" %d"", fs->words[i] / pot3[0] );

            for (j = 1; j < 5; j++)

                av_log(ctx, AV_LOG_DEBUG, "",%d"", fs->words[i] % pot3[j-1] / pot3[j] );

            av_log(ctx, AV_LOG_DEBUG, "";"");

        }

        av_log(ctx, AV_LOG_DEBUG, ""\n"");



        av_log(ctx, AV_LOG_DEBUG, ""framesignature:"");

        for (i = 0; i < SIGELEM_SIZE/5; i++) {

            av_log(ctx, AV_LOG_DEBUG, "" %d"", fs->framesig[i] / pot3[0] );

            for (j = 1; j < 5; j++)

                av_log(ctx, AV_LOG_DEBUG, "",%d"", fs->framesig[i] % pot3[j-1] / pot3[j] );

        }

        av_log(ctx, AV_LOG_DEBUG, ""\n"");

    }



    if (FF_INLINK_IDX(inlink) == 0)

        return ff_filter_frame(inlink->dst->outputs[0], picref);

    return 1;

}
",2001,"static int filter_frame(AVFilterLink *inclog, AVFrame *pinRef)

{

    AVFilterContext *cms = inclog->dst;

    SignatureContext *sic = cms->priv;

    StreamContext *sc = &(sic->streamcontexts[FF_INLINK_IDX(inclog)]);

    FineSignature* FS;



    static const uint8_t pot3[5] = { 3*3*3*3, 3*3*3, 3*3, 3, 1 };

    /* indexes of words : 210,217,219,274,334  44,175,233,270,273  57,70,103,237,269  100,285,295,337,354  101,102,111,275,296

    s2usw = sorted to unsorted wordvec: 44 is at index 5, 57 at index 10...

    */

    static const unsigned int wordvec[25] = {44,57,70,100,101,102,103,111,175,210,217,219,233,237,269,270,273,274,275,285,295,296,334,337,354};

    static const uint8_t      s2usw[25]   = { 5,10,11, 15, 20, 21, 12, 22,  6,  0,  1,  2,  7, 13, 14,  8,  9,  3, 23, 16, 17, 24,  4, 18, 19};



    uint8_t wordt2b[5] = { 0, 0, 0, 0, 0 }; /* word ternary to binary */

    uint64_t intpic[32][32];

    uint64_t rowcount;

    uint8_t *p = pinRef->data[0];

    int inti, intj;

    int *intjlut;



    uint64_t conflist[DIFFELEM_SIZE];

    int f = 0, g = 0, w = 0;

    int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a, b;

    int64_t denom;

    int i, j, k, ternary;

    uint64_t blocksum;

    int blocksize;

    int64_t th; /* threshold */

    int64_t sum;



    int64_t precfactor = (sc->divide) ? 65536 : BLOCK_LCM;



    /* initialize fs */

    if (sc->curfinesig) {

        FS = av_mallocz(sizeof(FineSignature));

        if (!FS)

            return AVERROR(ENOMEM);

        sc->curfinesig->next = FS;

        FS->prev = sc->curfinesig;

        sc->curfinesig = FS;

    } else {

        FS = sc->curfinesig = sc->finesiglist;

        sc->curcoarsesig1->first = FS;

    }



    FS->pts = pinRef->pts;

    FS->index = sc->lastindex++;



    memset(intpic, 0, sizeof(uint64_t)*32*32);

    intjlut = av_malloc_array(inclog->w, sizeof(int));

    if (!intjlut)

        return AVERROR(ENOMEM);

    for (i = 0; i < inclog->w; i++) {

        intjlut[i] = (i*32)/inclog->w;

    }



    for (i = 0; i < inclog->h; i++) {

        inti = (i*32)/inclog->h;

        for (j = 0; j < inclog->w; j++) {

            intj = intjlut[j];

            intpic[inti][intj] += p[j];

        }

        p += pinRef->linesize[0];

    }

    av_freep(&intjlut);



    /* The following calculates a summed area table (intpic) and brings the numbers

     * in intpic to the same denominator.

     * So you only have to handle the numinator in the following sections.

     */

    dh1 = inclog->h / 32;

    if (inclog->h % 32)

        dh2 = dh1 + 1;

    dw1 = inclog->w / 32;

    if (inclog->w % 32)

        dw2 = dw1 + 1;

    denom = (sc->divide) ? dh1 * dh2 * dw1 * dw2 : 1;



    for (i = 0; i < 32; i++) {

        rowcount = 0;

        a = 1;

        if (dh2 > 1) {

            a = ((inclog->h*(i+1))%32 == 0) ? (inclog->h*(i+1))/32 - 1 : (inclog->h*(i+1))/32;

            a -= ((inclog->h*i)%32 == 0) ? (inclog->h*i)/32 - 1 : (inclog->h*i)/32;

            a = (a == dh1)? dh2 : dh1;

        }

        for (j = 0; j < 32; j++) {

            b = 1;

            if (dw2 > 1) {

                b = ((inclog->w*(j+1))%32 == 0) ? (inclog->w*(j+1))/32 - 1 : (inclog->w*(j+1))/32;

                b -= ((inclog->w*j)%32 == 0) ? (inclog->w*j)/32 - 1 : (inclog->w*j)/32;

                b = (b == dw1)? dw2 : dw1;

            }

            rowcount += intpic[i][j] * a * b * precfactor / denom;

            if (i > 0) {

                intpic[i][j] = intpic[i-1][j] + rowcount;

            } else {

                intpic[i][j] = rowcount;

            }

        }

    }



    denom = (sc->divide) ? 1 : dh1 * dh2 * dw1 * dw2;



    for (i = 0; i < ELEMENT_COUNT; i++) {

        const ElemCat* elemcat = elements[i];

        int64_t* elemsignature;

        uint64_t* sortsignature;



        elemsignature = av_malloc_array(elemcat->elem_count, sizeof(int64_t));

        if (!elemsignature)

            return AVERROR(ENOMEM);

        sortsignature = av_malloc_array(elemcat->elem_count, sizeof(int64_t));

        if (!sortsignature)

            return AVERROR(ENOMEM);



        for (j = 0; j < elemcat->elem_count; j++) {

            blocksum = 0;

            blocksize = 0;

            for (k = 0; k < elemcat->left_count; k++) {

                blocksum += get_block_sum(sc, intpic, &elemcat->blocks[j*elemcat->block_count+k]);

                blocksize += get_block_size(&elemcat->blocks[j*elemcat->block_count+k]);

            }

            sum = blocksum / blocksize;

            if (elemcat->av_elem) {

                sum -= 128 * precfactor * denom;

            } else {

                blocksum = 0;

                blocksize = 0;

                for (; k < elemcat->block_count; k++) {

                    blocksum += get_block_sum(sc, intpic, &elemcat->blocks[j*elemcat->block_count+k]);

                    blocksize += get_block_size(&elemcat->blocks[j*elemcat->block_count+k]);

                }

                sum -= blocksum / blocksize;

                conflist[g++] = FFABS(sum * 8 / (precfactor * denom));

            }



            elemsignature[j] = sum;

            sortsignature[j] = FFABS(sum);

        }



        /* get threshold */

        qsort(sortsignature, elemcat->elem_count, sizeof(uint64_t), (void*) cmp);

        th = sortsignature[(int) (elemcat->elem_count*0.333)];



        /* ternarize */

        for (j = 0; j < elemcat->elem_count; j++) {

            if (elemsignature[j] < -th) {

                ternary = 0;

            } else if (elemsignature[j] <= th) {

                ternary = 1;

            } else {

                ternary = 2;

            }

            FS->framesig[f/5] += ternary * pot3[f%5];



            if (f == wordvec[w]) {

                FS->words[s2usw[w]/5] += ternary * pot3[wordt2b[s2usw[w]/5]++];

                if (w < 24)

                    w++;

            }

            f++;

        }

        av_freep(&elemsignature);

        av_freep(&sortsignature);

    }



    /* confidence */

    qsort(conflist, DIFFELEM_SIZE, sizeof(uint64_t), (void*) cmp);

    FS->confidence = FFMIN(conflist[DIFFELEM_SIZE/2], 255);



    /* coarsesignature */

    if (sc->coarsecount == 0) {

        if (sc->curcoarsesig2) {

            sc->curcoarsesig1 = av_mallocz(sizeof(CoarseSignature));

            if (!sc->curcoarsesig1)

                return AVERROR(ENOMEM);

            sc->curcoarsesig1->first = FS;

            sc->curcoarsesig2->next = sc->curcoarsesig1;

            sc->coarseend = sc->curcoarsesig1;

        }

    }

    if (sc->coarsecount == 45) {

        sc->midcoarse = 1;

        sc->curcoarsesig2 = av_mallocz(sizeof(CoarseSignature));

        if (!sc->curcoarsesig2)

            return AVERROR(ENOMEM);

        sc->curcoarsesig2->first = FS;

        sc->curcoarsesig1->next = sc->curcoarsesig2;

        sc->coarseend = sc->curcoarsesig2;

    }

    for (i = 0; i < 5; i++) {

        set_bit(sc->curcoarsesig1->data[i], FS->words[i]);

    }

    /* assuming the actual frame is the last */

    sc->curcoarsesig1->last = FS;

    if (sc->midcoarse) {

        for (i = 0; i < 5; i++) {

            set_bit(sc->curcoarsesig2->data[i], FS->words[i]);

        }

        sc->curcoarsesig2->last = FS;

    }



    sc->coarsecount = (sc->coarsecount+1)%90;



    /* debug printing finesignature */

    if (av_log_get_level() == AV_LOG_DEBUG) {

        av_log(cms, AV_LOG_DEBUG, ""input %d, confidence: %d
"", FF_INLINK_IDX(inclog), FS->confidence);



        av_log(cms, AV_LOG_DEBUG, ""words:"");

        for (i = 0; i < 5; i++) {

            av_log(cms, AV_LOG_DEBUG, "" %d:"", FS->words[i] );

            av_log(cms, AV_LOG_DEBUG, "" %d"", FS->words[i] / pot3[0] );

            for (j = 1; j < 5; j++)

                av_log(cms, AV_LOG_DEBUG, "",%d"", FS->words[i] % pot3[j-1] / pot3[j] );

            av_log(cms, AV_LOG_DEBUG, "";"");

        }

        av_log(cms, AV_LOG_DEBUG, ""
"");



        av_log(cms, AV_LOG_DEBUG, ""framesignature:"");

        for (i = 0; i < SIGELEM_SIZE/5; i++) {

            av_log(cms, AV_LOG_DEBUG, "" %d"", FS->framesig[i] / pot3[0] );

            for (j = 1; j < 5; j++)

                av_log(cms, AV_LOG_DEBUG, "",%d"", FS->framesig[i] % pot3[j-1] / pot3[j] );

        }

        av_log(cms, AV_LOG_DEBUG, ""
"");

    }



    if (FF_INLINK_IDX(inclog) == 0)

        return ff_filter_frame(inclog->dst->outputs[0], pinRef);

    return 1;

}
",1,1,0.0,1,"inlink,picref,ctx,sic,sc,fs,pot3,wordvec,s2usw,wordt2b,intpic,rowcount,p,inti,intj,intjlut,conflist,a,b,denom,i,j,k,ternary,blocksum,blocksize,th,sum,w,f","inlink:0.08572706580162048,picref:0.07212722301483154,ctx:0.06703323125839233,sic:0.05660414695739746,sc:0.039248138666152954,fs:0.058143794536590576,pot3:0.012752562761306763,wordvec:0.023488610982894897,s2usw:0.020549923181533813,wordt2b:0.016458898782730103,intpic:0.017875581979751587,rowcount:0.00706857442855835,p:0.01731756329536438,inti:0.028378993272781372,intj:0.02646312117576599,intjlut:0.02806118130683899,conflist:0.029696792364120483,a:0.003978073596954346,b:0.004426628351211548,denom:0.02082541584968567,i:0.0060193538665771484,j:0.012034326791763306,k:-0.00011390447616577148,ternary:0.016080349683761597,blocksum:0.02076396346092224,blocksize:0.028646916151046753,th:0.005195885896682739,sum:0.00040522217750549316,w:-0.0006254911422729492,f:0.005728781223297119,",4.0,71.0,"inlink:inclog,picref:pinRef,ctx:cms,fs:FS,",Greedy,505,0.5049930731455485
178,"static void test_dma_fragmented(void)

{

    AHCIQState *ahci;

    AHCICommand *cmd;

    uint8_t px;

    size_t bufsize = 4096;

    unsigned char *tx = g_malloc(bufsize);

    unsigned char *rx = g_malloc0(bufsize);

    uint64_t ptr;



    ahci = ahci_boot_and_enable(NULL);

    px = ahci_port_select(ahci);

    ahci_port_clear(ahci, px);



    /* create pattern */

    generate_pattern(tx, bufsize, AHCI_SECTOR_SIZE);



    /* Create a DMA buffer in guest memory, and write our pattern to it. */

    ptr = guest_alloc(ahci->parent->alloc, bufsize);

    g_assert(ptr);

    bufwrite(ptr, tx, bufsize);



    cmd = ahci_command_create(CMD_WRITE_DMA);

    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);

    ahci_command_commit(ahci, cmd, px);

    ahci_command_issue(ahci, cmd);

    ahci_command_verify(ahci, cmd);

    g_free(cmd);



    cmd = ahci_command_create(CMD_READ_DMA);

    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);

    ahci_command_commit(ahci, cmd, px);

    ahci_command_issue(ahci, cmd);

    ahci_command_verify(ahci, cmd);

    g_free(cmd);



    /* Read back the guest's receive buffer into local memory */

    bufread(ptr, rx, bufsize);

    guest_free(ahci->parent->alloc, ptr);



    g_assert_cmphex(memcmp(tx, rx, bufsize), ==, 0);



    ahci_shutdown(ahci);



    g_free(rx);

    g_free(tx);

}
",251,"static void test_dma_fragmented(void)

{

    AHCIQState *ahci;

    AHCICommand *help;

    uint8_t px;

    size_t bufsize = 4096;

    unsigned char *tc = g_malloc(bufsize);

    unsigned char *rx = g_malloc0(bufsize);

    uint64_t ptr;



    ahci = ahci_boot_and_enable(NULL);

    px = ahci_port_select(ahci);

    ahci_port_clear(ahci, px);



    /* create pattern */

    generate_pattern(tc, bufsize, AHCI_SECTOR_SIZE);



    /* Create a DMA buffer in guest memory, and write our pattern to it. */

    ptr = guest_alloc(ahci->parent->alloc, bufsize);

    g_assert(ptr);

    bufwrite(ptr, tc, bufsize);



    help = ahci_command_create(CMD_WRITE_DMA);

    ahci_command_adjust(help, 0, ptr, bufsize, 32);

    ahci_command_commit(ahci, help, px);

    ahci_command_issue(ahci, help);

    ahci_command_verify(ahci, help);

    g_free(help);



    help = ahci_command_create(CMD_READ_DMA);

    ahci_command_adjust(help, 0, ptr, bufsize, 32);

    ahci_command_commit(ahci, help, px);

    ahci_command_issue(ahci, help);

    ahci_command_verify(ahci, help);

    g_free(help);



    /* Read back the guest's receive buffer into local memory */

    bufread(ptr, rx, bufsize);

    guest_free(ahci->parent->alloc, ptr);



    g_assert_cmphex(memcmp(tc, rx, bufsize), ==, 0);



    ahci_shutdown(ahci);



    g_free(rx);

    g_free(tc);

}
",1,1,0.0,1,"ahci,cmd,px,tx,rx,ptr","ahci:-0.06536966562271118,cmd:-0.018989205360412598,px:-0.04263174533843994,tx:-0.027694880962371826,rx:-0.041028738021850586,ptr:-0.03500401973724365,",2.0,18.0,"cmd:help,tx:tc,",Greedy,171,0.1593801458676656
180,"static int w64_read_header(AVFormatContext *s, AVFormatParameters *ap)

{

    int64_t size;

    AVIOContext *pb  = s->pb;

    WAVContext    *wav = s->priv_data;

    AVStream *st;

    uint8_t guid[16];



    avio_read(pb, guid, 16);

    if (memcmp(guid, guid_riff, 16))

        return -1;



    if (avio_rl64(pb) < 16 + 8 + 16 + 8 + 16 + 8) /* riff + wave + fmt + sizes */

        return -1;



    avio_read(pb, guid, 16);

    if (memcmp(guid, guid_wave, 16)) {

        av_log(s, AV_LOG_ERROR, ""could not find wave guid\n"");

        return -1;

    }



    size = find_guid(pb, guid_fmt);

    if (size < 0) {

        av_log(s, AV_LOG_ERROR, ""could not find fmt guid\n"");

        return -1;

    }



    st = av_new_stream(s, 0);

    if (!st)

        return AVERROR(ENOMEM);



    /* subtract chunk header size - normal wav file doesn't count it */

    ff_get_wav_header(pb, st->codec, size - 24);

    avio_skip(pb, FFALIGN(size, INT64_C(8)) - size);



    st->need_parsing = AVSTREAM_PARSE_FULL;



    av_set_pts_info(st, 64, 1, st->codec->sample_rate);



    size = find_guid(pb, guid_data);

    if (size < 0) {

        av_log(s, AV_LOG_ERROR, ""could not find data guid\n"");

        return -1;

    }

    wav->data_end = avio_tell(pb) + size - 24;

    wav->w64      = 1;



    return 0;

}
",276,"static int w64_read_header(AVFormatContext *s, AVFormatParameters *ap)

{

    int64_t size;

    AVIOContext *summary  = s->summary;

    WAVContext    *wav = s->priv_data;

    AVStream *st;

    uint8_t guid[16];



    avio_read(summary, guid, 16);

    if (memcmp(guid, guid_riff, 16))

        return -1;



    if (avio_rl64(summary) < 16 + 8 + 16 + 8 + 16 + 8) /* riff + wave + fmt + sizes */

        return -1;



    avio_read(summary, guid, 16);

    if (memcmp(guid, guid_wave, 16)) {

        av_log(s, AV_LOG_ERROR, ""could not find wave guid
"");

        return -1;

    }



    size = find_guid(summary, guid_fmt);

    if (size < 0) {

        av_log(s, AV_LOG_ERROR, ""could not find fmt guid
"");

        return -1;

    }



    st = av_new_stream(s, 0);

    if (!st)

        return AVERROR(ENOMEM);



    /* subtract chunk header size - normal wav file doesn't count it */

    ff_get_wav_header(summary, st->codec, size - 24);

    avio_skip(summary, FFALIGN(size, INT64_C(8)) - size);



    st->need_parsing = AVSTREAM_PARSE_FULL;



    av_set_pts_info(st, 64, 1, st->codec->sample_rate);



    size = find_guid(summary, guid_data);

    if (size < 0) {

        av_log(s, AV_LOG_ERROR, ""could not find data guid
"");

        return -1;

    }

    wav->data_end = avio_tell(summary) + size - 24;

    wav->w64      = 1;



    return 0;

}
",1,1,0.0,1,"s,ap,size,pb,wav,st,guid","s:0.005676746368408203,ap:0.0005553364753723145,size:0.02423316240310669,pb:0.0431271493434906,wav:0.01669931411743164,st:0.003523498773574829,guid:0.01774650812149048,",1.0,10.0,"pb:summary,",Greedy,108,0.1066032369931539
181,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)

{

	long i;

	long num_pixels = src_size >> 1;



	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = src[2*i];

	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
",121,"void rgb15tobgr15(const uint8_t *loc, uint8_t *lbl, long  src_scale)

{

	long uri;

	long num_pixels =  src_scale >> 1;



	for(uri=0; uri<num_pixels; uri++)

	{

	    unsigned fb,group,rg;

	    register uint16_t rsgb;

	    rsgb = loc[2*uri];

	    rg = rsgb&0x1F;

	    group = (rsgb&0x3E0)>>5;

	    fb = (rsgb&0x7C00)>>10;

	    lbl[2*uri] = (fb&0x1F) | ((group&0x1F)<<5) | ((rg&0x1F)<<10);

	}

}
",1,1,0.0,1,"src,dst,src_size,i,b,g,r,rgb","src:-0.061305344104766846,dst:-0.09111416339874268,src_size:-0.03793621063232422,i:-0.02996504306793213,b:-0.005168795585632324,g:-0.0167233943939209,r:-0.032495200634002686,rgb:-0.09148097038269043,",8.0,26.0,"b:fb,g:group,i:uri,r:rg,src_size: src_scale,src:loc,dst:lbl,rgb:rsgb,",Greedy,332,0.3218201001485188
182,"int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)

{

    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));



    entry->rect.x = x;

    entry->rect.y = y;

    entry->rect.w = w;

    entry->rect.h = h;



    vnc_lock_queue(queue);

    QLIST_INSERT_HEAD(&job->rectangles, entry, next);

    vnc_unlock_queue(queue);

    return 1;

}
",90,"int vnc_job_add_rect(VncJob *node, int x, int y, int w, int h)

{

    VncRectEntry *link = g_malloc0(sizeof(VncRectEntry));



    link->rect.x = x;

    link->rect.y = y;

    link->rect.w = w;

    link->rect.h = h;



    vnc_lock_queue(queue);

    QLIST_INSERT_HEAD(&node->rectangles, link, next);

    vnc_unlock_queue(queue);

    return 1;

}
",1,1,0.0,1,"job,x,y,w,h,entry","job:0.09643219411373138,x:0.0008118301630020142,y:0.0035910606384277344,w:0.00798805058002472,h:0.008731245994567871,entry:0.15509378910064697,",2.0,8.0,"entry:link,job:node,",Greedy,119,0.1072372237841288
194,"int ff_ass_split_override_codes(const ASSCodesCallbacks *callbacks, void *priv,

                                const char *buf)

{

    const char *text = NULL;

    char new_line[2];

    int text_len = 0;



    while (*buf) {

        if (text && callbacks->text &&

            (sscanf(buf, ""\\%1[nN]"", new_line) == 1 ||

             !strncmp(buf, ""{\\"", 2))) {

            callbacks->text(priv, text, text_len);

            text = NULL;

        }

        if (sscanf(buf, ""\\%1[nN]"", new_line) == 1) {

            if (callbacks->new_line)

                callbacks->new_line(priv, new_line[0] == 'N');

            buf += 2;

        } else if (!strncmp(buf, ""{\\"", 2)) {

            buf++;

            while (*buf == '\\') {

                char style[2], c[2], sep[2], c_num[2] = ""0"", tmp[128] = {0};

                unsigned int color = 0xFFFFFFFF;

                int len, size = -1, an = -1, alpha = -1;

                int x1, y1, x2, y2, t1 = -1, t2 = -1;

                if (sscanf(buf, ""\\%1[bisu]%1[01\\}]%n"", style, c, &len) > 1) {

                    int close = c[0] == '0' ? 1 : c[0] == '1' ? 0 : -1;

                    len += close != -1;

                    if (callbacks->style)

                        callbacks->style(priv, style[0], close);

                } else if (sscanf(buf, ""\\c%1[\\}]%n"", sep, &len) > 0 ||

                           sscanf(buf, ""\\c&H%X&%1[\\}]%n"", &color, sep, &len) > 1 ||

                           sscanf(buf, ""\\%1[1234]c%1[\\}]%n"", c_num, sep, &len) > 1 ||

                           sscanf(buf, ""\\%1[1234]c&H%X&%1[\\}]%n"", c_num, &color, sep, &len) > 2) {

                    if (callbacks->color)

                        callbacks->color(priv, color, c_num[0] - '0');

                } else if (sscanf(buf, ""\\alpha%1[\\}]%n"", sep, &len) > 0 ||

                           sscanf(buf, ""\\alpha&H%2X&%1[\\}]%n"", &alpha, sep, &len) > 1 ||

                           sscanf(buf, ""\\%1[1234]a%1[\\}]%n"", c_num, sep, &len) > 1 ||

                           sscanf(buf, ""\\%1[1234]a&H%2X&%1[\\}]%n"", c_num, &alpha, sep, &len) > 2) {

                    if (callbacks->alpha)

                        callbacks->alpha(priv, alpha, c_num[0] - '0');

                } else if (sscanf(buf, ""\\fn%1[\\}]%n"", sep, &len) > 0 ||

                           sscanf(buf, ""\\fn%127[^\\}]%1[\\}]%n"", tmp, sep, &len) > 1) {

                    if (callbacks->font_name)

                        callbacks->font_name(priv, tmp[0] ? tmp : NULL);

                } else if (sscanf(buf, ""\\fs%1[\\}]%n"", sep, &len) > 0 ||

                           sscanf(buf, ""\\fs%u%1[\\}]%n"", &size, sep, &len) > 1) {

                    if (callbacks->font_size)

                        callbacks->font_size(priv, size);

                } else if (sscanf(buf, ""\\a%1[\\}]%n"", sep, &len) > 0 ||

                           sscanf(buf, ""\\a%2u%1[\\}]%n"", &an, sep, &len) > 1 ||

                           sscanf(buf, ""\\an%1[\\}]%n"", sep, &len) > 0 ||

                           sscanf(buf, ""\\an%1u%1[\\}]%n"", &an, sep, &len) > 1) {

                    if (an != -1 && buf[2] != 'n')

                        an = (an&3) + (an&4 ? 6 : an&8 ? 3 : 0);

                    if (callbacks->alignment)

                        callbacks->alignment(priv, an);

                } else if (sscanf(buf, ""\\r%1[\\}]%n"", sep, &len) > 0 ||

                           sscanf(buf, ""\\r%127[^\\}]%1[\\}]%n"", tmp, sep, &len) > 1) {

                    if (callbacks->cancel_overrides)

                        callbacks->cancel_overrides(priv, tmp);

                } else if (sscanf(buf, ""\\move(%d,%d,%d,%d)%1[\\}]%n"", &x1, &y1, &x2, &y2, sep, &len) > 4 ||

                           sscanf(buf, ""\\move(%d,%d,%d,%d,%d,%d)%1[\\}]%n"", &x1, &y1, &x2, &y2, &t1, &t2, sep, &len) > 6) {

                    if (callbacks->move)

                        callbacks->move(priv, x1, y1, x2, y2, t1, t2);

                } else if (sscanf(buf, ""\\pos(%d,%d)%1[\\}]%n"", &x1, &y1, sep, &len) > 2) {

                    if (callbacks->move)

                        callbacks->move(priv, x1, y1, x1, y1, -1, -1);

                } else if (sscanf(buf, ""\\org(%d,%d)%1[\\}]%n"", &x1, &y1, sep, &len) > 2) {

                    if (callbacks->origin)

                        callbacks->origin(priv, x1, y1);

                } else {

                    len = strcspn(buf+1, ""\\}"") + 2;  /* skip unknown code */

                }

                buf += len - 1;

            }

            if (*buf++ != '}')

                return AVERROR_INVALIDDATA;

        } else {

            if (!text) {

                text = buf;

                text_len = 1;

            } else

                text_len++;

            buf++;

        }

    }

    if (text && callbacks->text)

        callbacks->text(priv, text, text_len);

    if (callbacks->end)

        callbacks->end(priv);

    return 0;

}
",1124,"int ff_ass_split_override_codes(const ASSCodesCallbacks *callbacks, void *priv,

                                const char *wb)

{

    const char *type = NULL;

    char  new_liner[2];

    int ext_Len = 0;



    while (*wb) {

        if (type && callbacks->type &&

            (sscanf(wb, ""\\%1[nN]"",  new_liner) == 1 ||

             !strncmp(wb, ""{\\"", 2))) {

            callbacks->type(priv, type, ext_Len);

            type = NULL;

        }

        if (sscanf(wb, ""\\%1[nN]"",  new_liner) == 1) {

            if (callbacks-> new_liner)

                callbacks-> new_liner(priv,  new_liner[0] == 'N');

            wb += 2;

        } else if (!strncmp(wb, ""{\\"", 2)) {

            wb++;

            while (*wb == '\\') {

                char style[2], c[2], sep[2], c_num[2] = ""0"", tmp[128] = {0};

                unsigned int color = 0xFFFFFFFF;

                int len, size = -1, an = -1, alpha = -1;

                int x1, y1, x2, y2, t1 = -1, t2 = -1;

                if (sscanf(wb, ""\\%1[bisu]%1[01\\}]%n"", style, c, &len) > 1) {

                    int close = c[0] == '0' ? 1 : c[0] == '1' ? 0 : -1;

                    len += close != -1;

                    if (callbacks->style)

                        callbacks->style(priv, style[0], close);

                } else if (sscanf(wb, ""\\c%1[\\}]%n"", sep, &len) > 0 ||

                           sscanf(wb, ""\\c&H%X&%1[\\}]%n"", &color, sep, &len) > 1 ||

                           sscanf(wb, ""\\%1[1234]c%1[\\}]%n"", c_num, sep, &len) > 1 ||

                           sscanf(wb, ""\\%1[1234]c&H%X&%1[\\}]%n"", c_num, &color, sep, &len) > 2) {

                    if (callbacks->color)

                        callbacks->color(priv, color, c_num[0] - '0');

                } else if (sscanf(wb, ""\\alpha%1[\\}]%n"", sep, &len) > 0 ||

                           sscanf(wb, ""\\alpha&H%2X&%1[\\}]%n"", &alpha, sep, &len) > 1 ||

                           sscanf(wb, ""\\%1[1234]a%1[\\}]%n"", c_num, sep, &len) > 1 ||

                           sscanf(wb, ""\\%1[1234]a&H%2X&%1[\\}]%n"", c_num, &alpha, sep, &len) > 2) {

                    if (callbacks->alpha)

                        callbacks->alpha(priv, alpha, c_num[0] - '0');

                } else if (sscanf(wb, ""\\fn%1[\\}]%n"", sep, &len) > 0 ||

                           sscanf(wb, ""\\fn%127[^\\}]%1[\\}]%n"", tmp, sep, &len) > 1) {

                    if (callbacks->font_name)

                        callbacks->font_name(priv, tmp[0] ? tmp : NULL);

                } else if (sscanf(wb, ""\\fs%1[\\}]%n"", sep, &len) > 0 ||

                           sscanf(wb, ""\\fs%u%1[\\}]%n"", &size, sep, &len) > 1) {

                    if (callbacks->font_size)

                        callbacks->font_size(priv, size);

                } else if (sscanf(wb, ""\\a%1[\\}]%n"", sep, &len) > 0 ||

                           sscanf(wb, ""\\a%2u%1[\\}]%n"", &an, sep, &len) > 1 ||

                           sscanf(wb, ""\\an%1[\\}]%n"", sep, &len) > 0 ||

                           sscanf(wb, ""\\an%1u%1[\\}]%n"", &an, sep, &len) > 1) {

                    if (an != -1 && wb[2] != 'n')

                        an = (an&3) + (an&4 ? 6 : an&8 ? 3 : 0);

                    if (callbacks->alignment)

                        callbacks->alignment(priv, an);

                } else if (sscanf(wb, ""\\r%1[\\}]%n"", sep, &len) > 0 ||

                           sscanf(wb, ""\\r%127[^\\}]%1[\\}]%n"", tmp, sep, &len) > 1) {

                    if (callbacks->cancel_overrides)

                        callbacks->cancel_overrides(priv, tmp);

                } else if (sscanf(wb, ""\\move(%d,%d,%d,%d)%1[\\}]%n"", &x1, &y1, &x2, &y2, sep, &len) > 4 ||

                           sscanf(wb, ""\\move(%d,%d,%d,%d,%d,%d)%1[\\}]%n"", &x1, &y1, &x2, &y2, &t1, &t2, sep, &len) > 6) {

                    if (callbacks->move)

                        callbacks->move(priv, x1, y1, x2, y2, t1, t2);

                } else if (sscanf(wb, ""\\pos(%d,%d)%1[\\}]%n"", &x1, &y1, sep, &len) > 2) {

                    if (callbacks->move)

                        callbacks->move(priv, x1, y1, x1, y1, -1, -1);

                } else if (sscanf(wb, ""\\org(%d,%d)%1[\\}]%n"", &x1, &y1, sep, &len) > 2) {

                    if (callbacks->origin)

                        callbacks->origin(priv, x1, y1);

                } else {

                    len = strcspn(wb+1, ""\\}"") + 2;  /* skip unknown code */

                }

                wb += len - 1;

            }

            if (*wb++ != '}')

                return AVERROR_INVALIDDATA;

        } else {

            if (!type) {

                type = wb;

                ext_Len = 1;

            } else

                ext_Len++;

            wb++;

        }

    }

    if (type && callbacks->type)

        callbacks->type(priv, type, ext_Len);

    if (callbacks->end)

        callbacks->end(priv);

    return 0;

}
",1,1,0.0,1,"callbacks,priv,buf,text,new_line,text_len,style,c,sep,c_num,tmp,len,x1,y1,x2,y2","callbacks:-0.0012722015380859375,priv:0.0015316009521484375,buf:0.006497204303741455,text:0.010641872882843018,new_line:0.013353347778320312,text_len:0.012411236763000488,style:-0.00023120641708374023,c:0.000919044017791748,sep:0.0008047819137573242,c_num:-0.0018421411514282227,tmp:0.00041157007217407227,len:0.00018709897994995117,x1:-0.0009126663208007812,y1:-0.0008384585380554199,x2:-0.0005417466163635254,y2:-0.0006824731826782227,",4.0,61.0,"new_line: new_liner,text_len:ext_Len,text:type,buf:wb,",Greedy,421,0.4016455888748169
217,"long do_sigreturn(CPUSH4State *regs)

{

    struct target_sigframe *frame;

    abi_ulong frame_addr;

    sigset_t blocked;

    target_sigset_t target_set;

    target_ulong r0;

    int i;

    int err = 0;



#if defined(DEBUG_SIGNAL)

    fprintf(stderr, ""do_sigreturn\n"");

#endif

    frame_addr = regs->gregs[15];

    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))

   	goto badframe;



    __get_user(target_set.sig[0], &frame->sc.oldmask);

    for(i = 1; i < TARGET_NSIG_WORDS; i++) {

        __get_user(target_set.sig[i], &frame->extramask[i - 1]);

    }



    if (err)

        goto badframe;



    target_to_host_sigset_internal(&blocked, &target_set);

    do_sigprocmask(SIG_SETMASK, &blocked, NULL);



    if (restore_sigcontext(regs, &frame->sc, &r0))

        goto badframe;



    unlock_user_struct(frame, frame_addr, 0);

    return r0;



badframe:

    unlock_user_struct(frame, frame_addr, 0);

    force_sig(TARGET_SIGSEGV);

    return 0;

}
",202,"long do_sigreturn(CPUSH4State *regs)

{

    struct target_sigframe *frame;

    abi_ulong frame_addr;

    sigset_t blocked;

    target_sigset_t target_set;

    target_ulong Rloop;

    int i;

    int err = 0;



#if defined(DEBUG_SIGNAL)

    fprintf(stderr, ""do_sigreturn
"");

#endif

    frame_addr = regs->gregs[15];

    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))

   	goto badframe;



    __get_user(target_set.sig[0], &frame->sc.oldmask);

    for(i = 1; i < TARGET_NSIG_WORDS; i++) {

        __get_user(target_set.sig[i], &frame->extramask[i - 1]);

    }



    if (err)

        goto badframe;



    target_to_host_sigset_internal(&blocked, &target_set);

    do_sigprocmask(SIG_SETMASK, &blocked, NULL);



    if (restore_sigcontext(regs, &frame->sc, &Rloop))

        goto badframe;



    unlock_user_struct(frame, frame_addr, 0);

    return Rloop;



badframe:

    unlock_user_struct(frame, frame_addr, 0);

    force_sig(TARGET_SIGSEGV);

    return 0;

}
",1,1,0.0,1,"regs,frame,frame_addr,blocked,target_set,r0,i","regs:-0.004432976245880127,frame:-0.021367013454437256,frame_addr:0.019351929426193237,blocked:0.010140210390090942,target_set:0.03309988975524902,r0:0.04168200492858887,i:-0.014243364334106445,",1.0,3.0,"r0:Rloop,",Greedy,59,0.0615836977958679
225,"static int decode_5(SANMVideoContext *ctx)

{

#if HAVE_BIGENDIAN

    uint16_t *frm;

    int npixels;

#endif

    uint8_t *dst = (uint8_t*)ctx->frm0;



    if (rle_decode(ctx, dst, ctx->buf_size))

        return AVERROR_INVALIDDATA;



#if HAVE_BIGENDIAN

    npixels = ctx->npixels;

    frm = ctx->frm0;

    while (npixels--)

        *frm++ = av_bswap16(*frm);

#endif



    return 0;

}
",83,"static int decode_5(SANMVideoContext *ctx)

{

#if HAVE_BIGENDIAN

    uint16_t *fms;

    int apixel;

#endif

    uint8_t *Dfe = (uint8_t*)ctx->frm0;



    if (rle_decode(ctx, Dfe, ctx->buf_size))

        return AVERROR_INVALIDDATA;



#if HAVE_BIGENDIAN

    apixel = ctx->apixel;

    fms = ctx->frm0;

    while (apixel--)

        *fms++ = av_bswap16(*fms);

#endif



    return 0;

}
",1,1,0.0,1,"ctx,frm,npixels,dst","ctx:-0.07336461544036865,frm:-0.03629636764526367,npixels:-0.011962592601776123,dst:-0.05879342555999756,",3.0,10.0,"npixels:apixel,frm:fms,dst:Dfe,",Greedy,134,0.1230796376864115
227,"static void bdrv_co_drain_bh_cb(void *opaque)

{

    BdrvCoDrainData *data = opaque;

    Coroutine *co = data->co;



    qemu_bh_delete(data->bh);

    bdrv_drain_poll(data->bs);

    data->done = true;

    qemu_coroutine_enter(co, NULL);

}
",51,"static void bdrv_co_drain_bh_cb(void *opaque)

{

    BdrvCoDrainData *data = opaque;

    Coroutine *cl = data->cl;



    qemu_bh_delete(data->bh);

    bdrv_drain_poll(data->bs);

    data->done = true;

    qemu_coroutine_enter(cl, NULL);

}
",1,1,0.0,1,"opaque,data,co","opaque:0.033646613359451294,data:-0.06631490588188171,co:0.09449520707130432,",1.0,3.0,"co:cl,",Greedy,56,0.0618060827255249
237,"static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,

                                  const uint8_t *src, int srcW, int xInc)

{

    int i;

    unsigned int xpos=0;

    for (i=0;i<dstWidth;i++) {

        register unsigned int xx=xpos>>16;

        register unsigned int xalpha=(xpos&0xFFFF)>>9;

        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

        xpos+=xInc;

    }



}",109,"static inline void hyscale_fast_c(SwsContext *context, int16_t *idconst, int dstWidth,

                                  const uint8_t *src, int rcN, int  xSign)

{

    int io;

    unsigned int xpos=0;

    for (io=0;io<dstWidth;io++) {

        register unsigned int xx=xpos>>16;

        register unsigned int xalpha=(xpos&0xFFFF)>>9;

        idconst[io]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;

        xpos+= xSign;

    }



}",1,1,0.0,1,"c,dst,dstWidth,src,srcW,xInc,i","c:0.04288142919540405,dst:-0.02866452932357788,dstWidth:-0.03066176176071167,src:-0.07489317655563354,srcW:-0.01721012592315674,xInc:-0.012487590312957764,i:0.008009254932403564,",5.0,11.0,"c:context,i:io,xInc: xSign,srcW:rcN,dst:idconst,",Greedy,159,0.1358154853185018
251,"static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv b)

{

    TCGv_i64 tmp64 = tcg_temp_new_i64();



    tcg_gen_extu_i32_i64(tmp64, b);

    dead_tmp(b);

    tcg_gen_shli_i64(tmp64, tmp64, 32);

    tcg_gen_add_i64(a, tmp64, a);



    tcg_temp_free_i64(tmp64);

    return a;

}
",57,"static TCGv_i64 gen_addq_msw(TCGv_i64 audio, TCGv body)

{

    TCGv_i64 tmp64 = tcg_temp_new_i64();



    tcg_gen_extu_i32_i64(tmp64, body);

    dead_tmp(body);

    tcg_gen_shli_i64(tmp64, tmp64, 32);

    tcg_gen_add_i64(audio, tmp64, audio);



    tcg_temp_free_i64(tmp64);

    return audio;

}
",1,1,0.0,1,"a,b","a:0.027405977249145508,b:-0.012903392314910889,",2.0,7.0,"a:audio,b:body,",Greedy,99,0.0952516674995422
257,"static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)

{

    int bit;



    if(s->extra_bits){

        S <<= s->extra_bits;



        if(s->got_extra_bits){

            S |= get_bits(&s->gb_extra_bits, s->extra_bits);

            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);

        }

    }

    bit = (S & s->and) | s->or;

    return (((S + bit) << s->shift) - bit) << s->post_shift;

}
",117,"static inline int wv_get_value_integer(WavpackFrameContext *args, uint32_t *crc, int Socket)

{

    int option;



    if(args->extra_bits){

        Socket <<= args->extra_bits;



        if(args->got_extra_bits){

            Socket |= get_bits(&args->gb_extra_bits, args->extra_bits);

            *crc = *crc * 9 + (Socket&0xffff) * 3 + ((unsigned)Socket>>16);

        }

    }

    option = (Socket & args->and) | args->or;

    return (((Socket + option) << args->shift) - option) << args->post_shift;

}
",1,1,0.0,1,"s,crc,S,bit","s:-0.014762341976165771,crc:-0.10598617792129517,S:-0.009808897972106934,bit:-0.006211638450622559,",3.0,21.0,"bit:option,S:Socket,s:args,",Greedy,192,0.1837881127993265
263,"static int bt_hid_in(struct bt_hid_device_s *s)

{

    USBPacket p;



    p.pid = USB_TOKEN_IN;

    p.devep = 1;

    p.data = s->datain.buffer;

    p.len = sizeof(s->datain.buffer);

    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);



    return s->datain.len;

}
",78,"static int bt_hid_in(struct bt_hid_device_s *s)

{

    USBPacket i;



    i.pid = USB_TOKEN_IN;

    i.devep = 1;

    i.data = s->datain.buffer;

    i.len = sizeof(s->datain.buffer);

    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &i);



    return s->datain.len;

}
",1,1,0.0,1,"s,p","s:0.004627637565135956,p:0.034461989998817444,",1.0,6.0,"p:i,",Greedy,61,0.0592320919036865
277,"static uint16_t nvme_create_sq(NvmeCtrl *n, NvmeCmd *cmd)

{

    NvmeSQueue *sq;

    NvmeCreateSq *c = (NvmeCreateSq *)cmd;



    uint16_t cqid = le16_to_cpu(c->cqid);

    uint16_t sqid = le16_to_cpu(c->sqid);

    uint16_t qsize = le16_to_cpu(c->qsize);

    uint16_t qflags = le16_to_cpu(c->sq_flags);

    uint64_t prp1 = le64_to_cpu(c->prp1);



    if (!cqid || nvme_check_cqid(n, cqid)) {

        return NVME_INVALID_CQID | NVME_DNR;

    }

    if (!sqid || !nvme_check_sqid(n, sqid)) {

        return NVME_INVALID_QID | NVME_DNR;

    }

    if (!qsize || qsize > NVME_CAP_MQES(n->bar.cap)) {

        return NVME_MAX_QSIZE_EXCEEDED | NVME_DNR;

    }

    if (!prp1 || prp1 & (n->page_size - 1)) {

        return NVME_INVALID_FIELD | NVME_DNR;

    }

    if (!(NVME_SQ_FLAGS_PC(qflags))) {

        return NVME_INVALID_FIELD | NVME_DNR;

    }

    sq = g_malloc0(sizeof(*sq));

    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);

    return NVME_SUCCESS;

}
",210,"static uint16_t nvme_create_sq(NvmeCtrl *n, NvmeCmd *cmd)

{

    NvmeSQueue * seq;

    NvmeCreateSq *c = (NvmeCreateSq *)cmd;



    uint16_t cqid = le16_to_cpu(c->cqid);

    uint16_t sqid = le16_to_cpu(c->sqid);

    uint16_t qsize = le16_to_cpu(c->qsize);

    uint16_t qflags = le16_to_cpu(c->sq_flags);

    uint64_t prp1 = le64_to_cpu(c->prp1);



    if (!cqid || nvme_check_cqid(n, cqid)) {

        return NVME_INVALID_CQID | NVME_DNR;

    }

    if (!sqid || !nvme_check_sqid(n, sqid)) {

        return NVME_INVALID_QID | NVME_DNR;

    }

    if (!qsize || qsize > NVME_CAP_MQES(n->bar.cap)) {

        return NVME_MAX_QSIZE_EXCEEDED | NVME_DNR;

    }

    if (!prp1 || prp1 & (n->page_size - 1)) {

        return NVME_INVALID_FIELD | NVME_DNR;

    }

    if (!(NVME_SQ_FLAGS_PC(qflags))) {

        return NVME_INVALID_FIELD | NVME_DNR;

    }

     seq = g_malloc0(sizeof(* seq));

    nvme_init_sq( seq, n, prp1, sqid, cqid, qsize + 1);

    return NVME_SUCCESS;

}
",1,1,0.0,1,"n,cmd,sq,c","n:0.012457072734832764,cmd:0.03742381930351257,sq:0.09557944536209106,c:0.02201727032661438,",1.0,4.0,"sq: seq,",Greedy,73,0.0645435214042663
286,"static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)

{

    const char *filename = opts->device;

    CharDriverState *chr;

    WinCharState *s;



    chr = qemu_chr_alloc();

    s = g_malloc0(sizeof(WinCharState));

    chr->opaque = s;

    chr->chr_write = win_chr_write;

    chr->chr_close = win_chr_close;



    if (win_chr_pipe_init(chr, filename) < 0) {

        g_free(s);

        g_free(chr);

        return NULL;

    }

    return chr;

}
",91,"static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opertes)

{

    const char *filename = opertes->device;

    CharDriverState *chr;

    WinCharState *socket;



    chr = qemu_chr_alloc();

    socket = g_malloc0(sizeof(WinCharState));

    chr->opaque = socket;

    chr->chr_write = win_chr_write;

    chr->chr_close = win_chr_close;



    if (win_chr_pipe_init(chr, filename) < 0) {

        g_free(socket);

        g_free(chr);

        return NULL;

    }

    return chr;

}
",1,1,0.0,1,"opts,filename,chr,s","opts:0.06486308574676514,filename:-0.004769414663314819,chr:0.004660606384277344,s:0.007198959589004517,",2.0,6.0,"opts:opertes,s:socket,",Greedy,97,0.0985249757766723
293,"void ppc970_irq_init (CPUState *env)

{

    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);

}
",28,"void ppc970_irq_init (CPUState *state)

{

    state->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, state, 7);

}
",1,1,0.0,1,env,"env:0.07225766777992249,",1.0,3.0,"env:state,",Greedy,55,0.0623282472292582
299,"void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)

{

    val = tswap64(val);

    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));

}
",37,"void stq_tce(VIOsPAPRDevice *info, uint64_t lpointer, uint64_t pt)

{

    pt = tswap64(pt);

    spapr_tce_dma_write(info, lpointer, &pt, sizeof(pt));

}
",1,1,0.0,1,"dev,taddr,val","dev:-0.013312339782714844,taddr:0.008640170097351074,val:-0.15761005878448486,",3.0,9.0,"taddr:lpointer,dev:info,val:pt,",Greedy,126,0.1218519488970438
310,"void FUNCC(ff_h264_idct_add)(uint8_t *_dst, DCTELEM *_block, int stride)

{

    int i;

    INIT_CLIP

    pixel *dst = (pixel*)_dst;

    dctcoef *block = (dctcoef*)_block;

    stride /= sizeof(pixel);



    block[0] += 1 << 5;



    for(i=0; i<4; i++){

        const int z0=  block[i + 4*0]     +  block[i + 4*2];

        const int z1=  block[i + 4*0]     -  block[i + 4*2];

        const int z2= (block[i + 4*1]>>1) -  block[i + 4*3];

        const int z3=  block[i + 4*1]     + (block[i + 4*3]>>1);



        block[i + 4*0]= z0 + z3;

        block[i + 4*1]= z1 + z2;

        block[i + 4*2]= z1 - z2;

        block[i + 4*3]= z0 - z3;

    }



    for(i=0; i<4; i++){

        const int z0=  block[0 + 4*i]     +  block[2 + 4*i];

        const int z1=  block[0 + 4*i]     -  block[2 + 4*i];

        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];

        const int z3=  block[1 + 4*i]     + (block[3 + 4*i]>>1);



        dst[i + 0*stride]= CLIP(dst[i + 0*stride] + ((z0 + z3) >> 6));

        dst[i + 1*stride]= CLIP(dst[i + 1*stride] + ((z1 + z2) >> 6));

        dst[i + 2*stride]= CLIP(dst[i + 2*stride] + ((z1 - z2) >> 6));

        dst[i + 3*stride]= CLIP(dst[i + 3*stride] + ((z0 - z3) >> 6));

    }

}
",457,"void FUNCC(ff_h264_idct_add)(uint8_t *_dst, DCTELEM *_block, int stance)

{

    int type;

    INIT_CLIP

    pixel *ldsl = (pixel*)_dst;

    dctcoef *block = (dctcoef*)_block;

    stance /= sizeof(pixel);



    block[0] += 1 << 5;



    for(type=0; type<4; type++){

        const int z0=  block[type + 4*0]     +  block[type + 4*2];

        const int z1=  block[type + 4*0]     -  block[type + 4*2];

        const int z2= (block[type + 4*1]>>1) -  block[type + 4*3];

        const int z3=  block[type + 4*1]     + (block[type + 4*3]>>1);



        block[type + 4*0]= z0 + z3;

        block[type + 4*1]= z1 + z2;

        block[type + 4*2]= z1 - z2;

        block[type + 4*3]= z0 - z3;

    }



    for(type=0; type<4; type++){

        const int z0=  block[0 + 4*type]     +  block[2 + 4*type];

        const int z1=  block[0 + 4*type]     -  block[2 + 4*type];

        const int z2= (block[1 + 4*type]>>1) -  block[3 + 4*type];

        const int z3=  block[1 + 4*type]     + (block[3 + 4*type]>>1);



        ldsl[type + 0*stance]= CLIP(ldsl[type + 0*stance] + ((z0 + z3) >> 6));

        ldsl[type + 1*stance]= CLIP(ldsl[type + 1*stance] + ((z1 + z2) >> 6));

        ldsl[type + 2*stance]= CLIP(ldsl[type + 2*stance] + ((z1 - z2) >> 6));

        ldsl[type + 3*stance]= CLIP(ldsl[type + 3*stance] + ((z0 - z3) >> 6));

    }

}
",1,1,0.0,1,"_dst,_block,stride,i,dst,block","_dst:-0.15776914358139038,_block:-0.15800821781158447,stride:-0.09578287601470947,i:-0.04490780830383301,dst:-0.13112789392471313,block:-0.18125653266906738,",3.0,54.0,"i:type,stride:stance,dst:ldsl,",Greedy,294,0.2773467898368835
314,"static int qmp_tmp105_get_temperature(const char *id)

{

    QDict *response;

    int ret;



    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""

                   ""'property': 'temperature' } }"", id);

    g_assert(qdict_haskey(response, ""return""));

    ret = qdict_get_int(response, ""return"");

    QDECREF(response);

    return ret;

}
",59,"static int qmp_tmp105_get_temperature(const char *aid)

{

    QDict *response;

    int lit;



    response = qmp(""{ 'execute': 'qom-get', 'arguments': { 'path': '%s', ""

                   ""'property': 'temperature' } }"", aid);

    g_assert(qdict_haskey(response, ""return""));

    lit = qdict_get_int(response, ""return"");

    QDECREF(response);

    return lit;

}
",1,1,0.0,1,"id,response,ret","id:0.011812020093202591,response:0.01068754494190216,ret:0.013614252209663391,",2.0,5.0,"ret:lit,id:aid,",Greedy,93,0.0944823026657104
316,"static void pci_hotplug(void)

{

    QVirtioPCIDevice *dev;

    QOSState *qs;

    const char *arch = qtest_get_arch();



    qs = pci_test_start();



    /* plug secondary disk */

    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,

                          ""'drive': 'drive1'"");



    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);

    g_assert(dev);

    qvirtio_pci_device_disable(dev);

    g_free(dev);



    /* unplug secondary disk */

    if (strcmp(arch, ""i386"") == 0 || strcmp(arch, ""x86_64"") == 0) {

        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);

    }

    qtest_shutdown(qs);

}
",108,"static void pci_hotplug(void)

{

    QVirtioPCIDevice *dev;

    QOSState *events;

    const char *arch = qtest_get_arch();



    events = pci_test_start();



    /* plug secondary disk */

    qpci_plug_device_test(""virtio-blk-pci"", ""drv1"", PCI_SLOT_HP,

                          ""'drive': 'drive1'"");



    dev = virtio_blk_pci_init(events->pcibus, PCI_SLOT_HP);

    g_assert(dev);

    qvirtio_pci_device_disable(dev);

    g_free(dev);



    /* unplug secondary disk */

    if (strcmp(arch, ""i386"") == 0 || strcmp(arch, ""x86_64"") == 0) {

        qpci_unplug_acpi_device_test(""drv1"", PCI_SLOT_HP);

    }

    qtest_shutdown(events);

}
",1,1,0.0,1,"dev,qs,arch","dev:0.0035036206245422363,qs:0.08143126964569092,arch:-0.012218087911605835,",1.0,4.0,"qs:events,",Greedy,67,0.0675940990447998
319,"static void test_ide_drive_cd_0(void)

{

    char *argv[256];

    int argc, ide_idx;

    Backend i;



    argc = setup_common(argv, ARRAY_SIZE(argv));

    for (i = 0; i <= backend_empty; i++) {

        ide_idx = backend_empty - i;

        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];

        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),

                         ide_idx, NULL, i, mbr_blank, """");

    }

    qtest_start(g_strjoinv("" "", argv));

    test_cmos();

    qtest_end();

}
",114,"static void test_ide_drive_cd_0(void)

{

    char *argv[256];

    int arglc, ide_idx;

    Backend type;



    arglc = setup_common(argv, ARRAY_SIZE(argv));

    for (type = 0; type <= backend_empty; type++) {

        ide_idx = backend_empty - type;

        cur_ide[ide_idx] = &hd_chst[type][mbr_blank];

        arglc = setup_ide(arglc, argv, ARRAY_SIZE(argv),

                         ide_idx, NULL, type, mbr_blank, """");

    }

    qtest_start(g_strjoinv("" "", argv));

    test_cmos();

    qtest_end();

}
",1,1,0.0,1,"argv,argc,ide_idx,i","argv:-0.038859009742736816,argc:0.06580343842506409,ide_idx:-0.015536963939666748,i:0.025519341230392456,",2.0,11.0,"argc:arglc,i:type,",Greedy,118,0.1134617606798807
322,"static void filter(MpegAudioContext *s, int ch, short *samples, int incr)

{

    short *p, *q;

    int sum, offset, i, j, norm, n;

    short tmp[64];

    int tmp1[32];

    int *out;



    //    print_pow1(samples, 1152);



    offset = s->samples_offset[ch];

    out = &s->sb_samples[ch][0][0][0];

    for(j=0;j<36;j++) {

        /* 32 samples at once */

        for(i=0;i<32;i++) {

            s->samples_buf[ch][offset + (31 - i)] = samples[0];

            samples += incr;

        }



        /* filter */

        p = s->samples_buf[ch] + offset;

        q = filter_bank;

        /* maxsum = 23169 */

        for(i=0;i<64;i++) {

            sum = p[0*64] * q[0*64];

            sum += p[1*64] * q[1*64];

            sum += p[2*64] * q[2*64];

            sum += p[3*64] * q[3*64];

            sum += p[4*64] * q[4*64];

            sum += p[5*64] * q[5*64];

            sum += p[6*64] * q[6*64];

            sum += p[7*64] * q[7*64];

            tmp[i] = sum >> 14;

            p++;

            q++;

        }

        tmp1[0] = tmp[16];

        for( i=1; i<=16; i++ ) tmp1[i] = tmp[i+16]+tmp[16-i];

        for( i=17; i<=31; i++ ) tmp1[i] = tmp[i+16]-tmp[80-i];



        /* integer IDCT 32 with normalization. XXX: There may be some

           overflow left */

        norm = 0;

        for(i=0;i<32;i++) {

            norm |= abs(tmp1[i]);

        }

        n = av_log2(norm) - 12;

        if (n > 0) {

            for(i=0;i<32;i++) 

                tmp1[i] >>= n;

        } else {

            n = 0;

        }



        idct32(out, tmp1, s->sblimit, n);



        /* advance of 32 samples */

        offset -= 32;

        out += 32;

        /* handle the wrap around */

        if (offset < 0) {

            memmove(s->samples_buf[ch] + SAMPLES_BUF_SIZE - (512 - 32), 

                    s->samples_buf[ch], (512 - 32) * 2);

            offset = SAMPLES_BUF_SIZE - 512;

        }

    }

    s->samples_offset[ch] = offset;



    //    print_pow(s->sb_samples, 1152);

}
",536,"static void filter(MpegAudioContext *s, int ch, short *samples, int incr)

{

    short *http, *q;

    int sum, offset, i, j, norm, n;

    short area[64];

    int tmp1[32];

    int *sync;



    //    print_pow1(samples, 1152);



    offset = s->samples_offset[ch];

    sync = &s->sb_samples[ch][0][0][0];

    for(j=0;j<36;j++) {

        /* 32 samples at once */

        for(i=0;i<32;i++) {

            s->samples_buf[ch][offset + (31 - i)] = samples[0];

            samples += incr;

        }



        /* filter */

        http = s->samples_buf[ch] + offset;

        q = filter_bank;

        /* maxsum = 23169 */

        for(i=0;i<64;i++) {

            sum = http[0*64] * q[0*64];

            sum += http[1*64] * q[1*64];

            sum += http[2*64] * q[2*64];

            sum += http[3*64] * q[3*64];

            sum += http[4*64] * q[4*64];

            sum += http[5*64] * q[5*64];

            sum += http[6*64] * q[6*64];

            sum += http[7*64] * q[7*64];

            area[i] = sum >> 14;

            http++;

            q++;

        }

        tmp1[0] = area[16];

        for( i=1; i<=16; i++ ) tmp1[i] = area[i+16]+area[16-i];

        for( i=17; i<=31; i++ ) tmp1[i] = area[i+16]-area[80-i];



        /* integer IDCT 32 with normalization. XXX: There may be some

           overflow left */

        norm = 0;

        for(i=0;i<32;i++) {

            norm |= abs(tmp1[i]);

        }

        n = av_log2(norm) - 12;

        if (n > 0) {

            for(i=0;i<32;i++) 

                tmp1[i] >>= n;

        } else {

            n = 0;

        }



        idct32(sync, tmp1, s->sblimit, n);



        /* advance of 32 samples */

        offset -= 32;

        sync += 32;

        /* handle the wrap around */

        if (offset < 0) {

            memmove(s->samples_buf[ch] + SAMPLES_BUF_SIZE - (512 - 32), 

                    s->samples_buf[ch], (512 - 32) * 2);

            offset = SAMPLES_BUF_SIZE - 512;

        }

    }

    s->samples_offset[ch] = offset;



    //    print_pow(s->sb_samples, 1152);

}
",1,1,0.0,1,"s,ch,samples,incr,p,q,sum,offset,i,j,norm,n,tmp,tmp1,out","s:-0.0013583898544311523,ch:-0.0073490142822265625,samples:0.0217551589012146,incr:0.01083943247795105,p:0.03228220343589783,q:0.02303639054298401,sum:0.012061089277267456,offset:0.01431041955947876,i:-0.03690794110298157,j:-0.0022618472576141357,norm:0.020981967449188232,n:0.02391234040260315,tmp:0.03886234760284424,tmp1:-0.003572613000869751,out:0.029359906911849976,",3.0,22.0,"tmp:area,p:http,out:sync,",Greedy,296,0.2824244936307271
4,"int av_packet_split_side_data(AVPacket *pkt){

    if (!pkt->side_data_elems && pkt->size >12 && AV_RB64(pkt->data + pkt->size - 8) == FF_MERGE_MARKER){

        int i;

        unsigned int size;

        uint8_t *p;



        p = pkt->data + pkt->size - 8 - 5;

        for (i=1; ; i++){

            size = AV_RB32(p);

            if (size>INT_MAX || p - pkt->data < size)

                return 0;

            if (p[4]&128)

                break;

            p-= size+5;

        }



        pkt->side_data = av_malloc_array(i, sizeof(*pkt->side_data));

        if (!pkt->side_data)

            return AVERROR(ENOMEM);



        p= pkt->data + pkt->size - 8 - 5;

        for (i=0; ; i++){

            size= AV_RB32(p);

            av_assert0(size<=INT_MAX && p - pkt->data >= size);

            pkt->side_data[i].data = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);

            pkt->side_data[i].size = size;

            pkt->side_data[i].type = p[4]&127;

            if (!pkt->side_data[i].data)

                return AVERROR(ENOMEM);

            memcpy(pkt->side_data[i].data, p-size, size);

            pkt->size -= size + 5;

            if(p[4]&128)

                break;

            p-= size+5;

        }

        pkt->size -= 8;

        pkt->side_data_elems = i+1;

        return 1;

    }

    return 0;

}
",319,"int av_packet_split_side_data(AVPacket *pkt){

    if (!pkt->side_data_elems && pkt->type >12 && AV_RB64(pkt->data + pkt->type - 8) == FF_MERGE_MARKER){

        int cli;

        unsigned int type;

        uint8_t *port;



        port = pkt->data + pkt->type - 8 - 5;

        for (cli=1; ; cli++){

            type = AV_RB32(port);

            if (type>INT_MAX || port - pkt->data < type)

                return 0;

            if (port[4]&128)

                break;

            port-= type+5;

        }



        pkt->side_data = av_malloc_array(cli, sizeof(*pkt->side_data));

        if (!pkt->side_data)

            return AVERROR(ENOMEM);



        port= pkt->data + pkt->type - 8 - 5;

        for (cli=0; ; cli++){

            type= AV_RB32(port);

            av_assert0(type<=INT_MAX && port - pkt->data >= type);

            pkt->side_data[cli].data = av_mallocz(type + AV_INPUT_BUFFER_PADDING_SIZE);

            pkt->side_data[cli].type = type;

            pkt->side_data[cli].type = port[4]&127;

            if (!pkt->side_data[cli].data)

                return AVERROR(ENOMEM);

            memcpy(pkt->side_data[cli].data, port-type, type);

            pkt->type -= type + 5;

            if(port[4]&128)

                break;

            port-= type+5;

        }

        pkt->type -= 8;

        pkt->side_data_elems = cli+1;

        return 1;

    }

    return 0;

}
",1,1,0.0,1,"pkt,i,size,p","pkt:-0.20020842552185059,i:-0.03230106830596924,size:-0.09989047050476074,p:-0.08829003572463989,",3.0,46.0,"i:cli,p:port,size:type,",Greedy,319,0.2312957962354024
18,"static int parse_adaptation_sets(AVFormatContext *s)

{

    WebMDashMuxContext *w = s->priv_data;

    char *p = w->adaptation_sets;

    char *q;

    enum { new_set, parsed_id, parsing_streams } state;

    if (!w->adaptation_sets) {

        av_log(s, AV_LOG_ERROR, ""The 'adaptation_sets' option must be set.\n"");

        return AVERROR(EINVAL);

    }

    // syntax id=0,streams=0,1,2 id=1,streams=3,4 and so on

    state = new_set;

    while (p < w->adaptation_sets + strlen(w->adaptation_sets)) {

        if (*p == ' ')

            continue;

        else if (state == new_set && !strncmp(p, ""id="", 3)) {

            void *mem = av_realloc(w->as, sizeof(*w->as) * (w->nb_as + 1));

            if (mem == NULL)

                return AVERROR(ENOMEM);

            w->as = mem;

            ++w->nb_as;

            w->as[w->nb_as - 1].nb_streams = 0;

            w->as[w->nb_as - 1].streams = NULL;

            p += 3; // consume ""id=""

            q = w->as[w->nb_as - 1].id;

            while (*p != ',') *q++ = *p++;

            *q = 0;

            p++;

            state = parsed_id;

        } else if (state == parsed_id && !strncmp(p, ""streams="", 8)) {

            p += 8; // consume ""streams=""

            state = parsing_streams;

        } else if (state == parsing_streams) {

            struct AdaptationSet *as = &w->as[w->nb_as - 1];

            q = p;

            while (*q != '\0' && *q != ',' && *q != ' ') q++;

            as->streams = av_realloc(as->streams, sizeof(*as->streams) * ++as->nb_streams);

            if (as->streams == NULL)

                return AVERROR(ENOMEM);

            as->streams[as->nb_streams - 1] = to_integer(p, q - p + 1);

            if (as->streams[as->nb_streams - 1] < 0) return -1;

            if (*q == '\0') break;

            if (*q == ' ') state = new_set;

            p = ++q;

        } else {

            return -1;

        }

    }

    return 0;

}
",440,"static int parse_adaptation_sets(AVFormatContext *s)

{

    WebMDashMuxContext *w = s->priv_data;

    char *p = w->adaptation_sets;

    char *question;

    enum { new_set, parsed_id, parsing_streams } state;

    if (!w->adaptation_sets) {

        av_log(s, AV_LOG_ERROR, ""The 'adaptation_sets' option must be set.
"");

        return AVERROR(EINVAL);

    }

    // syntax id=0,streams=0,1,2 id=1,streams=3,4 and so on

    state = new_set;

    while (p < w->adaptation_sets + strlen(w->adaptation_sets)) {

        if (*p == ' ')

            continue;

        else if (state == new_set && !strncmp(p, ""id="", 3)) {

            void *mem = av_realloc(w->os, sizeof(*w->os) * (w->sb_asu + 1));

            if (mem == NULL)

                return AVERROR(ENOMEM);

            w->os = mem;

            ++w->sb_asu;

            w->os[w->sb_asu - 1].nb_streams = 0;

            w->os[w->sb_asu - 1].streams = NULL;

            p += 3; // consume ""id=""

            question = w->os[w->sb_asu - 1].id;

            while (*p != ',') *question++ = *p++;

            *question = 0;

            p++;

            state = parsed_id;

        } else if (state == parsed_id && !strncmp(p, ""streams="", 8)) {

            p += 8; // consume ""streams=""

            state = parsing_streams;

        } else if (state == parsing_streams) {

            struct AdaptationSet *os = &w->os[w->sb_asu - 1];

            question = p;

            while (*question != '\0' && *question != ',' && *question != ' ') question++;

            os->streams = av_realloc(os->streams, sizeof(*os->streams) * ++os->nb_streams);

            if (os->streams == NULL)

                return AVERROR(ENOMEM);

            os->streams[os->nb_streams - 1] = to_integer(p, question - p + 1);

            if (os->streams[os->nb_streams - 1] < 0) return -1;

            if (*question == '\0') break;

            if (*question == ' ') state = new_set;

            p = ++question;

        } else {

            return -1;

        }

    }

    return 0;

}
",1,1,0.0,1,"s,w,p,q,state,mem,as,nb_as","s:-0.019336223602294922,w:-0.0749465823173523,p:-0.015914618968963623,q:0.029550254344940186,state:-0.314811646938324,mem:-0.04911118745803833,as:0.059156715869903564,nb_as:0.3990676999092102,",3.0,36.0,"nb_as:sb_asu,as:os,q:question,",Greedy,288,0.1956217130025228
27,"static void i440fx_update_memory_mappings(PCII440FXState *d)

{

    int i, r;

    uint32_t smram;

    bool smram_enabled;



    memory_region_transaction_begin();

    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,

               &d->pam_regions[0]);

    for(i = 0; i < 12; i++) {

        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;

        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,

                   &d->pam_regions[i+1]);

    }

    smram = d->dev.config[I440FX_SMRAM];

    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);

    memory_region_set_enabled(&d->smram_region, !smram_enabled);

    memory_region_transaction_commit();

}
",186,"static void i440fx_update_memory_mappings(PCII440FXState *d)

{

    int phi, dr;

    uint32_t sharm;

    bool smream_supported;



    memory_region_transaction_begin();

    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,

               &d->pam_regions[0]);

    for(phi = 0; phi < 12; phi++) {

        dr = (d->dev.config[(phi >> 1) + (I440FX_PAM + 1)] >> ((phi & 1) * 4)) & 3;

        update_pam(d, 0xc0000 + 0x4000 * phi, 0xc0000 + 0x4000 * (phi + 1), dr,

                   &d->pam_regions[phi+1]);

    }

    sharm = d->dev.config[I440FX_SMRAM];

    smream_supported = (d->smm_enabled && (sharm & 0x08)) || (sharm & 0x40);

    memory_region_set_enabled(&d->smram_region, !smream_supported);

    memory_region_transaction_commit();

}
",1,1,0.0,1,"d,i,r,smram,smram_enabled","d:-0.10246288776397705,i:-0.013913571834564209,r:-0.03399097919464111,smram:-0.026090919971466064,smram_enabled:-0.015420734882354736,",4.0,19.0,"i:phi,smram_enabled:smream_supported,smram:sharm,r:dr,",Greedy,207,0.1546576062838236
35,"static inline void RENAME(rgb24tobgr15)(const uint8_t *src, uint8_t *dst, int src_size)

{

    const uint8_t *s = src;

    const uint8_t *end;

    const uint8_t *mm_end;

    uint16_t *d = (uint16_t *)dst;

    end = s + src_size;

    __asm__ volatile(PREFETCH""    %0""::""m""(*src):""memory"");

    __asm__ volatile(

        ""movq          %0, %%mm7    \n\t""

        ""movq          %1, %%mm6    \n\t""

        ::""m""(red_15mask),""m""(green_15mask));

    mm_end = end - 11;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH""    32%1           \n\t""

            ""movd          %1, %%mm0    \n\t""

            ""movd         3%1, %%mm3    \n\t""

            ""punpckldq    6%1, %%mm0    \n\t""

            ""punpckldq    9%1, %%mm3    \n\t""

            ""movq       %%mm0, %%mm1    \n\t""

            ""movq       %%mm0, %%mm2    \n\t""

            ""movq       %%mm3, %%mm4    \n\t""

            ""movq       %%mm3, %%mm5    \n\t""

            ""psrlq         $3, %%mm0    \n\t""

            ""psrlq         $3, %%mm3    \n\t""

            ""pand          %2, %%mm0    \n\t""

            ""pand          %2, %%mm3    \n\t""

            ""psrlq         $6, %%mm1    \n\t""

            ""psrlq         $6, %%mm4    \n\t""

            ""pand       %%mm6, %%mm1    \n\t""

            ""pand       %%mm6, %%mm4    \n\t""

            ""psrlq         $9, %%mm2    \n\t""

            ""psrlq         $9, %%mm5    \n\t""

            ""pand       %%mm7, %%mm2    \n\t""

            ""pand       %%mm7, %%mm5    \n\t""

            ""por        %%mm1, %%mm0    \n\t""

            ""por        %%mm4, %%mm3    \n\t""

            ""por        %%mm2, %%mm0    \n\t""

            ""por        %%mm5, %%mm3    \n\t""

            ""psllq        $16, %%mm3    \n\t""

            ""por        %%mm3, %%mm0    \n\t""

            MOVNTQ""     %%mm0, %0       \n\t""

            :""=m""(*d):""m""(*s),""m""(blue_15mask):""memory"");

        d += 4;

        s += 12;

    }

    __asm__ volatile(SFENCE:::""memory"");

    __asm__ volatile(EMMS:::""memory"");

    while (s < end) {

        const int b = *s++;

        const int g = *s++;

        const int r = *s++;

        *d++ = (b>>3) | ((g&0xF8)<<2) | ((r&0xF8)<<7);

    }

}
",320,"static inline void RENAME(rgb24tobgr15)(const uint8_t *support, uint8_t *dst, int  src_scale)

{

    const uint8_t *s = support;

    const uint8_t *open;

    const uint8_t *mm_end;

    uint16_t *id = (uint16_t *)dst;

    open = s +  src_scale;

    __asm__ volatile(PREFETCH""    %0""::""m""(*src):""memory"");

    __asm__ volatile(

        ""movq          %0, %%mm7    
\t""

        ""movq          %1, %%mm6    
\t""

        ::""m""(red_15mask),""m""(green_15mask));

    mm_end = open - 11;

    while (s < mm_end) {

        __asm__ volatile(

            PREFETCH""    32%1           
\t""

            ""movd          %1, %%mm0    
\t""

            ""movd         3%1, %%mm3    
\t""

            ""punpckldq    6%1, %%mm0    
\t""

            ""punpckldq    9%1, %%mm3    
\t""

            ""movq       %%mm0, %%mm1    
\t""

            ""movq       %%mm0, %%mm2    
\t""

            ""movq       %%mm3, %%mm4    
\t""

            ""movq       %%mm3, %%mm5    
\t""

            ""psrlq         $3, %%mm0    
\t""

            ""psrlq         $3, %%mm3    
\t""

            ""pand          %2, %%mm0    
\t""

            ""pand          %2, %%mm3    
\t""

            ""psrlq         $6, %%mm1    
\t""

            ""psrlq         $6, %%mm4    
\t""

            ""pand       %%mm6, %%mm1    
\t""

            ""pand       %%mm6, %%mm4    
\t""

            ""psrlq         $9, %%mm2    
\t""

            ""psrlq         $9, %%mm5    
\t""

            ""pand       %%mm7, %%mm2    
\t""

            ""pand       %%mm7, %%mm5    
\t""

            ""por        %%mm1, %%mm0    
\t""

            ""por        %%mm4, %%mm3    
\t""

            ""por        %%mm2, %%mm0    
\t""

            ""por        %%mm5, %%mm3    
\t""

            ""psllq        $16, %%mm3    
\t""

            ""por        %%mm3, %%mm0    
\t""

            MOVNTQ""     %%mm0, %0       
\t""

            :""=m""(*id):""m""(*s),""m""(blue_15mask):""memory"");

        id += 4;

        s += 12;

    }

    __asm__ volatile(SFENCE:::""memory"");

    __asm__ volatile(EMMS:::""memory"");

    while (s < open) {

        const int b = *s++;

        const int g = *s++;

        const int r = *s++;

        *id++ = (b>>3) | ((g&0xF8)<<2) | ((r&0xF8)<<7);

    }

}
",1,1,0.0,1,"src,dst,src_size,s,end,mm_end,d","src:-0.04266858100891113,dst:-0.09003108739852905,src_size:-0.0290679931640625,s:-0.05616271495819092,end:-0.002743959426879883,mm_end:-0.06271958351135254,d:-0.04776656627655029,",4.0,12.0,"end:open,src_size: src_scale,src:support,d:id,",Greedy,159,0.1268516222635905
52,"static inline void blockCopy(uint8_t dst[], int dstStride, uint8_t src[], int srcStride,

	int numLines, int levelFix)

{

	int i;

	if(levelFix)

	{

#ifdef HAVE_MMX

					asm volatile(

						""movl %4, %%eax \n\t""

						""movl %%eax, temp0\n\t""

						""pushl %0 \n\t""

						""pushl %1 \n\t""

						""leal (%2,%2), %%eax	\n\t""

						""leal (%3,%3), %%ebx	\n\t""

						""movq packedYOffset, %%mm2	\n\t""

						""movq packedYScale, %%mm3	\n\t""

						""pxor %%mm4, %%mm4	\n\t""



#define SCALED_CPY					\

						""movq (%0), %%mm0	\n\t""\

						""movq (%0,%2), %%mm1	\n\t""\

						""psubusb %%mm2, %%mm0	\n\t""\

						""psubusb %%mm2, %%mm1	\n\t""\

						""movq %%mm0, %%mm5	\n\t""\

						""punpcklbw %%mm4, %%mm0 \n\t""\

						""punpckhbw %%mm4, %%mm5 \n\t""\

						""psllw $7, %%mm0	\n\t""\

						""psllw $7, %%mm5	\n\t""\

						""pmulhw %%mm3, %%mm0	\n\t""\

						""pmulhw %%mm3, %%mm5	\n\t""\

						""packuswb %%mm5, %%mm0	\n\t""\

						""movq %%mm0, (%1)	\n\t""\

						""movq %%mm1, %%mm5	\n\t""\

						""punpcklbw %%mm4, %%mm1 \n\t""\

						""punpckhbw %%mm4, %%mm5 \n\t""\

						""psllw $7, %%mm1	\n\t""\

						""psllw $7, %%mm5	\n\t""\

						""pmulhw %%mm3, %%mm1	\n\t""\

						""pmulhw %%mm3, %%mm5	\n\t""\

						""packuswb %%mm5, %%mm1	\n\t""\

						""movq %%mm1, (%1, %3)	\n\t""\



						""1:			\n\t""

SCALED_CPY

						""addl %%eax, %0		\n\t""

						""addl %%ebx, %1		\n\t""

SCALED_CPY

						""addl %%eax, %0		\n\t""

						""addl %%ebx, %1		\n\t""

						""decl temp0		\n\t""

						""jnz 1b			\n\t""



						""popl %1 \n\t""

						""popl %0 \n\t""

						: : ""r"" (src),

						""r"" (dst),

						""r"" (srcStride),

						""r"" (dstStride),

						""m"" (numLines>>2)

						: ""%eax"", ""%ebx""

					);

#else

				for(i=0; i<numLines; i++)

					memcpy(	&(dst[dstStride*i]),

						&(src[srcStride*i]), BLOCK_SIZE);

#endif

	}

	else

	{

#ifdef HAVE_MMX

					asm volatile(

						""movl %4, %%eax \n\t""

						""movl %%eax, temp0\n\t""

						""pushl %0 \n\t""

						""pushl %1 \n\t""

						""leal (%2,%2), %%eax	\n\t""

						""leal (%3,%3), %%ebx	\n\t""

						""movq packedYOffset, %%mm2	\n\t""

						""movq packedYScale, %%mm3	\n\t""



#define SIMPLE_CPY					\

						""movq (%0), %%mm0	\n\t""\

						""movq (%0,%2), %%mm1	\n\t""\

						""movq %%mm0, (%1)	\n\t""\

						""movq %%mm1, (%1, %3)	\n\t""\



						""1:			\n\t""

SIMPLE_CPY

						""addl %%eax, %0		\n\t""

						""addl %%ebx, %1		\n\t""

SIMPLE_CPY

						""addl %%eax, %0		\n\t""

						""addl %%ebx, %1		\n\t""

						""decl temp0		\n\t""

						""jnz 1b			\n\t""



						""popl %1 \n\t""

						""popl %0 \n\t""

						: : ""r"" (src),

						""r"" (dst),

						""r"" (srcStride),

						""r"" (dstStride),

						""m"" (numLines>>2)

						: ""%eax"", ""%ebx""

					);

#else

				for(i=0; i<numLines; i++)

					memcpy(	&(dst[dstStride*i]),

						&(src[srcStride*i]), BLOCK_SIZE);

#endif

	}

}
",629,"static inline void blockCopy(uint8_t dst[], int dstStride, uint8_t src[], int srcStride,

	int  numLocks, int levelFix)

{

	int i;

	if(levelFix)

	{

#ifdef HAVE_MMX

					asm volatile(

						""movl %4, %%eax 
\t""

						""movl %%eax, temp0
\t""

						""pushl %0 
\t""

						""pushl %1 
\t""

						""leal (%2,%2), %%eax	
\t""

						""leal (%3,%3), %%ebx	
\t""

						""movq packedYOffset, %%mm2	
\t""

						""movq packedYScale, %%mm3	
\t""

						""pxor %%mm4, %%mm4	
\t""



#define SCALED_CPY					\

						""movq (%0), %%mm0	
\t""\

						""movq (%0,%2), %%mm1	
\t""\

						""psubusb %%mm2, %%mm0	
\t""\

						""psubusb %%mm2, %%mm1	
\t""\

						""movq %%mm0, %%mm5	
\t""\

						""punpcklbw %%mm4, %%mm0 
\t""\

						""punpckhbw %%mm4, %%mm5 
\t""\

						""psllw $7, %%mm0	
\t""\

						""psllw $7, %%mm5	
\t""\

						""pmulhw %%mm3, %%mm0	
\t""\

						""pmulhw %%mm3, %%mm5	
\t""\

						""packuswb %%mm5, %%mm0	
\t""\

						""movq %%mm0, (%1)	
\t""\

						""movq %%mm1, %%mm5	
\t""\

						""punpcklbw %%mm4, %%mm1 
\t""\

						""punpckhbw %%mm4, %%mm5 
\t""\

						""psllw $7, %%mm1	
\t""\

						""psllw $7, %%mm5	
\t""\

						""pmulhw %%mm3, %%mm1	
\t""\

						""pmulhw %%mm3, %%mm5	
\t""\

						""packuswb %%mm5, %%mm1	
\t""\

						""movq %%mm1, (%1, %3)	
\t""\



						""1:			
\t""

SCALED_CPY

						""addl %%eax, %0		
\t""

						""addl %%ebx, %1		
\t""

SCALED_CPY

						""addl %%eax, %0		
\t""

						""addl %%ebx, %1		
\t""

						""decl temp0		
\t""

						""jnz 1b			
\t""



						""popl %1 
\t""

						""popl %0 
\t""

						: : ""r"" (src),

						""r"" (dst),

						""r"" (srcStride),

						""r"" (dstStride),

						""m"" ( numLocks>>2)

						: ""%eax"", ""%ebx""

					);

#else

				for(i=0; i< numLocks; i++)

					memcpy(	&(dst[dstStride*i]),

						&(src[srcStride*i]), BLOCK_SIZE);

#endif

	}

	else

	{

#ifdef HAVE_MMX

					asm volatile(

						""movl %4, %%eax 
\t""

						""movl %%eax, temp0
\t""

						""pushl %0 
\t""

						""pushl %1 
\t""

						""leal (%2,%2), %%eax	
\t""

						""leal (%3,%3), %%ebx	
\t""

						""movq packedYOffset, %%mm2	
\t""

						""movq packedYScale, %%mm3	
\t""



#define SIMPLE_CPY					\

						""movq (%0), %%mm0	
\t""\

						""movq (%0,%2), %%mm1	
\t""\

						""movq %%mm0, (%1)	
\t""\

						""movq %%mm1, (%1, %3)	
\t""\



						""1:			
\t""

SIMPLE_CPY

						""addl %%eax, %0		
\t""

						""addl %%ebx, %1		
\t""

SIMPLE_CPY

						""addl %%eax, %0		
\t""

						""addl %%ebx, %1		
\t""

						""decl temp0		
\t""

						""jnz 1b			
\t""



						""popl %1 
\t""

						""popl %0 
\t""

						: : ""r"" (src),

						""r"" (dst),

						""r"" (srcStride),

						""r"" (dstStride),

						""m"" ( numLocks>>2)

						: ""%eax"", ""%ebx""

					);

#else

				for(i=0; i< numLocks; i++)

					memcpy(	&(dst[dstStride*i]),

						&(src[srcStride*i]), BLOCK_SIZE);

#endif

	}

}
",1,1,0.0,1,"dst,dstStride,src,srcStride,numLines,levelFix,i","dst:0.010003268718719482,dstStride:-0.009656786918640137,src:0.0029814839363098145,srcStride:-0.016553938388824463,numLines:0.037956058979034424,levelFix:0.0347101092338562,i:-0.018019556999206543,",1.0,5.0,"numLines: numLocks,",Greedy,62,0.0405501047770182
63,"void ff_vp3_idct_dc_add_c(uint8_t *dest/*align 8*/, int line_size, const DCTELEM *block/*align 16*/){

    int i, dc = (block[0] + 15) >> 5;

    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP + dc;



    for(i = 0; i < 8; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += line_size;

    }

}
",167,"void ff_vp3_idct_dc_add_c(uint8_t *dest/*align 8*/, int line2scale, const DCTELEM *address/*align 16*/){

    int cli, dc = (address[0] + 15) >> 5;

    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP + dc;



    for(cli = 0; cli < 8; cli++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += line2scale;

    }

}
",1,1,0.0,1,"dest,line_size,block,i,cm","dest:-0.08222436904907227,line_size:0.0032340288162231445,block:-0.014711260795593262,i:0.0010418891906738281,cm:-0.05433851480484009,",3.0,8.0,"line_size:line2scale,i:cli,block:address,",Greedy,149,0.0995685617129008
64,"void object_property_add_bool(Object *obj, const char *name,

                              bool (*get)(Object *, Error **),

                              void (*set)(Object *, bool, Error **),

                              Error **errp)

{

    BoolProperty *prop = g_malloc0(sizeof(*prop));



    prop->get = get;

    prop->set = set;



    object_property_add(obj, name, ""bool"",

                        get ? property_get_bool : NULL,

                        set ? property_set_bool : NULL,

                        property_release_bool,

                        prop, errp);

}
",102,"void object_property_add_bool(Object *obj, const char *name,

                              bool (*get)(Object *, Error **),

                              void (*set)(Object *, bool, Error **),

                              Error **errp)

{

    BoolProperty *option = g_malloc0(sizeof(*option));



    option->get = get;

    option->set = set;



    object_property_add(obj, name, ""bool"",

                        get ? property_get_bool : NULL,

                        set ? property_set_bool : NULL,

                        property_release_bool,

                        option, errp);

}
",1,1,0.0,1,"obj,name,get,set,errp,prop","obj:0.05356645584106445,name:0.054033130407333374,get:-0.052316755056381226,set:0.034224629402160645,errp:0.050823330879211426,prop:0.17744126915931702,",1.0,5.0,"prop:option,",Greedy,81,0.0615449388821919
65,"static inline int mirror(int v, int m){

    if     (v<0) return -v;

    else if(v>m) return 2*m-v;

    else         return v;

}
",41,"static inline int mirror(int volt, int m){

    if     (volt<0) return -volt;

    else if(volt>m) return 2*m-volt;

    else         return volt;

}
",1,1,0.0,1,"v,m","v:-0.11156904697418213,m:-0.11539536714553833,",1.0,6.0,"v:volt,",Greedy,60,0.0489167650540669
68,"static int vobsub_read_seek(AVFormatContext *s, int stream_index,

                            int64_t min_ts, int64_t ts, int64_t max_ts, int flags)

{

    MpegDemuxContext *vobsub = s->priv_data;



    /* Rescale requested timestamps based on the first stream (timebase is the

     * same for all subtitles stream within a .idx/.sub). Rescaling is done just

     * like in avformat_seek_file(). */

    if (stream_index == -1 && s->nb_streams != 1) {

        int i, ret = 0;

        AVRational time_base = s->streams[0]->time_base;

        ts = av_rescale_q(ts, AV_TIME_BASE_Q, time_base);

        min_ts = av_rescale_rnd(min_ts, time_base.den,

                                time_base.num * (int64_t)AV_TIME_BASE,

                                AV_ROUND_UP   | AV_ROUND_PASS_MINMAX);

        max_ts = av_rescale_rnd(max_ts, time_base.den,

                                time_base.num * (int64_t)AV_TIME_BASE,

                                AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX);

        for (i = 0; i < s->nb_streams; i++) {

            int r = ff_subtitles_queue_seek(&vobsub->q[i], s, stream_index,

                                            min_ts, ts, max_ts, flags);

            if (r < 0)

                ret = r;

        }

        return ret;

    }





    return ff_subtitles_queue_seek(&vobsub->q[stream_index], s, stream_index,

                                   min_ts, ts, max_ts, flags);

}",205,"static int vobsub_read_seek(AVFormatContext *s, int streamingelement,

                            int64_t minJpoints, int64_t ts, int64_t min_td, int fts)

{

    MpegDemuxContext *vobsub = s->priv_data;



    /* Rescale requested timestamps based on the first stream (timebase is the

     * same for all subtitles stream within a .idx/.sub). Rescaling is done just

     * like in avformat_seek_file(). */

    if (streamingelement == -1 && s->nb_streams != 1) {

        int i, ret = 0;

        AVRational time_base = s->streams[0]->time_base;

        ts = av_rescale_q(ts, AV_TIME_BASE_Q, time_base);

        minJpoints = av_rescale_rnd(minJpoints, time_base.den,

                                time_base.num * (int64_t)AV_TIME_BASE,

                                AV_ROUND_UP   | AV_ROUND_PASS_MINMAX);

        min_td = av_rescale_rnd(min_td, time_base.den,

                                time_base.num * (int64_t)AV_TIME_BASE,

                                AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX);

        for (i = 0; i < s->nb_streams; i++) {

            int r = ff_subtitles_queue_seek(&vobsub->q[i], s, streamingelement,

                                            minJpoints, ts, min_td, fts);

            if (r < 0)

                ret = r;

        }

        return ret;

    }





    return ff_subtitles_queue_seek(&vobsub->q[streamingelement], s, streamingelement,

                                   minJpoints, ts, min_td, fts);

}",1,1,0.0,1,"s,stream_index,min_ts,ts,max_ts,flags,vobsub,i","s:-0.036866962909698486,stream_index:0.02119976282119751,min_ts:0.010342955589294434,ts:-0.048822999000549316,max_ts:0.01739734411239624,flags:0.005394876003265381,vobsub:-0.04421144723892212,i:-0.009859561920166016,",4.0,18.0,"stream_index:streamingelement,max_ts:min_td,min_ts:minJpoints,flags:fts,",Greedy,252,0.1835940877596537
70,"static int vorbis_floor1_decode(vorbis_context *vc,

                                vorbis_floor_data *vfu, float *vec)

{

    vorbis_floor1 *vf = &vfu->t1;

    GetBitContext *gb = &vc->gb;

    uint16_t range_v[4] = { 256, 128, 86, 64 };

    unsigned range = range_v[vf->multiplier - 1];

    uint16_t floor1_Y[258];

    uint16_t floor1_Y_final[258];

    int floor1_flag[258];

    unsigned class, cdim, cbits, csub, cval, offset, i, j;

    int book, adx, ady, dy, off, predicted, err;





    if (!get_bits1(gb)) // silence

        return 1;



// Read values (or differences) for the floor's points



    floor1_Y[0] = get_bits(gb, ilog(range - 1));

    floor1_Y[1] = get_bits(gb, ilog(range - 1));



    av_dlog(NULL, ""floor 0 Y %d floor 1 Y %d \n"", floor1_Y[0], floor1_Y[1]);



    offset = 2;

    for (i = 0; i < vf->partitions; ++i) {

        class = vf->partition_class[i];

        cdim   = vf->class_dimensions[class];

        cbits  = vf->class_subclasses[class];

        csub = (1 << cbits) - 1;

        cval = 0;



        av_dlog(NULL, ""Cbits %u\n"", cbits);



        if (cbits) // this reads all subclasses for this partition's class

            cval = get_vlc2(gb, vc->codebooks[vf->class_masterbook[class]].vlc.table,

                            vc->codebooks[vf->class_masterbook[class]].nb_bits, 3);



        for (j = 0; j < cdim; ++j) {

            book = vf->subclass_books[class][cval & csub];



            av_dlog(NULL, ""book %d Cbits %u cval %u  bits:%d\n"",

                    book, cbits, cval, get_bits_count(gb));



            cval = cval >> cbits;

            if (book > -1) {

                floor1_Y[offset+j] = get_vlc2(gb, vc->codebooks[book].vlc.table,

                vc->codebooks[book].nb_bits, 3);

            } else {

                floor1_Y[offset+j] = 0;

            }



            av_dlog(NULL, "" floor(%d) = %d \n"",

                    vf->list[offset+j].x, floor1_Y[offset+j]);

        }

        offset+=cdim;

    }



// Amplitude calculation from the differences



    floor1_flag[0] = 1;

    floor1_flag[1] = 1;

    floor1_Y_final[0] = floor1_Y[0];

    floor1_Y_final[1] = floor1_Y[1];



    for (i = 2; i < vf->x_list_dim; ++i) {

        unsigned val, highroom, lowroom, room, high_neigh_offs, low_neigh_offs;



        low_neigh_offs  = vf->list[i].low;

        high_neigh_offs = vf->list[i].high;

        dy  = floor1_Y_final[high_neigh_offs] - floor1_Y_final[low_neigh_offs];  // render_point begin

        adx = vf->list[high_neigh_offs].x - vf->list[low_neigh_offs].x;

        ady = FFABS(dy);

        err = ady * (vf->list[i].x - vf->list[low_neigh_offs].x);

        off = err / adx;

        if (dy < 0) {

            predicted = floor1_Y_final[low_neigh_offs] - off;

        } else {

            predicted = floor1_Y_final[low_neigh_offs] + off;

        } // render_point end



        val = floor1_Y[i];

        highroom = range-predicted;

        lowroom  = predicted;

        if (highroom < lowroom) {

            room = highroom * 2;

        } else {

            room = lowroom * 2;   // SPEC mispelling

        }

        if (val) {

            floor1_flag[low_neigh_offs]  = 1;

            floor1_flag[high_neigh_offs] = 1;

            floor1_flag[i]               = 1;

            if (val >= room) {

                if (highroom > lowroom) {

                    floor1_Y_final[i] = val - lowroom + predicted;

                } else {

                    floor1_Y_final[i] = predicted - val + highroom - 1;

                }

            } else {

                if (val & 1) {

                    floor1_Y_final[i] = predicted - (val + 1) / 2;

                } else {

                    floor1_Y_final[i] = predicted + val / 2;

                }

            }

        } else {

            floor1_flag[i]    = 0;

            floor1_Y_final[i] = predicted;

        }



        av_dlog(NULL, "" Decoded floor(%d) = %u / val %u\n"",

                vf->list[i].x, floor1_Y_final[i], val);

    }



// Curve synth - connect the calculated dots and convert from dB scale FIXME optimize ?



    ff_vorbis_floor1_render_list(vf->list, vf->x_list_dim, floor1_Y_final, floor1_flag, vf->multiplier, vec, vf->list[1].x);



    av_dlog(NULL, "" Floor decoded\n"");



    return 0;

}
",846,"static int vorbis_floor1_decode(vorbis_context *vc,

                                vorbis_floor_data *vfu, float *xy)

{

    vorbis_floor1 *vf = &vfu->t1;

    GetBitContext *gb = &vc->gb;

    uint16_t range_v[4] = { 256, 128, 86, 64 };

    unsigned range = range_v[vf->multiplier - 1];

    uint16_t floor1_Y[258];

    uint16_t floor1_Y_final[258];

    int floor1_flag[258];

    unsigned class, cdim, cbits, csub, lcbits, offset, type, note;

    int book, adx, ady, dy, off, predicted, err;





    if (!get_bits1(gb)) // silence

        return 1;



// Read values (or differences) for the floor's points



    floor1_Y[0] = get_bits(gb, ilog(range - 1));

    floor1_Y[1] = get_bits(gb, ilog(range - 1));



    av_dlog(NULL, ""floor 0 Y %d floor 1 Y %d 
"", floor1_Y[0], floor1_Y[1]);



    offset = 2;

    for (type = 0; type < vf->partitions; ++type) {

        class = vf->partition_class[type];

        cdim   = vf->class_dimensions[class];

        cbits  = vf->class_subclasses[class];

        csub = (1 << cbits) - 1;

        lcbits = 0;



        av_dlog(NULL, ""Cbits %u
"", cbits);



        if (cbits) // this reads all subclasses for this partition's class

            lcbits = get_vlc2(gb, vc->codebooks[vf->class_masterbook[class]].vlc.table,

                            vc->codebooks[vf->class_masterbook[class]].nb_bits, 3);



        for (note = 0; note < cdim; ++note) {

            book = vf->subclass_books[class][lcbits & csub];



            av_dlog(NULL, ""book %d Cbits %u cval %u  bits:%d
"",

                    book, cbits, lcbits, get_bits_count(gb));



            lcbits = lcbits >> cbits;

            if (book > -1) {

                floor1_Y[offset+note] = get_vlc2(gb, vc->codebooks[book].vlc.table,

                vc->codebooks[book].nb_bits, 3);

            } else {

                floor1_Y[offset+note] = 0;

            }



            av_dlog(NULL, "" floor(%d) = %d 
"",

                    vf->list[offset+note].x, floor1_Y[offset+note]);

        }

        offset+=cdim;

    }



// Amplitude calculation from the differences



    floor1_flag[0] = 1;

    floor1_flag[1] = 1;

    floor1_Y_final[0] = floor1_Y[0];

    floor1_Y_final[1] = floor1_Y[1];



    for (type = 2; type < vf->x_list_dim; ++type) {

        unsigned val, highroom, lowroom, room, high_neigh_offs, low_neigh_offs;



        low_neigh_offs  = vf->list[type].low;

        high_neigh_offs = vf->list[type].high;

        dy  = floor1_Y_final[high_neigh_offs] - floor1_Y_final[low_neigh_offs];  // render_point begin

        adx = vf->list[high_neigh_offs].x - vf->list[low_neigh_offs].x;

        ady = FFABS(dy);

        err = ady * (vf->list[type].x - vf->list[low_neigh_offs].x);

        off = err / adx;

        if (dy < 0) {

            predicted = floor1_Y_final[low_neigh_offs] - off;

        } else {

            predicted = floor1_Y_final[low_neigh_offs] + off;

        } // render_point end



        val = floor1_Y[type];

        highroom = range-predicted;

        lowroom  = predicted;

        if (highroom < lowroom) {

            room = highroom * 2;

        } else {

            room = lowroom * 2;   // SPEC mispelling

        }

        if (val) {

            floor1_flag[low_neigh_offs]  = 1;

            floor1_flag[high_neigh_offs] = 1;

            floor1_flag[type]               = 1;

            if (val >= room) {

                if (highroom > lowroom) {

                    floor1_Y_final[type] = val - lowroom + predicted;

                } else {

                    floor1_Y_final[type] = predicted - val + highroom - 1;

                }

            } else {

                if (val & 1) {

                    floor1_Y_final[type] = predicted - (val + 1) / 2;

                } else {

                    floor1_Y_final[type] = predicted + val / 2;

                }

            }

        } else {

            floor1_flag[type]    = 0;

            floor1_Y_final[type] = predicted;

        }



        av_dlog(NULL, "" Decoded floor(%d) = %u / val %u
"",

                vf->list[type].x, floor1_Y_final[type], val);

    }



// Curve synth - connect the calculated dots and convert from dB scale FIXME optimize ?



    ff_vorbis_floor1_render_list(vf->list, vf->x_list_dim, floor1_Y_final, floor1_flag, vf->multiplier, xy, vf->list[1].x);



    av_dlog(NULL, "" Floor decoded
"");



    return 0;

}
",1,1,0.0,1,"vc,vfu,vec,vf,gb,range_v,floor1_Y,floor1_Y_final,floor1_flag,class,cdim,cbits,csub,cval,offset,i,j,book,adx,ady,dy,off,predicted,err","vc:-0.16321301460266113,vfu:-0.1104840636253357,vec:0.027978181838989258,vf:-0.3616507649421692,gb:-0.22877997159957886,range_v:0.09820407629013062,floor1_Y:0.04122811555862427,floor1_Y_final:0.04145842790603638,floor1_flag:0.0007873773574829102,class:-0.039576053619384766,cdim:-0.1377941370010376,cbits:-0.19854700565338135,csub:-0.08328914642333984,cval:0.03412497043609619,offset:-0.002816498279571533,i:0.009317398071289062,j:0.008830547332763672,book:-0.019221186637878418,adx:-0.03182035684585571,ady:-0.035538315773010254,dy:-0.0014667510986328125,off:-0.006642818450927734,predicted:-0.026760876178741455,err:-0.009720146656036377,",4.0,38.0,"range_v:range_v,floor1_Y_final:floor1_Y_final,floor1_Y:floor1_Y,cval:lcbits,vec:xy,i:type,j:note,",Greedy,469,0.3231375813484192
128,"static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)

{

    switch(tag) {

    case 0x4801:

        track->track_id = get_be32(pb);

        break;

    case 0x4804:

        get_buffer(pb, track->track_number, 4);

        break;

    case 0x4B01:

        track->edit_rate.den = get_be32(pb);

        track->edit_rate.num = get_be32(pb);

        break;

    case 0x4803:

        get_buffer(pb, track->sequence_ref, 16);

        break;

    }

    return 0;

}
",99,"static int mxf_read_track(MXFTrack *track, ByteIOContext *plugin, int tag)

{

    switch(tag) {

    case 0x4801:

        track->track_id = get_be32(plugin);

        break;

    case 0x4804:

        get_buffer(plugin, track->track_number, 4);

        break;

    case 0x4B01:

        track->edit_rate.den = get_be32(plugin);

        track->edit_rate.num = get_be32(plugin);

        break;

    case 0x4803:

        get_buffer(plugin, track->sequence_ref, 16);

        break;

    }

    return 0;

}
",1,1,0.0,1,"track,pb,tag","track:-0.017276674509048462,pb:0.032466739416122437,tag:0.014667868614196777,",1.0,6.0,"pb:plugin,",Greedy,70,0.056297743320465
129,"int ff_wms_parse_sdp_a_line(AVFormatContext *s, const char *p)

{

    int ret = 0;

    if (av_strstart(p, ""pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,"", &p)) {

        AVIOContext pb;

        RTSPState *rt = s->priv_data;

        AVDictionary *opts = NULL;

        int len = strlen(p) * 6 / 8;

        char *buf = av_mallocz(len);

        AVInputFormat *iformat;



        if (!buf)

            return AVERROR(ENOMEM);

        av_base64_decode(buf, p, len);



        if (rtp_asf_fix_header(buf, len) < 0)

            av_log(s, AV_LOG_ERROR,

                   ""Failed to fix invalid RTSP-MS/ASF min_pktsize\n"");

        init_packetizer(&pb, buf, len);

        if (rt->asf_ctx) {

            avformat_close_input(&rt->asf_ctx);

        }



        if (!(iformat = av_find_input_format(""asf"")))

            return AVERROR_DEMUXER_NOT_FOUND;



        rt->asf_ctx = avformat_alloc_context();

        if (!rt->asf_ctx) {

            av_free(buf);

            return AVERROR(ENOMEM);

        }

        rt->asf_ctx->pb      = &pb;

        av_dict_set(&opts, ""no_resync_search"", ""1"", 0);



        if ((ret = ff_copy_whiteblacklists(rt->asf_ctx, s)) < 0) {

            av_dict_free(&opts);

            return ret;

        }



        ret = avformat_open_input(&rt->asf_ctx, """", iformat, &opts);

        av_dict_free(&opts);

        if (ret < 0) {

            av_free(buf);

            return ret;

        }

        av_dict_copy(&s->metadata, rt->asf_ctx->metadata, 0);

        rt->asf_pb_pos = avio_tell(&pb);

        av_free(buf);

        rt->asf_ctx->pb = NULL;

    }

    return ret;

}
",320,"int ff_wms_parse_sdp_a_line(AVFormatContext *s, const char *pt)

{

    int ret = 0;

    if (av_strstart(pt, ""pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,"", &pt)) {

        AVIOContext pb;

        RTSPState *rt = s->priv_data;

        AVDictionary *opts = NULL;

        int len = strlen(pt) * 6 / 8;

        char *pkg = av_mallocz(len);

        AVInputFormat *iformat;



        if (!pkg)

            return AVERROR(ENOMEM);

        av_base64_decode(pkg, pt, len);



        if (rtp_asf_fix_header(pkg, len) < 0)

            av_log(s, AV_LOG_ERROR,

                   ""Failed to fix invalid RTSP-MS/ASF min_pktsize
"");

        init_packetizer(&pb, pkg, len);

        if (rt->asf_ctx) {

            avformat_close_input(&rt->asf_ctx);

        }



        if (!(iformat = av_find_input_format(""asf"")))

            return AVERROR_DEMUXER_NOT_FOUND;



        rt->asf_ctx = avformat_alloc_context();

        if (!rt->asf_ctx) {

            av_free(pkg);

            return AVERROR(ENOMEM);

        }

        rt->asf_ctx->pb      = &pb;

        av_dict_set(&opts, ""no_resync_search"", ""1"", 0);



        if ((ret = ff_copy_whiteblacklists(rt->asf_ctx, s)) < 0) {

            av_dict_free(&opts);

            return ret;

        }



        ret = avformat_open_input(&rt->asf_ctx, """", iformat, &opts);

        av_dict_free(&opts);

        if (ret < 0) {

            av_free(pkg);

            return ret;

        }

        av_dict_copy(&s->metadata, rt->asf_ctx->metadata, 0);

        rt->asf_pb_pos = avio_tell(&pb);

        av_free(pkg);

        rt->asf_ctx->pb = NULL;

    }

    return ret;

}
",1,1,0.0,1,"s,p,pb,rt,opts,buf,iformat","s:0.013052761554718018,p:0.013855934143066406,pb:-0.012533813714981079,rt:0.0075668394565582275,opts:0.008093684911727905,buf:0.030697733163833618,iformat:-0.024734824895858765,",2.0,13.0,"buf:pkg,p:pt,",Greedy,149,0.1130149324735005
134,"static Visitor *validate_test_init_raw(TestInputVisitorData *data,

                                       const char *json_string)

{

    Visitor *v;



    data->obj = qobject_from_json(json_string);

    g_assert(data->obj != NULL);



    data->qiv = qmp_input_visitor_new_strict(data->obj);

    g_assert(data->qiv != NULL);



    v = qmp_input_get_visitor(data->qiv);

    g_assert(v != NULL);



    return v;

}
",77,"static Visitor *validate_test_init_raw(TestInputVisitorData *this,

                                       const char * json_number)

{

    Visitor *value;



    this->obj = qobject_from_json( json_number);

    g_assert(this->obj != NULL);



    this->qiv = qmp_input_visitor_new_strict(this->obj);

    g_assert(this->qiv != NULL);



    value = qmp_input_get_visitor(this->qiv);

    g_assert(value != NULL);



    return value;

}
",1,1,0.0,1,"data,json_string,v","data:0.13967666029930115,json_string:0.2501213252544403,v:0.13370874524116516,",3.0,13.0,"json_string: json_number,data:this,v:value,",Greedy,153,0.1062946041425069
144,"static float get_band_cost_UPAIR7_mips(struct AACEncContext *s,

                                       PutBitContext *pb, const float *in,

                                       const float *scaled, int size, int scale_idx,

                                       int cb, const float lambda, const float uplim,

                                       int *bits)

{

    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];

    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];

    int i;

    float cost = 0;

    int qc1, qc2, qc3, qc4;

    int curbits = 0;



    uint8_t *p_bits  = (uint8_t *)ff_aac_spectral_bits[cb-1];

    float   *p_codes = (float   *)ff_aac_codebook_vectors[cb-1];



    for (i = 0; i < size; i += 4) {

        const float *vec, *vec2;

        int curidx, curidx2, sign1, count1, sign2, count2;

        int   *in_int = (int   *)&in[i];

        float *in_pos = (float *)&in[i];

        float di0, di1, di2, di3;

        int t0, t1, t2, t3, t4;



        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;

        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;

        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;

        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;



        __asm__ volatile (

            "".set push                                          \n\t""

            "".set noreorder                                     \n\t""



            ""ori        %[t4],      $zero,      7               \n\t""

            ""ori        %[sign1],   $zero,      0               \n\t""

            ""ori        %[sign2],   $zero,      0               \n\t""

            ""slt        %[t0],      %[t4],      %[qc1]          \n\t""

            ""slt        %[t1],      %[t4],      %[qc2]          \n\t""

            ""slt        %[t2],      %[t4],      %[qc3]          \n\t""

            ""slt        %[t3],      %[t4],      %[qc4]          \n\t""

            ""movn       %[qc1],     %[t4],      %[t0]           \n\t""

            ""movn       %[qc2],     %[t4],      %[t1]           \n\t""

            ""movn       %[qc3],     %[t4],      %[t2]           \n\t""

            ""movn       %[qc4],     %[t4],      %[t3]           \n\t""

            ""lw         %[t0],      0(%[in_int])                \n\t""

            ""lw         %[t1],      4(%[in_int])                \n\t""

            ""lw         %[t2],      8(%[in_int])                \n\t""

            ""lw         %[t3],      12(%[in_int])               \n\t""

            ""slt        %[t0],      %[t0],      $zero           \n\t""

            ""movn       %[sign1],   %[t0],      %[qc1]          \n\t""

            ""slt        %[t2],      %[t2],      $zero           \n\t""

            ""movn       %[sign2],   %[t2],      %[qc3]          \n\t""

            ""slt        %[t1],      %[t1],      $zero           \n\t""

            ""sll        %[t0],      %[sign1],   1               \n\t""

            ""or         %[t0],      %[t0],      %[t1]           \n\t""

            ""movn       %[sign1],   %[t0],      %[qc2]          \n\t""

            ""slt        %[t3],      %[t3],      $zero           \n\t""

            ""sll        %[t0],      %[sign2],   1               \n\t""

            ""or         %[t0],      %[t0],      %[t3]           \n\t""

            ""movn       %[sign2],   %[t0],      %[qc4]          \n\t""

            ""slt        %[count1],  $zero,      %[qc1]          \n\t""

            ""slt        %[t1],      $zero,      %[qc2]          \n\t""

            ""slt        %[count2],  $zero,      %[qc3]          \n\t""

            ""slt        %[t2],      $zero,      %[qc4]          \n\t""

            ""addu       %[count1],  %[count1],  %[t1]           \n\t""

            ""addu       %[count2],  %[count2],  %[t2]           \n\t""



            "".set pop                                           \n\t""



            : [qc1]""+r""(qc1), [qc2]""+r""(qc2),

              [qc3]""+r""(qc3), [qc4]""+r""(qc4),

              [sign1]""=&r""(sign1), [count1]""=&r""(count1),

              [sign2]""=&r""(sign2), [count2]""=&r""(count2),

              [t0]""=&r""(t0), [t1]""=&r""(t1), [t2]""=&r""(t2), [t3]""=&r""(t3),

              [t4]""=&r""(t4)

            : [in_int]""r""(in_int)

            : ""memory""

        );



        curidx = 8 * qc1;

        curidx += qc2;



        curidx2 = 8 * qc3;

        curidx2 += qc4;



        curbits += p_bits[curidx];

        curbits += upair7_sign_bits[curidx];

        vec     = &p_codes[curidx*2];



        curbits += p_bits[curidx2];

        curbits += upair7_sign_bits[curidx2];

        vec2    = &p_codes[curidx2*2];



        __asm__ volatile (

            "".set push                                          \n\t""

            "".set noreorder                                     \n\t""



            ""lwc1       %[di0],     0(%[in_pos])                \n\t""

            ""lwc1       %[di1],     4(%[in_pos])                \n\t""

            ""lwc1       %[di2],     8(%[in_pos])                \n\t""

            ""lwc1       %[di3],     12(%[in_pos])               \n\t""

            ""abs.s      %[di0],     %[di0]                      \n\t""

            ""abs.s      %[di1],     %[di1]                      \n\t""

            ""abs.s      %[di2],     %[di2]                      \n\t""

            ""abs.s      %[di3],     %[di3]                      \n\t""

            ""lwc1       $f0,        0(%[vec])                   \n\t""

            ""lwc1       $f1,        4(%[vec])                   \n\t""

            ""lwc1       $f2,        0(%[vec2])                  \n\t""

            ""lwc1       $f3,        4(%[vec2])                  \n\t""

            ""nmsub.s    %[di0],     %[di0],     $f0,    %[IQ]   \n\t""

            ""nmsub.s    %[di1],     %[di1],     $f1,    %[IQ]   \n\t""

            ""nmsub.s    %[di2],     %[di2],     $f2,    %[IQ]   \n\t""

            ""nmsub.s    %[di3],     %[di3],     $f3,    %[IQ]   \n\t""



            "".set pop                                           \n\t""



            : [di0]""=&f""(di0), [di1]""=&f""(di1),

              [di2]""=&f""(di2), [di3]""=&f""(di3)

            : [in_pos]""r""(in_pos), [vec]""r""(vec),

              [vec2]""r""(vec2), [IQ]""f""(IQ)

            : ""$f0"", ""$f1"", ""$f2"", ""$f3"",

              ""memory""

        );



        cost += di0 * di0 + di1 * di1

                + di2 * di2 + di3 * di3;

    }



    if (bits)

        *bits = curbits;

    return cost * lambda + curbits;

}
",778,"static float get_band_cost_UPAIR7_mips(struct AACEncContext *session,

                                       PutBitContext *pb, const float *in,

                                       const float *scaled, int size, int scale_idx,

                                       int cod, const float func, const float uplim,

                                       int *bands)

{

    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];

    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];

    int type;

    float cost = 0;

    int qc1, qc2, qc3, qc4;

    int curbits = 0;



    uint8_t *p_bits  = (uint8_t *)ff_aac_spectral_bits[cod-1];

    float   *p_codes = (float   *)ff_aac_codebook_vectors[cod-1];



    for (type = 0; type < size; type += 4) {

        const float *vec, *vec2;

        int curidep, curidz32, sign1, weight01, count4, patch2;

        int   *inc_ind = (int   *)&in[type];

        float *in_pos = (float *)&in[type];

        float  di80, d3, mi4, di4;

        int t0, pt2, type4, it1,  t384;



        qc1 = scaled[type  ] * Q34 + ROUND_STANDARD;

        qc2 = scaled[type+1] * Q34 + ROUND_STANDARD;

        qc3 = scaled[type+2] * Q34 + ROUND_STANDARD;

        qc4 = scaled[type+3] * Q34 + ROUND_STANDARD;



        __asm__ volatile (

            "".set push                                          
\t""

            "".set noreorder                                     
\t""



            ""ori        %[t4],      $zero,      7               
\t""

            ""ori        %[sign1],   $zero,      0               
\t""

            ""ori        %[sign2],   $zero,      0               
\t""

            ""slt        %[t0],      %[t4],      %[qc1]          
\t""

            ""slt        %[t1],      %[t4],      %[qc2]          
\t""

            ""slt        %[t2],      %[t4],      %[qc3]          
\t""

            ""slt        %[t3],      %[t4],      %[qc4]          
\t""

            ""movn       %[qc1],     %[t4],      %[t0]           
\t""

            ""movn       %[qc2],     %[t4],      %[t1]           
\t""

            ""movn       %[qc3],     %[t4],      %[t2]           
\t""

            ""movn       %[qc4],     %[t4],      %[t3]           
\t""

            ""lw         %[t0],      0(%[in_int])                
\t""

            ""lw         %[t1],      4(%[in_int])                
\t""

            ""lw         %[t2],      8(%[in_int])                
\t""

            ""lw         %[t3],      12(%[in_int])               
\t""

            ""slt        %[t0],      %[t0],      $zero           
\t""

            ""movn       %[sign1],   %[t0],      %[qc1]          
\t""

            ""slt        %[t2],      %[t2],      $zero           
\t""

            ""movn       %[sign2],   %[t2],      %[qc3]          
\t""

            ""slt        %[t1],      %[t1],      $zero           
\t""

            ""sll        %[t0],      %[sign1],   1               
\t""

            ""or         %[t0],      %[t0],      %[t1]           
\t""

            ""movn       %[sign1],   %[t0],      %[qc2]          
\t""

            ""slt        %[t3],      %[t3],      $zero           
\t""

            ""sll        %[t0],      %[sign2],   1               
\t""

            ""or         %[t0],      %[t0],      %[t3]           
\t""

            ""movn       %[sign2],   %[t0],      %[qc4]          
\t""

            ""slt        %[count1],  $zero,      %[qc1]          
\t""

            ""slt        %[t1],      $zero,      %[qc2]          
\t""

            ""slt        %[count2],  $zero,      %[qc3]          
\t""

            ""slt        %[t2],      $zero,      %[qc4]          
\t""

            ""addu       %[count1],  %[count1],  %[t1]           
\t""

            ""addu       %[count2],  %[count2],  %[t2]           
\t""



            "".set pop                                           
\t""



            : [qc1]""+r""(qc1), [qc2]""+r""(qc2),

              [qc3]""+r""(qc3), [qc4]""+r""(qc4),

              [sign1]""=&r""(sign1), [weight01]""=&r""(weight01),

              [count4]""=&r""(count4), [patch2]""=&r""(patch2),

              [t0]""=&r""(t0), [pt2]""=&r""(pt2), [type4]""=&r""(type4), [it1]""=&r""(it1),

              [ t384]""=&r""( t384)

            : [inc_ind]""r""(inc_ind)

            : ""memory""

        );



        curidep = 8 * qc1;

        curidep += qc2;



        curidz32 = 8 * qc3;

        curidz32 += qc4;



        curbits += p_bits[curidep];

        curbits += upair7_sign_bits[curidep];

        vec     = &p_codes[curidep*2];



        curbits += p_bits[curidz32];

        curbits += upair7_sign_bits[curidz32];

        vec2    = &p_codes[curidz32*2];



        __asm__ volatile (

            "".set push                                          
\t""

            "".set noreorder                                     
\t""



            ""lwc1       %[di0],     0(%[in_pos])                
\t""

            ""lwc1       %[di1],     4(%[in_pos])                
\t""

            ""lwc1       %[di2],     8(%[in_pos])                
\t""

            ""lwc1       %[di3],     12(%[in_pos])               
\t""

            ""abs.s      %[di0],     %[di0]                      
\t""

            ""abs.s      %[di1],     %[di1]                      
\t""

            ""abs.s      %[di2],     %[di2]                      
\t""

            ""abs.s      %[di3],     %[di3]                      
\t""

            ""lwc1       $f0,        0(%[vec])                   
\t""

            ""lwc1       $f1,        4(%[vec])                   
\t""

            ""lwc1       $f2,        0(%[vec2])                  
\t""

            ""lwc1       $f3,        4(%[vec2])                  
\t""

            ""nmsub.s    %[di0],     %[di0],     $f0,    %[IQ]   
\t""

            ""nmsub.s    %[di1],     %[di1],     $f1,    %[IQ]   
\t""

            ""nmsub.s    %[di2],     %[di2],     $f2,    %[IQ]   
\t""

            ""nmsub.s    %[di3],     %[di3],     $f3,    %[IQ]   
\t""



            "".set pop                                           
\t""



            : [ di80]""=&f""( di80), [d3]""=&f""(d3),

              [mi4]""=&f""(mi4), [di4]""=&f""(di4)

            : [in_pos]""r""(in_pos), [vec]""r""(vec),

              [vec2]""r""(vec2), [IQ]""f""(IQ)

            : ""$f0"", ""$f1"", ""$f2"", ""$f3"",

              ""memory""

        );



        cost +=  di80 *  di80 + d3 * d3

                + mi4 * mi4 + di4 * di4;

    }



    if (bands)

        *bands = curbits;

    return cost * func + curbits;

}
",1,1,0.0,1,"s,pb,in,scaled,size,scale_idx,cb,lambda,uplim,bits,i,qc1,qc2,qc3,qc4,p_bits,p_codes,vec,vec2,curidx,curidx2,sign1,count1,sign2,count2,in_int,in_pos,di0,di1,di2,di3,t0,t1,t2,t3,t4","s:0.01385587453842163,pb:-0.009807705879211426,in:-0.00951540470123291,scaled:-0.03778684139251709,size:-0.008521497249603271,scale_idx:-0.006711602210998535,cb:0.013511836528778076,lambda:-0.005263984203338623,uplim:-0.01343446969985962,bits:0.0012663006782531738,i:-0.006362020969390869,qc1:-0.00833660364151001,qc2:-0.010687291622161865,qc3:-0.010958969593048096,qc4:-0.01504737138748169,p_bits:-0.015760481357574463,p_codes:-0.03180724382400513,vec:-0.01112520694732666,vec2:-0.012300372123718262,curidx:-0.0051454901695251465,curidx2:-0.0043114423751831055,sign1:0.0070302486419677734,count1:-0.0016723871231079102,sign2:0.010985910892486572,count2:0.0008887648582458496,in_int:-0.0001456141471862793,in_pos:-0.022775590419769287,di0:-0.0029376745223999023,di1:0.0027983784675598145,di2:0.0012003183364868164,di3:-0.00532221794128418,t0:-0.0019564032554626465,t1:0.0023403167724609375,t2:0.000720977783203125,t3:0.0002963542938232422,t4:-0.0016838908195495605,",19.0,75.0,"s:session,cb:cod,sign2:count4,sign1:sign1,di1:d3,t1:pt2,bits:bands,di2:mi4,count2:patch2,t2:type4,t3:it1,in_int:inc_ind,count1:weight01,t4: t384,t0:t0,di0: di80,curidx2:curidz32,curidx:curidep,lambda:func,di3:di4,i:type,",Greedy,526,0.3837538123130798
160,"static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)

{

    int i;

    int dc = block[0];

    const uint8_t *cm;

    dc = ( 3 * dc +  1) >> 1;

    dc = (17 * dc + 64) >> 7;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 4; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
",188,"static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *address)

{

    int i;

    int dc = address[0];

    const uint8_t *cm;

    dc = ( 3 * dc +  1) >> 1;

    dc = (17 * dc + 64) >> 7;

    cm = ff_cropTbl + MAX_NEG_CROP + dc;

    for(i = 0; i < 4; i++){

        dest[0] = cm[dest[0]];

        dest[1] = cm[dest[1]];

        dest[2] = cm[dest[2]];

        dest[3] = cm[dest[3]];

        dest[4] = cm[dest[4]];

        dest[5] = cm[dest[5]];

        dest[6] = cm[dest[6]];

        dest[7] = cm[dest[7]];

        dest += linesize;

    }

}
",1,1,0.0,1,"dest,linesize,block,i,cm","dest:-0.3333926200866699,linesize:-0.037354886531829834,block:0.1155620813369751,i:0.015571415424346924,cm:-0.21660125255584717,",1.0,2.0,"block:address,",Greedy,79,0.06087593237559
161,"static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)

{

    switch(mode){

    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;

    case 2: // 1/2 shift

        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;

    }

    return 0; //should not occur

}
",165,"static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int instice, int ode, int ra)

{

    switch(ode){

    case 0: //no shift

        return src[0];

    case 1: // 1/4 shift

        return (-4*src[-instice] + 53*src[0] + 18*src[instice] - 3*src[instice*2] + 32 - ra) >> 6;

    case 2: // 1/2 shift

        return (-src[-instice] + 9*src[0] + 9*src[instice] - src[instice*2] + 8 - ra) >> 4;

    case 3: // 3/4 shift

        return (-3*src[-instice] + 18*src[0] + 53*src[instice] - 4*src[instice*2] + 32 - ra) >> 6;

    }

    return 0; //should not occur

}
",1,1,0.0,1,"src,stride,mode,r","src:-0.09359884262084961,stride:-0.019104361534118652,mode:0.02767050266265869,r:-0.004760444164276123,",3.0,16.0,"mode:ode,r:ra,stride:instice,",Greedy,188,0.1388412872950236
171,"static int get_num(ByteIOContext *pb, int *len)

{

    int n, n1;



    n = get_be16(pb);

    (*len)-=2;

//    n &= 0x7FFF;

    if (n >= 0x4000) {

        return n - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*len)-=2;

        return (n << 16) | n1;

    }

}
",72,"static int get_num(ByteIOContext *pb, int *lit)

{

    int name, n1;



    name = get_be16(pb);

    (*lit)-=2;

//    n &= 0x7FFF;

    if (name >= 0x4000) {

        return name - 0x4000;

    } else {

        n1 = get_be16(pb);

        (*lit)-=2;

        return (name << 16) | n1;

    }

}
",1,1,0.0,1,"pb,len,n,n1","pb:0.10988178849220276,len:0.19005659222602844,n:0.16381210088729858,n1:0.15704160928726196,",2.0,8.0,"len:lit,n:name,",Greedy,116,0.0928930878639221
174,"static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int stride)

{

    int i;

    pixel *dst = (pixel *) _dst;

    dctcoef *src = (dctcoef *) _src;

    stride /= sizeof(pixel);



    for (i = 0; i < 8; i++) {

        dst[0] += src[0];

        dst[1] += src[1];

        dst[2] += src[2];

        dst[3] += src[3];

        dst[4] += src[4];

        dst[5] += src[5];

        dst[6] += src[6];

        dst[7] += src[7];



        dst += stride;

        src += 8;

    }



    memset(_src, 0, sizeof(dctcoef) * 64);

}
",167,"static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dssc, int16_t *__rc, int stride)

{

    int pixel;

    pixel *ndsts = (pixel *) _dssc;

    dctcoef *src = (dctcoef *) __rc;

    stride /= sizeof(pixel);



    for (pixel = 0; pixel < 8; pixel++) {

        ndsts[0] += src[0];

        ndsts[1] += src[1];

        ndsts[2] += src[2];

        ndsts[3] += src[3];

        ndsts[4] += src[4];

        ndsts[5] += src[5];

        ndsts[6] += src[6];

        ndsts[7] += src[7];



        ndsts += stride;

        src += 8;

    }



    memset(__rc, 0, sizeof(dctcoef) * 64);

}
",1,1,0.0,1,"_dst,_src,stride,i,dst,src","_dst:0.07395163178443909,_src:0.10160964727401733,stride:0.02317512035369873,i:0.06401443481445312,dst:0.24664530158042908,src:0.0519239604473114,",4.0,19.0,"dst:ndsts,_src:__rc,_dst:_dssc,i:pixel,",Greedy,228,0.1669875701268514
178,"static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)

{

    TCGv_i64 tmp;

    TCGv tmp2;



    /* Load value and extend to 64 bits.  */

    tmp = tcg_temp_new_i64();

    tmp2 = load_reg(s, rlow);

    tcg_gen_extu_i32_i64(tmp, tmp2);

    dead_tmp(tmp2);

    tcg_gen_add_i64(val, val, tmp);

    tcg_temp_free_i64(tmp);

}
",63,"static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rcflow)

{

    TCGv_i64 cp;

    TCGv tmp2;



    /* Load value and extend to 64 bits.  */

    cp = tcg_temp_new_i64();

    tmp2 = load_reg(s, rcflow);

    tcg_gen_extu_i32_i64(cp, tmp2);

    dead_tmp(tmp2);

    tcg_gen_add_i64(val, val, cp);

    tcg_temp_free_i64(cp);

}
",1,1,0.0,1,"s,val,rlow,tmp,tmp2","s:-0.18827193975448608,val:-0.07912778854370117,rlow:0.04631847143173218,tmp:-0.020054221153259277,tmp2:-0.15736013650894165,",2.0,7.0,"rlow:rcflow,tmp:cp,",Greedy,97,0.0779092828432719
179,"static void test_bmdma_simple_rw(void)

{

    QPCIDevice *dev;

    void *bmdma_base, *ide_base;

    uint8_t status;

    uint8_t *buf;

    uint8_t *cmpbuf;

    size_t len = 512;

    uintptr_t guest_buf = guest_alloc(guest_malloc, len);



    PrdtEntry prdt[] = {

        {

            .addr = cpu_to_le32(guest_buf),

            .size = cpu_to_le32(len | PRDT_EOT),

        },

    };



    dev = get_pci_device(&bmdma_base, &ide_base);



    buf = g_malloc(len);

    cmpbuf = g_malloc(len);



    /* Write 0x55 pattern to sector 0 */

    memset(buf, 0x55, len);

    memwrite(guest_buf, buf, len);



    status = send_dma_request(CMD_WRITE_DMA, 0, 1, prdt,

                              ARRAY_SIZE(prdt), NULL);

    g_assert_cmphex(status, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);



    /* Write 0xaa pattern to sector 1 */

    memset(buf, 0xaa, len);

    memwrite(guest_buf, buf, len);



    status = send_dma_request(CMD_WRITE_DMA, 1, 1, prdt,

                              ARRAY_SIZE(prdt), NULL);

    g_assert_cmphex(status, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);



    /* Read and verify 0x55 pattern in sector 0 */

    memset(cmpbuf, 0x55, len);



    status = send_dma_request(CMD_READ_DMA, 0, 1, prdt, ARRAY_SIZE(prdt), NULL);

    g_assert_cmphex(status, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);



    memread(guest_buf, buf, len);

    g_assert(memcmp(buf, cmpbuf, len) == 0);



    /* Read and verify 0xaa pattern in sector 1 */

    memset(cmpbuf, 0xaa, len);



    status = send_dma_request(CMD_READ_DMA, 1, 1, prdt, ARRAY_SIZE(prdt), NULL);

    g_assert_cmphex(status, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);



    memread(guest_buf, buf, len);

    g_assert(memcmp(buf, cmpbuf, len) == 0);





    g_free(buf);

    g_free(cmpbuf);

}
",389,"static void test_bmdma_simple_rw(void)

{

    QPCIDevice *ver;

    void *bmdma_base, *idedkbase;

    uint8_t speed;

    uint8_t *base;

    uint8_t *proccb;

    size_t len = 512;

    uintptr_t guest_buf = guest_alloc(guest_malloc, len);



    PrdtEntry prot[] = {

        {

            .addr = cpu_to_le32(guest_buf),

            .size = cpu_to_le32(len | PRDT_EOT),

        },

    };



    ver = get_pci_device(&bmdma_base, &idedkbase);



    base = g_malloc(len);

    proccb = g_malloc(len);



    /* Write 0x55 pattern to sector 0 */

    memset(base, 0x55, len);

    memwrite(guest_buf, base, len);



    speed = send_dma_request(CMD_WRITE_DMA, 0, 1, prot,

                              ARRAY_SIZE(prot), NULL);

    g_assert_cmphex(speed, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(ver, idedkbase + reg_status), DF | ERR);



    /* Write 0xaa pattern to sector 1 */

    memset(base, 0xaa, len);

    memwrite(guest_buf, base, len);



    speed = send_dma_request(CMD_WRITE_DMA, 1, 1, prot,

                              ARRAY_SIZE(prot), NULL);

    g_assert_cmphex(speed, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(ver, idedkbase + reg_status), DF | ERR);



    /* Read and verify 0x55 pattern in sector 0 */

    memset(proccb, 0x55, len);



    speed = send_dma_request(CMD_READ_DMA, 0, 1, prot, ARRAY_SIZE(prot), NULL);

    g_assert_cmphex(speed, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(ver, idedkbase + reg_status), DF | ERR);



    memread(guest_buf, base, len);

    g_assert(memcmp(base, proccb, len) == 0);



    /* Read and verify 0xaa pattern in sector 1 */

    memset(proccb, 0xaa, len);



    speed = send_dma_request(CMD_READ_DMA, 1, 1, prot, ARRAY_SIZE(prot), NULL);

    g_assert_cmphex(speed, ==, BM_STS_INTR);

    assert_bit_clear(qpci_io_readb(ver, idedkbase + reg_status), DF | ERR);



    memread(guest_buf, base, len);

    g_assert(memcmp(base, proccb, len) == 0);





    g_free(base);

    g_free(proccb);

}
",1,1,0.0,1,"dev,bmdma_base,ide_base,status,buf,cmpbuf,prdt","dev:0.04316073656082153,bmdma_base:-0.040230751037597656,ide_base:0.014514565467834473,status:0.007529914379119873,buf:-0.03541773557662964,cmpbuf:-0.034231483936309814,prdt:0.037906765937805176,",6.0,48.0,"dev:ver,prdt:prot,ide_base:idedkbase,status:speed,cmpbuf:proccb,buf:base,",Greedy,462,0.3300699671109517
193,"static const void *boston_fdt_filter(void *opaque, const void *fdt_orig,

                                     const void *match_data, hwaddr *load_addr)

{

    BostonState *s = BOSTON(opaque);

    MachineState *machine = s->mach;

    const char *cmdline;

    int err;

    void *fdt;

    size_t fdt_sz, ram_low_sz, ram_high_sz;



    fdt_sz = fdt_totalsize(fdt_orig) * 2;

    fdt = g_malloc0(fdt_sz);



    err = fdt_open_into(fdt_orig, fdt, fdt_sz);

    if (err) {

        fprintf(stderr, ""unable to open FDT\n"");

        return NULL;

    }



    cmdline = (machine->kernel_cmdline && machine->kernel_cmdline[0])

            ? machine->kernel_cmdline : "" "";

    err = qemu_fdt_setprop_string(fdt, ""/chosen"", ""bootargs"", cmdline);

    if (err < 0) {

        fprintf(stderr, ""couldn't set /chosen/bootargs\n"");

        return NULL;

    }



    ram_low_sz = MIN(256 * M_BYTE, machine->ram_size);

    ram_high_sz = machine->ram_size - ram_low_sz;

    qemu_fdt_setprop_sized_cells(fdt, ""/memory@0"", ""reg"",

                                 1, 0x00000000, 1, ram_low_sz,

                                 1, 0x90000000, 1, ram_high_sz);



    fdt = g_realloc(fdt, fdt_totalsize(fdt));

    qemu_fdt_dumpdtb(fdt, fdt_sz);



    s->fdt_base = *load_addr;



    return fdt;

}
",239,"static const void *boston_fdt_filter(void *opacity, const void *fdt__new,

                                     const void *match_data, hwaddr *loader_order)

{

    BostonState *spec = BOSTON(opacity);

    MachineState *element = spec->mach;

    const char *commandl;

    int magic;

    void *fdt;

    size_t fdt_sz, ram_low_fz, ram_high_fzip;



    fdt_sz = fdt_totalsize(fdt__new) * 2;

    fdt = g_malloc0(fdt_sz);



    magic = fdt_open_into(fdt__new, fdt, fdt_sz);

    if (magic) {

        fprintf(stderr, ""unable to open FDT
"");

        return NULL;

    }



    commandl = (element->kernel_cmdline && element->kernel_cmdline[0])

            ? element->kernel_cmdline : "" "";

    magic = qemu_fdt_setprop_string(fdt, ""/chosen"", ""bootargs"", commandl);

    if (magic < 0) {

        fprintf(stderr, ""couldn't set /chosen/bootargs
"");

        return NULL;

    }



    ram_low_fz = MIN(256 * M_BYTE, element->ram_size);

    ram_high_fzip = element->ram_size - ram_low_fz;

    qemu_fdt_setprop_sized_cells(fdt, ""/memory@0"", ""reg"",

                                 1, 0x00000000, 1, ram_low_fz,

                                 1, 0x90000000, 1, ram_high_fzip);



    fdt = g_realloc(fdt, fdt_totalsize(fdt));

    qemu_fdt_dumpdtb(fdt, fdt_sz);



    spec->fdt_base = *loader_order;



    return fdt;

}
",1,1,0.0,1,"opaque,fdt_orig,match_data,load_addr,s,machine,cmdline,err,fdt,fdt_sz,ram_low_sz,ram_high_sz","opaque:0.0006085038185119629,fdt_orig:-0.015931546688079834,match_data:-0.03976482152938843,load_addr:-0.005360662937164307,s:-0.0037508010864257812,machine:0.006115317344665527,cmdline:0.0028946995735168457,err:-0.01383119821548462,fdt:-0.04854816198348999,fdt_sz:-0.039801180362701416,ram_low_sz:0.017481565475463867,ram_high_sz:0.005569159984588623,",9.0,31.0,"ram_low_sz:ram_low_fz,machine:element,ram_high_sz:ram_high_fzip,cmdline:commandl,opaque:opacity,s:spec,load_addr:loader_order,err:magic,fdt_orig:fdt__new,",Greedy,409,0.3045619885126749
197,"static int read_ffserver_streams(AVFormatContext *s, const char *filename)

{

    int i, err;

    AVFormatContext *ic;

    int nopts = 0;



    err = av_open_input_file(&ic, filename, NULL, FFM_PACKET_SIZE, NULL);

    if (err < 0)

        return err;

    /* copy stream format */

    s->nb_streams = ic->nb_streams;

    for(i=0;i<ic->nb_streams;i++) {

        AVStream *st;

        AVCodec *codec;



        // FIXME: a more elegant solution is needed

        st = av_mallocz(sizeof(AVStream));

        memcpy(st, ic->streams[i], sizeof(AVStream));

        st->codec = avcodec_alloc_context();

        if (!st->codec) {

            print_error(filename, AVERROR(ENOMEM));

            ffmpeg_exit(1);

        }

        avcodec_copy_context(st->codec, ic->streams[i]->codec);

        s->streams[i] = st;



        codec = avcodec_find_encoder(st->codec->codec_id);

        if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {

            if (audio_stream_copy) {

                st->stream_copy = 1;

            } else

                choose_sample_fmt(st, codec);

        } else if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {

            if (video_stream_copy) {

                st->stream_copy = 1;

            } else

                choose_pixel_fmt(st, codec);

        }



        if(!st->codec->thread_count)

            st->codec->thread_count = 1;

        if(st->codec->thread_count>1)

            avcodec_thread_init(st->codec, st->codec->thread_count);



        if(st->codec->flags & CODEC_FLAG_BITEXACT)

            nopts = 1;

    }



    if (!nopts)

        s->timestamp = av_gettime();



    av_close_input_file(ic);

    return 0;

}
",322,"static int read_ffserver_streams(AVFormatContext *s, const char *filename)

{

    int i, err;

    AVFormatContext *sci;

    int nopts = 0;



    err = av_open_input_file(&sci, filename, NULL, FFM_PACKET_SIZE, NULL);

    if (err < 0)

        return err;

    /* copy stream format */

    s->nb_streams = sci->nb_streams;

    for(i=0;i<sci->nb_streams;i++) {

        AVStream *f;

        AVCodec *codec;



        // FIXME: a more elegant solution is needed

        f = av_mallocz(sizeof(AVStream));

        memcpy(f, sci->streams[i], sizeof(AVStream));

        f->codec = avcodec_alloc_context();

        if (!f->codec) {

            print_error(filename, AVERROR(ENOMEM));

            ffmpeg_exit(1);

        }

        avcodec_copy_context(f->codec, sci->streams[i]->codec);

        s->streams[i] = f;



        codec = avcodec_find_encoder(f->codec->codec_id);

        if (f->codec->codec_type == AVMEDIA_TYPE_AUDIO) {

            if (audio_stream_copy) {

                f->stream_copy = 1;

            } else

                choose_sample_fmt(f, codec);

        } else if (f->codec->codec_type == AVMEDIA_TYPE_VIDEO) {

            if (video_stream_copy) {

                f->stream_copy = 1;

            } else

                choose_pixel_fmt(f, codec);

        }



        if(!f->codec->thread_count)

            f->codec->thread_count = 1;

        if(f->codec->thread_count>1)

            avcodec_thread_init(f->codec, f->codec->thread_count);



        if(f->codec->flags & CODEC_FLAG_BITEXACT)

            nopts = 1;

    }



    if (!nopts)

        s->timestamp = av_gettime();



    av_close_input_file(sci);

    return 0;

}
",1,1,0.0,1,"s,filename,i,err,ic,st,codec","s:0.018541693687438965,filename:0.012883186340332031,i:-0.0023478269577026367,err:0.00353395938873291,ic:0.02644619345664978,st:0.0347769558429718,codec:-0.0043766796588897705,",2.0,27.0,"st:f,ic:sci,",Greedy,209,0.1576713482538859
212,"static inline void gen_st16(TCGv val, TCGv addr, int index)

{

    tcg_gen_qemu_st16(val, addr, index);

    dead_tmp(val);

}
",30,"static inline void gen_st16(TCGv call, TCGv addr, int value)

{

    tcg_gen_qemu_st16(call, addr, value);

    dead_tmp(call);

}
",1,1,0.0,1,"val,addr,index","val:0.0015575885772705078,addr:-0.0034197568893432617,index:-0.00020009279251098633,",2.0,5.0,"val:call,index:value,",Greedy,88,0.0646471182505289
221,"static int video_thread(void *arg)

{

    VideoState *is = arg;

    AVFrame *frame = avcodec_alloc_frame();

    int64_t pts_int;

    double pts;

    int ret;



#if CONFIG_AVFILTER

    AVFilterGraph *graph = avfilter_graph_alloc();

    AVFilterContext *filt_out = NULL;

    int64_t pos;

    int last_w = is->video_st->codec->width;

    int last_h = is->video_st->codec->height;



    if ((ret = configure_video_filters(graph, is, vfilters)) < 0)

        goto the_end;

    filt_out = is->out_video_filter;

#endif



    for (;;) {

#if !CONFIG_AVFILTER

        AVPacket pkt;

#else

        AVFilterBufferRef *picref;

        AVRational tb;

#endif

        while (is->paused && !is->videoq.abort_request)

            SDL_Delay(10);

#if CONFIG_AVFILTER

        if (   last_w != is->video_st->codec->width

            || last_h != is->video_st->codec->height) {

            av_dlog(NULL, ""Changing size %dx%d -> %dx%d\n"", last_w, last_h,

                    is->video_st->codec->width, is->video_st->codec->height);

            avfilter_graph_free(&graph);

            graph = avfilter_graph_alloc();

            if ((ret = configure_video_filters(graph, is, vfilters)) < 0)

                goto the_end;

            filt_out = is->out_video_filter;

            last_w = is->video_st->codec->width;

            last_h = is->video_st->codec->height;

        }

        ret = get_filtered_video_frame(filt_out, frame, &picref, &tb);

        if (picref) {

            pts_int = picref->pts;

            pos     = picref->pos;

            frame->opaque = picref;

        }



        if (av_cmp_q(tb, is->video_st->time_base)) {

            av_unused int64_t pts1 = pts_int;

            pts_int = av_rescale_q(pts_int, tb, is->video_st->time_base);

            av_dlog(NULL, ""video_thread(): ""

                    ""tb:%d/%d pts:%""PRId64"" -> tb:%d/%d pts:%""PRId64""\n"",

                    tb.num, tb.den, pts1,

                    is->video_st->time_base.num, is->video_st->time_base.den, pts_int);

        }

#else

        ret = get_video_frame(is, frame, &pts_int, &pkt);

#endif



        if (ret < 0)

            goto the_end;



        if (!ret)

            continue;



        pts = pts_int * av_q2d(is->video_st->time_base);



#if CONFIG_AVFILTER

        ret = output_picture2(is, frame, pts, pos);

#else

        ret = output_picture2(is, frame, pts,  pkt.pos);

        av_free_packet(&pkt);

#endif

        if (ret < 0)

            goto the_end;



        if (step)

            if (cur_stream)

                stream_pause(cur_stream);

    }

 the_end:

#if CONFIG_AVFILTER

    avfilter_graph_free(&graph);

#endif

    av_free(frame);

    return 0;

}
",503,"static int video_thread(void *arg)

{

    VideoState *is = arg;

    AVFrame *frame = avcodec_alloc_frame();

    int64_t pts1bit;

    double pts;

    int alt;



#if CONFIG_AVFILTER

    AVFilterGraph *gp = avfilter_graph_alloc();

    AVFilterContext *filt_out = NULL;

    int64_t pos;

    int last_w = is->video_st->codec->width;

    int last_h = is->video_st->codec->height;



    if ((alt = configure_video_filters(gp, is, vfilters)) < 0)

        goto the_end;

    filt_out = is->out_video_filter;

#endif



    for (;;) {

#if !CONFIG_AVFILTER

        AVPacket pkt;

#else

        AVFilterBufferRef *picref;

        AVRational tb;

#endif

        while (is->paused && !is->videoq.abort_request)

            SDL_Delay(10);

#if CONFIG_AVFILTER

        if (   last_w != is->video_st->codec->width

            || last_h != is->video_st->codec->height) {

            av_dlog(NULL, ""Changing size %dx%d -> %dx%d
"", last_w, last_h,

                    is->video_st->codec->width, is->video_st->codec->height);

            avfilter_graph_free(&gp);

            gp = avfilter_graph_alloc();

            if ((alt = configure_video_filters(gp, is, vfilters)) < 0)

                goto the_end;

            filt_out = is->out_video_filter;

            last_w = is->video_st->codec->width;

            last_h = is->video_st->codec->height;

        }

        alt = get_filtered_video_frame(filt_out, frame, &picref, &tb);

        if (picref) {

            pts1bit = picref->pts;

            pos     = picref->pos;

            frame->opaque = picref;

        }



        if (av_cmp_q(tb, is->video_st->time_base)) {

            av_unused int64_t pts1 = pts1bit;

            pts1bit = av_rescale_q(pts1bit, tb, is->video_st->time_base);

            av_dlog(NULL, ""video_thread(): ""

                    ""tb:%d/%d pts:%""PRId64"" -> tb:%d/%d pts:%""PRId64""
"",

                    tb.num, tb.den, pts1,

                    is->video_st->time_base.num, is->video_st->time_base.den, pts1bit);

        }

#else

        alt = get_video_frame(is, frame, &pts1bit, &pkt);

#endif



        if (alt < 0)

            goto the_end;



        if (!alt)

            continue;



        pts = pts1bit * av_q2d(is->video_st->time_base);



#if CONFIG_AVFILTER

        alt = output_picture2(is, frame, pts, pos);

#else

        alt = output_picture2(is, frame, pts,  pkt.pos);

        av_free_packet(&pkt);

#endif

        if (alt < 0)

            goto the_end;



        if (step)

            if (cur_stream)

                stream_pause(cur_stream);

    }

 the_end:

#if CONFIG_AVFILTER

    avfilter_graph_free(&gp);

#endif

    av_free(frame);

    return 0;

}
",1,1,0.0,1,"arg,is,frame,pts_int,pts,ret,graph,filt_out,pos,pkt,picref,tb","arg:-0.0033039748668670654,is:-0.005704939365386963,frame:0.00703352689743042,pts_int:0.017274796962738037,pts:-0.013935953378677368,ret:0.016756922006607056,graph:0.01332119107246399,filt_out:0.012592673301696777,pos:0.003819584846496582,pkt:0.008964508771896362,picref:-0.024963080883026123,tb:-0.018363922834396362,",3.0,24.0,"pts_int:pts1bit,ret:alt,graph:gp,",Greedy,210,0.1524675726890564
224,"int av_aes_init(AVAES *a, const uint8_t *key, int key_bits, int decrypt)

{

    int i, j, t, rconpointer = 0;

    uint8_t tk[8][4];

    int KC = key_bits >> 5;

    int rounds = KC + 6;

    uint8_t log8[256];

    uint8_t alog8[512];



    if (!enc_multbl[FF_ARRAY_ELEMS(enc_multbl)-1][FF_ARRAY_ELEMS(enc_multbl[0])-1]) {

        j = 1;

        for (i = 0; i < 255; i++) {

            alog8[i] = alog8[i + 255] = j;

            log8[j] = i;

            j ^= j + j;

            if (j > 255)

                j ^= 0x11B;

        }

        for (i = 0; i < 256; i++) {

            j = i ? alog8[255 - log8[i]] : 0;

            j ^= (j << 1) ^ (j << 2) ^ (j << 3) ^ (j << 4);

            j = (j ^ (j >> 8) ^ 99) & 255;

            inv_sbox[j] = i;

            sbox[i] = j;

        }

        init_multbl2(dec_multbl[0], (const int[4]) { 0xe, 0x9, 0xd, 0xb },

                     log8, alog8, inv_sbox);

        init_multbl2(enc_multbl[0], (const int[4]) { 0x2, 0x1, 0x1, 0x3 },

                     log8, alog8, sbox);

    }



    if (key_bits != 128 && key_bits != 192 && key_bits != 256)

        return -1;



    a->rounds = rounds;



    memcpy(tk, key, KC * 4);



    for (t = 0; t < (rounds + 1) * 16;) {

        memcpy(a->round_key[0].u8 + t, tk, KC * 4);

        t += KC * 4;



        for (i = 0; i < 4; i++)

            tk[0][i] ^= sbox[tk[KC - 1][(i + 1) & 3]];

        tk[0][0] ^= rcon[rconpointer++];



        for (j = 1; j < KC; j++) {

            if (KC != 8 || j != KC >> 1)

                for (i = 0; i < 4; i++)

                    tk[j][i] ^= tk[j - 1][i];

            else

                for (i = 0; i < 4; i++)

                    tk[j][i] ^= sbox[tk[j - 1][i]];

        }

    }



    if (decrypt) {

        for (i = 1; i < rounds; i++) {

            av_aes_block tmp[3];

            tmp[2] = a->round_key[i];

            subshift(&tmp[1], 0, sbox);

            mix(tmp, dec_multbl, 1, 3);

            a->round_key[i] = tmp[0];

        }

    } else {

        for (i = 0; i < (rounds + 1) >> 1; i++) {

            FFSWAP(av_aes_block, a->round_key[i], a->round_key[rounds-i]);

        }

    }



    return 0;

}
",646,"int av_aes_init(AVAES *a, const uint8_t *key, int key_bits, int decrypt)

{

    int i, jet, t, rconpointer = 0;

    uint8_t tk[8][4];

    int KC = key_bits >> 5;

    int rounds = KC + 6;

    uint8_t log8[256];

    uint8_t alog8[512];



    if (!enc_multbl[FF_ARRAY_ELEMS(enc_multbl)-1][FF_ARRAY_ELEMS(enc_multbl[0])-1]) {

        jet = 1;

        for (i = 0; i < 255; i++) {

            alog8[i] = alog8[i + 255] = jet;

            log8[jet] = i;

            jet ^= jet + jet;

            if (jet > 255)

                jet ^= 0x11B;

        }

        for (i = 0; i < 256; i++) {

            jet = i ? alog8[255 - log8[i]] : 0;

            jet ^= (jet << 1) ^ (jet << 2) ^ (jet << 3) ^ (jet << 4);

            jet = (jet ^ (jet >> 8) ^ 99) & 255;

            inv_sbox[jet] = i;

            sbox[i] = jet;

        }

        init_multbl2(dec_multbl[0], (const int[4]) { 0xe, 0x9, 0xd, 0xb },

                     log8, alog8, inv_sbox);

        init_multbl2(enc_multbl[0], (const int[4]) { 0x2, 0x1, 0x1, 0x3 },

                     log8, alog8, sbox);

    }



    if (key_bits != 128 && key_bits != 192 && key_bits != 256)

        return -1;



    a->rounds = rounds;



    memcpy(tk, key, KC * 4);



    for (t = 0; t < (rounds + 1) * 16;) {

        memcpy(a->round_key[0].u8 + t, tk, KC * 4);

        t += KC * 4;



        for (i = 0; i < 4; i++)

            tk[0][i] ^= sbox[tk[KC - 1][(i + 1) & 3]];

        tk[0][0] ^= rcon[rconpointer++];



        for (jet = 1; jet < KC; jet++) {

            if (KC != 8 || jet != KC >> 1)

                for (i = 0; i < 4; i++)

                    tk[jet][i] ^= tk[jet - 1][i];

            else

                for (i = 0; i < 4; i++)

                    tk[jet][i] ^= sbox[tk[jet - 1][i]];

        }

    }



    if (decrypt) {

        for (i = 1; i < rounds; i++) {

            av_aes_block tmp[3];

            tmp[2] = a->round_key[i];

            subshift(&tmp[1], 0, sbox);

            mix(tmp, dec_multbl, 1, 3);

            a->round_key[i] = tmp[0];

        }

    } else {

        for (i = 0; i < (rounds + 1) >> 1; i++) {

            FFSWAP(av_aes_block, a->round_key[i], a->round_key[rounds-i]);

        }

    }



    return 0;

}
",1,1,0.0,1,"a,key,key_bits,decrypt,i,j,t,tk,log8,alog8","a:0.037320613861083984,key:0.03037816286087036,key_bits:0.02346763014793396,decrypt:-0.00681227445602417,i:0.004325270652770996,j:0.0662507712841034,t:0.010382533073425293,tk:0.0330452024936676,log8:0.05639442801475525,alog8:0.04114943742752075,",1.0,28.0,"j:jet,",Greedy,165,0.1007812738418579
225,"static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,

	unsigned int width, unsigned int height,

	int lumStride, int chromStride, int dstStride)

{

	//FIXME interpolate chroma

	RENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);

}
",72,"static inline void RENAME(yv12touyvy)(const uint8_t *umscur, const uint8_t *ausource, const uint8_t *fstat, uint8_t *cdsrc,

	unsigned int width, unsigned int ty,

	int lumStride, int chromStride, int dstSTide)

{

	//FIXME interpolate chroma

	RENAME(yuvPlanartouyvy)(umscur, ausource, fstat, cdsrc, width, ty, lumStride, chromStride, dstSTide, 2);

}
",1,1,0.0,1,"ysrc,usrc,vsrc,dst,height,lumStride,chromStride,dstStride","ysrc:0.24830877780914307,usrc:0.06264752149581909,vsrc:0.013059169054031372,dst:0.08428645133972168,height:-0.01826685667037964,lumStride:-0.02658793330192566,chromStride:-0.026480406522750854,dstStride:0.0736033022403717,",6.0,12.0,"ysrc:umscur,dst:cdsrc,dstStride:dstSTide,usrc:ausource,vsrc:fstat,height:ty,",Greedy,186,0.1377423882484436
229,"static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)

{

    ASFContext *asf  = s->priv_data;

    AVIOContext *pb  = s->pb;

    uint64_t size    = avio_rl64(pb);

    uint16_t nb_desc = avio_rl16(pb);

    int i, ret;



    for (i = 0; i < nb_desc; i++) {

        uint16_t name_len, type, val_len;

        uint8_t *name = NULL;



        name_len = avio_rl16(pb);

        if (!name_len)

            return AVERROR_INVALIDDATA;

        name = av_malloc(name_len);

        if (!name)

            return AVERROR(ENOMEM);

        avio_get_str16le(pb, name_len, name,

                         name_len);

        type    = avio_rl16(pb);

        val_len = avio_rl16(pb);



        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)

            return ret;

    }



    align_position(pb, asf->offset, size);

    return 0;

}
",181,"static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)

{

    ASFContext *asf  = s->priv_data;

    AVIOContext *platform  = s->platform;

    uint64_t size    = avio_rl64(platform);

    uint16_t nb_desc = avio_rl16(platform);

    int ui, ret;



    for (ui = 0; ui < nb_desc; ui++) {

        uint16_t pass_len, Type,  name_lin;

        uint8_t *option = NULL;



        pass_len = avio_rl16(platform);

        if (!pass_len)

            return AVERROR_INVALIDDATA;

        option = av_malloc(pass_len);

        if (!option)

            return AVERROR(ENOMEM);

        avio_get_str16le(platform, pass_len, option,

                         pass_len);

        Type    = avio_rl16(platform);

         name_lin = avio_rl16(platform);



        if ((ret = process_metadata(s, option, pass_len,  name_lin, Type, &s->metadata)) < 0)

            return ret;

    }



    align_position(platform, asf->offset, size);

    return 0;

}
",1,1,0.0,1,"s,g,asf,pb,i,ret,name_len,type,val_len,name","s:-0.02463012933731079,g:-0.020145058631896973,asf:-0.031948864459991455,pb:0.049518048763275146,i:-0.010413885116577148,ret:-0.017781734466552734,name_len:0.027473092079162598,type:0.006317734718322754,val_len:0.005069911479949951,name:-0.016241490840911865,",6.0,31.0,"pb:platform,name_len:pass_len,type:Type,val_len: name_lin,i:ui,name:option,",Greedy,359,0.2359704176584879
231,"static void vmxnet3_net_uninit(VMXNET3State *s)

{

    g_free(s->mcast_list);

    vmxnet_tx_pkt_reset(s->tx_pkt);

    vmxnet_tx_pkt_uninit(s->tx_pkt);

    vmxnet_rx_pkt_uninit(s->rx_pkt);

    qemu_del_nic(s->nic);

}
",45,"static void vmxnet3_net_uninit(VMXNET3State *as)

{

    g_free(as->mcast_list);

    vmxnet_tx_pkt_reset(as->tx_pkt);

    vmxnet_tx_pkt_uninit(as->tx_pkt);

    vmxnet_rx_pkt_uninit(as->rx_pkt);

    qemu_del_nic(as->nic);

}
",1,1,0.0,1,s,"s:0.04513978958129883,",1.0,6.0,"s:as,",Greedy,56,0.0437568624814351
234,"CPUArchState *cpu_copy(CPUArchState *env)

{

    CPUState *cpu = ENV_GET_CPU(env);

    CPUState *new_cpu = cpu_init(cpu_model);

    CPUArchState *new_env = cpu->env_ptr;

    CPUBreakpoint *bp;

    CPUWatchpoint *wp;



    /* Reset non arch specific state */

    cpu_reset(new_cpu);



    memcpy(new_env, env, sizeof(CPUArchState));



    /* Clone all break/watchpoints.

       Note: Once we support ptrace with hw-debug register access, make sure

       BP_CPU break/watchpoints are handled correctly on clone. */

    QTAILQ_INIT(&cpu->breakpoints);

    QTAILQ_INIT(&cpu->watchpoints);

    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {

        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);

    }

    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {

        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);

    }



    return new_env;

}
",142,"CPUArchState *cpu_copy(CPUArchState *env)

{

    CPUState *cp = ENV_GET_CPU(env);

    CPUState *new_cpu = cpu_init(cpu_model);

    CPUArchState *new_env = cp->env_ptr;

    CPUBreakpoint *bp;

    CPUWatchpoint *wp;



    /* Reset non arch specific state */

    cpu_reset(new_cpu);



    memcpy(new_env, env, sizeof(CPUArchState));



    /* Clone all break/watchpoints.

       Note: Once we support ptrace with hw-debug register access, make sure

       BP_CPU break/watchpoints are handled correctly on clone. */

    QTAILQ_INIT(&cp->breakpoints);

    QTAILQ_INIT(&cp->watchpoints);

    QTAILQ_FOREACH(bp, &cp->breakpoints, entry) {

        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);

    }

    QTAILQ_FOREACH(wp, &cp->watchpoints, entry) {

        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);

    }



    return new_env;

}
",1,1,0.0,1,"env,cpu,new_cpu,new_env,bp,wp","env:-0.037615835666656494,cpu:0.010695159435272217,new_cpu:-0.04571056365966797,new_env:-0.03956615924835205,bp:-0.059396564960479736,wp:-0.07077354192733765,",1.0,6.0,"cpu:cp,",Greedy,82,0.056162408987681
239,"target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)

{

    check_hwrena(env, 0);

    return env->CP0_EBase & 0x3ff;

}
",23,"target_ulong helper_rdhwr_cpunum(CPUMIPSState *enable)

{

    check_hwrena(enable, 0);

    return enable->CP0_EBase & 0x3ff;

}
",1,1,0.0,1,env,"env:0.14762908220291138,",1.0,3.0,"env:enable,",Greedy,56,0.0448187430699666
242,"static av_always_inline void rv40_weak_loop_filter(uint8_t *src,

                                                   const int step,

                                                   const int stride,

                                                   const int filter_p1,

                                                   const int filter_q1,

                                                   const int alpha,

                                                   const int beta,

                                                   const int lim_p0q0,

                                                   const int lim_q1,

                                                   const int lim_p1)

{

    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;

    int i, t, u, diff;



    for (i = 0; i < 4; i++, src += stride) {

        int diff_p1p0 = src[-2*step] - src[-1*step];

        int diff_q1q0 = src[ 1*step] - src[ 0*step];

        int diff_p1p2 = src[-2*step] - src[-3*step];

        int diff_q1q2 = src[ 1*step] - src[ 2*step];



        t = src[0*step] - src[-1*step];

        if (!t)

            continue;



        u = (alpha * FFABS(t)) >> 7;

        if (u > 3 - (filter_p1 && filter_q1))

            continue;



        t <<= 2;

        if (filter_p1 && filter_q1)

            t += src[-2*step] - src[1*step];



        diff = CLIP_SYMM((t + 4) >> 3, lim_p0q0);

        src[-1*step] = cm[src[-1*step] + diff];

        src[ 0*step] = cm[src[ 0*step] - diff];



        if (filter_p1 && FFABS(diff_p1p2) <= beta) {

            t = (diff_p1p0 + diff_p1p2 - diff) >> 1;

            src[-2*step] = cm[src[-2*step] - CLIP_SYMM(t, lim_p1)];

        }



        if (filter_q1 && FFABS(diff_q1q2) <= beta) {

            t = (diff_q1q0 + diff_q1q2 + diff) >> 1;

            src[ 1*step] = cm[src[ 1*step] - CLIP_SYMM(t, lim_q1)];

        }

    }

}
",378,"static av_always_inline void rv40_weak_loop_filter(uint8_t *src,

                                                   const int step,

                                                   const int Striding,

                                                   const int filter_p1,

                                                   const int filter_q1,

                                                   const int alpha,

                                                   const int tc,

                                                   const int lim_p0q0,

                                                   const int lim_q1,

                                                   const int lim_p1)

{

    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;

    int i, t, u, diff;



    for (i = 0; i < 4; i++, src += Striding) {

        int diff_p1p0 = src[-2*step] - src[-1*step];

        int diff_q1q0 = src[ 1*step] - src[ 0*step];

        int diff_p1p2 = src[-2*step] - src[-3*step];

        int diff_q1q2 = src[ 1*step] - src[ 2*step];



        t = src[0*step] - src[-1*step];

        if (!t)

            continue;



        u = (alpha * FFABS(t)) >> 7;

        if (u > 3 - (filter_p1 && filter_q1))

            continue;



        t <<= 2;

        if (filter_p1 && filter_q1)

            t += src[-2*step] - src[1*step];



        diff = CLIP_SYMM((t + 4) >> 3, lim_p0q0);

        src[-1*step] = cm[src[-1*step] + diff];

        src[ 0*step] = cm[src[ 0*step] - diff];



        if (filter_p1 && FFABS(diff_p1p2) <= tc) {

            t = (diff_p1p0 + diff_p1p2 - diff) >> 1;

            src[-2*step] = cm[src[-2*step] - CLIP_SYMM(t, lim_p1)];

        }



        if (filter_q1 && FFABS(diff_q1q2) <= tc) {

            t = (diff_q1q0 + diff_q1q2 + diff) >> 1;

            src[ 1*step] = cm[src[ 1*step] - CLIP_SYMM(t, lim_q1)];

        }

    }

}
",1,1,0.0,1,"src,step,stride,filter_p1,filter_q1,alpha,beta,lim_p0q0,lim_q1,lim_p1,cm,i,t,u,diff","src:-0.01872915029525757,step:0.005569815635681152,stride:0.021913588047027588,filter_p1:-0.047557532787323,filter_q1:-0.03835195302963257,alpha:0.011421799659729004,beta:0.02591872215270996,lim_p0q0:-0.036632418632507324,lim_q1:-0.019855856895446777,lim_p1:-0.02203267812728882,cm:-0.06392085552215576,i:-0.016258835792541504,t:-0.0024279356002807617,u:0.013733267784118652,diff:-0.007216155529022217,",2.0,5.0,"beta:tc,stride:Striding,",Greedy,161,0.1165913343429565
243,"static void con_disconnect(struct XenDevice *xendev)

{

    struct XenConsole *con = container_of(xendev, struct XenConsole, xendev);



    if (con->chr) {

        qemu_chr_add_handlers(con->chr, NULL, NULL, NULL, NULL);

        qemu_chr_fe_release(con->chr);

    }

    xen_be_unbind_evtchn(&con->xendev);



    if (con->sring) {

        if (!xendev->dev) {

            munmap(con->sring, XC_PAGE_SIZE);

        } else {

            xengnttab_unmap(xendev->gnttabdev, con->sring, 1);

        }

        con->sring = NULL;

    }

}
",112,"static void con_disconnect(struct XenDevice *xendev)

{

    struct XenConsole *func = container_of(xendev, struct XenConsole, xendev);



    if (func->chr) {

        qemu_chr_add_handlers(func->chr, NULL, NULL, NULL, NULL);

        qemu_chr_fe_release(func->chr);

    }

    xen_be_unbind_evtchn(&func->xendev);



    if (func->sring) {

        if (!xendev->dev) {

            munmap(func->sring, XC_PAGE_SIZE);

        } else {

            xengnttab_unmap(xendev->gnttabdev, func->sring, 1);

        }

        func->sring = NULL;

    }

}
",1,1,0.0,1,"xendev,con","xendev:-0.006855398416519165,con:0.057324230670928955,",1.0,9.0,"con:func,",Greedy,80,0.05747811794281
249,"static int filter_slice(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs)

{

    YADIFContext *s = ctx->priv;

    ThreadData *td  = arg;

    int refs = s->cur->linesize[td->plane];

    int df = (s->csp->comp[td->plane].depth_minus1 + 8) / 8;

    int pix_3 = 3 * df;

    int slice_h = td->h / nb_jobs;

    int slice_start = jobnr * slice_h;

    int slice_end   = (jobnr == nb_jobs - 1) ? td->h : (jobnr + 1) * slice_h;

    int y;



    /* filtering reads 3 pixels to the left/right; to avoid invalid reads,

     * we need to call the c variant which avoids this for border pixels

     */

    for (y = slice_start; y < slice_end; y++) {

        if ((y ^ td->parity) & 1) {

            uint8_t *prev = &s->prev->data[td->plane][y * refs];

            uint8_t *cur  = &s->cur ->data[td->plane][y * refs];

            uint8_t *next = &s->next->data[td->plane][y * refs];

            uint8_t *dst  = &td->frame->data[td->plane][y * td->frame->linesize[td->plane]];

            int     mode  = y == 1 || y + 2 == td->h ? 2 : s->mode;

            s->filter_line(dst + pix_3, prev + pix_3, cur + pix_3,

                           next + pix_3, td->w - 6,

                           y + 1 < td->h ? refs : -refs,

                           y ? -refs : refs,

                           td->parity ^ td->tff, mode);

            s->filter_edges(dst, prev, cur, next, td->w,

                            y + 1 < td->h ? refs : -refs,

                            y ? -refs : refs,

                            td->parity ^ td->tff, mode);

        } else {

            memcpy(&td->frame->data[td->plane][y * td->frame->linesize[td->plane]],

                   &s->cur->data[td->plane][y * refs], td->w * df);

        }

    }

    return 0;

}
",424,"static int filter_slice(AVFilterContext *ctx, void *arg, int caseNR, int nb_jobs)

{

    YADIFContext *st = ctx->priv;

    ThreadData *td  = arg;

    int refs = st->cur->linesize[td->plane];

    int df = (st->csp->comp[td->plane].depth_minus1 + 8) / 8;

    int pix_3 = 3 * df;

    int slice_h = td->h / nb_jobs;

    int slice_start = caseNR * slice_h;

    int slice_end   = (caseNR == nb_jobs - 1) ? td->h : (caseNR + 1) * slice_h;

    int y;



    /* filtering reads 3 pixels to the left/right; to avoid invalid reads,

     * we need to call the c variant which avoids this for border pixels

     */

    for (y = slice_start; y < slice_end; y++) {

        if ((y ^ td->parity) & 1) {

            uint8_t *prev = &st->prev->data[td->plane][y * refs];

            uint8_t *cur  = &st->cur ->data[td->plane][y * refs];

            uint8_t *next = &st->next->data[td->plane][y * refs];

            uint8_t *dst  = &td->frame->data[td->plane][y * td->frame->linesize[td->plane]];

            int     mode  = y == 1 || y + 2 == td->h ? 2 : st->mode;

            st->filter_line(dst + pix_3, prev + pix_3, cur + pix_3,

                           next + pix_3, td->w - 6,

                           y + 1 < td->h ? refs : -refs,

                           y ? -refs : refs,

                           td->parity ^ td->tff, mode);

            st->filter_edges(dst, prev, cur, next, td->w,

                            y + 1 < td->h ? refs : -refs,

                            y ? -refs : refs,

                            td->parity ^ td->tff, mode);

        } else {

            memcpy(&td->frame->data[td->plane][y * td->frame->linesize[td->plane]],

                   &st->cur->data[td->plane][y * refs], td->w * df);

        }

    }

    return 0;

}
",1,1,0.0,1,"ctx,arg,jobnr,nb_jobs,s,td,y,prev,cur,next,dst","ctx:-0.07075762748718262,arg:-0.01957571506500244,jobnr:0.02985513210296631,nb_jobs:-1.4135497212409973,s:0.0097084641456604,td:-0.01879158616065979,y:0.005156159400939941,prev:-0.03379666805267334,cur:-0.018814027309417725,next:-0.03285723924636841,dst:-0.06973332166671753,",2.0,14.0,"jobnr:caseNR,s:st,",Greedy,197,0.1368298093477885
253,"static void quantize_and_encode_band_cost_SPAIR_mips(struct AACEncContext *s,

                                                     PutBitContext *pb, const float *in, float *out,

                                                     const float *scaled, int size, int scale_idx,

                                                     int cb, const float lambda, const float uplim,

                                                     int *bits, const float ROUNDING)

{

    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];

    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];

    int i;

    int qc1, qc2, qc3, qc4;



    uint8_t  *p_bits  = (uint8_t  *)ff_aac_spectral_bits[cb-1];

    uint16_t *p_codes = (uint16_t *)ff_aac_spectral_codes[cb-1];

    float    *p_vec   = (float    *)ff_aac_codebook_vectors[cb-1];



    abs_pow34_v(s->scoefs, in, size);

    scaled = s->scoefs;

    for (i = 0; i < size; i += 4) {

        int curidx, curidx2;

        int *in_int = (int *)&in[i];

        uint8_t v_bits;

        unsigned int v_codes;

        int t0, t1, t2, t3, t4, t5, t6, t7;

        const float *vec1, *vec2;



        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;

        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;

        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;

        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;



        __asm__ volatile (

            "".set push                      \n\t""

            "".set noreorder                 \n\t""



            ""ori    %[t4],  $zero,  4       \n\t""

            ""slt    %[t0],  %[t4],  %[qc1]  \n\t""

            ""slt    %[t1],  %[t4],  %[qc2]  \n\t""

            ""slt    %[t2],  %[t4],  %[qc3]  \n\t""

            ""slt    %[t3],  %[t4],  %[qc4]  \n\t""

            ""movn   %[qc1], %[t4],  %[t0]   \n\t""

            ""movn   %[qc2], %[t4],  %[t1]   \n\t""

            ""movn   %[qc3], %[t4],  %[t2]   \n\t""

            ""movn   %[qc4], %[t4],  %[t3]   \n\t""

            ""lw     %[t0],  0(%[in_int])    \n\t""

            ""lw     %[t1],  4(%[in_int])    \n\t""

            ""lw     %[t2],  8(%[in_int])    \n\t""

            ""lw     %[t3],  12(%[in_int])   \n\t""

            ""srl    %[t0],  %[t0],  31      \n\t""

            ""srl    %[t1],  %[t1],  31      \n\t""

            ""srl    %[t2],  %[t2],  31      \n\t""

            ""srl    %[t3],  %[t3],  31      \n\t""

            ""subu   %[t4],  $zero,  %[qc1]  \n\t""

            ""subu   %[t5],  $zero,  %[qc2]  \n\t""

            ""subu   %[t6],  $zero,  %[qc3]  \n\t""

            ""subu   %[t7],  $zero,  %[qc4]  \n\t""

            ""movn   %[qc1], %[t4],  %[t0]   \n\t""

            ""movn   %[qc2], %[t5],  %[t1]   \n\t""

            ""movn   %[qc3], %[t6],  %[t2]   \n\t""

            ""movn   %[qc4], %[t7],  %[t3]   \n\t""



            "".set pop                       \n\t""



            : [qc1]""+r""(qc1), [qc2]""+r""(qc2),

              [qc3]""+r""(qc3), [qc4]""+r""(qc4),

              [t0]""=&r""(t0), [t1]""=&r""(t1), [t2]""=&r""(t2), [t3]""=&r""(t3),

              [t4]""=&r""(t4), [t5]""=&r""(t5), [t6]""=&r""(t6), [t7]""=&r""(t7)

            : [in_int]""r""(in_int)

            : ""memory""

        );



        curidx = 9 * qc1;

        curidx += qc2 + 40;



        curidx2 = 9 * qc3;

        curidx2 += qc4 + 40;



        v_codes = (p_codes[curidx] << p_bits[curidx2]) | (p_codes[curidx2]);

        v_bits  = p_bits[curidx] + p_bits[curidx2];

        put_bits(pb, v_bits, v_codes);



        if (out) {

           vec1 = &p_vec[curidx*2 ];

           vec2 = &p_vec[curidx2*2];

           out[i+0] = vec1[0] * IQ;

           out[i+1] = vec1[1] * IQ;

           out[i+2] = vec2[0] * IQ;

           out[i+3] = vec2[1] * IQ;

        }

    }

}
",645,"static void quantize_and_encode_band_cost_SPAIR_mips(struct AACEncContext *settings,

                                                     PutBitContext *prot, const float *in, float *cmd,

                                                     const float *scaled, int size, int scale_idx,

                                                     int btn, const float lambda, const float uplim,

                                                     int *bands, const float ROUNDING)

{

    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];

    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];

    int i;

    int qc1, qc2, qc3, qc4;



    uint8_t  *p_bits  = (uint8_t  *)ff_aac_spectral_bits[btn-1];

    uint16_t *p_codes = (uint16_t *)ff_aac_spectral_codes[btn-1];

    float    *p_norm   = (float    *)ff_aac_codebook_vectors[btn-1];



    abs_pow34_v(settings->scoefs, in, size);

    scaled = settings->scoefs;

    for (i = 0; i < size; i += 4) {

        int curidx, curIdf1;

        int *in_int = (int *)&in[i];

        uint8_t v_bits;

        unsigned int v_seq;

        int ta0, T3, T22, itthree, t4, t5, t06, t7;

        const float *vec1, *vec2;



        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;

        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;

        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;

        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;



        __asm__ volatile (

            "".set push                      
\t""

            "".set noreorder                 
\t""



            ""ori    %[t4],  $zero,  4       
\t""

            ""slt    %[t0],  %[t4],  %[qc1]  
\t""

            ""slt    %[t1],  %[t4],  %[qc2]  
\t""

            ""slt    %[t2],  %[t4],  %[qc3]  
\t""

            ""slt    %[t3],  %[t4],  %[qc4]  
\t""

            ""movn   %[qc1], %[t4],  %[t0]   
\t""

            ""movn   %[qc2], %[t4],  %[t1]   
\t""

            ""movn   %[qc3], %[t4],  %[t2]   
\t""

            ""movn   %[qc4], %[t4],  %[t3]   
\t""

            ""lw     %[t0],  0(%[in_int])    
\t""

            ""lw     %[t1],  4(%[in_int])    
\t""

            ""lw     %[t2],  8(%[in_int])    
\t""

            ""lw     %[t3],  12(%[in_int])   
\t""

            ""srl    %[t0],  %[t0],  31      
\t""

            ""srl    %[t1],  %[t1],  31      
\t""

            ""srl    %[t2],  %[t2],  31      
\t""

            ""srl    %[t3],  %[t3],  31      
\t""

            ""subu   %[t4],  $zero,  %[qc1]  
\t""

            ""subu   %[t5],  $zero,  %[qc2]  
\t""

            ""subu   %[t6],  $zero,  %[qc3]  
\t""

            ""subu   %[t7],  $zero,  %[qc4]  
\t""

            ""movn   %[qc1], %[t4],  %[t0]   
\t""

            ""movn   %[qc2], %[t5],  %[t1]   
\t""

            ""movn   %[qc3], %[t6],  %[t2]   
\t""

            ""movn   %[qc4], %[t7],  %[t3]   
\t""



            "".set pop                       
\t""



            : [qc1]""+r""(qc1), [qc2]""+r""(qc2),

              [qc3]""+r""(qc3), [qc4]""+r""(qc4),

              [ta0]""=&r""(ta0), [T3]""=&r""(T3), [T22]""=&r""(T22), [itthree]""=&r""(itthree),

              [t4]""=&r""(t4), [t5]""=&r""(t5), [t06]""=&r""(t06), [t7]""=&r""(t7)

            : [in_int]""r""(in_int)

            : ""memory""

        );



        curidx = 9 * qc1;

        curidx += qc2 + 40;



        curIdf1 = 9 * qc3;

        curIdf1 += qc4 + 40;



        v_seq = (p_codes[curidx] << p_bits[curIdf1]) | (p_codes[curIdf1]);

        v_bits  = p_bits[curidx] + p_bits[curIdf1];

        put_bits(prot, v_bits, v_seq);



        if (cmd) {

           vec1 = &p_norm[curidx*2 ];

           vec2 = &p_norm[curIdf1*2];

           cmd[i+0] = vec1[0] * IQ;

           cmd[i+1] = vec1[1] * IQ;

           cmd[i+2] = vec2[0] * IQ;

           cmd[i+3] = vec2[1] * IQ;

        }

    }

}
",1,1,0.0,1,"s,pb,in,out,scaled,size,scale_idx,cb,lambda,uplim,bits,ROUNDING,i,qc1,qc2,qc3,qc4,p_bits,p_codes,p_vec,curidx,curidx2,in_int,v_bits,v_codes,t0,t1,t2,t3,t4,t5,t6,t7,vec1,vec2","s:0.0015988349914550781,pb:0.009211301803588867,in:-0.002881169319152832,out:0.0203855037689209,scaled:-0.007656276226043701,size:-0.01267087459564209,scale_idx:-0.04213446378707886,cb:0.0018955469131469727,lambda:-0.011498808860778809,uplim:-0.006294190883636475,bits:0.0012986063957214355,ROUNDING:-0.0038518905639648438,i:-0.003950238227844238,qc1:-0.003938615322113037,qc2:-0.00021475553512573242,qc3:-0.007271170616149902,qc4:-0.016827046871185303,p_bits:-0.01756763458251953,p_codes:-0.00228959321975708,p_vec:0.006368696689605713,curidx:-0.0006455183029174805,curidx2:0.005432069301605225,in_int:-0.010046303272247314,v_bits:-0.002694845199584961,v_codes:0.002908170223236084,t0:0.002665281295776367,t1:0.0037007927894592285,t2:0.00880366563796997,t3:0.005078017711639404,t4:0.0010165572166442871,t5:0.004388928413391113,t6:0.002901792526245117,t7:-0.0005832910537719727,vec1:-0.012676119804382324,vec2:-0.009484052658081055,",13.0,44.0,"out:cmd,pb:prot,t2:T22,p_vec:p_norm,curidx2:curIdf1,t3:itthree,t5:t5,t1:T3,v_codes:v_seq,t6:t06,t0:ta0,cb:btn,s:settings,bits:bands,",Greedy,408,0.3382314205169677
262,"static void sdhci_send_command(SDHCIState *s)

{

    SDRequest request;

    uint8_t response[16];

    int rlen;



    s->errintsts = 0;

    s->acmd12errsts = 0;

    request.cmd = s->cmdreg >> 8;

    request.arg = s->argument;

    DPRINT_L1(""sending CMD%u ARG[0x%08x]\n"", request.cmd, request.arg);

    rlen = sdbus_do_command(&s->sdbus, &request, response);



    if (s->cmdreg & SDHC_CMD_RESPONSE) {

        if (rlen == 4) {

            s->rspreg[0] = (response[0] << 24) | (response[1] << 16) |

                           (response[2] << 8)  |  response[3];

            s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0;

            DPRINT_L1(""Response: RSPREG[31..0]=0x%08x\n"", s->rspreg[0]);

        } else if (rlen == 16) {

            s->rspreg[0] = (response[11] << 24) | (response[12] << 16) |

                           (response[13] << 8) |  response[14];

            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |

                           (response[9] << 8)  |  response[10];

            s->rspreg[2] = (response[3] << 24) | (response[4] << 16) |

                           (response[5] << 8)  |  response[6];

            s->rspreg[3] = (response[0] << 16) | (response[1] << 8) |

                            response[2];

            DPRINT_L1(""Response received:\n RSPREG[127..96]=0x%08x, RSPREG[95..""

                  ""64]=0x%08x,\n RSPREG[63..32]=0x%08x, RSPREG[31..0]=0x%08x\n"",

                  s->rspreg[3], s->rspreg[2], s->rspreg[1], s->rspreg[0]);

        } else {

            ERRPRINT(""Timeout waiting for command response\n"");

            if (s->errintstsen & SDHC_EISEN_CMDTIMEOUT) {

                s->errintsts |= SDHC_EIS_CMDTIMEOUT;

                s->norintsts |= SDHC_NIS_ERR;

            }

        }



        if ((s->norintstsen & SDHC_NISEN_TRSCMP) &&

            (s->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) {

            s->norintsts |= SDHC_NIS_TRSCMP;

        }

    }



    if (s->norintstsen & SDHC_NISEN_CMDCMP) {

        s->norintsts |= SDHC_NIS_CMDCMP;

    }



    sdhci_update_irq(s);



    if (s->blksize && (s->cmdreg & SDHC_CMD_DATA_PRESENT)) {

        s->data_count = 0;

        sdhci_data_transfer(s);

    }

}
",515,"static void sdhci_send_command(SDHCIState *s)

{

    SDRequest request;

    uint8_t response[16];

    int rrlen;



    s->errintsts = 0;

    s->acmd12errsts = 0;

    request.cmd = s->cmdreg >> 8;

    request.arg = s->argument;

    DPRINT_L1(""sending CMD%u ARG[0x%08x]
"", request.cmd, request.arg);

    rrlen = sdbus_do_command(&s->sdbus, &request, response);



    if (s->cmdreg & SDHC_CMD_RESPONSE) {

        if (rrlen == 4) {

            s->rspreg[0] = (response[0] << 24) | (response[1] << 16) |

                           (response[2] << 8)  |  response[3];

            s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0;

            DPRINT_L1(""Response: RSPREG[31..0]=0x%08x
"", s->rspreg[0]);

        } else if (rrlen == 16) {

            s->rspreg[0] = (response[11] << 24) | (response[12] << 16) |

                           (response[13] << 8) |  response[14];

            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |

                           (response[9] << 8)  |  response[10];

            s->rspreg[2] = (response[3] << 24) | (response[4] << 16) |

                           (response[5] << 8)  |  response[6];

            s->rspreg[3] = (response[0] << 16) | (response[1] << 8) |

                            response[2];

            DPRINT_L1(""Response received:
 RSPREG[127..96]=0x%08x, RSPREG[95..""

                  ""64]=0x%08x,
 RSPREG[63..32]=0x%08x, RSPREG[31..0]=0x%08x
"",

                  s->rspreg[3], s->rspreg[2], s->rspreg[1], s->rspreg[0]);

        } else {

            ERRPRINT(""Timeout waiting for command response
"");

            if (s->errintstsen & SDHC_EISEN_CMDTIMEOUT) {

                s->errintsts |= SDHC_EIS_CMDTIMEOUT;

                s->norintsts |= SDHC_NIS_ERR;

            }

        }



        if ((s->norintstsen & SDHC_NISEN_TRSCMP) &&

            (s->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) {

            s->norintsts |= SDHC_NIS_TRSCMP;

        }

    }



    if (s->norintstsen & SDHC_NISEN_CMDCMP) {

        s->norintsts |= SDHC_NIS_CMDCMP;

    }



    sdhci_update_irq(s);



    if (s->blksize && (s->cmdreg & SDHC_CMD_DATA_PRESENT)) {

        s->data_count = 0;

        sdhci_data_transfer(s);

    }

}
",1,1,0.0,1,"s,request,response,rlen","s:-0.06098616123199463,request:0.006864398717880249,response:-0.07968506217002869,rlen:0.08337020874023438,",1.0,4.0,"rlen:rrlen,",Greedy,113,0.0894647002220153
270,"static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *s,

                                                    int16_t *block, int n)

{

    int level, i, j, run;

    RLTable *rl = &ff_rl_mpeg1;

    uint8_t * const scantable = s->intra_scantable.permutated;

    const int qscale          = s->qscale;

    OPEN_READER(re, &s->gb);

    i = -1;



    // special case for first coefficient, no need to add second VLC table

    UPDATE_CACHE(re, &s->gb);

    if (((int32_t)GET_CACHE(re, &s->gb)) < 0) {

        level = (3 * qscale) >> 1;

        if (GET_CACHE(re, &s->gb) & 0x40000000)

            level = -level;

        block[0] = level;

        i++;

        SKIP_BITS(re, &s->gb, 2);

        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)

            goto end;

    }



    /* now quantify & encode AC coefficients */

    for (;;) {

        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);



        if (level != 0) {

            i += run;

            j  = scantable[i];

            level = ((level * 2 + 1) * qscale) >> 1;

            level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);

            SKIP_BITS(re, &s->gb, 1);

        } else {

            /* escape */

            run = SHOW_UBITS(re, &s->gb, 6) + 1; LAST_SKIP_BITS(re, &s->gb, 6);

            UPDATE_CACHE(re, &s->gb);

            level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);



            i += run;

            j  = scantable[i];

            if (level < 0) {

                level = ((-level * 2 + 1) * qscale) >> 1;

                level = -level;

            } else {

                level = ((level * 2 + 1) * qscale) >> 1;

            }

        }



        block[j] = level;

        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)

            break;

        UPDATE_CACHE(re, &s->gb);

    }

end:

    LAST_SKIP_BITS(re, &s->gb, 2);

    CLOSE_READER(re, &s->gb);

    s->block_last_index[n] = i;

    return 0;

}
",489,"static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *s,

                                                    int16_t *block, int n)

{

    int letter, i, j, type;

    RLTable *rl = &ff_rl_mpeg1;

    uint8_t * const scantable = s->intra_scantable.permutated;

    const int qscale          = s->qscale;

    OPEN_READER(re, &s->gb);

    i = -1;



    // special case for first coefficient, no need to add second VLC table

    UPDATE_CACHE(re, &s->gb);

    if (((int32_t)GET_CACHE(re, &s->gb)) < 0) {

        letter = (3 * qscale) >> 1;

        if (GET_CACHE(re, &s->gb) & 0x40000000)

            letter = -letter;

        block[0] = letter;

        i++;

        SKIP_BITS(re, &s->gb, 2);

        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)

            goto end;

    }



    /* now quantify & encode AC coefficients */

    for (;;) {

        GET_RL_VLC(letter, type, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);



        if (letter != 0) {

            i += type;

            j  = scantable[i];

            letter = ((letter * 2 + 1) * qscale) >> 1;

            letter = (letter ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);

            SKIP_BITS(re, &s->gb, 1);

        } else {

            /* escape */

            type = SHOW_UBITS(re, &s->gb, 6) + 1; LAST_SKIP_BITS(re, &s->gb, 6);

            UPDATE_CACHE(re, &s->gb);

            letter = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);



            i += type;

            j  = scantable[i];

            if (letter < 0) {

                letter = ((-letter * 2 + 1) * qscale) >> 1;

                letter = -letter;

            } else {

                letter = ((letter * 2 + 1) * qscale) >> 1;

            }

        }



        block[j] = letter;

        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)

            break;

        UPDATE_CACHE(re, &s->gb);

    }

end:

    LAST_SKIP_BITS(re, &s->gb, 2);

    CLOSE_READER(re, &s->gb);

    s->block_last_index[n] = i;

    return 0;

}
",1,1,0.0,1,"s,block,n,level,i,j,run,rl,scantable","s:-0.08778640627861023,block:0.0006523728370666504,n:-0.004226803779602051,level:0.02759343385696411,i:0.0022471249103546143,j:0.014375418424606323,run:0.04718220233917236,rl:0.015173912048339844,scantable:-0.012118399143218994,",2.0,25.0,"run:type,level:letter,",Greedy,206,0.1405451377232869
273,"static void qpa_fini_out (HWVoiceOut *hw)

{

    void *ret;

    PAVoiceOut *pa = (PAVoiceOut *) hw;



    audio_pt_lock (&pa->pt, AUDIO_FUNC);

    pa->done = 1;

    audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC);

    audio_pt_join (&pa->pt, &ret, AUDIO_FUNC);



    if (pa->s) {

        pa_simple_free (pa->s);

        pa->s = NULL;

    }



    audio_pt_fini (&pa->pt, AUDIO_FUNC);

    g_free (pa->pcm_buf);

    pa->pcm_buf = NULL;

}
",107,"static void qpa_fini_out (HWVoiceOut *ctx)

{

    void *alt;

    PAVoiceOut *qa = (PAVoiceOut *) ctx;



    audio_pt_lock (&qa->pt, AUDIO_FUNC);

    qa->done = 1;

    audio_pt_unlock_and_signal (&qa->pt, AUDIO_FUNC);

    audio_pt_join (&qa->pt, &alt, AUDIO_FUNC);



    if (qa->s) {

        pa_simple_free (qa->s);

        qa->s = NULL;

    }



    audio_pt_fini (&qa->pt, AUDIO_FUNC);

    g_free (qa->pcm_buf);

    qa->pcm_buf = NULL;

}
",1,1,0.0,1,"hw,ret,pa","hw:0.03402361273765564,ret:0.046637922525405884,pa:-0.07505041360855103,",3.0,15.0,"ret:alt,hw:ctx,pa:qa,",Greedy,155,0.1134019255638122
278,"static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)

{

    int ret, i;



    frame->width  = s->avctx->width  + 2;

    frame->height = s->avctx->height + 2;

    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)

        return ret;

    for (i = 0; frame->data[i]; i++) {

        int offset = frame->linesize[i] + (1 << sps->pixel_shift);

        frame->data[i] += offset;

    }

    frame->width  = s->avctx->width;

    frame->height = s->avctx->height;



    return 0;

}
",138,"static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *Sfs)

{

    int ret, io;



    frame->width  = s->avctx->width  + 2;

    frame->height = s->avctx->height + 2;

    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)

        return ret;

    for (io = 0; frame->data[io]; io++) {

        int offset = frame->linesize[io] + (1 << Sfs->pixel_shift);

        frame->data[io] += offset;

    }

    frame->width  = s->avctx->width;

    frame->height = s->avctx->height;



    return 0;

}
",1,1,0.0,1,"s,frame,sps,ret,i","s:-0.038382112979888916,frame:-0.05934441089630127,sps:-0.03190261125564575,ret:-0.10554027557373047,i:-0.007095992565155029,",2.0,8.0,"i:io,sps:Sfs,",Greedy,111,0.0867079734802246
287,"int qemu_chr_fe_read_all(CharDriverState *s, uint8_t *buf, int len)

{

    int offset = 0, counter = 10;

    int res;



    if (!s->chr_sync_read) {

        return 0;

    }

    

    if (s->replay && replay_mode == REPLAY_MODE_PLAY) {

        return replay_char_read_all_load(buf);

    }



    while (offset < len) {

        do {

            res = s->chr_sync_read(s, buf + offset, len - offset);

            if (res == -1 && errno == EAGAIN) {

                g_usleep(100);

            }

        } while (res == -1 && errno == EAGAIN);



        if (res == 0) {

            break;

        }



        if (res < 0) {

            if (s->replay && replay_mode == REPLAY_MODE_RECORD) {

                replay_char_read_all_save_error(res);

            }

            return res;

        }



        offset += res;



        if (!counter--) {

            break;

        }

    }



    if (s->replay && replay_mode == REPLAY_MODE_RECORD) {

        replay_char_read_all_save_buf(buf, offset);

    }

    return offset;

}
",188,"int qemu_chr_fe_read_all(CharDriverState *state, uint8_t *buf, int list)

{

    int offset = 0, clock = 10;

    int res;



    if (!state->chr_sync_read) {

        return 0;

    }

    

    if (state->replay && replay_mode == REPLAY_MODE_PLAY) {

        return replay_char_read_all_load(buf);

    }



    while (offset < list) {

        do {

            res = state->chr_sync_read(state, buf + offset, list - offset);

            if (res == -1 && errno == EAGAIN) {

                g_usleep(100);

            }

        } while (res == -1 && errno == EAGAIN);



        if (res == 0) {

            break;

        }



        if (res < 0) {

            if (state->replay && replay_mode == REPLAY_MODE_RECORD) {

                replay_char_read_all_save_error(res);

            }

            return res;

        }



        offset += res;



        if (!clock--) {

            break;

        }

    }



    if (state->replay && replay_mode == REPLAY_MODE_RECORD) {

        replay_char_read_all_save_buf(buf, offset);

    }

    return offset;

}
",1,1,0.0,1,"s,buf,len,res,counter","s:0.009157359600067139,buf:-0.0426754355430603,len:-0.01169884204864502,res:-0.021436214447021484,counter:-0.005513787269592285,",3.0,12.0,"s:state,counter:clock,len:list,",Greedy,168,0.052354876200358
293,"static bool qht_insert__locked(struct qht *ht, struct qht_map *map,

                               struct qht_bucket *head, void *p, uint32_t hash,

                               bool *needs_resize)

{

    struct qht_bucket *b = head;

    struct qht_bucket *prev = NULL;

    struct qht_bucket *new = NULL;

    int i;



    do {

        for (i = 0; i < QHT_BUCKET_ENTRIES; i++) {

            if (b->pointers[i]) {

                if (unlikely(b->pointers[i] == p)) {

                    return false;

                }

            } else {

                goto found;

            }

        }

        prev = b;

        b = b->next;

    } while (b);



    b = qemu_memalign(QHT_BUCKET_ALIGN, sizeof(*b));

    memset(b, 0, sizeof(*b));

    new = b;

    i = 0;

    atomic_inc(&map->n_added_buckets);

    if (unlikely(qht_map_needs_resize(map)) && needs_resize) {

        *needs_resize = true;

    }



 found:

    /* found an empty key: acquire the seqlock and write */

    seqlock_write_begin(&head->sequence);

    if (new) {

        atomic_rcu_set(&prev->next, b);

    }

    b->hashes[i] = hash;

    /* smp_wmb() implicit in seqlock_write_begin.  */

    atomic_set(&b->pointers[i], p);

    seqlock_write_end(&head->sequence);

    return true;

}
",245,"static bool qht_insert__locked(struct qht *hard, struct qht_map *map,

                               struct qht_bucket *hook, void *port, uint32_t image,

                               bool *needs_resample)

{

    struct qht_bucket *b = hook;

    struct qht_bucket *loc = NULL;

    struct qht_bucket *new = NULL;

    int api;



    do {

        for (api = 0; api < QHT_BUCKET_ENTRIES; api++) {

            if (b->pointers[api]) {

                if (unlikely(b->pointers[api] == port)) {

                    return false;

                }

            } else {

                goto found;

            }

        }

        loc = b;

        b = b->next;

    } while (b);



    b = qemu_memalign(QHT_BUCKET_ALIGN, sizeof(*b));

    memset(b, 0, sizeof(*b));

    new = b;

    api = 0;

    atomic_inc(&map->n_added_buckets);

    if (unlikely(qht_map_needs_resize(map)) && needs_resample) {

        *needs_resample = true;

    }



 found:

    /* found an empty key: acquire the seqlock and write */

    seqlock_write_begin(&hook->sequence);

    if (new) {

        atomic_rcu_set(&loc->next, b);

    }

    b->hashes[api] = image;

    /* smp_wmb() implicit in seqlock_write_begin.  */

    atomic_set(&b->pointers[api], port);

    seqlock_write_end(&hook->sequence);

    return true;

}
",1,1,0.0,1,"ht,map,head,p,hash,needs_resize,b,prev,new,i","ht:-0.0353432297706604,map:-0.05419951677322388,head:-0.03616166114807129,p:-0.031191468238830566,hash:-0.012933075428009033,needs_resize:-0.006132960319519043,b:-0.089499831199646,prev:-0.03445935249328613,new:-0.03654074668884277,i:0.00047981739044189453,",7.0,25.0,"i:api,needs_resize:needs_resample,hash:image,p:port,prev:loc,ht:hard,head:hook,",Greedy,347,0.1080484787623087
339,"void *g_realloc(void *ptr, size_t size)

{

    size_t old_size, copy;

    void *new_ptr;



    if (!ptr)

        return g_malloc(size);

    old_size = *(size_t *)((char *)ptr - 16);

    copy = old_size < size ? old_size : size;

    new_ptr = g_malloc(size);

    memcpy(new_ptr, ptr, copy);

    g_free(ptr);

    return new_ptr;

}
",84,"void *g_realloc(void *address, size_t type)

{

    size_t  old_scale, clip;

    void *new__addr;



    if (!address)

        return g_malloc(type);

     old_scale = *(size_t *)((char *)address - 16);

    clip =  old_scale < type ?  old_scale : type;

    new__addr = g_malloc(type);

    memcpy(new__addr, address, clip);

    g_free(address);

    return new__addr;

}
",1,1,0.0,1,"ptr,size,old_size,copy,new_ptr","ptr:-0.0980372428894043,size:-0.05103403329849243,old_size:-0.08300560712814331,copy:-0.0540081262588501,new_ptr:-0.01668238639831543,",5.0,21.0,"new_ptr:new__addr,size:type,copy:clip,old_size: old_scale,ptr:address,",Greedy,203,0.0623033563296
341,"static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,
                            AVPacket *avpkt)
{
    const uint8_t *buf = avpkt->data;
    int buf_size       = avpkt->size;
    AVFrame *const p   = data;
    int compressed, xmin, ymin, xmax, ymax;
    unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x,
                 bytes_per_scanline;
    uint8_t *ptr;
    const uint8_t *buf_end = buf + buf_size;
    const uint8_t *bufstart = buf;
    uint8_t *scanline;
    int ret = -1;
    if (buf[0] != 0x0a || buf[1] > 5) {
        av_log(avctx, AV_LOG_ERROR, ""this is not PCX encoded data\n"");
    compressed = buf[2];
    xmin       = AV_RL16(buf + 4);
    ymin       = AV_RL16(buf + 6);
    xmax       = AV_RL16(buf + 8);
    ymax       = AV_RL16(buf + 10);
    if (xmax < xmin || ymax < ymin) {
        av_log(avctx, AV_LOG_ERROR, ""invalid image dimensions\n"");
    w = xmax - xmin + 1;
    h = ymax - ymin + 1;
    bits_per_pixel     = buf[3];
    bytes_per_line     = AV_RL16(buf + 66);
    nplanes            = buf[65];
    bytes_per_scanline = nplanes * bytes_per_line;
    if (bytes_per_scanline < (w * bits_per_pixel * nplanes + 7) / 8 ||
        (!compressed && bytes_per_scanline > buf_size / h)) {
        av_log(avctx, AV_LOG_ERROR, ""PCX data is corrupted\n"");
    switch ((nplanes << 8) + bits_per_pixel) {
    case 0x0308:
        avctx->pix_fmt = AV_PIX_FMT_RGB24;
        break;
    case 0x0108:
    case 0x0104:
    case 0x0102:
    case 0x0101:
    case 0x0401:
    case 0x0301:
    case 0x0201:
        avctx->pix_fmt = AV_PIX_FMT_PAL8;
        break;
    default:
        av_log(avctx, AV_LOG_ERROR, ""invalid PCX file\n"");
    buf += 128;
    if ((ret = ff_set_dimensions(avctx, w, h)) < 0)
        return ret;
    if ((ret = ff_get_buffer(avctx, p, 0)) < 0) {
        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");
        return ret;
    p->pict_type = AV_PICTURE_TYPE_I;
    ptr    = p->data[0];
    stride = p->linesize[0];
    scanline = av_malloc(bytes_per_scanline + AV_INPUT_BUFFER_PADDING_SIZE);
    if (!scanline)
        return AVERROR(ENOMEM);
    if (nplanes == 3 && bits_per_pixel == 8) {
        for (y = 0; y < h; y++) {
            buf = pcx_rle_decode(buf, buf_end,
                                 scanline, bytes_per_scanline, compressed);
            for (x = 0; x < w; x++) {
                ptr[3 * x]     = scanline[x];
                ptr[3 * x + 1] = scanline[x + bytes_per_line];
                ptr[3 * x + 2] = scanline[x + (bytes_per_line << 1)];
            ptr += stride;
    } else if (nplanes == 1 && bits_per_pixel == 8) {
        const uint8_t *palstart = bufstart + buf_size - 769;
        if (buf_size < 769) {
            av_log(avctx, AV_LOG_ERROR, ""File is too short\n"");
            ret = avctx->err_recognition & AV_EF_EXPLODE ?
                  AVERROR_INVALIDDATA : buf_size;
            goto end;
        for (y = 0; y < h; y++, ptr += stride) {
            buf = pcx_rle_decode(buf, buf_end,
                                 scanline, bytes_per_scanline, compressed);
            memcpy(ptr, scanline, w);
        if (buf != palstart) {
            av_log(avctx, AV_LOG_WARNING, ""image data possibly corrupted\n"");
            buf = palstart;
        if (*buf++ != 12) {
            av_log(avctx, AV_LOG_ERROR, ""expected palette after image data\n"");
            ret = avctx->err_recognition & AV_EF_EXPLODE ?
                  AVERROR_INVALIDDATA : buf_size;
            goto end;
    } else if (nplanes == 1) {   /* all packed formats, max. 16 colors */
        GetBitContext s;
        for (y = 0; y < h; y++) {
            init_get_bits(&s, scanline, bytes_per_scanline << 3);
            buf = pcx_rle_decode(buf, buf_end,
                                 scanline, bytes_per_scanline, compressed);
            for (x = 0; x < w; x++)
                ptr[x] = get_bits(&s, bits_per_pixel);
            ptr += stride;
    } else {    /* planar, 4, 8 or 16 colors */
        int i;
        for (y = 0; y < h; y++) {
            buf = pcx_rle_decode(buf, buf_end,
                                 scanline, bytes_per_scanline, compressed);
            for (x = 0; x < w; x++) {
                int m = 0x80 >> (x & 7), v = 0;
                for (i = nplanes - 1; i >= 0; i--) {
                    v <<= 1;
                    v  += !!(scanline[i * bytes_per_line + (x >> 3)] & m);
                ptr[x] = v;
            ptr += stride;
    if (nplanes == 1 && bits_per_pixel == 8) {
        pcx_palette(&buf, (uint32_t *)p->data[1], 256);
    } else if (bits_per_pixel < 8) {
        const uint8_t *palette = bufstart + 16;
        pcx_palette(&palette, (uint32_t *)p->data[1], 16);
    *got_frame = 1;
    ret = buf - bufstart;
end:
    av_free(scanline);
    return ret;",987,"static int pcx_decode_frame(AVCodecContext *avctx, void *pad, int *af_range,
                            AVPacket *avpkt)
{
    const uint8_t poolf =avpktt->pad;
    int buf_size       = avpkt->size;
    AVFrame *constep   = pad;
    int  compression, yskip, yskip, axend, tmax;
    unsigned int end, ha, bits_pernice, bytes_perjword, Nbands, stride, y, image,
                 bytes_per_imagel;
    uint8_t *port;
    const uint8_t *bbuffer_start= pool + buf_size;
    const uint8_t *bbuffrom= pool;
    uint8_t *synline;
    int ret = -1;
    if (pool[0] != 0x0a || pool[1] > 5) {
        av_log(avctx, AV_LOG_ERROR, ""this is not PCX encoded data
"");
    c compression= pool[2];
    xyskip      = AV_RL16(pool + 4);
    yyskip      = AV_RL16(pool + 6);
    xaxend      = AV_RL16(pool + 8);
    ytmax      = AV_RL16(pool + 10);
    if (xmaxend yskip || ytmax< yskip) {
        av_log(avctx, AV_LOG_ERROR, ""invalid image dimensions
"");
    w end xaxend- yskip + 1;
    hha= ytmax- yskip + 1;
    bbits_pernice    = pool[3];
    bbytes_perjword    = AV_RL16(pool + 66);
    nNbands           = pool[65];
   bytes_per_imagele = Nbands * bytes_perjword;
    if (bytes_per_imagel < (end * bits_pernice * Nbands + 7) / 8 ||
        (! compression && bbytes_per_imagel> buf_size / ha)) {
        av_log(avctx, AV_LOG_ERROR, ""PCX data is corrupted
"");
    switch (Nbandss << 8) + bits_pernice) {
    case 0x0308:
        avctx->pix_fmt = AV_PIX_FMT_RGB24;
        break;
    case 0x0108:
    case 0x0104:
    case 0x0102:
    case 0x0101:
    case 0x0401:
    case 0x0301:
    case 0x0201:
        avctx->pix_fmt = AV_PIX_FMT_PAL8;
        break;
    default:
        av_log(avctx, AV_LOG_ERROR, ""invalid PCX file
"");
    pool += 128;
    if ((ret = ff_set_dimensions(avctx, end, ha)) < 0)
        return ret;
    if ((ret = ff_get_buffer(avctx, e, 0)) < 0) {
        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed
"");
        return ret;
    e->pict_type = AV_PICTURE_TYPE_I;
   portr    =ep->pad[0];
    stride = e->linesize[0];
  synlinene = av_malloc(bytes_per_imagel + AV_INPUT_BUFFER_PADDING_SIZE);
    if (!synline)
        return AVERROR(ENOMEM);
    if Nbandss == 3 && bits_pernice == 8) {
        for (yy= 0; yy< ha; y++) {
            pool = pcx_rle_decode(pool, buffer_start,
                                 synline, bybytes_per_imagel compression);
            for (x image 0; x image end; image++) {
                ptr[3 * portge]     = scansynlinege];
                ptr[3 * portge + 1] = scansynlinege + bytes_perjword];
                ptr[3 * portge + 2] = scansynlinege + (bytes_perjword << 1)];
            port += stride;
    } else if Nbandss == 1 && bits_pernice == 8) {
        const uint8_t *palstart = buffrom + buf_size - 769;
        if (buf_size < 769) {
            av_log(avctx, AV_LOG_ERROR, ""File is too short
"");
            ret = avctx->err_recognition & AV_EF_EXPLODE ?
                  AVERROR_INVALIDDATA : buf_size;
            goto end;
        for (yy= 0; yy< ha; y++, port += stride) {
            pool = pcx_rle_decode(pool, buffer_start,
                                 synline, bybytes_per_imagel compression);
            memcpy(ptportscsynlineend);
        if (pool != palstart) {
            av_log(avctx, AV_LOG_WARNING, ""image data possibly corrupted
"");
            pool = palstart;
        if (*pool++ != 12) {
            av_log(avctx, AV_LOG_ERROR, ""expected palette after image data
"");
            ret = avctx->err_recognition & AV_EF_EXPLODE ?
                  AVERROR_INVALIDDATA : buf_size;
            goto end;
    } else if (Nbands == 1) {   /* all packed formats, max. 16 colors */
        GetBitContext s;
        for (yy= 0; yy< ha; y++) {
            init_get_bits(&ssynlinene, bytes_per_imagel << 3);
            pool = pcx_rle_decode(pool, buffer_start,
                                 synline, bybytes_per_imagel compression);
            for (x image 0; x image end; image++)
                ptrportgex] = get_bits(&s, bits_pernice);
            port += stride;
    } else {    /* planar, 4, 8 or 16 colors */
        int i;
        for (yy= 0; yy< ha; y++) {
            pool = pcx_rle_decode(pool, buffer_start,
                                 synline, bybytes_per_imagel compression);
            for (x image 0; x image end; image++) {
                int m = 0x80 >> (image & 7), v = 0;
                for (i = Nbands - 1; i >= 0; i--) {
                    v <<= 1;
                    v  += !!(scansynline bytes_perjword + (image >> 3)] & m);
                ptr[portge] = v;
            port += stride;
    if Nbandss == 1 && bits_pernice == 8) {
        pcx_palette(poolf, (uint32_t *ep->pad[1], 256);
    } else if (bits_pernice < 8) {
        const uint8_t *palette = buffrom + 16;
        pcx_palette(&palette, (uint32_t *ep->pad[1], 16);
    *af_range = 1;
    ret = pool - buffrom;
end:
    av_free(synline);
    return ret;",1,1,0.0,1,"avctx,data,got_frame,avpkt,buf,p,compressed,xmin,ymin,xmax,ymax,w,h,bits_per_pixel,bytes_per_line,nplanes,stride,y,x,bytes_per_scanline,ptr,buf_end,bufstart,scanline",,4.0,37.0,"avctx:avctx,data:pad,got_frame:af_range,avpkt:avpkt,buf:pool,p:e,compressed: compression,xmin:yskip,ymin:yskip,xmax:axend,ymax:tmax,w:end,h:ha,bits_per_pixel:bits_pernice,bytes_per_line:bytes_perjword,nplanes:Nbands,stride:stride,y:y,x:image,bytes_per_scanline:bytes_per_imagel,ptr:port,buf_end:buffer_start,bufstart:buffrom,scanline:synline,",GA,3404,1.3985918402671813
368,"static int minimum_frame_bits(VC2EncContext *s)

{

    int slice_x, slice_y, bits = 0;

    s->size_scaler = 64;

    for (slice_y = 0; slice_y < s->num_y; slice_y++) {

        for (slice_x = 0; slice_x < s->num_x; slice_x++) {

            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);

        }

    }

    return bits;

}
",79,"static int minimum_frame_bits(VC2EncContext *ssl)

{

    int sliceamed, player08y, bits = 0;

    ssl->size_scaler = 64;

    for (player08y = 0; player08y < ssl->num_y; player08y++) {

        for (sliceamed = 0; sliceamed < ssl->num_x; sliceamed++) {

            bits += count_hq_slice(ssl, NULL, sliceamed, player08y, ssl->q_ceil);

        }

    }

    return bits;

}
",1,1,0.0,1,"s,slice_x,slice_y","s:-0.010813355445861816,slice_x:-0.04360383749008179,slice_y:-0.03635209798812866,",3.0,16.0,"s:ssl,slice_y:player08y,slice_x:sliceamed,",Greedy,176,0.0523705959320068
369,"static void fd_coroutine_enter(void *opaque)

{

    FDYieldUntilData *data = opaque;

    qemu_set_fd_handler(data->fd, NULL, NULL, NULL);

    qemu_coroutine_enter(data->co, NULL);

}
",38,"static void fd_coroutine_enter(void *ospacity)

{

    FDYieldUntilData *data = ospacity;

    qemu_set_fd_handler(data->fd, NULL, NULL, NULL);

    qemu_coroutine_enter(data->co, NULL);

}
",1,1,0.0,1,"opaque,data","opaque:0.10438787937164307,data:0.05463102459907532,",1.0,2.0,"opaque:ospacity,",Greedy,34,0.0143246134122212
377,"static int get_cpsr(QEMUFile *f, void *opaque, size_t size)

{

    ARMCPU *cpu = opaque;

    CPUARMState *env = &cpu->env;

    uint32_t val = qemu_get_be32(f);



    env->aarch64 = ((val & PSTATE_nRW) == 0);



    if (is_a64(env)) {

        pstate_write(env, val);

        return 0;

    }



    /* Avoid mode switch when restoring CPSR */

    env->uncached_cpsr = val & CPSR_M;

    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);

    return 0;

}
",95,"static int get_cpsr(QEMUFile *f, void *opaque, size_t size)

{

    ARMCPU *cp = opaque;

    CPUARMState *exe = &cp->exe;

    uint32_t val = qemu_get_be32(f);



    exe->aarch64 = ((val & PSTATE_nRW) == 0);



    if (is_a64(exe)) {

        pstate_write(exe, val);

        return 0;

    }



    /* Avoid mode switch when restoring CPSR */

    exe->uncached_cpsr = val & CPSR_M;

    cpsr_write(exe, val, 0xffffffff, CPSRWriteRaw);

    return 0;

}
",1,1,0.0,1,"f,opaque,size,cpu,env","f:-0.07268142700195312,opaque:0.0664084255695343,size:-0.0327610969543457,cpu:0.0889396071434021,env:0.10670909285545349,",2.0,9.0,"env:exe,cpu:cp,",Greedy,132,0.0400033712387084
381,"static int read_directory(BDRVVVFATState* s, int mapping_index)

{

    mapping_t* mapping = array_get(&(s->mapping), mapping_index);

    direntry_t* direntry;

    const char* dirname = mapping->path;

    int first_cluster = mapping->begin;

    int parent_index = mapping->info.dir.parent_mapping_index;

    mapping_t* parent_mapping = (mapping_t*)

        (parent_index >= 0 ? array_get(&(s->mapping), parent_index) : NULL);

    int first_cluster_of_parent = parent_mapping ? parent_mapping->begin : -1;



    DIR* dir=opendir(dirname);

    struct dirent* entry;

    int i;



    assert(mapping->mode & MODE_DIRECTORY);



    if(!dir) {

        mapping->end = mapping->begin;

        return -1;

    }



    i = mapping->info.dir.first_dir_index =

            first_cluster == 0 ? 0 : s->directory.next;



    if (first_cluster != 0) {

        /* create the top entries of a subdirectory */

        (void)create_short_and_long_name(s, i, ""."", 1);

        (void)create_short_and_long_name(s, i, "".."", 1);

    }



    /* actually read the directory, and allocate the mappings */

    while((entry=readdir(dir))) {

        unsigned int length=strlen(dirname)+2+strlen(entry->d_name);

        char* buffer;

        direntry_t* direntry;

        struct stat st;

        int is_dot=!strcmp(entry->d_name,""."");

        int is_dotdot=!strcmp(entry->d_name,"".."");



        if(first_cluster == 0 && (is_dotdot || is_dot))

            continue;



        buffer = g_malloc(length);

        snprintf(buffer,length,""%s/%s"",dirname,entry->d_name);



        if(stat(buffer,&st)<0) {

            g_free(buffer);

            continue;

        }



        /* create directory entry for this file */

        if (!is_dot && !is_dotdot) {

            direntry = create_short_and_long_name(s, i, entry->d_name, 0);

        } else {

            direntry = array_get(&(s->directory), is_dot ? i : i + 1);

        }

        direntry->attributes=(S_ISDIR(st.st_mode)?0x10:0x20);

        direntry->reserved[0]=direntry->reserved[1]=0;

        direntry->ctime=fat_datetime(st.st_ctime,1);

        direntry->cdate=fat_datetime(st.st_ctime,0);

        direntry->adate=fat_datetime(st.st_atime,0);

        direntry->begin_hi=0;

        direntry->mtime=fat_datetime(st.st_mtime,1);

        direntry->mdate=fat_datetime(st.st_mtime,0);

        if(is_dotdot)

            set_begin_of_direntry(direntry, first_cluster_of_parent);

        else if(is_dot)

            set_begin_of_direntry(direntry, first_cluster);

        else

            direntry->begin=0; /* do that later */

        if (st.st_size > 0x7fffffff) {

            fprintf(stderr, ""File %s is larger than 2GB\n"", buffer);

            g_free(buffer);

            closedir(dir);

            return -2;

        }

        direntry->size=cpu_to_le32(S_ISDIR(st.st_mode)?0:st.st_size);



        /* create mapping for this file */

        if(!is_dot && !is_dotdot && (S_ISDIR(st.st_mode) || st.st_size)) {

            s->current_mapping = array_get_next(&(s->mapping));

            s->current_mapping->begin=0;

            s->current_mapping->end=st.st_size;

            /*

             * we get the direntry of the most recent direntry, which

             * contains the short name and all the relevant information.

             */

            s->current_mapping->dir_index=s->directory.next-1;

            s->current_mapping->first_mapping_index = -1;

            if (S_ISDIR(st.st_mode)) {

                s->current_mapping->mode = MODE_DIRECTORY;

                s->current_mapping->info.dir.parent_mapping_index =

                    mapping_index;

            } else {

                s->current_mapping->mode = MODE_UNDEFINED;

                s->current_mapping->info.file.offset = 0;

            }

            s->current_mapping->path=buffer;

            s->current_mapping->read_only =

                (st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0;

        } else {

            g_free(buffer);

        }

    }

    closedir(dir);



    /* fill with zeroes up to the end of the cluster */

    while(s->directory.next%(0x10*s->sectors_per_cluster)) {

        direntry_t* direntry=array_get_next(&(s->directory));

        memset(direntry,0,sizeof(direntry_t));

    }



/* TODO: if there are more entries, bootsector has to be adjusted! */

#define ROOT_ENTRIES (0x02 * 0x10 * s->sectors_per_cluster)

    if (mapping_index == 0 && s->directory.next < ROOT_ENTRIES) {

        /* root directory */

        int cur = s->directory.next;

        array_ensure_allocated(&(s->directory), ROOT_ENTRIES - 1);

        s->directory.next = ROOT_ENTRIES;

        memset(array_get(&(s->directory), cur), 0,

                (ROOT_ENTRIES - cur) * sizeof(direntry_t));

    }



    /* re-get the mapping, since s->mapping was possibly realloc()ed */

    mapping = array_get(&(s->mapping), mapping_index);

    first_cluster += (s->directory.next - mapping->info.dir.first_dir_index)

        * 0x20 / s->cluster_size;

    mapping->end = first_cluster;



    direntry = array_get(&(s->directory), mapping->dir_index);

    set_begin_of_direntry(direntry, mapping->begin);



    return 0;

}
",936,"static int read_directory(BDRVVVFATState* s, int mapping_index)

{

    mapping_t* mapping = array_get(&(s->mapping), mapping_index);

    direntry_t* direntry;

    const char* directorytype = mapping->path;

    int first_cluster = mapping->begin;

    int parent_index = mapping->info.direction.parent_mapping_index;

    mapping_t* parent_smaming = (mapping_t*)

        (parent_index >= 0 ? array_get(&(s->mapping), parent_index) : NULL);

    int first_cluster_of_parent = parent_smaming ? parent_smaming->begin : -1;



    DIR* direction=opendir(directorytype);

    struct dirent* action;

    int ui;



    assert(mapping->mode & MODE_DIRECTORY);



    if(!direction) {

        mapping->end = mapping->begin;

        return -1;

    }



    ui = mapping->info.direction.first_dir_index =

            first_cluster == 0 ? 0 : s->directory.next;



    if (first_cluster != 0) {

        /* create the top entries of a subdirectory */

        (void)create_short_and_long_name(s, ui, ""."", 1);

        (void)create_short_and_long_name(s, ui, "".."", 1);

    }



    /* actually read the directory, and allocate the mappings */

    while((action=readdir(direction))) {

        unsigned int length=strlen(directorytype)+2+strlen(action->d_name);

        char* comment;

        direntry_t* direntry;

        struct stat St;

        int is_dot=!strcmp(action->d_name,""."");

        int is_dotdot=!strcmp(action->d_name,"".."");



        if(first_cluster == 0 && (is_dotdot || is_dot))

            continue;



        comment = g_malloc(length);

        snprintf(comment,length,""%s/%s"",directorytype,action->d_name);



        if(stat(comment,&St)<0) {

            g_free(comment);

            continue;

        }



        /* create directory entry for this file */

        if (!is_dot && !is_dotdot) {

            direntry = create_short_and_long_name(s, ui, action->d_name, 0);

        } else {

            direntry = array_get(&(s->directory), is_dot ? ui : ui + 1);

        }

        direntry->attributes=(S_ISDIR(St.st_mode)?0x10:0x20);

        direntry->reserved[0]=direntry->reserved[1]=0;

        direntry->ctime=fat_datetime(St.st_ctime,1);

        direntry->cdate=fat_datetime(St.st_ctime,0);

        direntry->adate=fat_datetime(St.st_atime,0);

        direntry->begin_hi=0;

        direntry->mtime=fat_datetime(St.st_mtime,1);

        direntry->mdate=fat_datetime(St.st_mtime,0);

        if(is_dotdot)

            set_begin_of_direntry(direntry, first_cluster_of_parent);

        else if(is_dot)

            set_begin_of_direntry(direntry, first_cluster);

        else

            direntry->begin=0; /* do that later */

        if (St.st_size > 0x7fffffff) {

            fprintf(stderr, ""File %s is larger than 2GB
"", comment);

            g_free(comment);

            closedir(direction);

            return -2;

        }

        direntry->size=cpu_to_le32(S_ISDIR(St.st_mode)?0:St.st_size);



        /* create mapping for this file */

        if(!is_dot && !is_dotdot && (S_ISDIR(St.st_mode) || St.st_size)) {

            s->current_mapping = array_get_next(&(s->mapping));

            s->current_mapping->begin=0;

            s->current_mapping->end=St.st_size;

            /*

             * we get the direntry of the most recent direntry, which

             * contains the short name and all the relevant information.

             */

            s->current_mapping->dir_index=s->directory.next-1;

            s->current_mapping->first_mapping_index = -1;

            if (S_ISDIR(St.st_mode)) {

                s->current_mapping->mode = MODE_DIRECTORY;

                s->current_mapping->info.direction.parent_mapping_index =

                    mapping_index;

            } else {

                s->current_mapping->mode = MODE_UNDEFINED;

                s->current_mapping->info.file.offset = 0;

            }

            s->current_mapping->path=comment;

            s->current_mapping->read_only =

                (St.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0;

        } else {

            g_free(comment);

        }

    }

    closedir(direction);



    /* fill with zeroes up to the end of the cluster */

    while(s->directory.next%(0x10*s->sectors_per_cluster)) {

        direntry_t* direntry=array_get_next(&(s->directory));

        memset(direntry,0,sizeof(direntry_t));

    }



/* TODO: if there are more entries, bootsector has to be adjusted! */

#define ROOT_ENTRIES (0x02 * 0x10 * s->sectors_per_cluster)

    if (mapping_index == 0 && s->directory.next < ROOT_ENTRIES) {

        /* root directory */

        int cur = s->directory.next;

        array_ensure_allocated(&(s->directory), ROOT_ENTRIES - 1);

        s->directory.next = ROOT_ENTRIES;

        memset(array_get(&(s->directory), cur), 0,

                (ROOT_ENTRIES - cur) * sizeof(direntry_t));

    }



    /* re-get the mapping, since s->mapping was possibly realloc()ed */

    mapping = array_get(&(s->mapping), mapping_index);

    first_cluster += (s->directory.next - mapping->info.direction.first_dir_index)

        * 0x20 / s->cluster_size;

    mapping->end = first_cluster;



    direntry = array_get(&(s->directory), mapping->dir_index);

    set_begin_of_direntry(direntry, mapping->begin);



    return 0;

}
",1,1,0.0,1,"s,mapping_index,mapping,direntry,dirname,parent_mapping,dir,entry,i,buffer,st","s:-0.039842188358306885,mapping_index:-0.023335814476013184,mapping:-0.037740111351013184,direntry:-0.018859565258026123,dirname:-0.015063583850860596,parent_mapping:0.02265608310699463,dir:-0.005042731761932373,entry:-0.01829087734222412,i:-0.002044379711151123,buffer:-0.015295565128326416,st:-0.014188766479492188,",7.0,55.0,"parent_mapping:parent_smaming,i:ui,dir:direction,st:St,dirname:directorytype,buffer:comment,entry:action,",Greedy,487,0.1773317337036132
386,"static void diff_pixels_altivec(int16_t *restrict block, const uint8_t *s1,

                                const uint8_t *s2, int stride)

{

    int i;

    vec_u8 perm1 = vec_lvsl(0, s1);

    vec_u8 perm2 = vec_lvsl(0, s2);

    const vec_u8 zero = (const vec_u8)vec_splat_u8(0);

    vec_s16 shorts1, shorts2;



    for (i = 0; i < 4; i++) {

        /* Read potentially unaligned pixels.

         * We're reading 16 pixels, and actually only want 8,

         * but we simply ignore the extras. */

        vec_u8 pixl  = vec_ld(0,  s1);

        vec_u8 pixr  = vec_ld(15, s1);

        vec_u8 bytes = vec_perm(pixl, pixr, perm1);



        // Convert the bytes into shorts.

        shorts1 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the same for the second block of pixels.

        pixl  = vec_ld(0,  s2);

        pixr  = vec_ld(15, s2);

        bytes = vec_perm(pixl, pixr, perm2);



        // Convert the bytes into shorts.

        shorts2 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the subtraction.

        shorts1 = vec_sub(shorts1, shorts2);



        // Save the data to the block, we assume the block is 16-byte aligned.

        vec_st(shorts1, 0, (vec_s16 *)block);



        s1    += stride;

        s2    += stride;

        block += 8;



        /* The code below is a copy of the code above...

         * This is a manual unroll. */



        /* Read potentially unaligned pixels.

         * We're reading 16 pixels, and actually only want 8,

         * but we simply ignore the extras. */

        pixl  = vec_ld(0,  s1);

        pixr  = vec_ld(15, s1);

        bytes = vec_perm(pixl, pixr, perm1);



        // Convert the bytes into shorts.

        shorts1 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the same for the second block of pixels.

        pixl  = vec_ld(0,  s2);

        pixr  = vec_ld(15, s2);

        bytes = vec_perm(pixl, pixr, perm2);



        // Convert the bytes into shorts.

        shorts2 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the subtraction.

        shorts1 = vec_sub(shorts1, shorts2);



        // Save the data to the block, we assume the block is 16-byte aligned.

        vec_st(shorts1, 0, (vec_s16 *)block);



        s1    += stride;

        s2    += stride;

        block += 8;

    }

}
",315,"static void diff_pixels_altivec(int16_t *restrict label, const uint8_t *s1,

                                const uint8_t *s2, int stride)

{

    int i;

    vec_u8 perm1 = vec_lvsl(0, s1);

    vec_u8 perm2 = vec_lvsl(0, s2);

    const vec_u8 zero = (const vec_u8)vec_splat_u8(0);

    vec_s16 shorts1, shorts2;



    for (i = 0; i < 4; i++) {

        /* Read potentially unaligned pixels.

         * We're reading 16 pixels, and actually only want 8,

         * but we simply ignore the extras. */

        vec_u8 pixl  = vec_ld(0,  s1);

        vec_u8 pixr  = vec_ld(15, s1);

        vec_u8 bytes = vec_perm(pixl, pixr, perm1);



        // Convert the bytes into shorts.

        shorts1 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the same for the second block of pixels.

        pixl  = vec_ld(0,  s2);

        pixr  = vec_ld(15, s2);

        bytes = vec_perm(pixl, pixr, perm2);



        // Convert the bytes into shorts.

        shorts2 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the subtraction.

        shorts1 = vec_sub(shorts1, shorts2);



        // Save the data to the block, we assume the block is 16-byte aligned.

        vec_st(shorts1, 0, (vec_s16 *)label);



        s1    += stride;

        s2    += stride;

        label += 8;



        /* The code below is a copy of the code above...

         * This is a manual unroll. */



        /* Read potentially unaligned pixels.

         * We're reading 16 pixels, and actually only want 8,

         * but we simply ignore the extras. */

        pixl  = vec_ld(0,  s1);

        pixr  = vec_ld(15, s1);

        bytes = vec_perm(pixl, pixr, perm1);



        // Convert the bytes into shorts.

        shorts1 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the same for the second block of pixels.

        pixl  = vec_ld(0,  s2);

        pixr  = vec_ld(15, s2);

        bytes = vec_perm(pixl, pixr, perm2);



        // Convert the bytes into shorts.

        shorts2 = (vec_s16)vec_mergeh(zero, bytes);



        // Do the subtraction.

        shorts1 = vec_sub(shorts1, shorts2);



        // Save the data to the block, we assume the block is 16-byte aligned.

        vec_st(shorts1, 0, (vec_s16 *)label);



        s1    += stride;

        s2    += stride;

        label += 8;

    }

}
",1,1,0.0,1,"block,s1,s2,stride,i,shorts1,shorts2","block:0.1051049530506134,s1:-0.04881182312965393,s2:0.009423822164535522,stride:0.04980674386024475,i:0.023906618356704712,shorts1:0.0199737548828125,shorts2:0.01319587230682373,",1.0,5.0,"block:label,",Greedy,108,0.0353283842404683
387,"int ff_thread_get_buffer(AVCodecContext *avctx, AVFrame *f)

{

    PerThreadContext *p = avctx->thread_opaque;

    int *progress, err;



    f->owner = avctx;



    ff_init_buffer_info(avctx, f);



    if (!(avctx->active_thread_type&FF_THREAD_FRAME)) {

        f->thread_opaque = NULL;

        return avctx->get_buffer(avctx, f);

    }



    if (p->state != STATE_SETTING_UP &&

        (avctx->codec->update_thread_context || (!avctx->thread_safe_callbacks &&

                avctx->get_buffer != avcodec_default_get_buffer))) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() cannot be called after ff_thread_finish_setup()\n"");

        return -1;

    }



    pthread_mutex_lock(&p->parent->buffer_mutex);

    f->thread_opaque = progress = allocate_progress(p);



    if (!progress) {

        pthread_mutex_unlock(&p->parent->buffer_mutex);

        return -1;

    }



    progress[0] =

    progress[1] = -1;



    if (avctx->thread_safe_callbacks ||

        avctx->get_buffer == avcodec_default_get_buffer) {

        err = avctx->get_buffer(avctx, f);

    } else {

        p->requested_frame = f;

        p->state = STATE_GET_BUFFER;

        pthread_mutex_lock(&p->progress_mutex);

        pthread_cond_signal(&p->progress_cond);



        while (p->state != STATE_SETTING_UP)

            pthread_cond_wait(&p->progress_cond, &p->progress_mutex);



        err = p->result;



        pthread_mutex_unlock(&p->progress_mutex);



        if (!avctx->codec->update_thread_context)

            ff_thread_finish_setup(avctx);

    }



    pthread_mutex_unlock(&p->parent->buffer_mutex);



    return err;

}
",284,"int ff_thread_get_buffer(AVCodecContext *attcmp, AVFrame *f)

{

    PerThreadContext *p = attcmp->thread_opaque;

    int *press, err;



    f->owner = attcmp;



    ff_init_buffer_info(attcmp, f);



    if (!(attcmp->active_thread_type&FF_THREAD_FRAME)) {

        f->thread_opaque = NULL;

        return attcmp->get_buffer(attcmp, f);

    }



    if (p->state != STATE_SETTING_UP &&

        (attcmp->codec->update_thread_context || (!attcmp->thread_safe_callbacks &&

                attcmp->get_buffer != avcodec_default_get_buffer))) {

        av_log(attcmp, AV_LOG_ERROR, ""get_buffer() cannot be called after ff_thread_finish_setup()
"");

        return -1;

    }



    pthread_mutex_lock(&p->parent->buffer_mutex);

    f->thread_opaque = press = allocate_progress(p);



    if (!press) {

        pthread_mutex_unlock(&p->parent->buffer_mutex);

        return -1;

    }



    press[0] =

    press[1] = -1;



    if (attcmp->thread_safe_callbacks ||

        attcmp->get_buffer == avcodec_default_get_buffer) {

        err = attcmp->get_buffer(attcmp, f);

    } else {

        p->requested_frame = f;

        p->state = STATE_GET_BUFFER;

        pthread_mutex_lock(&p->progress_mutex);

        pthread_cond_signal(&p->progress_cond);



        while (p->state != STATE_SETTING_UP)

            pthread_cond_wait(&p->progress_cond, &p->progress_mutex);



        err = p->result;



        pthread_mutex_unlock(&p->progress_mutex);



        if (!attcmp->codec->update_thread_context)

            ff_thread_finish_setup(attcmp);

    }



    pthread_mutex_unlock(&p->parent->buffer_mutex);



    return err;

}
",1,1,0.0,1,"avctx,f,p,progress,err","avctx:0.03844127058982849,f:0.009474635124206543,p:0.0039520263671875,progress:0.03228810429573059,err:0.016449332237243652,",2.0,22.0,"avctx:attcmp,progress:press,",Greedy,217,0.066030999024709
388,"bool qio_task_propagate_error(QIOTask *task,

                              Error **errp)

{

    if (task->err) {

        error_propagate(errp, task->err);


        return true;

    }



    return false;

}",37,"bool qio_task_propagate_error(QIOTask *device,

                              Error **irps)

{

    if (device->err) {

        error_propagate(irps, device->err);


        return true;

    }



    return false;

}",1,1,0.0,1,"task,errp","task:0.01995086669921875,errp:0.0838850736618042,",2.0,5.0,"errp:irps,task:device,",Greedy,81,0.0270022432009379
390,"yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],

            const int16_t *ubuf[2], const int16_t *vbuf[2],

            const int16_t *abuf[2], uint8_t *dest, int dstW,

            int yalpha, int uvalpha, int y)

{

    int hasAlpha = abuf[0] && abuf[1];

    const int16_t *buf0  = buf[0],  *buf1  = buf[1],

                  *abuf0 = hasAlpha ? abuf[0] : NULL,

                  *abuf1 = hasAlpha ? abuf[1] : NULL;

    int  yalpha1 = 4096 - yalpha;

    int i;



    for (i = 0; i < dstW; i++) {

        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;

        int A;



        Y = av_clip_uint8(Y);



        if (hasAlpha) {

            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;

            A = av_clip_uint8(A);

        }



        dest[i * 2    ] = Y;

        dest[i * 2 + 1] = hasAlpha ? A : 255;

    }

}
",233,"yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],

            const int16_t *ubuf[2], const int16_t *vbuf[2],

            const int16_t *abuf[2], uint8_t *dest, int dstW,

            int yalpha, int uvalpha, int y)

{

    int hasAlpha = abuf[0] && abuf[1];

    const int16_t *buf0  = buf[0],  *buf1  = buf[1],

                  *abuf0 = hasAlpha ? abuf[0] : NULL,

                  *abuf1 = hasAlpha ? abuf[1] : NULL;

    int  yalpha1 = 4096 - yalpha;

    int i;



    for (i = 0; i < dstW; i++) {

        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;

        int H;



        Y = av_clip_uint8(Y);



        if (hasAlpha) {

            H = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;

            H = av_clip_uint8(H);

        }



        dest[i * 2    ] = Y;

        dest[i * 2 + 1] = hasAlpha ? H : 255;

    }

}
",1,1,0.0,1,"buf0,buf1,abuf0,abuf1,i,A","buf0:0.08630034327507019,buf1:0.02844199538230896,abuf0:0.024534881114959717,abuf1:0.028901517391204834,i:0.08238440752029419,A:0.09983676671981812,",1.0,5.0,"A:H,",Greedy,80,0.0272604465484619
391,"static void device_unparent(Object *obj)

{

    DeviceState *dev = DEVICE(obj);

    BusState *bus;



    if (dev->realized) {

        object_property_set_bool(obj, false, ""realized"", NULL);

    }

    while (dev->num_child_bus) {

        bus = QLIST_FIRST(&dev->child_bus);

        object_unparent(OBJECT(bus));

    }

    if (dev->parent_bus) {

        bus_remove_child(dev->parent_bus, dev);

        object_unref(OBJECT(dev->parent_bus));

        dev->parent_bus = NULL;

    }



    /* Only send event if the device had been completely realized */

    if (dev->pending_deleted_event) {

        g_assert(dev->canonical_path);



        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,

                                       &error_abort);

        g_free(dev->canonical_path);

        dev->canonical_path = NULL;

    }

}
",150,"static void device_unparent(Object *obj)

{

    DeviceState *adv = DEVICE(obj);

    BusState *state;



    if (adv->realized) {

        object_property_set_bool(obj, false, ""realized"", NULL);

    }

    while (adv->num_child_bus) {

        state = QLIST_FIRST(&adv->child_bus);

        object_unparent(OBJECT(state));

    }

    if (adv->parent_bus) {

        bus_remove_child(adv->parent_bus, adv);

        object_unref(OBJECT(adv->parent_bus));

        adv->parent_bus = NULL;

    }



    /* Only send event if the device had been completely realized */

    if (adv->pending_deleted_event) {

        g_assert(adv->canonical_path);



        qapi_event_send_device_deleted(!!adv->id, adv->id, adv->canonical_path,

                                       &error_abort);

        g_free(adv->canonical_path);

        adv->canonical_path = NULL;

    }

}
",1,1,0.0,1,"obj,dev,bus","obj:-0.01957648992538452,dev:-0.0015016794204711914,bus:0.005842626094818115,",2.0,19.0,"bus:state,dev:adv,",Greedy,149,0.0453201174736022
3,"void vp8_decode_mvs(VP8Context *s, VP8Macroblock *mb,

                    int mb_x, int mb_y, int layout)

{

    VP8Macroblock *mb_edge[3] = { 0      /* top */,

                                  mb - 1 /* left */,

                                  0      /* top-left */ };

    enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV };

    enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT };

    int idx = CNT_ZERO;

    int cur_sign_bias = s->sign_bias[mb->ref_frame];

    int8_t *sign_bias = s->sign_bias;

    VP56mv near_mv[4];

    uint8_t cnt[4] = { 0 };

    VP56RangeCoder *c = &s->c;



    if (!layout) { // layout is inlined (s->mb_layout is not)

        mb_edge[0] = mb + 2;

        mb_edge[2] = mb + 1;

    } else {

        mb_edge[0] = mb - s->mb_width - 1;

        mb_edge[2] = mb - s->mb_width - 2;

    }



    AV_ZERO32(&near_mv[0]);

    AV_ZERO32(&near_mv[1]);

    AV_ZERO32(&near_mv[2]);



    /* Process MB on top, left and top-left */

#define MV_EDGE_CHECK(n)                                                      \

    {                                                                         \

        VP8Macroblock *edge = mb_edge[n];                                     \

        int edge_ref = edge->ref_frame;                                       \

        if (edge_ref != VP56_FRAME_CURRENT) {                                 \

            uint32_t mv = AV_RN32A(&edge->mv);                                \

            if (mv) {                                                         \

                if (cur_sign_bias != sign_bias[edge_ref]) {                   \

                    /* SWAR negate of the values in mv. */                    \

                    mv = ~mv;                                                 \

                    mv = ((mv & 0x7fff7fff) +                                 \

                          0x00010001) ^ (mv & 0x80008000);                    \

                }                                                             \

                if (!n || mv != AV_RN32A(&near_mv[idx]))                      \

                    AV_WN32A(&near_mv[++idx], mv);                            \

                cnt[idx] += 1 + (n != 2);                                     \

            } else                                                            \

                cnt[CNT_ZERO] += 1 + (n != 2);                                \

        }                                                                     \

    }



    MV_EDGE_CHECK(0)

    MV_EDGE_CHECK(1)

    MV_EDGE_CHECK(2)



    mb->partitioning = VP8_SPLITMVMODE_NONE;

    if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_ZERO]][0])) {

        mb->mode = VP8_MVMODE_MV;



        /* If we have three distinct MVs, merge first and last if they're the same */

        if (cnt[CNT_SPLITMV] &&

            AV_RN32A(&near_mv[1 + VP8_EDGE_TOP]) == AV_RN32A(&near_mv[1 + VP8_EDGE_TOPLEFT]))

            cnt[CNT_NEAREST] += 1;



        /* Swap near and nearest if necessary */

        if (cnt[CNT_NEAR] > cnt[CNT_NEAREST]) {

            FFSWAP(uint8_t,     cnt[CNT_NEAREST],     cnt[CNT_NEAR]);

            FFSWAP( VP56mv, near_mv[CNT_NEAREST], near_mv[CNT_NEAR]);

        }



        if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAREST]][1])) {

            if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAR]][2])) {

                /* Choose the best mv out of 0,0 and the nearest mv */

                clamp_mv(s, &mb->mv, &near_mv[CNT_ZERO + (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])]);

                cnt[CNT_SPLITMV] = ((mb_edge[VP8_EDGE_LEFT]->mode    == VP8_MVMODE_SPLIT) +

                                    (mb_edge[VP8_EDGE_TOP]->mode     == VP8_MVMODE_SPLIT)) * 2 +

                                    (mb_edge[VP8_EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT);



                if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_SPLITMV]][3])) {

                    mb->mode = VP8_MVMODE_SPLIT;

                    mb->mv = mb->bmv[decode_splitmvs(s, c, mb, layout, IS_VP8) - 1];

                } else {

                    mb->mv.y  += vp8_read_mv_component(c, s->prob->mvc[0]);

                    mb->mv.x  += vp8_read_mv_component(c, s->prob->mvc[1]);

                    mb->bmv[0] = mb->mv;

                }

            } else {

                clamp_mv(s, &mb->mv, &near_mv[CNT_NEAR]);

                mb->bmv[0] = mb->mv;

            }

        } else {

            clamp_mv(s, &mb->mv, &near_mv[CNT_NEAREST]);

            mb->bmv[0] = mb->mv;

        }

    } else {

        mb->mode = VP8_MVMODE_ZERO;

        AV_ZERO32(&mb->mv);

        mb->bmv[0] = mb->mv;

    }

}
",625,"void vp8_decode_mvs(VP8Context *s, VP8Macroblock *url,

                    int mb_x, int mb_y, int layout)

{

    VP8Macroblock *mb_edge[3] = { 0      /* top */,

                                  url - 1 /* left */,

                                  0      /* top-left */ };

    enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV };

    enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT };

    int idx = CNT_ZERO;

    int cur_sign_bias = s->sign_bias[url->ref_frame];

    int8_t *sign_bias = s->sign_bias;

    VP56mv near_vmvg[4];

    uint8_t cnt[4] = { 0 };

    VP56RangeCoder *c = &s->c;



    if (!layout) { // layout is inlined (s->mb_layout is not)

        mb_edge[0] = url + 2;

        mb_edge[2] = url + 1;

    } else {

        mb_edge[0] = url - s->mb_width - 1;

        mb_edge[2] = url - s->mb_width - 2;

    }



    AV_ZERO32(&near_vmvg[0]);

    AV_ZERO32(&near_vmvg[1]);

    AV_ZERO32(&near_vmvg[2]);



    /* Process MB on top, left and top-left */

#define MV_EDGE_CHECK(n)                                                      \

    {                                                                         \

        VP8Macroblock *edge = mb_edge[n];                                     \

        int edge_ref = edge->ref_frame;                                       \

        if (edge_ref != VP56_FRAME_CURRENT) {                                 \

            uint32_t mv = AV_RN32A(&edge->mv);                                \

            if (mv) {                                                         \

                if (cur_sign_bias != sign_bias[edge_ref]) {                   \

                    /* SWAR negate of the values in mv. */                    \

                    mv = ~mv;                                                 \

                    mv = ((mv & 0x7fff7fff) +                                 \

                          0x00010001) ^ (mv & 0x80008000);                    \

                }                                                             \

                if (!n || mv != AV_RN32A(&near_vmvg[idx]))                      \

                    AV_WN32A(&near_vmvg[++idx], mv);                            \

                cnt[idx] += 1 + (n != 2);                                     \

            } else                                                            \

                cnt[CNT_ZERO] += 1 + (n != 2);                                \

        }                                                                     \

    }



    MV_EDGE_CHECK(0)

    MV_EDGE_CHECK(1)

    MV_EDGE_CHECK(2)



    url->partitioning = VP8_SPLITMVMODE_NONE;

    if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_ZERO]][0])) {

        url->mode = VP8_MVMODE_MV;



        /* If we have three distinct MVs, merge first and last if they're the same */

        if (cnt[CNT_SPLITMV] &&

            AV_RN32A(&near_vmvg[1 + VP8_EDGE_TOP]) == AV_RN32A(&near_vmvg[1 + VP8_EDGE_TOPLEFT]))

            cnt[CNT_NEAREST] += 1;



        /* Swap near and nearest if necessary */

        if (cnt[CNT_NEAR] > cnt[CNT_NEAREST]) {

            FFSWAP(uint8_t,     cnt[CNT_NEAREST],     cnt[CNT_NEAR]);

            FFSWAP( VP56mv, near_vmvg[CNT_NEAREST], near_vmvg[CNT_NEAR]);

        }



        if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAREST]][1])) {

            if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAR]][2])) {

                /* Choose the best mv out of 0,0 and the nearest mv */

                clamp_mv(s, &url->mv, &near_vmvg[CNT_ZERO + (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])]);

                cnt[CNT_SPLITMV] = ((mb_edge[VP8_EDGE_LEFT]->mode    == VP8_MVMODE_SPLIT) +

                                    (mb_edge[VP8_EDGE_TOP]->mode     == VP8_MVMODE_SPLIT)) * 2 +

                                    (mb_edge[VP8_EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT);



                if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_SPLITMV]][3])) {

                    url->mode = VP8_MVMODE_SPLIT;

                    url->mv = url->bmv[decode_splitmvs(s, c, url, layout, IS_VP8) - 1];

                } else {

                    url->mv.y  += vp8_read_mv_component(c, s->prob->mvc[0]);

                    url->mv.x  += vp8_read_mv_component(c, s->prob->mvc[1]);

                    url->bmv[0] = url->mv;

                }

            } else {

                clamp_mv(s, &url->mv, &near_vmvg[CNT_NEAR]);

                url->bmv[0] = url->mv;

            }

        } else {

            clamp_mv(s, &url->mv, &near_vmvg[CNT_NEAREST]);

            url->bmv[0] = url->mv;

        }

    } else {

        url->mode = VP8_MVMODE_ZERO;

        AV_ZERO32(&url->mv);

        url->bmv[0] = url->mv;

    }

}
",1,1,0.0,1,"s,mb,mb_x,mb_y,layout,mb_edge,sign_bias,near_mv,cnt,c","s:-0.008607923984527588,mb:0.06107664108276367,mb_x:0.0007769465446472168,mb_y:-0.018323302268981934,layout:-0.0018195509910583496,mb_edge:0.04731571674346924,sign_bias:0.01599109172821045,near_mv:0.048162102699279785,cnt:0.00554347038269043,c:0.005018472671508789,",2.0,39.0,"mb:url,near_mv:near_vmvg,",Greedy,206,0.1568029483159383
38,"static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)

{

    uint64_t start = MAX(r1.start, r2.start);

    /* off-by-one arithmetic to prevent overflow */

    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);

    return addrrange_make(start, end - start + 1);

}
",58,"static AddrRange addrrange_intersection(AddrRange e01, AddrRange r2)

{

    uint64_t start = MAX(e01.start, r2.start);

    /* off-by-one arithmetic to prevent overflow */

    uint64_t end = MIN(addrrange_end(e01) - 1, addrrange_end(r2) - 1);

    return addrrange_make(start, end - start + 1);

}
",1,1,0.0,1,"r1,r2","r1:-0.11735540628433228,r2:-0.15672504901885986,",1.0,3.0,"r1:e01,",Greedy,38,0.0341271082560221
42,"static uint32_t dcr_read_pob (void *opaque, int dcrn)

{

    ppc4xx_pob_t *pob;

    uint32_t ret;



    pob = opaque;

    switch (dcrn) {

    case POB0_BEAR:

        ret = pob->bear;

        break;

    case POB0_BESR0:

    case POB0_BESR1:

        ret = pob->besr[dcrn - POB0_BESR0];

        break;

    default:

        /* Avoid gcc warning */

        ret = 0;

        break;

    }



    return ret;

}
",71,"static uint32_t dcr_read_pob (void *opaque, int drcns)

{

    ppc4xx_pob_t *pob;

    uint32_t ret;



    pob = opaque;

    switch (drcns) {

    case POB0_BEAR:

        ret = pob->bear;

        break;

    case POB0_BESR0:

    case POB0_BESR1:

        ret = pob->besr[drcns - POB0_BESR0];

        break;

    default:

        /* Avoid gcc warning */

        ret = 0;

        break;

    }



    return ret;

}
",1,1,0.0,1,"opaque,dcrn,pob,ret","opaque:-0.09274917840957642,dcrn:0.08478140830993652,pob:0.0809066891670227,ret:-0.10784953832626343,",1.0,3.0,"dcrn:drcns,",Greedy,67,0.0539268652598063
45,"static int default_lockmgr_cb(void **arg, enum AVLockOp op)

{

    void * volatile * mutex = arg;

    int err;



    switch (op) {

    case AV_LOCK_CREATE:

        return 0;

    case AV_LOCK_OBTAIN:

        if (!*mutex) {

            pthread_mutex_t *tmp = av_malloc(sizeof(pthread_mutex_t));

            if (!tmp)

                return AVERROR(ENOMEM);

            if ((err = pthread_mutex_init(tmp, NULL))) {

                av_free(tmp);

                return AVERROR(err);

            }

            if (avpriv_atomic_ptr_cas(mutex, NULL, tmp)) {

                pthread_mutex_destroy(tmp);

                av_free(tmp);

            }

        }



        if ((err = pthread_mutex_lock(*mutex)))

            return AVERROR(err);



        return 0;

    case AV_LOCK_RELEASE:

        if ((err = pthread_mutex_unlock(*mutex)))

            return AVERROR(err);



        return 0;

    case AV_LOCK_DESTROY:

        if (*mutex)

            pthread_mutex_destroy(*mutex);

        av_free(*mutex);

        avpriv_atomic_ptr_cas(mutex, *mutex, NULL);

        return 0;

    }

    return 1;

}
",202,"static int default_lockmgr_cb(void **arg, enum AVLockOp node)

{

    void * volatile *  mutix = arg;

    int type;



    switch (node) {

    case AV_LOCK_CREATE:

        return 0;

    case AV_LOCK_OBTAIN:

        if (!* mutix) {

            pthread_mutex_t *tc = av_malloc(sizeof(pthread_mutex_t));

            if (!tc)

                return AVERROR(ENOMEM);

            if ((type = pthread_mutex_init(tc, NULL))) {

                av_free(tc);

                return AVERROR(type);

            }

            if (avpriv_atomic_ptr_cas( mutix, NULL, tc)) {

                pthread_mutex_destroy(tc);

                av_free(tc);

            }

        }



        if ((type = pthread_mutex_lock(* mutix)))

            return AVERROR(type);



        return 0;

    case AV_LOCK_RELEASE:

        if ((type = pthread_mutex_unlock(* mutix)))

            return AVERROR(type);



        return 0;

    case AV_LOCK_DESTROY:

        if (* mutix)

            pthread_mutex_destroy(* mutix);

        av_free(* mutix);

        avpriv_atomic_ptr_cas( mutix, * mutix, NULL);

        return 0;

    }

    return 1;

}
",1,1,0.0,1,"arg,op,mutex,err,tmp","arg:-0.025930404663085938,op:0.029680907726287842,mutex:0.002917051315307617,err:0.008001267910003662,tmp:-0.020016074180603027,",4.0,26.0,"op:node,err:type,mutex: mutix,tmp:tc,",Greedy,297,0.2170685410499572
54,"static int rle_unpack(const unsigned char *src, int src_len, int src_count,

                      unsigned char *dest, int dest_len)

{

    const unsigned char *ps;

    const unsigned char *ps_end;

    unsigned char *pd;

    int i, l;

    unsigned char *dest_end = dest + dest_len;



    ps = src;

    ps_end = src + src_len;

    pd = dest;

    if (src_count & 1) {

        if (ps_end - ps < 1)

            return 0;

        *pd++ = *ps++;

    }



    src_count >>= 1;

    i = 0;

    do {

        if (ps_end - ps < 1)

            break;

        l = *ps++;

        if (l & 0x80) {

            l = (l & 0x7F) * 2;

            if (pd + l > dest_end || ps_end - ps < l)

                return ps - src;

            memcpy(pd, ps, l);

            ps += l;

            pd += l;

        } else {

            if (pd + i > dest_end || ps_end - ps < 2)

                return ps - src;

            for (i = 0; i < l; i++) {

                *pd++ = ps[0];

                *pd++ = ps[1];

            }

            ps += 2;

        }

        i += l;

    } while (i < src_count);



    return ps - src;

}
",254,"static int rle_unpack(const unsigned char *setup, int src_len, int src_count,

                      unsigned char *dest, int dest_len)

{

    const unsigned char *ps;

    const unsigned char *ps_end;

    unsigned char *pd;

    int i, l;

    unsigned char *dest_end = dest + dest_len;



    ps = setup;

    ps_end = setup + src_len;

    pd = dest;

    if (src_count & 1) {

        if (ps_end - ps < 1)

            return 0;

        *pd++ = *ps++;

    }



    src_count >>= 1;

    i = 0;

    do {

        if (ps_end - ps < 1)

            break;

        l = *ps++;

        if (l & 0x80) {

            l = (l & 0x7F) * 2;

            if (pd + l > dest_end || ps_end - ps < l)

                return ps - setup;

            memcpy(pd, ps, l);

            ps += l;

            pd += l;

        } else {

            if (pd + i > dest_end || ps_end - ps < 2)

                return ps - setup;

            for (i = 0; i < l; i++) {

                *pd++ = ps[0];

                *pd++ = ps[1];

            }

            ps += 2;

        }

        i += l;

    } while (i < src_count);



    return ps - setup;

}
",1,1,0.0,1,"src,src_len,src_count,dest,dest_len,ps,ps_end,pd,i,l,dest_end","src:0.08236515522003174,src_len:0.0029592812061309814,src_count:0.009185075759887695,dest:0.054693400859832764,dest_len:0.0013065338134765625,ps:0.0752314031124115,ps_end:-0.05649930238723755,pd:0.08003503084182739,i:0.005843222141265869,l:0.04856759309768677,dest_end:0.008301973342895508,",1.0,6.0,"src:setup,",Greedy,140,0.0973651806513468
56,"static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)

{

    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);

    DeviceState *vdev = DEVICE(&dev->vdev);



    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));

    if (qdev_init(vdev) < 0) {

        return -1;

    }



    object_property_set_link(OBJECT(dev),

                             OBJECT(dev->vdev.conf.default_backend), ""rng"",

                             NULL);



    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));

}
",93,"static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)

{

    VirtIORNGS390 *diff = VIRTIO_RNG_S390(s390_dev);

    DeviceState *vdev = DEVICE(&diff->vdev);



    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));

    if (qdev_init(vdev) < 0) {

        return -1;

    }



    object_property_set_link(OBJECT(diff),

                             OBJECT(diff->vdev.conf.default_backend), ""rng"",

                             NULL);



    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));

}
",1,1,0.0,1,"s390_dev,dev,vdev","s390_dev:-0.19113242626190186,dev:0.005638003349304199,vdev:-0.010813772678375244,",1.0,4.0,"dev:diff,",Greedy,67,0.0495150327682495
75,"static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,

                            const DisasInsn *di)

{

    unsigned r2 = extract32(insn, 21, 5);

    unsigned r1 = extract32(insn, 16, 5);

    unsigned cf = extract32(insn, 12, 4);

    unsigned rt = extract32(insn,  0, 5);

    TCGv tcg_r1, tcg_r2;

    ExitStatus ret;



    if (cf) {

        nullify_over(ctx);

    }

    tcg_r1 = load_gpr(ctx, r1);

    tcg_r2 = load_gpr(ctx, r2);

    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);

    return nullify_end(ctx, ret);

}
",130,"static ExitStatus trans_log(DisasContext *cas, uint32_t linssn,

                            const DisasInsn *di)

{

    unsigned r2 = extract32(linssn, 21, 5);

    unsigned r1 = extract32(linssn, 16, 5);

    unsigned cf = extract32(linssn, 12, 4);

    unsigned rt = extract32(linssn,  0, 5);

    TCGv tcg_r1, tcg_R82;

    ExitStatus lit;



    if (cf) {

        nullify_over(cas);

    }

    tcg_r1 = load_gpr(cas, r1);

    tcg_R82 = load_gpr(cas, r2);

    lit = do_log(cas, rt, tcg_r1, tcg_R82, cf, di->f_ttt);

    return nullify_end(cas, lit);

}
",1,1,0.0,1,"ctx,insn,di,tcg_r1,tcg_r2,ret","ctx:0.0004538893699645996,insn:-0.006567597389221191,di:-0.09997028112411499,tcg_r1:-0.07969826459884644,tcg_r2:-0.07219094038009644,ret:-0.031505703926086426,",4.0,17.0,"ctx:cas,insn:linssn,ret:lit,tcg_r2:tcg_R82,",Greedy,214,0.1475162943204244
88,"int avpriv_dca_convert_bitstream(const uint8_t *src, int src_size, uint8_t *dst,

                             int max_size)

{

    uint32_t mrk;

    int i, tmp;

    const uint16_t *ssrc = (const uint16_t *) src;

    uint16_t *sdst = (uint16_t *) dst;

    PutBitContext pb;



    if ((unsigned) src_size > (unsigned) max_size)

        src_size = max_size;



    mrk = AV_RB32(src);

    switch (mrk) {

    case DCA_SYNCWORD_CORE_BE:

        memcpy(dst, src, src_size);

        return src_size;

    case DCA_SYNCWORD_CORE_LE:

        for (i = 0; i < (src_size + 1) >> 1; i++)

            *sdst++ = av_bswap16(*ssrc++);

        return src_size;

    case DCA_SYNCWORD_CORE_14B_BE:

    case DCA_SYNCWORD_CORE_14B_LE:

        init_put_bits(&pb, dst, max_size);

        for (i = 0; i < (src_size + 1) >> 1; i++, src += 2) {

            tmp = ((mrk == DCA_SYNCWORD_CORE_14B_BE) ? AV_RB16(src) : AV_RL16(src)) & 0x3FFF;

            put_bits(&pb, 14, tmp);

        }

        flush_put_bits(&pb);

        return (put_bits_count(&pb) + 7) >> 3;

    default:

        return AVERROR_INVALIDDATA;

    }

}
",230,"int avpriv_dca_convert_bitstream(const uint8_t *ssl, int rc_address, uint8_t *dst,

                             int  max_name)

{

    uint32_t vrks;

    int type, tmp;

    const uint16_t *ssrc = (const uint16_t *) ssl;

    uint16_t *sdst = (uint16_t *) dst;

    PutBitContext pb;



    if ((unsigned) rc_address > (unsigned)  max_name)

        rc_address =  max_name;



    vrks = AV_RB32(ssl);

    switch (vrks) {

    case DCA_SYNCWORD_CORE_BE:

        memcpy(dst, ssl, rc_address);

        return rc_address;

    case DCA_SYNCWORD_CORE_LE:

        for (type = 0; type < (rc_address + 1) >> 1; type++)

            *sdst++ = av_bswap16(*ssrc++);

        return rc_address;

    case DCA_SYNCWORD_CORE_14B_BE:

    case DCA_SYNCWORD_CORE_14B_LE:

        init_put_bits(&pb, dst,  max_name);

        for (type = 0; type < (rc_address + 1) >> 1; type++, ssl += 2) {

            tmp = ((vrks == DCA_SYNCWORD_CORE_14B_BE) ? AV_RB16(ssl) : AV_RL16(ssl)) & 0x3FFF;

            put_bits(&pb, 14, tmp);

        }

        flush_put_bits(&pb);

        return (put_bits_count(&pb) + 7) >> 3;

    default:

        return AVERROR_INVALIDDATA;

    }

}
",1,1,0.0,1,"src,src_size,dst,max_size,mrk,i,tmp,ssrc,sdst,pb","src:0.01628321409225464,src_size:0.07441067695617676,dst:-0.032308757305145264,max_size:0.050292134284973145,mrk:0.07682585716247559,i:0.015512824058532715,tmp:-0.0346950888633728,ssrc:-0.07551270723342896,sdst:-0.03167968988418579,pb:-0.01913166046142578,",5.0,30.0,"mrk:vrks,src_size:rc_address,max_size: max_name,src:ssl,i:type,",Greedy,303,0.2236150662104288
90,"int pvpanic_init(ISABus *bus)

{

    isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);

    return 0;

}
",19,"int pvpanic_init(ISABus *us)

{

    isa_create_simple(us, TYPE_ISA_PVPANIC_DEVICE);

    return 0;

}
",1,1,0.0,1,bus,"bus:0.004895597696304321,",1.0,2.0,"bus:us,",Greedy,39,0.0269943912823994
94,"void object_property_allow_set_link(Object *obj, const char *name,

                                    Object *val, Error **errp)

{

    /* Allow the link to be set, always */

}
",23,"void object_property_allow_set_link(Object *obj, const char *name,

                                    Object *sel, Error **errp)

{

    /* Allow the link to be set, always */

}
",1,1,0.0,1,"obj,name,val,errp","obj:-0.0020529627799987793,name:0.028959453105926514,val:0.07740992307662964,errp:-0.00760883092880249,",1.0,1.0,"val:sel,",Greedy,32,0.0293591260910034
105,"static void picmemset(PicContext *s, AVFrame *frame, unsigned value, int run,

                      int *x, int *y, int *plane, int bits_per_plane)

{

    uint8_t *d;

    int shift = *plane * bits_per_plane;

    unsigned mask  = ((1 << bits_per_plane) - 1) << shift;

    value   <<= shift;



    while (run > 0) {

        int j;

        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {

            d = frame->data[0] + *y * frame->linesize[0];

            d[*x] |= (value >> j) & mask;

            *x += 1;

            if (*x == s->width) {

                *y -= 1;

                *x = 0;

                if (*y < 0) {

                   *y = s->height - 1;

                   *plane += 1;

                   if (*plane >= s->nb_planes)

                       return;

                   value <<= bits_per_plane;

                   mask  <<= bits_per_plane;

                }

            }

        }

        run--;

    }

}
",199,"static void picmemset(PicContext *vs, AVFrame *frame, unsigned value, int run,

                      int *x, int *y, int *plane, int bits_per_plane)

{

    uint8_t *fd;

    int shift = *plane * bits_per_plane;

    unsigned mask  = ((1 << bits_per_plane) - 1) << shift;

    value   <<= shift;



    while (run > 0) {

        int j;

        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {

            fd = frame->data[0] + *y * frame->linesize[0];

            fd[*x] |= (value >> j) & mask;

            *x += 1;

            if (*x == vs->width) {

                *y -= 1;

                *x = 0;

                if (*y < 0) {

                   *y = vs->height - 1;

                   *plane += 1;

                   if (*plane >= vs->nb_planes)

                       return;

                   value <<= bits_per_plane;

                   mask  <<= bits_per_plane;

                }

            }

        }

        run--;

    }

}
",1,1,0.0,1,"s,frame,value,run,x,y,plane,bits_per_plane,d,j","s:0.030509650707244873,frame:-0.03405827283859253,value:-0.13471704721450806,run:-0.08921557664871216,x:-0.03079378604888916,y:-0.15741604566574097,plane:-0.034027814865112305,bits_per_plane:-0.0447995662689209,d:0.034833431243896484,j:-0.00853651762008667,",2.0,7.0,"d:fd,s:vs,",Greedy,150,0.1158365607261657
106,"mp_image_t* vf_get_image(vf_instance_t* vf, unsigned int outfmt, int mp_imgtype, int mp_imgflag, int w, int h){

    MPContext *m= (MPContext*)(((uint8_t*)vf) - offsetof(MPContext, next_vf));

  mp_image_t* mpi=NULL;

  int w2;

  int number = mp_imgtype >> 16;



  av_assert0(vf->next == NULL); // all existing filters call this just on next



  //vf_dint needs these as it calls vf_get_image() before configuring the output

  if(vf->w==0 && w>0) vf->w=w;

  if(vf->h==0 && h>0) vf->h=h;



  av_assert0(w == -1 || w >= vf->w);

  av_assert0(h == -1 || h >= vf->h);

  av_assert0(vf->w > 0);

  av_assert0(vf->h > 0);



  av_log(m->avfctx, AV_LOG_DEBUG, ""get_image: %d:%d, vf: %d:%d\n"", w,h,vf->w,vf->h);



  if (w == -1) w = vf->w;

  if (h == -1) h = vf->h;



  w2=(mp_imgflag&MP_IMGFLAG_ACCEPT_ALIGNED_STRIDE)?((w+15)&(~15)):w;



  // Note: we should call libvo first to check if it supports direct rendering

  // and if not, then fallback to software buffers:

  switch(mp_imgtype & 0xff){

  case MP_IMGTYPE_EXPORT:

    if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=new_mp_image(w2,h);

    mpi=vf->imgctx.export_images[0];

    break;

  case MP_IMGTYPE_STATIC:

    if(!vf->imgctx.static_images[0]) vf->imgctx.static_images[0]=new_mp_image(w2,h);

    mpi=vf->imgctx.static_images[0];

    break;

  case MP_IMGTYPE_TEMP:

    if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,h);

    mpi=vf->imgctx.temp_images[0];

    break;

  case MP_IMGTYPE_IPB:

    if(!(mp_imgflag&MP_IMGFLAG_READABLE)){ // B frame:

      if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,h);

      mpi=vf->imgctx.temp_images[0];

      break;

    }

  case MP_IMGTYPE_IP:

    if(!vf->imgctx.static_images[vf->imgctx.static_idx]) vf->imgctx.static_images[vf->imgctx.static_idx]=new_mp_image(w2,h);

    mpi=vf->imgctx.static_images[vf->imgctx.static_idx];

    vf->imgctx.static_idx^=1;

    break;

  case MP_IMGTYPE_NUMBERED:

    if (number == -1) {

      int i;

      for (i = 0; i < NUM_NUMBERED_MPI; i++)

        if (!vf->imgctx.numbered_images[i] || !vf->imgctx.numbered_images[i]->usage_count)

          break;

      number = i;

    }

    if (number < 0 || number >= NUM_NUMBERED_MPI) return NULL;

    if (!vf->imgctx.numbered_images[number]) vf->imgctx.numbered_images[number] = new_mp_image(w2,h);

    mpi = vf->imgctx.numbered_images[number];

    mpi->number = number;

    break;

  }

  if(mpi){

    mpi->type=mp_imgtype;

    mpi->w=vf->w; mpi->h=vf->h;

    // keep buffer allocation status & color flags only:

//    mpi->flags&=~(MP_IMGFLAG_PRESERVE|MP_IMGFLAG_READABLE|MP_IMGFLAG_DIRECT);

    mpi->flags&=MP_IMGFLAG_ALLOCATED|MP_IMGFLAG_TYPE_DISPLAYED|MP_IMGFLAGMASK_COLORS;

    // accept restrictions, draw_slice and palette flags only:

    mpi->flags|=mp_imgflag&(MP_IMGFLAGMASK_RESTRICTIONS|MP_IMGFLAG_DRAW_CALLBACK|MP_IMGFLAG_RGB_PALETTE);

    if(!vf->draw_slice) mpi->flags&=~MP_IMGFLAG_DRAW_CALLBACK;

    if(mpi->width!=w2 || mpi->height!=h){

//      printf(""vf.c: MPI parameters changed!  %dx%d -> %dx%d   \n"", mpi->width,mpi->height,w2,h);

        if(mpi->flags&MP_IMGFLAG_ALLOCATED){

            if(mpi->width<w2 || mpi->height<h){

                // need to re-allocate buffer memory:

                av_free(mpi->planes[0]);

                mpi->flags&=~MP_IMGFLAG_ALLOCATED;

                mp_msg(MSGT_VFILTER,MSGL_V,""vf.c: have to REALLOCATE buffer memory :(\n"");

            }

//      } else {

        } {

            mpi->width=w2; mpi->chroma_width=(w2 + (1<<mpi->chroma_x_shift) - 1)>>mpi->chroma_x_shift;

            mpi->height=h; mpi->chroma_height=(h + (1<<mpi->chroma_y_shift) - 1)>>mpi->chroma_y_shift;

        }

    }

    if(!mpi->bpp) mp_image_setfmt(mpi,outfmt);

    if(!(mpi->flags&MP_IMGFLAG_ALLOCATED) && mpi->type>MP_IMGTYPE_EXPORT){



        av_assert0(!vf->get_image);

        // check libvo first!

        if(vf->get_image) vf->get_image(vf,mpi);



        if(!(mpi->flags&MP_IMGFLAG_DIRECT)){

          // non-direct and not yet allocated image. allocate it!

          if (!mpi->bpp) { // no way we can allocate this

              mp_msg(MSGT_DECVIDEO, MSGL_FATAL,

                     ""vf_get_image: Tried to allocate a format that can not be allocated!\n"");

              return NULL;

          }



          // check if codec prefer aligned stride:

          if(mp_imgflag&MP_IMGFLAG_PREFER_ALIGNED_STRIDE){

              int align=(mpi->flags&MP_IMGFLAG_PLANAR &&

                         mpi->flags&MP_IMGFLAG_YUV) ?

                         (8<<mpi->chroma_x_shift)-1 : 15; // -- maybe FIXME

              w2=((w+align)&(~align));

              if(mpi->width!=w2){

#if 0

                  // we have to change width... check if we CAN co it:

                  int flags=vf->query_format(vf,outfmt); // should not fail

                  if(!(flags&3)) mp_msg(MSGT_DECVIDEO,MSGL_WARN,""??? vf_get_image{vf->query_format(outfmt)} failed!\n"");

//                printf(""query -> 0x%X    \n"",flags);

                  if(flags&VFCAP_ACCEPT_STRIDE){

#endif

                      mpi->width=w2;

                      mpi->chroma_width=(w2 + (1<<mpi->chroma_x_shift) - 1)>>mpi->chroma_x_shift;

//                  }

              }

          }



          mp_image_alloc_planes(mpi);

//        printf(""clearing img!\n"");

          vf_mpi_clear(mpi,0,0,mpi->width,mpi->height);

        }

    }

    av_assert0(!vf->start_slice);

    if(mpi->flags&MP_IMGFLAG_DRAW_CALLBACK)

        if(vf->start_slice) vf->start_slice(vf,mpi);

    if(!(mpi->flags&MP_IMGFLAG_TYPE_DISPLAYED)){

            mp_msg(MSGT_DECVIDEO,MSGL_V,""*** [%s] %s%s mp_image_t, %dx%dx%dbpp %s %s, %d bytes\n"",

                  ""NULL""/*vf->info->name*/,

                  (mpi->type==MP_IMGTYPE_EXPORT)?""Exporting"":

                  ((mpi->flags&MP_IMGFLAG_DIRECT)?""Direct Rendering"":""Allocating""),

                  (mpi->flags&MP_IMGFLAG_DRAW_CALLBACK)?"" (slices)"":"""",

                  mpi->width,mpi->height,mpi->bpp,

                  (mpi->flags&MP_IMGFLAG_YUV)?""YUV"":((mpi->flags&MP_IMGFLAG_SWAPPED)?""BGR"":""RGB""),

                  (mpi->flags&MP_IMGFLAG_PLANAR)?""planar"":""packed"",

                  mpi->bpp*mpi->width*mpi->height/8);

            mp_msg(MSGT_DECVIDEO,MSGL_DBG2,""(imgfmt: %x, planes: %p,%p,%p strides: %d,%d,%d, chroma: %dx%d, shift: h:%d,v:%d)\n"",

                mpi->imgfmt, mpi->planes[0], mpi->planes[1], mpi->planes[2],

                mpi->stride[0], mpi->stride[1], mpi->stride[2],

                mpi->chroma_width, mpi->chroma_height, mpi->chroma_x_shift, mpi->chroma_y_shift);

            mpi->flags|=MP_IMGFLAG_TYPE_DISPLAYED;

    }



  mpi->qscale = NULL;

  }

  mpi->usage_count++;

//    printf(""\rVF_MPI: %p %p %p %d %d %d    \n"",

//      mpi->planes[0],mpi->planes[1],mpi->planes[2],

//      mpi->stride[0],mpi->stride[1],mpi->stride[2]);

  return mpi;

}
",1299,"mp_image_t* vf_get_image(vf_instance_t* vf, unsigned int outfunmt, int mp_ngType, int mp_imgflag, int w, int v){

    MPContext *mod= (MPContext*)(((uint8_t*)vf) - offsetof(MPContext, next_vf));

  mp_image_t* mpid=NULL;

  int w2;

  int number = mp_ngType >> 16;



  av_assert0(vf->next == NULL); // all existing filters call this just on next



  //vf_dint needs these as it calls vf_get_image() before configuring the output

  if(vf->w==0 && w>0) vf->w=w;

  if(vf->v==0 && v>0) vf->v=v;



  av_assert0(w == -1 || w >= vf->w);

  av_assert0(v == -1 || v >= vf->v);

  av_assert0(vf->w > 0);

  av_assert0(vf->v > 0);



  av_log(mod->avfctx, AV_LOG_DEBUG, ""get_image: %d:%d, vf: %d:%d
"", w,v,vf->w,vf->v);



  if (w == -1) w = vf->w;

  if (v == -1) v = vf->v;



  w2=(mp_imgflag&MP_IMGFLAG_ACCEPT_ALIGNED_STRIDE)?((w+15)&(~15)):w;



  // Note: we should call libvo first to check if it supports direct rendering

  // and if not, then fallback to software buffers:

  switch(mp_ngType & 0xff){

  case MP_IMGTYPE_EXPORT:

    if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=new_mp_image(w2,v);

    mpid=vf->imgctx.export_images[0];

    break;

  case MP_IMGTYPE_STATIC:

    if(!vf->imgctx.static_images[0]) vf->imgctx.static_images[0]=new_mp_image(w2,v);

    mpid=vf->imgctx.static_images[0];

    break;

  case MP_IMGTYPE_TEMP:

    if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,v);

    mpid=vf->imgctx.temp_images[0];

    break;

  case MP_IMGTYPE_IPB:

    if(!(mp_imgflag&MP_IMGFLAG_READABLE)){ // B frame:

      if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,v);

      mpid=vf->imgctx.temp_images[0];

      break;

    }

  case MP_IMGTYPE_IP:

    if(!vf->imgctx.static_images[vf->imgctx.static_idx]) vf->imgctx.static_images[vf->imgctx.static_idx]=new_mp_image(w2,v);

    mpid=vf->imgctx.static_images[vf->imgctx.static_idx];

    vf->imgctx.static_idx^=1;

    break;

  case MP_IMGTYPE_NUMBERED:

    if (number == -1) {

      int i;

      for (i = 0; i < NUM_NUMBERED_MPI; i++)

        if (!vf->imgctx.numbered_images[i] || !vf->imgctx.numbered_images[i]->usage_count)

          break;

      number = i;

    }

    if (number < 0 || number >= NUM_NUMBERED_MPI) return NULL;

    if (!vf->imgctx.numbered_images[number]) vf->imgctx.numbered_images[number] = new_mp_image(w2,v);

    mpid = vf->imgctx.numbered_images[number];

    mpid->number = number;

    break;

  }

  if(mpid){

    mpid->type=mp_ngType;

    mpid->w=vf->w; mpid->v=vf->v;

    // keep buffer allocation status & color flags only:

//    mpi->flags&=~(MP_IMGFLAG_PRESERVE|MP_IMGFLAG_READABLE|MP_IMGFLAG_DIRECT);

    mpid->flags&=MP_IMGFLAG_ALLOCATED|MP_IMGFLAG_TYPE_DISPLAYED|MP_IMGFLAGMASK_COLORS;

    // accept restrictions, draw_slice and palette flags only:

    mpid->flags|=mp_imgflag&(MP_IMGFLAGMASK_RESTRICTIONS|MP_IMGFLAG_DRAW_CALLBACK|MP_IMGFLAG_RGB_PALETTE);

    if(!vf->draw_slice) mpid->flags&=~MP_IMGFLAG_DRAW_CALLBACK;

    if(mpid->width!=w2 || mpid->height!=v){

//      printf(""vf.c: MPI parameters changed!  %dx%d -> %dx%d   
"", mpi->width,mpi->height,w2,h);

        if(mpid->flags&MP_IMGFLAG_ALLOCATED){

            if(mpid->width<w2 || mpid->height<v){

                // need to re-allocate buffer memory:

                av_free(mpid->planes[0]);

                mpid->flags&=~MP_IMGFLAG_ALLOCATED;

                mp_msg(MSGT_VFILTER,MSGL_V,""vf.c: have to REALLOCATE buffer memory :(
"");

            }

//      } else {

        } {

            mpid->width=w2; mpid->chroma_width=(w2 + (1<<mpid->chroma_x_shift) - 1)>>mpid->chroma_x_shift;

            mpid->height=v; mpid->chroma_height=(v + (1<<mpid->chroma_y_shift) - 1)>>mpid->chroma_y_shift;

        }

    }

    if(!mpid->bpp) mp_image_setfmt(mpid,outfunmt);

    if(!(mpid->flags&MP_IMGFLAG_ALLOCATED) && mpid->type>MP_IMGTYPE_EXPORT){



        av_assert0(!vf->get_image);

        // check libvo first!

        if(vf->get_image) vf->get_image(vf,mpid);



        if(!(mpid->flags&MP_IMGFLAG_DIRECT)){

          // non-direct and not yet allocated image. allocate it!

          if (!mpid->bpp) { // no way we can allocate this

              mp_msg(MSGT_DECVIDEO, MSGL_FATAL,

                     ""vf_get_image: Tried to allocate a format that can not be allocated!
"");

              return NULL;

          }



          // check if codec prefer aligned stride:

          if(mp_imgflag&MP_IMGFLAG_PREFER_ALIGNED_STRIDE){

              int align=(mpid->flags&MP_IMGFLAG_PLANAR &&

                         mpid->flags&MP_IMGFLAG_YUV) ?

                         (8<<mpid->chroma_x_shift)-1 : 15; // -- maybe FIXME

              w2=((w+align)&(~align));

              if(mpid->width!=w2){

#if 0

                  // we have to change width... check if we CAN co it:

                  int flags=vf->query_format(vf,outfunmt); // should not fail

                  if(!(flags&3)) mp_msg(MSGT_DECVIDEO,MSGL_WARN,""??? vf_get_image{vf->query_format(outfmt)} failed!
"");

//                printf(""query -> 0x%X    
"",flags);

                  if(flags&VFCAP_ACCEPT_STRIDE){

#endif

                      mpi->width=w2;

                      mpid->chroma_width=(w2 + (1<<mpid->chroma_x_shift) - 1)>>mpid->chroma_x_shift;

//                  }

              }

          }



          mp_image_alloc_planes(mpid);

//        printf(""clearing img!
"");

          vf_mpi_clear(mpid,0,0,mpid->width,mpid->height);

        }

    }

    av_assert0(!vf->start_slice);

    if(mpid->flags&MP_IMGFLAG_DRAW_CALLBACK)

        if(vf->start_slice) vf->start_slice(vf,mpid);

    if(!(mpid->flags&MP_IMGFLAG_TYPE_DISPLAYED)){

            mp_msg(MSGT_DECVIDEO,MSGL_V,""*** [%s] %s%s mp_image_t, %dx%dx%dbpp %s %s, %d bytes
"",

                  ""NULL""/*vf->info->name*/,

                  (mpid->type==MP_IMGTYPE_EXPORT)?""Exporting"":

                  ((mpid->flags&MP_IMGFLAG_DIRECT)?""Direct Rendering"":""Allocating""),

                  (mpid->flags&MP_IMGFLAG_DRAW_CALLBACK)?"" (slices)"":"""",

                  mpid->width,mpid->height,mpid->bpp,

                  (mpid->flags&MP_IMGFLAG_YUV)?""YUV"":((mpid->flags&MP_IMGFLAG_SWAPPED)?""BGR"":""RGB""),

                  (mpid->flags&MP_IMGFLAG_PLANAR)?""planar"":""packed"",

                  mpid->bpp*mpid->width*mpid->height/8);

            mp_msg(MSGT_DECVIDEO,MSGL_DBG2,""(imgfmt: %x, planes: %p,%p,%p strides: %d,%d,%d, chroma: %dx%d, shift: h:%d,v:%d)
"",

                mpid->imgfmt, mpid->planes[0], mpid->planes[1], mpid->planes[2],

                mpid->stride[0], mpid->stride[1], mpid->stride[2],

                mpid->chroma_width, mpid->chroma_height, mpid->chroma_x_shift, mpid->chroma_y_shift);

            mpid->flags|=MP_IMGFLAG_TYPE_DISPLAYED;

    }



  mpid->qscale = NULL;

  }

  mpid->usage_count++;

//    printf(""\rVF_MPI: %p %p %p %d %d %d    
"",

//      mpi->planes[0],mpi->planes[1],mpi->planes[2],

//      mpi->stride[0],mpi->stride[1],mpi->stride[2]);

  return mpid;

}
",1,1,0.0,1,"vf,outfmt,mp_imgtype,mp_imgflag,w,h,m,mpi,w2","vf:-0.0402279794216156,outfmt:-0.01202729344367981,mp_imgtype:0.02849477529525757,mp_imgflag:-0.06028634309768677,w:-0.03654488921165466,h:-0.009527087211608887,m:0.020134180784225464,mpi:0.0400007963180542,w2:-0.014950275421142578,",5.0,113.0,"mpi:mpid,mp_imgtype:mp_ngType,m:mod,h:v,outfmt:outfunmt,",Greedy,401,0.3270870288213094
115,"static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size)

{

    DeviceState *dev;

    SysBusDevice *s;

    RamDevice *d;



    /* allocate RAM */

    dev = qdev_create(NULL, ""memory"");

    s = sysbus_from_qdev(dev);



    d = FROM_SYSBUS(RamDevice, s);

    d->size = RAM_size;

    qdev_init(dev);



    sysbus_mmio_map(s, 0, addr);

}
",70,"static void ram_init(target_phys_addr_t attr, ram_addr_t RAM_bytes)

{

    DeviceState *dev;

    SysBusDevice *sh;

    RamDevice *fd;



    /* allocate RAM */

    dev = qdev_create(NULL, ""memory"");

    sh = sysbus_from_qdev(dev);



    fd = FROM_SYSBUS(RamDevice, sh);

    fd->size = RAM_bytes;

    qdev_init(dev);



    sysbus_mmio_map(sh, 0, attr);

}
",1,1,0.0,1,"addr,RAM_size,dev,s,d","addr:0.0422893762588501,RAM_size:-0.055407434701919556,dev:-0.22125768661499023,s:-0.06120187044143677,d:-0.021940678358078003,",4.0,11.0,"addr:attr,d:fd,RAM_size:RAM_bytes,s:sh,",Greedy,164,0.1051817417144775
119,"static int qemu_rdma_register_and_get_keys(RDMAContext *rdma,

        RDMALocalBlock *block, uintptr_t host_addr,

        uint32_t *lkey, uint32_t *rkey, int chunk,

        uint8_t *chunk_start, uint8_t *chunk_end)

{

    if (block->mr) {

        if (lkey) {

            *lkey = block->mr->lkey;

        }

        if (rkey) {

            *rkey = block->mr->rkey;

        }

        return 0;

    }



    /* allocate memory to store chunk MRs */

    if (!block->pmr) {

        block->pmr = g_malloc0(block->nb_chunks * sizeof(struct ibv_mr *));

    }



    /*

     * If 'rkey', then we're the destination, so grant access to the source.

     *

     * If 'lkey', then we're the source VM, so grant access only to ourselves.

     */

    if (!block->pmr[chunk]) {

        uint64_t len = chunk_end - chunk_start;



        trace_qemu_rdma_register_and_get_keys(len, chunk_start);



        block->pmr[chunk] = ibv_reg_mr(rdma->pd,

                chunk_start, len,

                (rkey ? (IBV_ACCESS_LOCAL_WRITE |

                        IBV_ACCESS_REMOTE_WRITE) : 0));



        if (!block->pmr[chunk]) {

            perror(""Failed to register chunk!"");

            fprintf(stderr, ""Chunk details: block: %d chunk index %d""

                            "" start %"" PRIuPTR "" end %"" PRIuPTR

                            "" host %"" PRIuPTR

                            "" local %"" PRIuPTR "" registrations: %d\n"",

                            block->index, chunk, (uintptr_t)chunk_start,

                            (uintptr_t)chunk_end, host_addr,

                            (uintptr_t)block->local_host_addr,

                            rdma->total_registrations);

            return -1;

        }

        rdma->total_registrations++;

    }



    if (lkey) {

        *lkey = block->pmr[chunk]->lkey;

    }

    if (rkey) {

        *rkey = block->pmr[chunk]->rkey;

    }

    return 0;

}
",276,"static int qemu_rdma_register_and_get_keys(RDMAContext *rdma,

        RDMALocalBlock *ack, uintptr_t server_name,

        uint32_t *lkey, uint32_t *rkey, int chunk,

        uint8_t *chunk_start, uint8_t *chunk_end)

{

    if (ack->mr) {

        if (lkey) {

            *lkey = ack->mr->lkey;

        }

        if (rkey) {

            *rkey = ack->mr->rkey;

        }

        return 0;

    }



    /* allocate memory to store chunk MRs */

    if (!ack->pmr) {

        ack->pmr = g_malloc0(ack->nb_chunks * sizeof(struct ibv_mr *));

    }



    /*

     * If 'rkey', then we're the destination, so grant access to the source.

     *

     * If 'lkey', then we're the source VM, so grant access only to ourselves.

     */

    if (!ack->pmr[chunk]) {

        uint64_t len = chunk_end - chunk_start;



        trace_qemu_rdma_register_and_get_keys(len, chunk_start);



        ack->pmr[chunk] = ibv_reg_mr(rdma->pd,

                chunk_start, len,

                (rkey ? (IBV_ACCESS_LOCAL_WRITE |

                        IBV_ACCESS_REMOTE_WRITE) : 0));



        if (!ack->pmr[chunk]) {

            perror(""Failed to register chunk!"");

            fprintf(stderr, ""Chunk details: block: %d chunk index %d""

                            "" start %"" PRIuPTR "" end %"" PRIuPTR

                            "" host %"" PRIuPTR

                            "" local %"" PRIuPTR "" registrations: %d
"",

                            ack->index, chunk, (uintptr_t)chunk_start,

                            (uintptr_t)chunk_end, server_name,

                            (uintptr_t)ack->local_host_addr,

                            rdma->total_regustrations);

            return -1;

        }

        rdma->total_regustrations++;

    }



    if (lkey) {

        *lkey = ack->pmr[chunk]->lkey;

    }

    if (rkey) {

        *rkey = ack->pmr[chunk]->rkey;

    }

    return 0;

}
",1,1,0.0,1,"rdma,block,host_addr,lkey,rkey,chunk,chunk_start,chunk_end,total_registrations","rdma:-0.0710563063621521,block:-0.005637824535369873,host_addr:0.0006403326988220215,lkey:-0.014482855796813965,rkey:-0.008879601955413818,chunk:-0.01380985975265503,chunk_start:-0.02803260087966919,chunk_end:-0.02328699827194214,total_registrations:0.008019030094146729,",3.0,18.0,"total_registrations:total_regustrations,host_addr:server_name,block:ack,",Greedy,179,0.1277240832646687
123,"static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw,

                                  cavs_vector *col_mv)

{

    cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS;

    int den = h->direct_den[col_mv->ref];

    int m = FF_SIGNBIT(col_mv->x);



    pmv_fw->dist = h->dist[1];

    pmv_bw->dist = h->dist[0];

    pmv_fw->ref = 1;

    pmv_bw->ref = 0;

    /* scale the co-located motion vector according to its temporal span */

    pmv_fw->x =     (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;

    pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);

    m = FF_SIGNBIT(col_mv->y);

    pmv_fw->y =     (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;

    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);

}
",236,"static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_feat,

                                  cavs_vector *col_mv)

{

    cavs_vector *pmv_bw = pmv_feat + MV_BWD_OFFS;

    int den = h->direct_den[col_mv->ref];

    int m = FF_SIGNBIT(col_mv->x);



    pmv_feat->dist = h->dist[1];

    pmv_bw->dist = h->dist[0];

    pmv_feat->ref = 1;

    pmv_bw->ref = 0;

    /* scale the co-located motion vector according to its temporal span */

    pmv_feat->x =     (((den + (den * col_mv->x * pmv_feat->dist ^ m) - m - 1) >> 14) ^ m) - m;

    pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);

    m = FF_SIGNBIT(col_mv->y);

    pmv_feat->y =     (((den + (den * col_mv->y * pmv_feat->dist ^ m) - m - 1) >> 14) ^ m) - m;

    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);

}
",1,1,0.0,1,"h,pmv_fw,col_mv,pmv_bw","h:0.11537885665893555,pmv_fw:0.4740975499153137,col_mv:0.2887013256549835,pmv_bw:0.23208552598953247,",1.0,8.0,"pmv_fw:pmv_feat,",Greedy,77,0.0473732630411783
130,"static void free_geotags(TiffContext *const s)

{

    int i;

    for (i = 0; i < s->geotag_count; i++) {

        if (s->geotags[i].val)

            av_freep(&s->geotags[i].val);

    }

    av_freep(&s->geotags);


}",63,"static void free_geotags(TiffContext *const s)

{

    int di;

    for (di = 0; di < s->geotag_count; di++) {

        if (s->geotags[di].val)

            av_freep(&s->geotags[di].val);

    }

    av_freep(&s->geotags);


}",1,1,0.0,1,"s,i","s:-0.0247809961438179,i:0.019653618335723877,",1.0,6.0,"i:di,",Greedy,74,0.0540783445040384
131,"void ff_bink_idct_c(DCTELEM *block)

{

    int i;

    DCTELEM temp[64];



    for (i = 0; i < 8; i++)

        bink_idct_col(&temp[i], &block[i]);

    for (i = 0; i < 8; i++) {

        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );

    }

}
",84,"void ff_bink_idct_c(DCTELEM *element)

{

    int ui;

    DCTELEM temp[64];



    for (ui = 0; ui < 8; ui++)

        bink_idct_col(&temp[ui], &element[ui]);

    for (ui = 0; ui < 8; ui++) {

        IDCT_ROW( (&element[8*ui]), (&temp[8*ui]) );

    }

}
",1,1,0.0,1,"block,i,temp","block:-0.0988004207611084,i:-0.09093612432479858,temp:-0.13719993829727173,",2.0,14.0,"i:ui,block:element,",Greedy,129,0.0978897968928019
147,"static void usbredir_interrupt_packet(void *priv, uint32_t id,

    struct usb_redir_interrupt_packet_header *interrupt_packet,

    uint8_t *data, int data_len)

{

    USBRedirDevice *dev = priv;

    uint8_t ep = interrupt_packet->endpoint;



    DPRINTF(""interrupt-in status %d ep %02X len %d id %u\n"",

            interrupt_packet->status, ep, data_len, id);



    if (dev->endpoint[EP2I(ep)].type != USB_ENDPOINT_XFER_INT) {

        ERROR(""received int packet for non interrupt endpoint %02X\n"", ep);

        free(data);

        return;

    }



    if (ep & USB_DIR_IN) {

        if (dev->endpoint[EP2I(ep)].interrupt_started == 0) {

            DPRINTF(""received int packet while not started ep %02X\n"", ep);

            free(data);

            return;

        }



        /* bufp_alloc also adds the packet to the ep queue */

        bufp_alloc(dev, data, data_len, interrupt_packet->status, ep);

    } else {

        int len = interrupt_packet->length;



        AsyncURB *aurb = async_find(dev, id);

        if (!aurb) {

            return;

        }



        if (aurb->interrupt_packet.endpoint != interrupt_packet->endpoint) {

            ERROR(""return int packet mismatch, please report this!\n"");

            len = USB_RET_NAK;

        }



        if (aurb->packet) {

            aurb->packet->len = usbredir_handle_status(dev,

                                               interrupt_packet->status, len);

            usb_packet_complete(&dev->dev, aurb->packet);

        }

        async_free(dev, aurb);

    }

}
",241,"static void usbredir_interrupt_packet(void *tty, uint32_t id,

    struct usb_redir_interrupt_packet_header *interrupt_packet,

    uint8_t *data, int data_len)

{

    USBRedirDevice *dev = tty;

    uint8_t ep = interrupt_packet->endpoint;



    DPRINTF(""interrupt-in status %d ep %02X len %d id %u
"",

            interrupt_packet->status, ep, data_len, id);



    if (dev->endpoint[EP2I(ep)].type != USB_ENDPOINT_XFER_INT) {

        ERROR(""received int packet for non interrupt endpoint %02X
"", ep);

        free(data);

        return;

    }



    if (ep & USB_DIR_IN) {

        if (dev->endpoint[EP2I(ep)].interrupt_started == 0) {

            DPRINTF(""received int packet while not started ep %02X
"", ep);

            free(data);

            return;

        }



        /* bufp_alloc also adds the packet to the ep queue */

        bufp_alloc(dev, data, data_len, interrupt_packet->status, ep);

    } else {

        int len = interrupt_packet->length;



        AsyncURB *aurb = async_find(dev, id);

        if (!aurb) {

            return;

        }



        if (aurb->interrupt_packet.endpoint != interrupt_packet->endpoint) {

            ERROR(""return int packet mismatch, please report this!
"");

            len = USB_RET_NAK;

        }



        if (aurb->packet) {

            aurb->packet->len = usbredir_handle_status(dev,

                                               interrupt_packet->status, len);

            usb_packet_complete(&dev->dev, aurb->packet);

        }

        async_free(dev, aurb);

    }

}
",1,1,0.0,1,"priv,id,interrupt_packet,data,data_len,dev,aurb","priv:0.04886326193809509,id:0.01860836148262024,interrupt_packet:-0.11998116970062256,data:0.028828740119934082,data_len:0.007004410028457642,dev:0.023615092039108276,aurb:0.008215844631195068,",1.0,2.0,"priv:tty,",Greedy,73,0.0605996251106262
151,"static inline void RENAME(rgb24tobgr24)(const uint8_t *src, uint8_t *dst, long src_size)

{

	unsigned i;

#ifdef HAVE_MMX

	long mmx_size= 23 - src_size;

	asm volatile (

		""test %%""REG_a"", %%""REG_a""	\n\t""

		""jns 2f				\n\t""

		""movq ""MANGLE(mask24r)"", %%mm5	\n\t""

		""movq ""MANGLE(mask24g)"", %%mm6	\n\t""

		""movq ""MANGLE(mask24b)"", %%mm7	\n\t""

		ASMALIGN(4)

		""1:				\n\t""

		PREFETCH"" 32(%1, %%""REG_a"")	\n\t""

		""movq   (%1, %%""REG_a""), %%mm0	\n\t"" // BGR BGR BG

		""movq   (%1, %%""REG_a""), %%mm1	\n\t"" // BGR BGR BG

		""movq  2(%1, %%""REG_a""), %%mm2	\n\t"" // R BGR BGR B

		""psllq $16, %%mm0		\n\t"" // 00 BGR BGR

		""pand %%mm5, %%mm0		\n\t""

		""pand %%mm6, %%mm1		\n\t""

		""pand %%mm7, %%mm2		\n\t""

		""por %%mm0, %%mm1		\n\t""

		""por %%mm2, %%mm1		\n\t""

		""movq  6(%1, %%""REG_a""), %%mm0	\n\t"" // BGR BGR BG

		MOVNTQ"" %%mm1,   (%2, %%""REG_a"")\n\t"" // RGB RGB RG

		""movq  8(%1, %%""REG_a""), %%mm1	\n\t"" // R BGR BGR B

		""movq 10(%1, %%""REG_a""), %%mm2	\n\t"" // GR BGR BGR

		""pand %%mm7, %%mm0		\n\t""

		""pand %%mm5, %%mm1		\n\t""

		""pand %%mm6, %%mm2		\n\t""

		""por %%mm0, %%mm1		\n\t""

		""por %%mm2, %%mm1		\n\t""

		""movq 14(%1, %%""REG_a""), %%mm0	\n\t"" // R BGR BGR B

		MOVNTQ"" %%mm1,  8(%2, %%""REG_a"")\n\t"" // B RGB RGB R

		""movq 16(%1, %%""REG_a""), %%mm1	\n\t"" // GR BGR BGR

		""movq 18(%1, %%""REG_a""), %%mm2	\n\t"" // BGR BGR BG

		""pand %%mm6, %%mm0		\n\t""

		""pand %%mm7, %%mm1		\n\t""

		""pand %%mm5, %%mm2		\n\t""

		""por %%mm0, %%mm1		\n\t""

		""por %%mm2, %%mm1		\n\t""

		MOVNTQ"" %%mm1, 16(%2, %%""REG_a"")\n\t""

		""add $24, %%""REG_a""		\n\t""

		"" js 1b				\n\t""

		""2:				\n\t""

		: ""+a"" (mmx_size)

		: ""r"" (src-mmx_size), ""r""(dst-mmx_size)

	);



	__asm __volatile(SFENCE:::""memory"");

	__asm __volatile(EMMS:::""memory"");



	if(mmx_size==23) return; //finihsed, was multiple of 8



	src+= src_size;

	dst+= src_size;

	src_size= 23-mmx_size;

	src-= src_size;

	dst-= src_size;

#endif

	for(i=0; i<src_size; i+=3)

	{

		register uint8_t x;

		x          = src[i + 2];

		dst[i + 1] = src[i + 1];

		dst[i + 2] = src[i + 0];

		dst[i + 0] = x;

	}

}
",368,"static inline void RENAME(rgb24tobgr24)(const uint8_t *support, uint8_t *dst, long src_speed)

{

	unsigned uri;

#ifdef HAVE_MMX

	long mmx_size= 23 - src_speed;

	asm volatile (

		""test %%""REG_a"", %%""REG_a""	
\t""

		""jns 2f				
\t""

		""movq ""MANGLE(mask24r)"", %%mm5	
\t""

		""movq ""MANGLE(mask24g)"", %%mm6	
\t""

		""movq ""MANGLE(mask24b)"", %%mm7	
\t""

		ASMALIGN(4)

		""1:				
\t""

		PREFETCH"" 32(%1, %%""REG_a"")	
\t""

		""movq   (%1, %%""REG_a""), %%mm0	
\t"" // BGR BGR BG

		""movq   (%1, %%""REG_a""), %%mm1	
\t"" // BGR BGR BG

		""movq  2(%1, %%""REG_a""), %%mm2	
\t"" // R BGR BGR B

		""psllq $16, %%mm0		
\t"" // 00 BGR BGR

		""pand %%mm5, %%mm0		
\t""

		""pand %%mm6, %%mm1		
\t""

		""pand %%mm7, %%mm2		
\t""

		""por %%mm0, %%mm1		
\t""

		""por %%mm2, %%mm1		
\t""

		""movq  6(%1, %%""REG_a""), %%mm0	
\t"" // BGR BGR BG

		MOVNTQ"" %%mm1,   (%2, %%""REG_a"")
\t"" // RGB RGB RG

		""movq  8(%1, %%""REG_a""), %%mm1	
\t"" // R BGR BGR B

		""movq 10(%1, %%""REG_a""), %%mm2	
\t"" // GR BGR BGR

		""pand %%mm7, %%mm0		
\t""

		""pand %%mm5, %%mm1		
\t""

		""pand %%mm6, %%mm2		
\t""

		""por %%mm0, %%mm1		
\t""

		""por %%mm2, %%mm1		
\t""

		""movq 14(%1, %%""REG_a""), %%mm0	
\t"" // R BGR BGR B

		MOVNTQ"" %%mm1,  8(%2, %%""REG_a"")
\t"" // B RGB RGB R

		""movq 16(%1, %%""REG_a""), %%mm1	
\t"" // GR BGR BGR

		""movq 18(%1, %%""REG_a""), %%mm2	
\t"" // BGR BGR BG

		""pand %%mm6, %%mm0		
\t""

		""pand %%mm7, %%mm1		
\t""

		""pand %%mm5, %%mm2		
\t""

		""por %%mm0, %%mm1		
\t""

		""por %%mm2, %%mm1		
\t""

		MOVNTQ"" %%mm1, 16(%2, %%""REG_a"")
\t""

		""add $24, %%""REG_a""		
\t""

		"" js 1b				
\t""

		""2:				
\t""

		: ""+a"" (mmx_size)

		: ""r"" (src-mmx_size), ""r""(dst-mmx_size)

	);



	__asm __volatile(SFENCE:::""mac"");

	__asm __volatile(EMMS:::""mac"");



	if(mmx_size==23) return; //finihsed, was multiple of 8



	support+= src_speed;

	dst+= src_speed;

	src_speed= 23-mmx_size;

	support-= src_speed;

	dst-= src_speed;

#endif

	for(uri=0; uri<src_speed; uri+=3)

	{

		register uint8_t x;

		x          = support[uri + 2];

		dst[uri + 1] = support[uri + 1];

		dst[uri + 2] = support[uri + 0];

		dst[uri + 0] = x;

	}

}
",1,1,0.0,1,"src,dst,src_size,i,memory,x","src:-0.05904090404510498,dst:-0.06776559352874756,src_size:0.4632088541984558,i:-0.03140139579772949,memory:0.020718753337860107,x:-0.09086281061172485,",4.0,26.0,"src_size:src_speed,memory:mac,i:uri,src:support,",Greedy,243,0.1692519148190816
153,"static int decode_frame(AVCodecContext *avctx, void *data,

                        int *got_frame, AVPacket *avpkt)

{

    const uint8_t *buf = avpkt->data;

    int buf_size       = avpkt->size;

    H264Context *h     = avctx->priv_data;

    AVFrame *pict      = data;

    int buf_index      = 0;

    Picture *out;

    int i, out_idx;

    int ret;



    h->flags  = avctx->flags;



    /* end of stream, output what is still in the buffers */

    if (buf_size == 0) {

 out:



        h->cur_pic_ptr = NULL;

        h->first_field = 0;



        // FIXME factorize this with the output code below

        out     = h->delayed_pic[0];

        out_idx = 0;

        for (i = 1;

             h->delayed_pic[i] &&

             !h->delayed_pic[i]->f.key_frame &&

             !h->delayed_pic[i]->mmco_reset;

             i++)

            if (h->delayed_pic[i]->poc < out->poc) {

                out     = h->delayed_pic[i];

                out_idx = i;

            }



        for (i = out_idx; h->delayed_pic[i]; i++)

            h->delayed_pic[i] = h->delayed_pic[i + 1];



        if (out) {

            out->reference &= ~DELAYED_PIC_REF;

            ret = output_frame(h, pict, &out->f);

            if (ret < 0)

                return ret;

            *got_frame = 1;

        }



        return buf_index;

    }

    if(h->is_avc && buf_size >= 9 && buf[0]==1 && buf[2]==0 && (buf[4]&0xFC)==0xFC && (buf[5]&0x1F) && buf[8]==0x67){

        int cnt= buf[5]&0x1f;

        const uint8_t *p= buf+6;

        while(cnt--){

            int nalsize= AV_RB16(p) + 2;

            if(nalsize > buf_size - (p-buf) || p[2]!=0x67)

                goto not_extra;

            p += nalsize;

        }

        cnt = *(p++);

        if(!cnt)

            goto not_extra;

        while(cnt--){

            int nalsize= AV_RB16(p) + 2;

            if(nalsize > buf_size - (p-buf) || p[2]!=0x68)

                goto not_extra;

            p += nalsize;

        }



        return ff_h264_decode_extradata(h, buf, buf_size);

    }

not_extra:



    buf_index = decode_nal_units(h, buf, buf_size, 0);

    if (buf_index < 0)

        return -1;



    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {

        av_assert0(buf_index <= buf_size);

        goto out;

    }



    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {

        if (avctx->skip_frame >= AVDISCARD_NONREF ||

            buf_size >= 4 && !memcmp(""Q264"", buf, 4))

            return buf_size;

        av_log(avctx, AV_LOG_ERROR, ""no frame!\n"");

        return -1;

    }



    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) ||

        (h->mb_y >= h->mb_height && h->mb_height)) {

        if (avctx->flags2 & CODEC_FLAG2_CHUNKS)

            decode_postinit(h, 1);



        field_end(h, 0);



        /* Wait for second field. */

        *got_frame = 0;

        if (h->next_output_pic && (h->next_output_pic->sync || h->sync>1)) {

            ret = output_frame(h, pict, &h->next_output_pic->f);

            if (ret < 0)

                return ret;

            *got_frame = 1;

            if (CONFIG_MPEGVIDEO) {

                ff_print_debug_info2(h->avctx, h->next_output_pic, pict, h->er.mbskip_table,

                                    &h->low_delay,

                                    h->mb_width, h->mb_height, h->mb_stride, 1);

            }

        }

    }



    assert(pict->data[0] || !*got_frame);



    return get_consumed_bytes(buf_index, buf_size);

}
",718,"static int decode_frame(AVCodecContext *avctx, void *data,

                        int *gotallline, AVPacket *avpkt)

{

    const uint8_t *img = avpkt->data;

    int buf_size       = avpkt->size;

    H264Context *h     = avctx->priv_data;

    AVFrame *pict      = data;

    int buf_index      = 0;

    Picture *out;

    int i, out_idx;

    int ret;



    h->flags  = avctx->flags;



    /* end of stream, output what is still in the buffers */

    if (buf_size == 0) {

 out:



        h->cur_pic_ptr = NULL;

        h->first_field = 0;



        // FIXME factorize this with the output code below

        out     = h->delayed_pic[0];

        out_idx = 0;

        for (i = 1;

             h->delayed_pic[i] &&

             !h->delayed_pic[i]->f.key_frame &&

             !h->delayed_pic[i]->mmco_reset;

             i++)

            if (h->delayed_pic[i]->poc < out->poc) {

                out     = h->delayed_pic[i];

                out_idx = i;

            }



        for (i = out_idx; h->delayed_pic[i]; i++)

            h->delayed_pic[i] = h->delayed_pic[i + 1];



        if (out) {

            out->reference &= ~DELAYED_PIC_REF;

            ret = output_frame(h, pict, &out->f);

            if (ret < 0)

                return ret;

            *gotallline = 1;

        }



        return buf_index;

    }

    if(h->is_avc && buf_size >= 9 && img[0]==1 && img[2]==0 && (img[4]&0xFC)==0xFC && (img[5]&0x1F) && img[8]==0x67){

        int cnt= img[5]&0x1f;

        const uint8_t *fp= img+6;

        while(cnt--){

            int nalsize= AV_RB16(fp) + 2;

            if(nalsize > buf_size - (fp-img) || fp[2]!=0x67)

                goto not_extra;

            fp += nalsize;

        }

        cnt = *(fp++);

        if(!cnt)

            goto not_extra;

        while(cnt--){

            int nalsize= AV_RB16(fp) + 2;

            if(nalsize > buf_size - (fp-img) || fp[2]!=0x68)

                goto not_extra;

            fp += nalsize;

        }



        return ff_h264_decode_extradata(h, img, buf_size);

    }

not_extra:



    buf_index = decode_nal_units(h, img, buf_size, 0);

    if (buf_index < 0)

        return -1;



    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {

        av_assert0(buf_index <= buf_size);

        goto out;

    }



    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {

        if (avctx->skip_frame >= AVDISCARD_NONREF ||

            buf_size >= 4 && !memcmp(""Q264"", img, 4))

            return buf_size;

        av_log(avctx, AV_LOG_ERROR, ""no frame!
"");

        return -1;

    }



    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) ||

        (h->mb_y >= h->mb_height && h->mb_height)) {

        if (avctx->flags2 & CODEC_FLAG2_CHUNKS)

            decode_postinit(h, 1);



        field_end(h, 0);



        /* Wait for second field. */

        *gotallline = 0;

        if (h->next_output_pic && (h->next_output_pic->sync || h->sync>1)) {

            ret = output_frame(h, pict, &h->next_output_pic->f);

            if (ret < 0)

                return ret;

            *gotallline = 1;

            if (CONFIG_MPEGVIDEO) {

                ff_print_debug_info2(h->avctx, h->next_output_pic, pict, h->er.mbskip_table,

                                    &h->low_delay,

                                    h->mb_width, h->mb_height, h->mb_stride, 1);

            }

        }

    }



    assert(pict->data[0] || !*gotallline);



    return get_consumed_bytes(buf_index, buf_size);

}
",1,1,0.0,1,"avctx,data,got_frame,avpkt,buf,h,pict,out,i,out_idx,ret,p,cnt","avctx:-0.015735656023025513,data:0.018213361501693726,got_frame:0.02003943920135498,avpkt:0.014928460121154785,buf:0.018379896879196167,h:0.003865480422973633,pict:0.0081939697265625,out:-0.015837430953979492,i:-0.005021929740905762,out_idx:0.0069658756256103516,ret:0.0027806460857391357,p:0.04535076022148132,cnt:0.006916731595993042,",3.0,28.0,"p:fp,got_frame:gotallline,buf:img,",Greedy,289,0.1879968365033467
209,"PCIBus *pci_prep_init(qemu_irq *pic)

{

    PREPPCIState *s;

    PCIDevice *d;

    int PPC_io_memory;



    s = qemu_mallocz(sizeof(PREPPCIState));

    s->bus = pci_register_bus(prep_set_irq, prep_map_irq, pic, 0, 2);



    register_ioport_write(0xcf8, 4, 4, pci_prep_addr_writel, s);

    register_ioport_read(0xcf8, 4, 4, pci_prep_addr_readl, s);



    register_ioport_write(0xcfc, 4, 1, pci_host_data_writeb, s);

    register_ioport_write(0xcfc, 4, 2, pci_host_data_writew, s);

    register_ioport_write(0xcfc, 4, 4, pci_host_data_writel, s);

    register_ioport_read(0xcfc, 4, 1, pci_host_data_readb, s);

    register_ioport_read(0xcfc, 4, 2, pci_host_data_readw, s);

    register_ioport_read(0xcfc, 4, 4, pci_host_data_readl, s);



    PPC_io_memory = cpu_register_io_memory(0, PPC_PCIIO_read,

                                           PPC_PCIIO_write, s);

    cpu_register_physical_memory(0x80800000, 0x00400000, PPC_io_memory);



    /* PCI host bridge */

    d = pci_register_device(s->bus, ""PREP Host Bridge - Motorola Raven"",

                            sizeof(PCIDevice), 0, NULL, NULL);

    d->config[0x00] = 0x57; // vendor_id : Motorola

    d->config[0x01] = 0x10;

    d->config[0x02] = 0x01; // device_id : Raven

    d->config[0x03] = 0x48;

    d->config[0x08] = 0x00; // revision

    d->config[0x0A] = 0x00; // class_sub = pci host

    d->config[0x0B] = 0x06; // class_base = PCI_bridge

    d->config[0x0C] = 0x08; // cache_line_size

    d->config[0x0D] = 0x10; // latency_timer

    d->config[0x0E] = 0x00; // header_type

    d->config[0x34] = 0x00; // capabilities_pointer



    return s->bus;

}
",301,"PCIBus *pci_prep_init(qemu_irq *pic)

{

    PREPPCIState *l;

    PCIDevice *d;

    int PPC_io_memory;



    l = qemu_mallocz(sizeof(PREPPCIState));

    l->bus = pci_register_bus(prep_set_irq, prep_map_irq, pic, 0, 2);



    register_ioport_write(0xcf8, 4, 4, pci_prep_addr_writel, l);

    register_ioport_read(0xcf8, 4, 4, pci_prep_addr_readl, l);



    register_ioport_write(0xcfc, 4, 1, pci_host_data_writeb, l);

    register_ioport_write(0xcfc, 4, 2, pci_host_data_writew, l);

    register_ioport_write(0xcfc, 4, 4, pci_host_data_writel, l);

    register_ioport_read(0xcfc, 4, 1, pci_host_data_readb, l);

    register_ioport_read(0xcfc, 4, 2, pci_host_data_readw, l);

    register_ioport_read(0xcfc, 4, 4, pci_host_data_readl, l);



    PPC_io_memory = cpu_register_io_memory(0, PPC_PCIIO_read,

                                           PPC_PCIIO_write, l);

    cpu_register_physical_memory(0x80800000, 0x00400000, PPC_io_memory);



    /* PCI host bridge */

    d = pci_register_device(l->bus, ""PREP Host Bridge - Motorola Raven"",

                            sizeof(PCIDevice), 0, NULL, NULL);

    d->config[0x00] = 0x57; // vendor_id : Motorola

    d->config[0x01] = 0x10;

    d->config[0x02] = 0x01; // device_id : Raven

    d->config[0x03] = 0x48;

    d->config[0x08] = 0x00; // revision

    d->config[0x0A] = 0x00; // class_sub = pci host

    d->config[0x0B] = 0x06; // class_base = PCI_bridge

    d->config[0x0C] = 0x08; // cache_line_size

    d->config[0x0D] = 0x10; // latency_timer

    d->config[0x0E] = 0x00; // header_type

    d->config[0x34] = 0x00; // capabilities_pointer



    return l->bus;

}
",1,1,0.0,1,"pic,s,d,PPC_io_memory","pic:0.06652569770812988,s:0.16276736557483673,d:0.03207367658615112,PPC_io_memory:0.05383524298667908,",1.0,14.0,"s:l,",Greedy,108,0.0855245073636372
219,"void decode_mb_mode(VP8Context *s, VP8Macroblock *mb, int mb_x, int mb_y,

                    uint8_t *segment, uint8_t *ref, int layout)

{

    VP56RangeCoder *c = &s->c;



    if (s->segmentation.update_map)

        *segment = vp8_rac_get_tree(c, vp8_segmentid_tree, s->prob->segmentid);

    else if (s->segmentation.enabled)

        *segment = ref ? *ref : *segment;

    mb->segment = *segment;



    mb->skip = s->mbskip_enabled ? vp56_rac_get_prob(c, s->prob->mbskip) : 0;



    if (s->keyframe) {

        mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_intra,

                                    vp8_pred16x16_prob_intra);



        if (mb->mode == MODE_I4x4) {

            decode_intra4x4_modes(s, c, mb, mb_x, 1, layout);

        } else {

            const uint32_t modes = vp8_pred4x4_mode[mb->mode] * 0x01010101u;

            if (s->mb_layout == 1)

                AV_WN32A(mb->intra4x4_pred_mode_top, modes);

            else

                AV_WN32A(s->intra4x4_pred_mode_top + 4 * mb_x, modes);

            AV_WN32A(s->intra4x4_pred_mode_left, modes);

        }



        mb->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree,

                                                vp8_pred8x8c_prob_intra);

        mb->ref_frame        = VP56_FRAME_CURRENT;

    } else if (vp56_rac_get_prob_branchy(c, s->prob->intra)) {

        // inter MB, 16.2

        if (vp56_rac_get_prob_branchy(c, s->prob->last))

            mb->ref_frame =

                vp56_rac_get_prob(c, s->prob->golden) ? VP56_FRAME_GOLDEN2 /* altref */

                                                      : VP56_FRAME_GOLDEN;

        else

            mb->ref_frame = VP56_FRAME_PREVIOUS;

        s->ref_count[mb->ref_frame - 1]++;



        // motion vectors, 16.3

        decode_mvs(s, mb, mb_x, mb_y, layout);

    } else {

        // intra MB, 16.1

        mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_inter, s->prob->pred16x16);



        if (mb->mode == MODE_I4x4)

            decode_intra4x4_modes(s, c, mb, mb_x, 0, layout);



        mb->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree,

                                                s->prob->pred8x8c);

        mb->ref_frame        = VP56_FRAME_CURRENT;

        mb->partitioning     = VP8_SPLITMVMODE_NONE;

        AV_ZERO32(&mb->bmv[0]);

    }

}
",395,"void decode_mb_mode(VP8Context *s, VP8Macroblock *ym, int mb_x, int mb_y,

                    uint8_t *segment, uint8_t *ref, int layout)

{

    VP56RangeCoder *c = &s->c;



    if (s->segmentation.update_map)

        *segment = vp8_rac_get_tree(c, vp8_segmentid_tree, s->prob->segmentid);

    else if (s->segmentation.enabled)

        *segment = ref ? *ref : *segment;

    ym->segment = *segment;



    ym->skip = s->mbskip_enabled ? vp56_rac_get_prob(c, s->prob->mbskip) : 0;



    if (s->keyframe) {

        ym->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_intra,

                                    vp8_pred16x16_prob_intra);



        if (ym->mode == MODE_I4x4) {

            decode_intra4x4_modes(s, c, ym, mb_x, 1, layout);

        } else {

            const uint32_t modes = vp8_pred4x4_mode[ym->mode] * 0x01010101u;

            if (s->mb_layout == 1)

                AV_WN32A(ym->intra4x4_pred_mode_top, modes);

            else

                AV_WN32A(s->intra4x4_pred_mode_top + 4 * mb_x, modes);

            AV_WN32A(s->intra4x4_pred_mode_left, modes);

        }



        ym->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree,

                                                vp8_pred8x8c_prob_intra);

        ym->ref_frame        = VP56_FRAME_CURRENT;

    } else if (vp56_rac_get_prob_branchy(c, s->prob->intra)) {

        // inter MB, 16.2

        if (vp56_rac_get_prob_branchy(c, s->prob->last))

            ym->ref_frame =

                vp56_rac_get_prob(c, s->prob->golden) ? VP56_FRAME_GOLDEN2 /* altref */

                                                      : VP56_FRAME_GOLDEN;

        else

            ym->ref_frame = VP56_FRAME_PREVIOUS;

        s->ref_count[ym->ref_frame - 1]++;



        // motion vectors, 16.3

        decode_mvs(s, ym, mb_x, mb_y, layout);

    } else {

        // intra MB, 16.1

        ym->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_inter, s->prob->pred16x16);



        if (ym->mode == MODE_I4x4)

            decode_intra4x4_modes(s, c, ym, mb_x, 0, layout);



        ym->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree,

                                                s->prob->pred8x8c);

        ym->ref_frame        = VP56_FRAME_CURRENT;

        ym->partitioning     = VP8_SPLITMVMODE_NONE;

        AV_ZERO32(&ym->bmv[0]);

    }

}
",1,1,0.0,1,"s,mb,mb_x,mb_y,segment,ref,layout,c,ref_frame","s:0.015346676111221313,mb:0.0679895281791687,mb_x:-0.025547385215759277,mb_y:-3.764033317565918e-05,segment:0.02133128046989441,ref:0.02654746174812317,layout:0.008822113275527954,c:0.04435482621192932,ref_frame:-0.0034690797328948975,",1.0,21.0,"mb:ym,",Greedy,141,0.0976445198059082
230,"static av_always_inline int coeff_abs_level_remaining_decode(HEVCContext *s, int rc_rice_param)

{

    int prefix = 0;

    int suffix = 0;

    int last_coeff_abs_level_remaining;

    int i;



    while (prefix < CABAC_MAX_BIN && get_cabac_bypass(&s->HEVClc->cc))

        prefix++;



    if (prefix < 3) {

        for (i = 0; i < rc_rice_param; i++)

            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);

        last_coeff_abs_level_remaining = (prefix << rc_rice_param) + suffix;

    } else {

        int prefix_minus3 = prefix - 3;



        if (prefix == CABAC_MAX_BIN) {

            av_log(s->avctx, AV_LOG_ERROR, ""CABAC_MAX_BIN : %d\n"", prefix);

            return 0;

        }



        for (i = 0; i < prefix_minus3 + rc_rice_param; i++)

            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);

        last_coeff_abs_level_remaining = (((1 << prefix_minus3) + 3 - 1)

                                              << rc_rice_param) + suffix;

    }

    return last_coeff_abs_level_remaining;

}
",189,"static av_always_inline int coeff_abs_level_remaining_decode(HEVCContext *g, int rc_rice_param)

{

    int prefix = 0;

    int suffix = 0;

    int last_coeff_abs_level_remaining;

    int i;



    while (prefix < CABAC_MAX_BIN && get_cabac_bypass(&g->HEVClc->cc))

        prefix++;



    if (prefix < 3) {

        for (i = 0; i < rc_rice_param; i++)

            suffix = (suffix << 1) | get_cabac_bypass(&g->HEVClc->cc);

        last_coeff_abs_level_remaining = (prefix << rc_rice_param) + suffix;

    } else {

        int prefix_minus3 = prefix - 3;



        if (prefix == CABAC_MAX_BIN) {

            av_log(g->avctx, AV_LOG_ERROR, ""CABAC_MAX_BIN : %d
"", prefix);

            return 0;

        }



        for (i = 0; i < prefix_minus3 + rc_rice_param; i++)

            suffix = (suffix << 1) | get_cabac_bypass(&g->HEVClc->cc);

        last_coeff_abs_level_remaining = (((1 << prefix_minus3) + 3 - 1)

                                              << rc_rice_param) + suffix;

    }

    return last_coeff_abs_level_remaining;

}
",1,1,0.0,1,"s,rc_rice_param,last_coeff_abs_level_remaining,i,prefix","s:0.07958489656448364,rc_rice_param:-0.016268640756607056,last_coeff_abs_level_remaining:-0.07694438099861145,i:0.02420908212661743,prefix:0.04720181226730347,",1.0,5.0,"s:g,",Greedy,79,0.05121857325236
232,"static inline int cris_addc_pi_m(int a, int **b)

{

	asm volatile (""addc [%1+], %0\n"" : ""+r"" (a), ""+b"" (*b));

	return a;

}
",38,"static inline int cris_addc_pi_m(int area, int **cb)

{

	asm volatile (""addc [%1+], %0
"" : ""+r"" (area), ""+b"" (*cb));

	return area;

}
",1,1,0.0,1,"a,b","a:0.021454572677612305,b:-0.010355651378631592,",2.0,5.0,"a:area,b:cb,",Greedy,82,0.0560563007990519
234,"static int decode_frame_byterun1(AVCodecContext *avctx,

                            void *data, int *data_size,

                            AVPacket *avpkt)

{

    IffContext *s = avctx->priv_data;

    const uint8_t *buf = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL;

    const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0;

    const uint8_t *buf_end = buf+buf_size;

    int y, plane, res;



    if ((res = extract_header(avctx, avpkt)) < 0)

        return res;

    if (s->init) {

        if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) {

            av_log(avctx, AV_LOG_ERROR, ""reget_buffer() failed\n"");

            return res;

        }

    } else if ((res = avctx->get_buffer(avctx, &s->frame)) < 0) {

        av_log(avctx, AV_LOG_ERROR, ""get_buffer() failed\n"");

        return res;

    } else if (avctx->bits_per_coded_sample <= 8 && avctx->pix_fmt != PIX_FMT_GRAY8) {

        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)

            return res;

    }

    s->init = 1;



    if (avctx->codec_tag == MKTAG('I','L','B','M')) { //interleaved

        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {

            for(y = 0; y < avctx->height ; y++ ) {

                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];

                memset(row, 0, avctx->width);

                for (plane = 0; plane < s->bpp; plane++) {

                    buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);

                    decodeplane8(row, s->planebuf, s->planesize, plane);

                }

            }

        } else if (s->ham) { // HAM to PIX_FMT_BGR32

            for (y = 0; y < avctx->height ; y++) {

                uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];

                memset(s->ham_buf, 0, avctx->width);

                for (plane = 0; plane < s->bpp; plane++) {

                    buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);

                    decodeplane8(s->ham_buf, s->planebuf, s->planesize, plane);

                }

                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);

            }

        } else { //PIX_FMT_BGR32

            for(y = 0; y < avctx->height ; y++ ) {

                uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];

                memset(row, 0, avctx->width << 2);

                for (plane = 0; plane < s->bpp; plane++) {

                    buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);

                    decodeplane32((uint32_t *) row, s->planebuf, s->planesize, plane);

                }

            }

        }

    } else if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) { // IFF-PBM

        for(y = 0; y < avctx->height ; y++ ) {

            uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];

            buf += decode_byterun(row, avctx->width, buf, buf_end);

        }

    } else { // IFF-PBM: HAM to PIX_FMT_BGR32

        for (y = 0; y < avctx->height ; y++) {

            uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];

            buf += decode_byterun(s->ham_buf, avctx->width, buf, buf_end);

            decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, avctx->width);

        }

    }



    *data_size = sizeof(AVFrame);

    *(AVFrame*)data = s->frame;

    return buf_size;

}
",814,"static int decode_frame_byterun1(AVCodecContext *ajxc,

                            void *pad, int *data_size,

                            AVPacket *avpkt)

{

    IffContext *s = ajxc->priv_data;

    const uint8_t *buf = avpkt->size >= 2 ? avpkt->pad + AV_RB16(avpkt->pad) : NULL;

    const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->pad) : 0;

    const uint8_t *buf_end = buf+buf_size;

    int y, pose, res;



    if ((res = extract_header(ajxc, avpkt)) < 0)

        return res;

    if (s->init) {

        if ((res = ajxc->reget_buffer(ajxc, &s->frame)) < 0) {

            av_log(ajxc, AV_LOG_ERROR, ""reget_buffer() failed
"");

            return res;

        }

    } else if ((res = ajxc->get_buffer(ajxc, &s->frame)) < 0) {

        av_log(ajxc, AV_LOG_ERROR, ""get_buffer() failed
"");

        return res;

    } else if (ajxc->bits_per_coded_sample <= 8 && ajxc->pix_fmt != PIX_FMT_GRAY8) {

        if ((res = ff_cmap_read_palette(ajxc, (uint32_t*)s->frame.pad[1])) < 0)

            return res;

    }

    s->init = 1;



    if (ajxc->codec_tag == MKTAG('I','L','B','M')) { //interleaved

        if (ajxc->pix_fmt == PIX_FMT_PAL8 || ajxc->pix_fmt == PIX_FMT_GRAY8) {

            for(y = 0; y < ajxc->height ; y++ ) {

                uint8_t *row = &s->frame.pad[0][ y*s->frame.linesize[0] ];

                memset(row, 0, ajxc->width);

                for (pose = 0; pose < s->bpp; pose++) {

                    buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);

                    decodeplane8(row, s->planebuf, s->planesize, pose);

                }

            }

        } else if (s->ham) { // HAM to PIX_FMT_BGR32

            for (y = 0; y < ajxc->height ; y++) {

                uint8_t *row = &s->frame.pad[0][y*s->frame.linesize[0]];

                memset(s->ham_buf, 0, ajxc->width);

                for (pose = 0; pose < s->bpp; pose++) {

                    buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);

                    decodeplane8(s->ham_buf, s->planebuf, s->planesize, pose);

                }

                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);

            }

        } else { //PIX_FMT_BGR32

            for(y = 0; y < ajxc->height ; y++ ) {

                uint8_t *row = &s->frame.pad[0][y*s->frame.linesize[0]];

                memset(row, 0, ajxc->width << 2);

                for (pose = 0; pose < s->bpp; pose++) {

                    buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);

                    decodeplane32((uint32_t *) row, s->planebuf, s->planesize, pose);

                }

            }

        }

    } else if (ajxc->pix_fmt == PIX_FMT_PAL8 || ajxc->pix_fmt == PIX_FMT_GRAY8) { // IFF-PBM

        for(y = 0; y < ajxc->height ; y++ ) {

            uint8_t *row = &s->frame.pad[0][y*s->frame.linesize[0]];

            buf += decode_byterun(row, ajxc->width, buf, buf_end);

        }

    } else { // IFF-PBM: HAM to PIX_FMT_BGR32

        for (y = 0; y < ajxc->height ; y++) {

            uint8_t *row = &s->frame.pad[0][y*s->frame.linesize[0]];

            buf += decode_byterun(s->ham_buf, ajxc->width, buf, buf_end);

            decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, ajxc->width);

        }

    }



    *data_size = sizeof(AVFrame);

    *(AVFrame*)pad = s->frame;

    return buf_size;

}
",1,1,0.0,1,"avctx,data,data_size,avpkt,s,buf,buf_end,y,plane,res,row","avctx:0.2024853229522705,data:0.03329199552536011,data_size:-0.03551250696182251,avpkt:-0.17304712533950806,s:-0.016796767711639404,buf:-0.026394128799438477,buf_end:-0.03866976499557495,y:0.01658838987350464,plane:0.035118699073791504,res:-0.009648680686950684,row:-0.07512253522872925,",3.0,52.0,"avctx:ajxc,plane:pose,data:pad,",Greedy,432,0.3253478209177653
235,"int alloc_picture(MpegEncContext *s, Picture *pic, int shared){

    const int big_mb_num= s->mb_stride*(s->mb_height+1) + 1; //the +1 is needed so memset(,,stride*height) does not sig11

    const int mb_array_size= s->mb_stride*s->mb_height;

    const int b8_array_size= s->b8_stride*s->mb_height*2;

    const int b4_array_size= s->b4_stride*s->mb_height*4;

    int i;



    if(shared){

        assert(pic->data[0]);

        assert(pic->type == 0 || pic->type == FF_BUFFER_TYPE_SHARED);

        pic->type= FF_BUFFER_TYPE_SHARED;

    }else{

        int r;



        assert(!pic->data[0]);



        r= s->avctx->get_buffer(s->avctx, (AVFrame*)pic);



        if(r<0 || !pic->age || !pic->type || !pic->data[0]){

            av_log(s->avctx, AV_LOG_ERROR, ""get_buffer() failed (%d %d %d %p)\n"", r, pic->age, pic->type, pic->data[0]);

            return -1;

        }



        if(s->linesize && (s->linesize != pic->linesize[0] || s->uvlinesize != pic->linesize[1])){

            av_log(s->avctx, AV_LOG_ERROR, ""get_buffer() failed (stride changed)\n"");

            return -1;

        }



        if(pic->linesize[1] != pic->linesize[2]){

            av_log(s->avctx, AV_LOG_ERROR, ""get_buffer() failed (uv stride mismatch)\n"");

            return -1;

        }



        s->linesize  = pic->linesize[0];

        s->uvlinesize= pic->linesize[1];

    }



    if(pic->qscale_table==NULL){

        if (s->encoding) {

            CHECKED_ALLOCZ(pic->mb_var   , mb_array_size * sizeof(int16_t))

            CHECKED_ALLOCZ(pic->mc_mb_var, mb_array_size * sizeof(int16_t))

            CHECKED_ALLOCZ(pic->mb_mean  , mb_array_size * sizeof(int8_t))

        }



        CHECKED_ALLOCZ(pic->mbskip_table , mb_array_size * sizeof(uint8_t)+2) //the +2 is for the slice end check

        CHECKED_ALLOCZ(pic->qscale_table , mb_array_size * sizeof(uint8_t))

        CHECKED_ALLOCZ(pic->mb_type_base , big_mb_num    * sizeof(uint32_t))

        pic->mb_type= pic->mb_type_base + s->mb_stride+1;

        if(s->out_format == FMT_H264){

            for(i=0; i<2; i++){

                CHECKED_ALLOCZ(pic->motion_val_base[i], 2 * (b4_array_size+4)  * sizeof(int16_t))

                pic->motion_val[i]= pic->motion_val_base[i]+4;

                CHECKED_ALLOCZ(pic->ref_index[i], b8_array_size * sizeof(uint8_t))

            }

            pic->motion_subsample_log2= 2;

        }else if(s->out_format == FMT_H263 || s->encoding || (s->avctx->debug&FF_DEBUG_MV) || (s->avctx->debug_mv)){

            for(i=0; i<2; i++){

                CHECKED_ALLOCZ(pic->motion_val_base[i], 2 * (b8_array_size+4) * sizeof(int16_t))

                pic->motion_val[i]= pic->motion_val_base[i]+4;

                CHECKED_ALLOCZ(pic->ref_index[i], b8_array_size * sizeof(uint8_t))

            }

            pic->motion_subsample_log2= 3;

        }

        if(s->avctx->debug&FF_DEBUG_DCT_COEFF) {

            CHECKED_ALLOCZ(pic->dct_coeff, 64 * mb_array_size * sizeof(DCTELEM)*6)

        }

        pic->qstride= s->mb_stride;

        CHECKED_ALLOCZ(pic->pan_scan , 1 * sizeof(AVPanScan))

    }



    /* It might be nicer if the application would keep track of these

     * but it would require an API change. */

    memmove(s->prev_pict_types+1, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE-1);

    s->prev_pict_types[0]= s->pict_type;

    if(pic->age < PREV_PICT_TYPES_BUFFER_SIZE && s->prev_pict_types[pic->age] == B_TYPE)

        pic->age= INT_MAX; // Skipped MBs in B-frames are quite rare in MPEG-1/2 and it is a bit tricky to skip them anyway.



    return 0;

fail: //for the CHECKED_ALLOCZ macro

    return -1;

}
",734,"int alloc_picture(MpegEncContext *l, Picture *pic, int shared){

    const int big_mb_num= l->mb_stride*(l->mb_height+1) + 1; //the +1 is needed so memset(,,stride*height) does not sig11

    const int mb_array_size= l->mb_stride*l->mb_height;

    const int b8_array_size= l->b8_stride*l->mb_height*2;

    const int b4_array_size= l->b4_stride*l->mb_height*4;

    int i;



    if(shared){

        assert(pic->data[0]);

        assert(pic->type == 0 || pic->type == FF_BUFFER_TYPE_SHARED);

        pic->type= FF_BUFFER_TYPE_SHARED;

    }else{

        int rate;



        assert(!pic->data[0]);



        rate= l->avctx->get_buffer(l->avctx, (AVFrame*)pic);



        if(rate<0 || !pic->age || !pic->type || !pic->data[0]){

            av_log(l->avctx, AV_LOG_ERROR, ""get_buffer() failed (%d %d %d %p)
"", rate, pic->age, pic->type, pic->data[0]);

            return -1;

        }



        if(l->linesize && (l->linesize != pic->linesize[0] || l->uvlinesize != pic->linesize[1])){

            av_log(l->avctx, AV_LOG_ERROR, ""get_buffer() failed (stride changed)
"");

            return -1;

        }



        if(pic->linesize[1] != pic->linesize[2]){

            av_log(l->avctx, AV_LOG_ERROR, ""get_buffer() failed (uv stride mismatch)
"");

            return -1;

        }



        l->linesize  = pic->linesize[0];

        l->uvlinesize= pic->linesize[1];

    }



    if(pic->qscale_table==NULL){

        if (l->encoding) {

            CHECKED_ALLOCZ(pic->mb_var   , mb_array_size * sizeof(int16_t))

            CHECKED_ALLOCZ(pic->mc_mb_var, mb_array_size * sizeof(int16_t))

            CHECKED_ALLOCZ(pic->mb_mean  , mb_array_size * sizeof(int8_t))

        }



        CHECKED_ALLOCZ(pic->mbskip_table , mb_array_size * sizeof(uint8_t)+2) //the +2 is for the slice end check

        CHECKED_ALLOCZ(pic->qscale_table , mb_array_size * sizeof(uint8_t))

        CHECKED_ALLOCZ(pic->mb_type_base , big_mb_num    * sizeof(uint32_t))

        pic->mb_type= pic->mb_type_base + l->mb_stride+1;

        if(l->out_format == FMT_H264){

            for(i=0; i<2; i++){

                CHECKED_ALLOCZ(pic->motion_val_base[i], 2 * (b4_array_size+4)  * sizeof(int16_t))

                pic->motion_val[i]= pic->motion_val_base[i]+4;

                CHECKED_ALLOCZ(pic->ref_index[i], b8_array_size * sizeof(uint8_t))

            }

            pic->motion_subsample_log2= 2;

        }else if(l->out_format == FMT_H263 || l->encoding || (l->avctx->debug&FF_DEBUG_MV) || (l->avctx->debug_mv)){

            for(i=0; i<2; i++){

                CHECKED_ALLOCZ(pic->motion_val_base[i], 2 * (b8_array_size+4) * sizeof(int16_t))

                pic->motion_val[i]= pic->motion_val_base[i]+4;

                CHECKED_ALLOCZ(pic->ref_index[i], b8_array_size * sizeof(uint8_t))

            }

            pic->motion_subsample_log2= 3;

        }

        if(l->avctx->debug&FF_DEBUG_DCT_COEFF) {

            CHECKED_ALLOCZ(pic->dct_coeff, 64 * mb_array_size * sizeof(DCTELEM)*6)

        }

        pic->qstride= l->mb_stride;

        CHECKED_ALLOCZ(pic->pan_scan , 1 * sizeof(AVPanScan))

    }



    /* It might be nicer if the application would keep track of these

     * but it would require an API change. */

    memmove(l->prev_pict_types+1, l->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE-1);

    l->prev_pict_types[0]= l->pict_type;

    if(pic->age < PREV_PICT_TYPES_BUFFER_SIZE && l->prev_pict_types[pic->age] == B_TYPE)

        pic->age= INT_MAX; // Skipped MBs in B-frames are quite rare in MPEG-1/2 and it is a bit tricky to skip them anyway.



    return 0;

fail: //for the CHECKED_ALLOCZ macro

    return -1;

}
",1,1,0.0,1,"s,pic,shared,i,r","s:0.019585996866226196,pic:-0.02792257070541382,shared:0.0073274970054626465,i:0.005448490381240845,r:0.03155127167701721,",2.0,37.0,"r:rate,s:l,",Greedy,230,0.1712087790171305
240,"static void vc1_v_overlap_c(uint8_t* src, int stride)

{

    int i;

    int a, b, c, d;

    int d1, d2;

    int rnd = 1;

    for(i = 0; i < 8; i++) {

        a = src[-2*stride];

        b = src[-stride];

        c = src[0];

        d = src[stride];

        d1 = (a - d + 3 + rnd) >> 3;

        d2 = (a - d + b - c + 4 - rnd) >> 3;



        src[-2*stride] = a - d1;

        src[-stride] = b - d2;

        src[0] = c + d2;

        src[stride] = d + d1;

        src++;

        rnd = !rnd;

    }

}
",160,"static void vc1_v_overlap_c(uint8_t* src, int Stride)

{

    int i;

    int a, b, c, d;

    int d1, b12;

    int rnd = 1;

    for(i = 0; i < 8; i++) {

        a = src[-2*Stride];

        b = src[-Stride];

        c = src[0];

        d = src[Stride];

        d1 = (a - d + 3 + rnd) >> 3;

        b12 = (a - d + b - c + 4 - rnd) >> 3;



        src[-2*Stride] = a - d1;

        src[-Stride] = b - b12;

        src[0] = c + b12;

        src[Stride] = d + d1;

        src++;

        rnd = !rnd;

    }

}
",1,1,0.0,1,"src,stride,i,a,b,c,d,d1,d2","src:-0.020771324634552002,stride:0.013219475746154785,i:-0.009124815464019775,a:-0.0441054105758667,b:-0.045397818088531494,c:-0.019048035144805908,d:-0.04574364423751831,d1:-0.02079629898071289,d2:0.009959995746612549,",2.0,11.0,"stride:Stride,d2:b12,",Greedy,170,0.1200914621353149
241,"void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *d,

                                        QGuestAllocator *alloc, uint16_t entry)

{

    uint16_t vector;

    uint32_t control;

    void *addr;



    g_assert(d->pdev->msix_enabled);

    addr = d->pdev->msix_table + (entry * 16);



    g_assert_cmpint(entry, >=, 0);

    g_assert_cmpint(entry, <, qpci_msix_table_size(d->pdev));

    d->config_msix_entry = entry;



    d->config_msix_data = 0x12345678;

    d->config_msix_addr = guest_alloc(alloc, 4);



    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_LOWER_ADDR,

                                                    d->config_msix_addr & ~0UL);

    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_UPPER_ADDR,

                                            (d->config_msix_addr >> 32) & ~0UL);

    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);



    control = qpci_io_readl(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL);

    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL,

                                        control & ~PCI_MSIX_ENTRY_CTRL_MASKBIT);



    qpci_io_writew(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR, entry);

    vector = qpci_io_readw(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR);

    g_assert_cmphex(vector, !=, VIRTIO_MSI_NO_VECTOR);

}
",219,"void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *f,

                                        QGuestAllocator *slot, uint16_t address)

{

    uint16_t token;

    uint32_t driver;

    void *act;



    g_assert(f->pdev->msix_enabled);

    act = f->pdev->msix_table + (address * 16);



    g_assert_cmpint(address, >=, 0);

    g_assert_cmpint(address, <, qpci_msix_table_size(f->pdev));

    f->config_msix_entry = address;



    f->config_msix_data = 0x12345678;

    f->config_msix_addr = guest_alloc(slot, 4);



    qpci_io_writel(f->pdev, act + PCI_MSIX_ENTRY_LOWER_ADDR,

                                                    f->config_msix_addr & ~0UL);

    qpci_io_writel(f->pdev, act + PCI_MSIX_ENTRY_UPPER_ADDR,

                                            (f->config_msix_addr >> 32) & ~0UL);

    qpci_io_writel(f->pdev, act + PCI_MSIX_ENTRY_DATA, f->config_msix_data);



    driver = qpci_io_readl(f->pdev, act + PCI_MSIX_ENTRY_VECTOR_CTRL);

    qpci_io_writel(f->pdev, act + PCI_MSIX_ENTRY_VECTOR_CTRL,

                                        driver & ~PCI_MSIX_ENTRY_CTRL_MASKBIT);



    qpci_io_writew(f->pdev, f->act + VIRTIO_MSI_CONFIG_VECTOR, address);

    token = qpci_io_readw(f->pdev, f->act + VIRTIO_MSI_CONFIG_VECTOR);

    g_assert_cmphex(token, !=, VIRTIO_MSI_NO_VECTOR);

}
",1,1,0.0,1,"d,alloc,entry,vector,control,addr","d:0.04070192575454712,alloc:0.003460109233856201,entry:-0.002854585647583008,vector:0.039666175842285156,control:-0.02186453342437744,addr:0.007812678813934326,",6.0,42.0,"d:f,vector:token,addr:act,alloc:slot,entry:address,control:driver,",Greedy,396,0.2710169116655985
243,"static void usb_msd_realize_bot(USBDevice *dev, Error **errp)

{

    MSDState *s = DO_UPCAST(MSDState, dev, dev);



    usb_desc_create_serial(dev);

    usb_desc_init(dev);

    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),

                 &usb_msd_scsi_info_bot, NULL);

    s->bus.qbus.allow_hotplug = 0;

    usb_msd_handle_reset(dev);

}
",78,"static void usb_msd_realize_bot(USBDevice *diff, Error **errp)

{

    MSDState *is = DO_UPCAST(MSDState, diff, diff);



    usb_desc_create_serial(diff);

    usb_desc_init(diff);

    scsi_bus_new(&is->bus, sizeof(is->bus), DEVICE(diff),

                 &usb_msd_scsi_info_bot, NULL);

    is->bus.qbus.allow_hotplug = 0;

    usb_msd_handle_reset(diff);

}
",1,1,0.0,1,"dev,errp,s","dev:0.030133888125419617,errp:-0.026787832379341125,s:0.039212778210639954,",2.0,11.0,"s:is,dev:diff,",Greedy,128,0.1005888183911641
252,"static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)

{

    AHCICmdHdr *cmd = ad->cur_cmd;

    uint32_t opts = le32_to_cpu(cmd->opts);

    uint64_t prdt_addr = le64_to_cpu(cmd->tbl_addr) + 0x80;

    int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN;

    dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG));

    dma_addr_t real_prdt_len = prdt_len;

    uint8_t *prdt;

    int i;

    int r = 0;

    int sum = 0;

    int off_idx = -1;

    int off_pos = -1;

    int tbl_entry_size;

    IDEBus *bus = &ad->port;

    BusState *qbus = BUS(bus);



    if (!sglist_alloc_hint) {

        DPRINTF(ad->port_no, ""no sg list given by guest: 0x%08x\n"", opts);

        return -1;

    }



    /* map PRDT */

    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,

                                DMA_DIRECTION_TO_DEVICE))){

        DPRINTF(ad->port_no, ""map failed\n"");

        return -1;

    }



    if (prdt_len < real_prdt_len) {

        DPRINTF(ad->port_no, ""mapped less than expected\n"");

        r = -1;

        goto out;

    }



    /* Get entries in the PRDT, init a qemu sglist accordingly */

    if (sglist_alloc_hint > 0) {

        AHCI_SG *tbl = (AHCI_SG *)prdt;

        sum = 0;

        for (i = 0; i < sglist_alloc_hint; i++) {

            /* flags_size is zero-based */

            tbl_entry_size = (le32_to_cpu(tbl[i].flags_size) + 1);

            if (offset <= (sum + tbl_entry_size)) {

                off_idx = i;

                off_pos = offset - sum;

                break;

            }

            sum += tbl_entry_size;

        }

        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {

            DPRINTF(ad->port_no, ""%s: Incorrect offset! ""

                            ""off_idx: %d, off_pos: %d\n"",

                            __func__, off_idx, off_pos);

            r = -1;

            goto out;

        }



        qemu_sglist_init(sglist, qbus->parent, (sglist_alloc_hint - off_idx),

                         ad->hba->as);

        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr + off_pos),

                        le32_to_cpu(tbl[off_idx].flags_size) + 1 - off_pos);



        for (i = off_idx + 1; i < sglist_alloc_hint; i++) {

            /* flags_size is zero-based */

            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),

                            le32_to_cpu(tbl[i].flags_size) + 1);

        }

    }



out:

    dma_memory_unmap(ad->hba->as, prdt, prdt_len,

                     DMA_DIRECTION_TO_DEVICE, prdt_len);

    return r;

}
",450,"static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)

{

    AHCICmdHdr *cmd = ad->cur_cmd;

    uint32_t opts = le32_to_cpu(cmd->opts);

    uint64_t prdt_addr = le64_to_cpu(cmd->tbl_addr) + 0x80;

    int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN;

    dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG));

    dma_addr_t real_prdt_len = prdt_len;

    uint8_t *Prt;

    int i;

    int r = 0;

    int sum = 0;

    int off_idx = -1;

    int off_pos = -1;

    int tbl_entry_size;

    IDEBus *bus = &ad->port;

    BusState *qbus = BUS(bus);



    if (!sglist_alloc_hint) {

        DPRINTF(ad->port_no, ""no sg list given by guest: 0x%08x
"", opts);

        return -1;

    }



    /* map PRDT */

    if (!(Prt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,

                                DMA_DIRECTION_TO_DEVICE))){

        DPRINTF(ad->port_no, ""map failed
"");

        return -1;

    }



    if (prdt_len < real_prdt_len) {

        DPRINTF(ad->port_no, ""mapped less than expected
"");

        r = -1;

        goto out;

    }



    /* Get entries in the PRDT, init a qemu sglist accordingly */

    if (sglist_alloc_hint > 0) {

        AHCI_SG *tbl = (AHCI_SG *)Prt;

        sum = 0;

        for (i = 0; i < sglist_alloc_hint; i++) {

            /* flags_size is zero-based */

            tbl_entry_size = (le32_to_cpu(tbl[i].flags_size) + 1);

            if (offset <= (sum + tbl_entry_size)) {

                off_idx = i;

                off_pos = offset - sum;

                break;

            }

            sum += tbl_entry_size;

        }

        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {

            DPRINTF(ad->port_no, ""%s: Incorrect offset! ""

                            ""off_idx: %d, off_pos: %d
"",

                            __func__, off_idx, off_pos);

            r = -1;

            goto out;

        }



        qemu_sglist_init(sglist, qbus->parent, (sglist_alloc_hint - off_idx),

                         ad->hba->as);

        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr + off_pos),

                        le32_to_cpu(tbl[off_idx].flags_size) + 1 - off_pos);



        for (i = off_idx + 1; i < sglist_alloc_hint; i++) {

            /* flags_size is zero-based */

            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),

                            le32_to_cpu(tbl[i].flags_size) + 1);

        }

    }



out:

    dma_memory_unmap(ad->hba->as, Prt, prdt_len,

                     DMA_DIRECTION_TO_DEVICE, prdt_len);

    return r;

}
",1,1,0.0,1,"ad,sglist,offset,cmd,prdt,i,tbl_entry_size,bus,qbus,tbl","ad:0.0009385943412780762,sglist:0.029805779457092285,offset:0.003997504711151123,cmd:0.010205596685409546,prdt:0.04274466633796692,i:0.004606485366821289,tbl_entry_size:-0.022326529026031494,bus:-0.014956265687942505,qbus:-0.006621599197387695,tbl:0.03049767017364502,",1.0,4.0,"prdt:Prt,",Greedy,86,0.0687017321586608
256,"void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)

{

	unsigned i;

	unsigned num_pixels = src_size >> 1;

	

	for(i=0; i<num_pixels; i++)

	{

	    unsigned b,g,r;

	    register uint16_t rgb;

	    rgb = src[2*i];

	    r = rgb&0x1F;

	    g = (rgb&0x3E0)>>5;

	    b = (rgb&0x7C00)>>10;

	    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);

	}

}
",122,"void rgb15tobgr15(const uint8_t *url, uint8_t *lbl, unsigned int source_scale)

{

	unsigned phi;

	unsigned num_pixels = source_scale >> 1;

	

	for(phi=0; phi<num_pixels; phi++)

	{

	    unsigned abb,group,rs;

	    register uint16_t  rba;

	     rba = url[2*phi];

	    rs =  rba&0x1F;

	    group = ( rba&0x3E0)>>5;

	    abb = ( rba&0x7C00)>>10;

	    lbl[2*phi] = (abb&0x1F) | ((group&0x1F)<<5) | ((rs&0x1F)<<10);

	}

}
",1,1,0.0,1,"src,dst,src_size,i,b,g,r,rgb","src:-0.07284510135650635,dst:-0.09146058559417725,src_size:-0.07202112674713135,i:-0.050292909145355225,b:-0.017143309116363525,g:-0.02402883768081665,r:-0.034506797790527344,rgb:-0.0934593677520752,",8.0,26.0,"b:abb,g:group,r:rs,i:phi,src_size:source_scale,src:url,dst:lbl,rgb: rba,",Greedy,327,0.2299940745035807
258,"static int lag_decode_prob(GetBitContext *gb, uint32_t *value)

{

    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };

    int i;

    int bit     = 0;

    int bits    = 0;

    int prevbit = 0;

    unsigned val;



    for (i = 0; i < 7; i++) {

        if (prevbit && bit)

            break;

        prevbit = bit;

        bit = get_bits1(gb);

        if (bit && !prevbit)

            bits += series[i];

    }

    bits--;

    if (bits < 0 || bits > 31) {

        *value = 0;

        return -1;

    } else if (bits == 0) {

        *value = 0;

        return 0;

    }



    val  = get_bits_long(gb, bits);

    val |= 1 << bits;



    *value = val - 1;



    return 0;

}
",171,"static int lag_decode_prob(GetBitContext *gb, uint32_t *value)

{

    static const uint8_t options[] = { 1, 2, 3, 5, 8, 13, 21 };

    int i;

    int bit     = 0;

    int bits    = 0;

    int prevbit = 0;

    unsigned count;



    for (i = 0; i < 7; i++) {

        if (prevbit && bit)

            break;

        prevbit = bit;

        bit = get_bits1(gb);

        if (bit && !prevbit)

            bits += options[i];

    }

    bits--;

    if (bits < 0 || bits > 31) {

        *value = 0;

        return -1;

    } else if (bits == 0) {

        *value = 0;

        return 0;

    }



    count  = get_bits_long(gb, bits);

    count |= 1 << bits;



    *value = count - 1;



    return 0;

}
",1,1,0.0,1,"gb,value,series,i,val,bits","gb:-0.10601884126663208,value:-0.09417557716369629,series:0.005518794059753418,i:-0.026858806610107422,val:0.003387629985809326,bits:0.00247114896774292,",2.0,6.0,"series:options,val:count,",Greedy,114,0.0818952004114786
263,"static void unix_wait_for_connect(int fd, Error *err, void *opaque)

{

    MigrationState *s = opaque;



    if (fd < 0) {

        DPRINTF(""migrate connect error: %s\n"", error_get_pretty(err));

        s->file = NULL;

        migrate_fd_error(s);

    } else {

        DPRINTF(""migrate connect success\n"");

        s->file = qemu_fopen_socket(fd, ""wb"");

        migrate_fd_connect(s);

    }

}
",79,"static void unix_wait_for_connect(int ffff, Error *later, void *opaque)

{

    MigrationState *s = opaque;



    if (ffff < 0) {

        DPRINTF(""migrate connect error: %s
"", error_get_pretty(later));

        s->file = NULL;

        migrate_fd_error(s);

    } else {

        DPRINTF(""migrate connect success
"");

        s->file = qemu_fopen_socket(ffff, ""wb"");

        migrate_fd_connect(s);

    }

}
",1,1,0.0,1,"fd,err,opaque,s","fd:0.04614326357841492,err:0.03860756754875183,opaque:-0.03456836938858032,s:-0.06355327367782593,",2.0,5.0,"fd:ffff,err:later,",Greedy,107,0.0668758749961853
274,"static void test_flush_nodev(void)

{

    QPCIDevice *dev;

    QPCIBar bmdma_bar, ide_bar;



    ide_test_start("""");



    dev = get_pci_device(&bmdma_bar, &ide_bar);



    /* FLUSH CACHE command on device 0*/

    qpci_io_writeb(dev, ide_bar, reg_device, 0);

    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);



    /* Just testing that qemu doesn't crash... */




    ide_test_quit();

}",60,"static void test_flush_nodev(void)

{

    QPCIDevice *info;

    QPCIBar bmdma_bar, ide_bar;



    ide_test_start("""");



    info = get_pci_device(&bmdma_bar, &ide_bar);



    /* FLUSH CACHE command on device 0*/

    qpci_io_writeb(info, ide_bar, reg_device, 0);

    qpci_io_writeb(info, ide_bar, reg_command, CMD_FLUSH_CACHE);



    /* Just testing that qemu doesn't crash... */




    ide_test_quit();

}",1,1,0.0,1,"dev,bmdma_bar,ide_bar","dev:-0.03571522235870361,bmdma_bar:-0.17639589309692383,ide_bar:-0.14543336629867554,",1.0,4.0,"dev:info,",Greedy,67,0.0433120409647623
289,"static void get_sensor_evt_enable(IPMIBmcSim *ibs,

                                  uint8_t *cmd, unsigned int cmd_len,

                                  uint8_t *rsp, unsigned int *rsp_len,

                                  unsigned int max_rsp_len)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    if ((cmd[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {

        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sens = ibs->sensors + cmd[2];

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));

    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);

}
",138,"static void get_sensor_evt_enable(IPMIBmcSim *ibs,

                                  uint8_t *id, unsigned int cmd_len,

                                  uint8_t *rdesp, unsigned int *rsp2limit,

                                  unsigned int max_rsp_len)

{

    IPMISensor *sens;



    IPMI_CHECK_CMD_LEN(3);

    if ((id[2] > MAX_SENSORS) ||

        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + id[2])) {

        rdesp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;

        return;

    }

    sens = ibs->sensors + id[2];

    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));

    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);

    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);

    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);

}
",1,1,0.0,1,"ibs,cmd,cmd_len,rsp,rsp_len,max_rsp_len,sens","ibs:0.009483158588409424,cmd:0.01613408327102661,cmd_len:0.010794997215270996,rsp:0.10447472333908081,rsp_len:0.05292177200317383,max_rsp_len:0.0044564008712768555,sens:0.009069442749023438,",3.0,7.0,"rsp:rdesp,rsp_len:rsp2limit,cmd:id,",Greedy,108,0.0870192130406697
290,"struct omap_uart_s *omap_uart_init(hwaddr base,

                qemu_irq irq, omap_clk fclk, omap_clk iclk,

                qemu_irq txdma, qemu_irq rxdma,

                const char *label, CharDriverState *chr)

{

    struct omap_uart_s *s = (struct omap_uart_s *)

            g_malloc0(sizeof(struct omap_uart_s));



    s->base = base;

    s->fclk = fclk;

    s->irq = irq;

    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,

                               omap_clk_getrate(fclk)/16,

                               chr ?: qemu_chr_new(label, ""null"", NULL),

                               DEVICE_NATIVE_ENDIAN);

    return s;

}
",114,"struct omap_uart_s *omap_uart_init(hwaddr base,

                qemu_irq iriqual, omap_clk fflok, omap_clk iclk,

                qemu_irq txfma, qemu_irq rxfma,

                const char *label, CharDriverState *chr)

{

    struct omap_uart_s *s = (struct omap_uart_s *)

            g_malloc0(sizeof(struct omap_uart_s));



    s->base = base;

    s->fflok = fflok;

    s->iriqual = iriqual;

    s->serial = serial_mm_init(get_system_memory(), base, 2, iriqual,

                               omap_clk_getrate(fflok)/16,

                               chr ?: qemu_chr_new(label, ""null"", NULL),

                               DEVICE_NATIVE_ENDIAN);

    return s;

}
",1,1,0.0,1,"base,irq,fclk,iclk,txdma,rxdma,label,chr,s","base:-0.03364640474319458,irq:0.10455429553985596,fclk:0.0855366438627243,iclk:-0.011085867881774902,txdma:0.05784229934215546,rxdma:0.06336070597171783,label:0.006398811936378479,chr:0.013689756393432617,s:0.052007079124450684,",4.0,10.0,"irq:iriqual,fclk:fflok,rxdma:rxfma,txdma:txfma,",Greedy,190,0.1337141911188761
296,"int xbzrle_encode_buffer(uint8_t *old_buf, uint8_t *new_buf, int slen,

                         uint8_t *dst, int dlen)

{

    uint32_t zrun_len = 0, nzrun_len = 0;

    int d = 0, i = 0;

    long res, xor;

    uint8_t *nzrun_start = NULL;



    g_assert(!(((uintptr_t)old_buf | (uintptr_t)new_buf | slen) %

               sizeof(long)));



    while (i < slen) {

        /* overflow */

        if (d + 2 > dlen) {

            return -1;

        }



        /* not aligned to sizeof(long) */

        res = (slen - i) % sizeof(long);

        while (res && old_buf[i] == new_buf[i]) {

            zrun_len++;

            i++;

            res--;

        }



        /* word at a time for speed */

        if (!res) {

            while (i < slen &&

                   (*(long *)(old_buf + i)) == (*(long *)(new_buf + i))) {

                i += sizeof(long);

                zrun_len += sizeof(long);

            }



            /* go over the rest */

            while (i < slen && old_buf[i] == new_buf[i]) {

                zrun_len++;

                i++;

            }

        }



        /* buffer unchanged */

        if (zrun_len == slen) {

            return 0;

        }



        /* skip last zero run */

        if (i == slen) {

            return d;

        }



        d += uleb128_encode_small(dst + d, zrun_len);



        zrun_len = 0;

        nzrun_start = new_buf + i;



        /* overflow */

        if (d + 2 > dlen) {

            return -1;

        }

        /* not aligned to sizeof(long) */

        res = (slen - i) % sizeof(long);

        while (res && old_buf[i] != new_buf[i]) {

            i++;

            nzrun_len++;

            res--;

        }



        /* word at a time for speed, use of 32-bit long okay */

        if (!res) {

            /* truncation to 32-bit long okay */

            long mask = (long)0x0101010101010101ULL;

            while (i < slen) {

                xor = *(long *)(old_buf + i) ^ *(long *)(new_buf + i);

                if ((xor - mask) & ~xor & (mask << 7)) {

                    /* found the end of an nzrun within the current long */

                    while (old_buf[i] != new_buf[i]) {

                        nzrun_len++;

                        i++;

                    }

                    break;

                } else {

                    i += sizeof(long);

                    nzrun_len += sizeof(long);

                }

            }

        }



        d += uleb128_encode_small(dst + d, nzrun_len);

        /* overflow */

        if (d + nzrun_len > dlen) {

            return -1;

        }

        memcpy(dst + d, nzrun_start, nzrun_len);

        d += nzrun_len;

        nzrun_len = 0;

    }



    return d;

}
",460,"int xbzrle_encode_buffer(uint8_t *old_buf, uint8_t *new_buf, int slen,

                         uint8_t *dst, int dlen)

{

    uint32_t zrunner_l = 0, nzrun_len = 0;

    int d = 0, i = 0;

    long res, xor;

    uint8_t *nzrun_start = NULL;



    g_assert(!(((uintptr_t)old_buf | (uintptr_t)new_buf | slen) %

               sizeof(long)));



    while (i < slen) {

        /* overflow */

        if (d + 2 > dlen) {

            return -1;

        }



        /* not aligned to sizeof(long) */

        res = (slen - i) % sizeof(long);

        while (res && old_buf[i] == new_buf[i]) {

            zrunner_l++;

            i++;

            res--;

        }



        /* word at a time for speed */

        if (!res) {

            while (i < slen &&

                   (*(long *)(old_buf + i)) == (*(long *)(new_buf + i))) {

                i += sizeof(long);

                zrunner_l += sizeof(long);

            }



            /* go over the rest */

            while (i < slen && old_buf[i] == new_buf[i]) {

                zrunner_l++;

                i++;

            }

        }



        /* buffer unchanged */

        if (zrunner_l == slen) {

            return 0;

        }



        /* skip last zero run */

        if (i == slen) {

            return d;

        }



        d += uleb128_encode_small(dst + d, zrunner_l);



        zrunner_l = 0;

        nzrun_start = new_buf + i;



        /* overflow */

        if (d + 2 > dlen) {

            return -1;

        }

        /* not aligned to sizeof(long) */

        res = (slen - i) % sizeof(long);

        while (res && old_buf[i] != new_buf[i]) {

            i++;

            nzrun_len++;

            res--;

        }



        /* word at a time for speed, use of 32-bit long okay */

        if (!res) {

            /* truncation to 32-bit long okay */

            long mask = (long)0x0101010101010101ULL;

            while (i < slen) {

                xor = *(long *)(old_buf + i) ^ *(long *)(new_buf + i);

                if ((xor - mask) & ~xor & (mask << 7)) {

                    /* found the end of an nzrun within the current long */

                    while (old_buf[i] != new_buf[i]) {

                        nzrun_len++;

                        i++;

                    }

                    break;

                } else {

                    i += sizeof(long);

                    nzrun_len += sizeof(long);

                }

            }

        }



        d += uleb128_encode_small(dst + d, nzrun_len);

        /* overflow */

        if (d + nzrun_len > dlen) {

            return -1;

        }

        memcpy(dst + d, nzrun_start, nzrun_len);

        d += nzrun_len;

        nzrun_len = 0;

    }



    return d;

}
",1,1,0.0,1,"old_buf,new_buf,slen,dst,dlen,res,xor,nzrun_start,i,zrun_len,nzrun_len","old_buf:0.169948011636734,new_buf:0.14715689420700073,slen:0.08195924758911133,dst:0.058131635189056396,dlen:0.017703115940093994,res:-0.056331902742385864,xor:0.0516035258769989,nzrun_start:0.07577455043792725,i:-0.09325474500656128,zrun_len:0.2557738423347473,nzrun_len:-0.020315587520599365,",1.0,7.0,"zrun_len:zrunner_l,",Greedy,169,0.1136596918106079
318,"static inline int get_block(GetBitContext *gb, DCTELEM *block, const uint8_t *scan,

                            const uint32_t *quant) {

    int coeff, i, n;

    int8_t ac;

    uint8_t dc = get_bits(gb, 8);



    // block not coded

    if (dc == 255)




    // number of non-zero coefficients

    coeff = get_bits(gb, 6);

    if (get_bits_count(gb) + (coeff << 1) >= gb->size_in_bits)




    // normally we would only need to clear the (63 - coeff) last values,

    // but since we do not know where they are we just clear the whole block

    memset(block, 0, 64 * sizeof(DCTELEM));



    // 2 bits per coefficient

    while (coeff) {

        ac = get_sbits(gb, 2);

        if (ac == -2)

            break; // continue with more bits

        PUT_COEFF(ac);

    }



    // 4 bits per coefficient

    ALIGN(4);



    while (coeff) {

        ac = get_sbits(gb, 4);

        if (ac == -8)

            break; // continue with more bits

        PUT_COEFF(ac);

    }



    // 8 bits per coefficient

    ALIGN(8);

    if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits)


    while (coeff) {

        ac = get_sbits(gb, 8);

        PUT_COEFF(ac);

    }



    PUT_COEFF(dc);

    return 1;

}",202,"static inline int get_block(GetBitContext *gb, DCTELEM *channel, const uint8_t *scan,

                            const uint32_t *quant) {

    int coeff, i, n;

    int8_t tc;

    uint8_t dc = get_bits(gb, 8);



    // block not coded

    if (dc == 255)




    // number of non-zero coefficients

    coeff = get_bits(gb, 6);

    if (get_bits_count(gb) + (coeff << 1) >= gb->size_in_bits)




    // normally we would only need to clear the (63 - coeff) last values,

    // but since we do not know where they are we just clear the whole block

    memset(channel, 0, 64 * sizeof(DCTELEM));



    // 2 bits per coefficient

    while (coeff) {

        tc = get_sbits(gb, 2);

        if (tc == -2)

            break; // continue with more bits

        PUT_COEFF(tc);

    }



    // 4 bits per coefficient

    ALIGN(4);



    while (coeff) {

        tc = get_sbits(gb, 4);

        if (tc == -8)

            break; // continue with more bits

        PUT_COEFF(tc);

    }



    // 8 bits per coefficient

    ALIGN(8);

    if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits)


    while (coeff) {

        tc = get_sbits(gb, 8);

        PUT_COEFF(tc);

    }



    PUT_COEFF(dc);

    return 1;

}",1,1,0.0,1,"gb,block,scan,quant,coeff,i,n,ac","gb:-0.009118497371673584,block:-0.005476176738739014,scan:-0.02781820297241211,quant:-0.02148270606994629,coeff:-0.02071458101272583,i:-0.00830000638961792,n:-0.016637802124023438,ac:0.005470752716064453,",2.0,11.0,"ac:tc,block:channel,",Greedy,135,0.0856196522712707
337,"static int esp_pci_scsi_init(PCIDevice *dev)

{

    PCIESPState *pci = PCI_ESP(dev);

    DeviceState *d = DEVICE(dev);

    ESPState *s = &pci->esp;

    uint8_t *pci_conf;

    Error *err = NULL;



    pci_conf = dev->config;



    /* Interrupt pin A */

    pci_conf[PCI_INTERRUPT_PIN] = 0x01;



    s->dma_memory_read = esp_pci_dma_memory_read;

    s->dma_memory_write = esp_pci_dma_memory_write;

    s->dma_opaque = pci;

    s->chip_id = TCHI_AM53C974;

    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,

                          ""esp-io"", 0x80);



    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);

    s->irq = pci_allocate_irq(dev);



    scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);

    if (!d->hotplugged) {

        scsi_bus_legacy_handle_cmdline(&s->bus, &err);

        if (err != NULL) {


            error_free(err);

            return -1;

        }

    }

    return 0;

}",191,"static int esp_pci_scsi_init(PCIDevice *diff)

{

    PCIESPState *pci = PCI_ESP(diff);

    DeviceState *fd = DEVICE(diff);

    ESPState *self = &pci->esp;

    uint8_t *pci_info;

    Error *ev = NULL;



    pci_info = diff->config;



    /* Interrupt pin A */

    pci_info[PCI_INTERRUPT_PIN] = 0x01;



    self->dma_memory_read = esp_pci_dma_memory_read;

    self->dma_memory_write = esp_pci_dma_memory_write;

    self->dma_opaque = pci;

    self->chip_id = TCHI_AM53C974;

    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,

                          ""esp-io"", 0x80);



    pci_register_bar(diff, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);

    self->irq = pci_allocate_irq(diff);



    scsi_bus_new(&self->bus, sizeof(self->bus), fd, &esp_pci_scsi_info, NULL);

    if (!fd->hotplugged) {

        scsi_bus_legacy_handle_cmdline(&self->bus, &ev);

        if (ev != NULL) {


            error_free(ev);

            return -1;

        }

    }

    return 0;

}",1,1,0.0,1,"dev,pci,d,s,pci_conf,err","dev:-0.06456908583641052,pci:-0.08460935950279236,d:-0.026890993118286133,s:-0.03226342797279358,pci_conf:0.046316444873809814,err:0.017516374588012695,",5.0,25.0,"pci_conf:pci_info,err:ev,d:fd,s:self,dev:diff,",Greedy,278,0.1891026457150777
338,"static void copy_frame(Jpeg2000EncoderContext *s)

{

    int tileno, compno, i, y, x;

    uint8_t *line;

    for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++){

        Jpeg2000Tile *tile = s->tile + tileno;

        if (s->planar){

            for (compno = 0; compno < s->ncomponents; compno++){

                Jpeg2000Component *comp = tile->comp + compno;

                int *dst = comp->data;

                line = s->picture.data[compno]

                       + comp->coord[1][0] * s->picture.linesize[compno]

                       + comp->coord[0][0];

                for (y = comp->coord[1][0]; y < comp->coord[1][1]; y++){

                    uint8_t *ptr = line;

                    for (x = comp->coord[0][0]; x < comp->coord[0][1]; x++)

                        *dst++ = *ptr++ - (1 << 7);

                    line += s->picture.linesize[compno];

                }

            }

        } else{

            line = s->picture.data[0] + tile->comp[0].coord[1][0] * s->picture.linesize[0]

                   + tile->comp[0].coord[0][0] * s->ncomponents;



            i = 0;

            for (y = tile->comp[0].coord[1][0]; y < tile->comp[0].coord[1][1]; y++){

                uint8_t *ptr = line;

                for (x = tile->comp[0].coord[0][0]; x < tile->comp[0].coord[0][1]; x++, i++){

                    for (compno = 0; compno < s->ncomponents; compno++){

                        tile->comp[compno].data[i] = *ptr++  - (1 << 7);

                    }

                }

                line += s->picture.linesize[0];

            }

        }

    }

}
",432,"static void copy_frame(Jpeg2000EncoderContext *sys)

{

    int tileno, compno, i, type, php;

    uint8_t *line;

    for (tileno = 0; tileno < sys->numXtiles * sys->numYtiles; tileno++){

        Jpeg2000Tile *tle = sys->tle + tileno;

        if (sys->planar){

            for (compno = 0; compno < sys->ncomponents; compno++){

                Jpeg2000Component *comp = tle->comp + compno;

                int *dst = comp->data;

                line = sys->picture.data[compno]

                       + comp->coord[1][0] * sys->picture.linesize[compno]

                       + comp->coord[0][0];

                for (type = comp->coord[1][0]; type < comp->coord[1][1]; type++){

                    uint8_t *ptr = line;

                    for (php = comp->coord[0][0]; php < comp->coord[0][1]; php++)

                        *dst++ = *ptr++ - (1 << 7);

                    line += sys->picture.linesize[compno];

                }

            }

        } else{

            line = sys->picture.data[0] + tle->comp[0].coord[1][0] * sys->picture.linesize[0]

                   + tle->comp[0].coord[0][0] * sys->ncomponents;



            i = 0;

            for (type = tle->comp[0].coord[1][0]; type < tle->comp[0].coord[1][1]; type++){

                uint8_t *ptr = line;

                for (php = tle->comp[0].coord[0][0]; php < tle->comp[0].coord[0][1]; php++, i++){

                    for (compno = 0; compno < sys->ncomponents; compno++){

                        tle->comp[compno].data[i] = *ptr++  - (1 << 7);

                    }

                }

                line += sys->picture.linesize[0];

            }

        }

    }

}
",1,1,0.0,1,"s,tileno,compno,i,y,x,line,tile,comp,dst,ptr","s:0.04635822772979736,tileno:-0.008039236068725586,compno:-0.03184026479721069,i:-0.014515340328216553,y:0.002259373664855957,x:0.016451656818389893,line:-0.037364065647125244,tile:-0.0012329816818237305,comp:-0.02762758731842041,dst:-0.09017080068588257,ptr:-0.10142046213150024,",4.0,38.0,"s:sys,x:php,y:type,tile:tle,",Greedy,373,0.2415910482406616
342,"int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)

{

    int64_t intnum=1;

    double num=1;

    int den=1;



    av_get_number(obj, name, o_out, &num, &den, &intnum);

    return num*intnum/den;

}
",60,"int64_t av_get_int(void *prefix, const char *comment, const AVOption **o__outs)

{

    int64_t intnum=1;

    double num=1;

    int den=1;



    av_get_number(prefix, comment, o__outs, &num, &den, &intnum);

    return num*intnum/den;

}
",1,1,0.0,1,"obj,name,o_out","obj:-0.06468349695205688,name:-0.04023665189743042,o_out:0.010570526123046875,",3.0,6.0,"o_out:o__outs,name:comment,obj:prefix,",Greedy,94,0.0636369506518046
356,"static int zero12v_decode_frame(AVCodecContext *avctx, void *data,

                                int *got_frame, AVPacket *avpkt)

{

    int line = 0, ret;

    const int width = avctx->width;

    AVFrame *pic = data;

    uint16_t *y, *u, *v;

    const uint8_t *line_end, *src = avpkt->data;

    int stride = avctx->width * 8 / 3;



    if (width == 1) {

        av_log(avctx, AV_LOG_ERROR, ""Width 1 not supported.\n"");

        return AVERROR_INVALIDDATA;

    }



    if (   avctx->codec_tag == MKTAG('0', '1', '2', 'v')

        && avpkt->size % avctx->height == 0

        && avpkt->size / avctx->height * 3 >= width * 8)

        stride = avpkt->size / avctx->height;



    if (avpkt->size < avctx->height * stride) {

        av_log(avctx, AV_LOG_ERROR, ""Packet too small: %d instead of %d\n"",

               avpkt->size, avctx->height * stride);

        return AVERROR_INVALIDDATA;

    }



    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)

        return ret;



    pic->pict_type = AV_PICTURE_TYPE_I;

    pic->key_frame = 1;



    y = (uint16_t *)pic->data[0];

    u = (uint16_t *)pic->data[1];

    v = (uint16_t *)pic->data[2];

    line_end = avpkt->data + stride;



    while (line++ < avctx->height) {

        while (1) {

            uint32_t t = AV_RL32(src);

            src += 4;

            *u++ = t <<  6 & 0xFFC0;

            *y++ = t >>  4 & 0xFFC0;

            *v++ = t >> 14 & 0xFFC0;



            if (src >= line_end - 1) {

                *y = 0x80;

                src++;

                line_end += stride;

                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);

                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);

                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);

                break;

            }



            t = AV_RL32(src);

            src += 4;

            *y++ = t <<  6 & 0xFFC0;

            *u++ = t >>  4 & 0xFFC0;

            *y++ = t >> 14 & 0xFFC0;

            if (src >= line_end - 2) {

                if (!(width & 1)) {

                    *y = 0x80;

                    src += 2;

                }

                line_end += stride;

                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);

                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);

                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);

                break;

            }



            t = AV_RL32(src);

            src += 4;

            *v++ = t <<  6 & 0xFFC0;

            *y++ = t >>  4 & 0xFFC0;

            *u++ = t >> 14 & 0xFFC0;



            if (src >= line_end - 1) {

                *y = 0x80;

                src++;

                line_end += stride;

                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);

                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);

                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);

                break;

            }



            t = AV_RL32(src);

            src += 4;

            *y++ = t <<  6 & 0xFFC0;

            *v++ = t >>  4 & 0xFFC0;

            *y++ = t >> 14 & 0xFFC0;



            if (src >= line_end - 2) {

                if (width & 1) {

                    *y = 0x80;

                    src += 2;

                }

                line_end += stride;

                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);

                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);

                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);

                break;

            }

        }

    }



    *got_frame = 1;



    return avpkt->size;

}
",865,"static int zero12v_decode_frame(AVCodecContext *avelc, void *data,

                                int *got_frame, AVPacket *avnpacket)

{

    int line = 0, ret;

    const int width = avelc->width;

    AVFrame *ctrl = data;

    uint16_t *y, *u, *v;

    const uint8_t *line_end, *src = avnpacket->data;

    int stride = avelc->width * 8 / 3;



    if (width == 1) {

        av_log(avelc, AV_LOG_ERROR, ""Width 1 not supported.
"");

        return AVERROR_INVALIDDATA;

    }



    if (   avelc->codec_tag == MKTAG('0', '1', '2', 'v')

        && avnpacket->size % avelc->height == 0

        && avnpacket->size / avelc->height * 3 >= width * 8)

        stride = avnpacket->size / avelc->height;



    if (avnpacket->size < avelc->height * stride) {

        av_log(avelc, AV_LOG_ERROR, ""Packet too small: %d instead of %d
"",

               avnpacket->size, avelc->height * stride);

        return AVERROR_INVALIDDATA;

    }



    if ((ret = ff_get_buffer(avelc, ctrl, 0)) < 0)

        return ret;



    ctrl->pict_type = AV_PICTURE_TYPE_I;

    ctrl->key_frame = 1;



    y = (uint16_t *)ctrl->data[0];

    u = (uint16_t *)ctrl->data[1];

    v = (uint16_t *)ctrl->data[2];

    line_end = avnpacket->data + stride;



    while (line++ < avelc->height) {

        while (1) {

            uint32_t t = AV_RL32(src);

            src += 4;

            *u++ = t <<  6 & 0xFFC0;

            *y++ = t >>  4 & 0xFFC0;

            *v++ = t >> 14 & 0xFFC0;



            if (src >= line_end - 1) {

                *y = 0x80;

                src++;

                line_end += stride;

                y = (uint16_t *)(ctrl->data[0] + line * ctrl->linesize[0]);

                u = (uint16_t *)(ctrl->data[1] + line * ctrl->linesize[1]);

                v = (uint16_t *)(ctrl->data[2] + line * ctrl->linesize[2]);

                break;

            }



            t = AV_RL32(src);

            src += 4;

            *y++ = t <<  6 & 0xFFC0;

            *u++ = t >>  4 & 0xFFC0;

            *y++ = t >> 14 & 0xFFC0;

            if (src >= line_end - 2) {

                if (!(width & 1)) {

                    *y = 0x80;

                    src += 2;

                }

                line_end += stride;

                y = (uint16_t *)(ctrl->data[0] + line * ctrl->linesize[0]);

                u = (uint16_t *)(ctrl->data[1] + line * ctrl->linesize[1]);

                v = (uint16_t *)(ctrl->data[2] + line * ctrl->linesize[2]);

                break;

            }



            t = AV_RL32(src);

            src += 4;

            *v++ = t <<  6 & 0xFFC0;

            *y++ = t >>  4 & 0xFFC0;

            *u++ = t >> 14 & 0xFFC0;



            if (src >= line_end - 1) {

                *y = 0x80;

                src++;

                line_end += stride;

                y = (uint16_t *)(ctrl->data[0] + line * ctrl->linesize[0]);

                u = (uint16_t *)(ctrl->data[1] + line * ctrl->linesize[1]);

                v = (uint16_t *)(ctrl->data[2] + line * ctrl->linesize[2]);

                break;

            }



            t = AV_RL32(src);

            src += 4;

            *y++ = t <<  6 & 0xFFC0;

            *v++ = t >>  4 & 0xFFC0;

            *y++ = t >> 14 & 0xFFC0;



            if (src >= line_end - 2) {

                if (width & 1) {

                    *y = 0x80;

                    src += 2;

                }

                line_end += stride;

                y = (uint16_t *)(ctrl->data[0] + line * ctrl->linesize[0]);

                u = (uint16_t *)(ctrl->data[1] + line * ctrl->linesize[1]);

                v = (uint16_t *)(ctrl->data[2] + line * ctrl->linesize[2]);

                break;

            }

        }

    }



    *got_frame = 1;



    return avnpacket->size;

}
",1,1,0.0,1,"avctx,data,got_frame,avpkt,ret,pic,y,u,v,line_end,src,line","avctx:0.0461079478263855,data:-0.028539299964904785,got_frame:0.0056191086769104,avpkt:0.03556889295578003,ret:-0.0281752347946167,pic:0.011057257652282715,y:-0.032388150691986084,u:-0.011113107204437256,v:-0.00615006685256958,line_end:-0.030781984329223633,src:-0.02231687307357788,line:0.0031121373176574707,",3.0,53.0,"avctx:avelc,avpkt:avnpacket,pic:ctrl,",Greedy,478,0.3429720362027486
359,"static void piix3_class_init(ObjectClass *klass, void *data)

{

    DeviceClass *dc = DEVICE_CLASS(klass);

    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);



    dc->desc        = ""ISA bridge"";

    dc->vmsd        = &vmstate_piix3;

    dc->no_user     = 1,

    k->no_hotplug   = 1;

    k->init         = piix3_initfn;

    k->config_write = piix3_write_config;

    k->vendor_id    = PCI_VENDOR_ID_INTEL;

    /* 82371SB PIIX3 PCI-to-ISA bridge (Step A1) */

    k->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;

    k->class_id     = PCI_CLASS_BRIDGE_ISA;

}
",88,"static void piix3_class_init(ObjectClass *Klasses, void *config)

{

    DeviceClass *device = DEVICE_CLASS(Klasses);

    PCIDeviceClass *kind = PCI_DEVICE_CLASS(Klasses);



    device->desc        = ""ISA bridge"";

    device->vmsd        = &vmstate_piix3;

    device->no_user     = 1,

    kind->no_hotplug   = 1;

    kind->init         = piix3_initfn;

    kind->config_write = piix3_write_config;

    kind->vendor_id    = PCI_VENDOR_ID_INTEL;

    /* 82371SB PIIX3 PCI-to-ISA bridge (Step A1) */

    kind->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;

    kind->class_id     = PCI_CLASS_BRIDGE_ISA;

}
",1,1,0.0,1,"klass,data,dc,k","klass:0.6295708417892456,data:0.07091599702835083,dc:0.06444531679153442,k:0.0066956281661987305,",4.0,15.0,"klass:Klasses,data:config,dc:device,k:kind,",Greedy,161,0.1237467964490254
367,"static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)

{

    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);

    outw(0xcfc, value);

}
",45,"static void qpci_pc_config_writew(QPCIBus *port, int devfn, uint8_t style, uint16_t message)

{

    outl(0xcf8, (1 << 31) | (devfn << 8) | style);

    outw(0xcfc, message);

}
",1,1,0.0,1,"bus,devfn,offset,value","bus:0.2206333875656128,devfn:0.14749643206596375,offset:0.1803208589553833,value:0.20211082696914673,",3.0,5.0,"bus:port,value:message,offset:style,",Greedy,102,0.0830545465151468
371,"static void gen_exception_return(DisasContext *s, TCGv_i32 pc)

{

    TCGv_i32 tmp;

    store_reg(s, 15, pc);

    tmp = load_cpu_field(spsr);

    gen_set_cpsr(tmp, CPSR_ERET_MASK);

    tcg_temp_free_i32(tmp);

    s->is_jmp = DISAS_UPDATE;

}
",50,"static void gen_exception_return(DisasContext *ctx, TCGv_i32 px)

{

    TCGv_i32 cmp;

    store_reg(ctx, 15, px);

    cmp = load_cpu_field(spsr);

    gen_set_cpsr(cmp, CPSR_ERET_MASK);

    tcg_temp_free_i32(cmp);

    ctx->is_jmp = DISAS_UPDATE;

}
",1,1,0.0,1,"s,pc,tmp","s:-0.0366787314414978,pc:0.030762791633605957,tmp:-0.056909263134002686,",3.0,9.0,"pc:px,s:ctx,tmp:cmp,",Greedy,146,0.1074709097544352
378,"static void set_int8(Object *obj, Visitor *v, void *opaque,

                     const char *name, Error **errp)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop = opaque;

    int8_t *ptr = qdev_get_prop_ptr(dev, prop);

    Error *local_err = NULL;

    int64_t value;



    if (dev->state != DEV_STATE_CREATED) {

        error_set(errp, QERR_PERMISSION_DENIED);

        return;

    }



    visit_type_int(v, &value, name, &local_err);

    if (local_err) {

        error_propagate(errp, local_err);

        return;

    }

    if (value > prop->info->min && value <= prop->info->max) {

        *ptr = value;

    } else {

        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,

                  dev->id?:"""", name, value, prop->info->min,

                  prop->info->max);

    }

}
",170,"static void set_int8(Object *obj, Visitor *v, void *opaque,

                     const char *name, Error **err)

{

    DeviceState *dev = DEVICE(obj);

    Property *prop = opaque;

    int8_t *ptr = qdev_get_prop_ptr(dev, prop);

    Error *localipstatus = NULL;

    int64_t value;



    if (dev->state != DEV_STATE_CREATED) {

        error_set(err, QERR_PERMISSION_DENIED);

        return;

    }



    visit_type_int(v, &value, name, &localipstatus);

    if (localipstatus) {

        error_propagate(err, localipstatus);

        return;

    }

    if (value > prop->info->min && value <= prop->info->max) {

        *ptr = value;

    } else {

        error_set(err, QERR_PROPERTY_VALUE_OUT_OF_RANGE,

                  dev->id?:"""", name, value, prop->info->min,

                  prop->info->max);

    }

}
",1,1,0.0,1,"obj,v,opaque,name,errp,dev,prop,ptr,local_err,value","obj:0.04388359189033508,v:-0.02796807885169983,opaque:0.0023069679737091064,name:-0.05570527911186218,errp:0.14622578024864197,dev:-0.025950998067855835,prop:0.0044942498207092285,ptr:0.031158089637756348,local_err:0.1553475558757782,value:-0.02800002694129944,",2.0,8.0,"local_err:localipstatus,errp:err,",Greedy,118,0.0926395416259765
380,"static int decode_channel_residues(WmallDecodeCtx *s, int ch, int tile_size)

{

    int i = 0;

    unsigned int ave_mean;

    s->transient[ch] = get_bits1(&s->gb);

    if (s->transient[ch]) {

        s->transient_pos[ch] = get_bits(&s->gb, av_log2(tile_size));

        if (s->transient_pos[ch])

            s->transient[ch] = 0;

        s->channel[ch].transient_counter =

            FFMAX(s->channel[ch].transient_counter, s->samples_per_frame / 2);

    } else if (s->channel[ch].transient_counter)

        s->transient[ch] = 1;



    if (s->seekable_tile) {

        ave_mean = get_bits(&s->gb, s->bits_per_sample);

        s->ave_sum[ch] = ave_mean << (s->movave_scaling + 1);

    }



    if (s->seekable_tile) {

        if (s->do_inter_ch_decorr)

            s->channel_residues[ch][0] = get_sbits(&s->gb, s->bits_per_sample + 1);

        else

            s->channel_residues[ch][0] = get_sbits(&s->gb, s->bits_per_sample);

        i++;

    }

    for (; i < tile_size; i++) {

        int quo = 0, rem, rem_bits, residue;

        while(get_bits1(&s->gb)) {

            quo++;

            if (get_bits_left(&s->gb) <= 0)

                return -1;

        }

        if (quo >= 32)

            quo += get_bits_long(&s->gb, get_bits(&s->gb, 5) + 1);



        ave_mean = (s->ave_sum[ch] + (1 << s->movave_scaling)) >> (s->movave_scaling + 1);

        if (ave_mean <= 1)

            residue = quo;

        else {

            rem_bits = av_ceil_log2(ave_mean);

            rem      = rem_bits ? get_bits(&s->gb, rem_bits) : 0;

            residue  = (quo << rem_bits) + rem;

        }



        s->ave_sum[ch] = residue + s->ave_sum[ch] -

                         (s->ave_sum[ch] >> s->movave_scaling);



        if (residue & 1)

            residue = -(residue >> 1) - 1;

        else

            residue = residue >> 1;

        s->channel_residues[ch][i] = residue;

    }



    return 0;



}
",462,"static int decode_channel_residues(WmallDecodeCtx *l, int cp, int tile_size)

{

    int i = 0;

    unsigned int ave_mean;

    l->transient[cp] = get_bits1(&l->gb);

    if (l->transient[cp]) {

        l->transient_pos[cp] = get_bits(&l->gb, av_log2(tile_size));

        if (l->transient_pos[cp])

            l->transient[cp] = 0;

        l->channel[cp].transient_counter =

            FFMAX(l->channel[cp].transient_counter, l->samples_per_frame / 2);

    } else if (l->channel[cp].transient_counter)

        l->transient[cp] = 1;



    if (l->seekable_tile) {

        ave_mean = get_bits(&l->gb, l->bits_per_sample);

        l->ave_sum[cp] = ave_mean << (l->movave_scaling + 1);

    }



    if (l->seekable_tile) {

        if (l->do_inter_ch_decorr)

            l->channel_residues[cp][0] = get_sbits(&l->gb, l->bits_per_sample + 1);

        else

            l->channel_residues[cp][0] = get_sbits(&l->gb, l->bits_per_sample);

        i++;

    }

    for (; i < tile_size; i++) {

        int quo = 0, remote, rem_bits, Residue;

        while(get_bits1(&l->gb)) {

            quo++;

            if (get_bits_left(&l->gb) <= 0)

                return -1;

        }

        if (quo >= 32)

            quo += get_bits_long(&l->gb, get_bits(&l->gb, 5) + 1);



        ave_mean = (l->ave_sum[cp] + (1 << l->movave_scaling)) >> (l->movave_scaling + 1);

        if (ave_mean <= 1)

            Residue = quo;

        else {

            rem_bits = av_ceil_log2(ave_mean);

            remote      = rem_bits ? get_bits(&l->gb, rem_bits) : 0;

            Residue  = (quo << rem_bits) + remote;

        }



        l->ave_sum[cp] = Residue + l->ave_sum[cp] -

                         (l->ave_sum[cp] >> l->movave_scaling);



        if (Residue & 1)

            Residue = -(Residue >> 1) - 1;

        else

            Residue = Residue >> 1;

        l->channel_residues[cp][i] = Residue;

    }



    return 0;



}
",1,1,0.0,1,"s,ch,tile_size,ave_mean,i,rem,rem_bits,residue,quo","s:-0.0011841058731079102,ch:0.001013725996017456,tile_size:-0.05418407917022705,ave_mean:-0.09074205160140991,i:-0.0027589797973632812,rem:0.006421416997909546,rem_bits:-0.017836183309555054,residue:0.03377309441566467,quo:-0.01014477014541626,",4.0,70.0,"residue:Residue,rem:remote,ch:cp,s:l,",Greedy,323,0.2243683139483133
394,"void qemu_put_be32(QEMUFile *f, unsigned int v)

{

    qemu_put_byte(f, v >> 24);

    qemu_put_byte(f, v >> 16);

    qemu_put_byte(f, v >> 8);

    qemu_put_byte(f, v);

}
",47,"void qemu_put_be32(QEMUFile *l, unsigned int v)

{

    qemu_put_byte(l, v >> 24);

    qemu_put_byte(l, v >> 16);

    qemu_put_byte(l, v >> 8);

    qemu_put_byte(l, v);

}
",1,1,0.0,1,"f,v","f:-0.00167044997215271,v:-0.23410803079605103,",1.0,5.0,"f:l,",Greedy,56,0.0419031858444213
398,"int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx,
                     uint8_t **poutbuf, int *poutbuf_size,
                     const uint8_t *buf, int buf_size,
                     int64_t pts, int64_t dts, int64_t pos)
{
    int index, i;
    uint8_t dummy_buf[AV_INPUT_BUFFER_PADDING_SIZE];
    if (!(s->flags & PARSER_FLAG_FETCHED_OFFSET)) {
        s->next_frame_offset =
        s->cur_offset        = pos;
        s->flags            |= PARSER_FLAG_FETCHED_OFFSET;
    }
    if (buf_size == 0) {
        /* padding is always necessary even if EOF, so we add it here */
        memset(dummy_buf, 0, sizeof(dummy_buf));
        buf = dummy_buf;
    } else if (s->cur_offset + buf_size != s->cur_frame_end[s->cur_frame_start_index]) { /* skip remainder packets */
        /* add a new packet descriptor */
        i = (s->cur_frame_start_index + 1) & (AV_PARSER_PTS_NB - 1);
        s->cur_frame_start_index = i;
        s->cur_frame_offset[i]   = s->cur_offset;
        s->cur_frame_end[i]      = s->cur_offset + buf_size;
        s->cur_frame_pts[i]      = pts;
        s->cur_frame_dts[i]      = dts;
        s->cur_frame_pos[i]      = pos;
    }
    if (s->fetch_timestamp) {
        s->fetch_timestamp = 0;
        s->last_pts        = s->pts;
        s->last_dts        = s->dts;
        s->last_pos        = s->pos;
        ff_fetch_timestamp(s, 0, 0, 0);
    }
    /* WARNING: the returned index can be negative */
    index = s->parser->parser_parse(s, avctx, (const uint8_t **) poutbuf,
                                    poutbuf_size, buf, buf_size);
    av_assert0(index > -0x20000000); // The API does not allow returning AVERROR codes
    /* update the file pointer */
    if (*poutbuf_size) {
        /* fill the data for the current frame */
        s->frame_offset = s->next_frame_offset;
        /* offset of the next frame */
        s->next_frame_offset = s->cur_offset + index;
        s->fetch_timestamp   = 1;
    }
    if (index < 0)
        index = 0;
    s->cur_offset += index;
    return index;
}",329,"int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx,
                     uint8_t **poutbuf, int *poutbuf_size,
                     const uint8_t *buf, int buf_size,
                     int64_t apts, int64_t dts, int64_t state)
{
    int index, type;
    uint8_t dummy_buf[AV_INPUT_BUFFER_PADDING_SIZE];
    if (!(s->flags & PARSER_FLAG_FETCHED_OFFSET)) {
        s->next_frame_offset =
        s->cur_offset        = state;
        s->flags            |= PARSER_FLAG_FETCHED_OFFSET;
    }
    if (buf_size == 0) {
        /* padding is always necessary even if EOF, so we add it here */
        memset(dummy_buf, 0, sizeof(dummy_buf));
        buf = dummy_buf;
    } else if (s->cur_offset + buf_size != s->cur_frame_end[s->cur_frame_start_index]) { /* skip remainder packets */
        /* add a new packet descriptor */
        type = (s->cur_frame_start_index + 1) & (AV_PARSER_PTS_NB - 1);
        s->cur_frame_start_index = type;
        s->cur_frame_offset[type]   = s->cur_offset;
        s->cur_frame_end[type]      = s->cur_offset + buf_size;
        s->cur_frame_pts[type]      = apts;
        s->cur_frame_dts[type]      = dts;
        s->cur_frame_pos[type]      = state;
    }
    if (s->fetch_timestamp) {
        s->fetch_timestamp = 0;
        s->last_pts        = s->apts;
        s->last_dts        = s->dts;
        s->last_pos        = s->state;
        ff_fetch_timestamp(s, 0, 0, 0);
    }
    /* WARNING: the returned index can be negative */
    index = s->parser->parser_parse(s, avctx, (const uint8_t **) poutbuf,
                                    poutbuf_size, buf, buf_size);
    av_assert0(index > -0x20000000); // The API does not allow returning AVERROR codes
    /* update the file pointer */
    if (*poutbuf_size) {
        /* fill the data for the current frame */
        s->frame_offset = s->next_frame_offset;
        /* offset of the next frame */
        s->next_frame_offset = s->cur_offset + index;
        s->fetch_timestamp   = 1;
    }
    if (index < 0)
        index = 0;
    s->cur_offset += index;
    return index;
}",1,1,0.0,1,"s,avctx,poutbuf,poutbuf_size,buf,buf_size,pts,dts,pos,index,i,dummy_buf","s:-0.006436049938201904,avctx:-0.020547568798065186,poutbuf:-0.013817548751831055,poutbuf_size:-0.009267628192901611,buf:-0.01531893014907837,buf_size:-0.027349889278411865,pts:0.007831692695617676,dts:-0.007479727268218994,pos:-0.0004532337188720703,index:-0.05375403165817261,i:-0.0002574920654296875,dummy_buf:-0.019551753997802734,",3.0,15.0,"pts:apts,i:type,pos:state,",Greedy,232,0.1586475531260172
