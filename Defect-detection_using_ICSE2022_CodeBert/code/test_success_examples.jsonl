[{"project": "test", "commit_id": "test", "target": 1, "func": "static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block)\n\n{\n\n    int i;\n\n    int dc = block[0];\n\n    const uint8_t *cm;\n\n    dc = (3 * dc +  1) >> 1;\n\n    dc = (3 * dc + 16) >> 5;\n\n    cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n    for(i = 0; i < 8; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += linesize;\n\n    }\n\n}\n", "idx": 121}, {"project": "test", "commit_id": "test", "target": 1, "func": "void OPPROTO op_udiv_T1_T0(void)\n{\n    uint64_t x0;\n    uint32_t x1;\n    x0 = T0 | ((uint64_t) (env->y) << 32);\n    x1 = T1;\n    x0 = x0 / x1;\n    if (x0 > 0xffffffff) {\n\tT0 = 0xffffffff;\n\tT1 = 1;\n    } else {\n\tT0 = x0;\n\tT1 = 0;\n    FORCE_RET();", "idx": 164}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc)\n{\n    uint8_t symbols[256];\n    uint8_t bits[256];\n    uint16_t codes[256];\n    int num_lens, num_codes, num_codes_sum, prefix;\n    int i, j, count;\n    prefix        = 0;\n    count         = 0;\n    num_codes_sum = 0;\n    num_lens = get_bits(gb, 5);\n    for (i = 0; i < num_lens; i++) {\n        num_codes      = get_bits(gb, 9);\n        num_codes_sum += num_codes;\n        if (num_codes_sum > 256) {\n            av_log(ctx->avctx, AV_LOG_ERROR,\n                   \"Too many VLCs (%d) to be read.\\n\", num_codes_sum);\n        for (j = 0; j < num_codes; j++) {\n            symbols[count] = get_bits(gb, 8);\n            bits[count]    = i + 1;\n            codes[count]   = prefix++;\n            count++;\n        if (prefix > (65535 - 256)/2) {\n        prefix <<= 1;\n    return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1,\n                              codes, 2, 2, symbols, 1, 1, 0);", "idx": 244}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void usbredir_bulk_packet(void *priv, uint32_t id,\n\n    struct usb_redir_bulk_packet_header *bulk_packet,\n\n    uint8_t *data, int data_len)\n\n{\n\n    USBRedirDevice *dev = priv;\n\n    uint8_t ep = bulk_packet->endpoint;\n\n    int len = bulk_packet->length;\n\n    AsyncURB *aurb;\n\n\n\n    DPRINTF(\"bulk-in status %d ep %02X len %d id %u\\n\", bulk_packet->status,\n\n            ep, len, id);\n\n\n\n    aurb = async_find(dev, id);\n\n    if (!aurb) {\n\n        free(data);\n\n        return;\n\n    }\n\n\n\n    if (aurb->bulk_packet.endpoint != bulk_packet->endpoint ||\n\n            aurb->bulk_packet.stream_id != bulk_packet->stream_id) {\n\n        ERROR(\"return bulk packet mismatch, please report this!\\n\");\n\n        len = USB_RET_NAK;\n\n    }\n\n\n\n    if (aurb->packet) {\n\n        len = usbredir_handle_status(dev, bulk_packet->status, len);\n\n        if (len > 0) {\n\n            usbredir_log_data(dev, \"bulk data in:\", data, data_len);\n\n            if (data_len <= aurb->packet->len) {\n\n                memcpy(aurb->packet->data, data, data_len);\n\n            } else {\n\n                ERROR(\"bulk buffer too small (%d > %d)\\n\", data_len,\n\n                      aurb->packet->len);\n\n                len = USB_RET_STALL;\n\n            }\n\n        }\n\n        aurb->packet->len = len;\n\n        usb_packet_complete(&dev->dev, aurb->packet);\n\n    }\n\n    async_free(dev, aurb);\n\n    free(data);\n\n}\n", "idx": 248}, {"project": "test", "commit_id": "test", "target": 1, "func": "static av_cold int hevc_init_context(AVCodecContext *avctx)\n{\n    HEVCContext *s = avctx->priv_data;\n    int i;\n    s->avctx = avctx;\n    s->HEVClc = av_mallocz(sizeof(HEVCLocalContext));\n    if (!s->HEVClc)\n        goto fail;\n    s->HEVClcList[0] = s->HEVClc;\n    s->sList[0] = s;\n    s->cabac_state = av_malloc(HEVC_CONTEXTS);\n    if (!s->cabac_state)\n        goto fail;\n    s->output_frame = av_frame_alloc();\n    if (!s->output_frame)\n        goto fail;\n    for (i = 0; i < FF_ARRAY_ELEMS(s->DPB); i++) {\n        s->DPB[i].frame = av_frame_alloc();\n        if (!s->DPB[i].frame)\n            goto fail;\n        s->DPB[i].tf.f = s->DPB[i].frame;\n    }\n    s->max_ra = INT_MAX;\n    s->md5_ctx = av_md5_alloc();\n    if (!s->md5_ctx)\n        goto fail;\n    ff_bswapdsp_init(&s->bdsp);\n    s->context_initialized = 1;\n    s->eos = 0;\n    return 0;\nfail:\n    hevc_decode_free(avctx);\n    return AVERROR(ENOMEM);\n}", "idx": 262}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s,\n\n                             uint32_t length)\n\n{\n\n    int n, i, r, g, b;\n\n\n\n    if ((length % 3) != 0 || length > 256 * 3)\n\n        return AVERROR_INVALIDDATA;\n\n    /* read the palette */\n\n    n = length / 3;\n\n    for (i = 0; i < n; i++) {\n\n        r = bytestream2_get_byte(&s->gb);\n\n        g = bytestream2_get_byte(&s->gb);\n\n        b = bytestream2_get_byte(&s->gb);\n\n        s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b;\n\n    }\n\n    for (; i < 256; i++)\n\n        s->palette[i] = (0xFFU << 24);\n\n    s->state |= PNG_PLTE;\n\n    bytestream2_skip(&s->gb, 4);     /* crc */\n\n\n\n    return 0;\n\n}\n", "idx": 265}, {"project": "test", "commit_id": "test", "target": 1, "func": "void st_flush_trace_buffer(void)\n\n{\n\n    if (trace_file_enabled) {\n\n        flush_trace_file();\n\n    }\n\n\n\n    /* Discard written trace records */\n\n    trace_idx = 0;\n\n}\n", "idx": 280}, {"project": "test", "commit_id": "test", "target": 1, "func": "void stream_start(const char *job_id, BlockDriverState *bs,\n\n                  BlockDriverState *base, const char *backing_file_str,\n\n                  int64_t speed, BlockdevOnError on_error,\n\n                  BlockCompletionFunc *cb, void *opaque, Error **errp)\n\n{\n\n    StreamBlockJob *s;\n\n\n\n    s = block_job_create(job_id, &stream_job_driver, bs, speed,\n\n                         cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->base = base;\n\n    s->backing_file_str = g_strdup(backing_file_str);\n\n\n\n    s->on_error = on_error;\n\n    s->common.co = qemu_coroutine_create(stream_run);\n\n    trace_stream_start(bs, base, s, s->common.co, opaque);\n\n    qemu_coroutine_enter(s->common.co, s);\n\n}\n", "idx": 369}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int omap_gpio_init(SysBusDevice *sbd)\n\n{\n\n    DeviceState *dev = DEVICE(sbd);\n\n    struct omap_gpif_s *s = OMAP1_GPIO(dev);\n\n\n\n    if (!s->clk) {\n\n        hw_error(\"omap-gpio: clk not connected\\n\");\n\n    }\n\n    qdev_init_gpio_in(dev, omap_gpio_set, 16);\n\n    qdev_init_gpio_out(dev, s->omap1.handler, 16);\n\n    sysbus_init_irq(sbd, &s->omap1.irq);\n\n    memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1,\n\n                          \"omap.gpio\", 0x1000);\n\n    sysbus_init_mmio(sbd, &s->iomem);\n\n    return 0;\n\n}\n", "idx": 373}, {"project": "test", "commit_id": "test", "target": 1, "func": "int ff_alloc_entries(AVCodecContext *avctx, int count)\n\n{\n\n    int i;\n\n\n\n    if (avctx->active_thread_type & FF_THREAD_SLICE)  {\n\n        SliceThreadContext *p = avctx->internal->thread_ctx;\n\n        p->thread_count  = avctx->thread_count;\n\n        p->entries       = av_mallocz_array(count, sizeof(int));\n\n\n\n        if (!p->entries) {\n\n            return AVERROR(ENOMEM);\n\n        }\n\n\n\n        p->entries_count  = count;\n\n        p->progress_mutex = av_malloc_array(p->thread_count, sizeof(pthread_mutex_t));\n\n        p->progress_cond  = av_malloc_array(p->thread_count, sizeof(pthread_cond_t));\n\n\n\n        for (i = 0; i < p->thread_count; i++) {\n\n            pthread_mutex_init(&p->progress_mutex[i], NULL);\n\n            pthread_cond_init(&p->progress_cond[i], NULL);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 439}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int bfi_decode_frame(AVCodecContext *avctx, void *data,\n\n                            int *data_size, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data, *buf_end = avpkt->data + avpkt->size;\n\n    int buf_size = avpkt->size;\n\n    BFIContext *bfi = avctx->priv_data;\n\n    uint8_t *dst = bfi->dst;\n\n    uint8_t *src, *dst_offset, colour1, colour2;\n\n    uint8_t *frame_end = bfi->dst + avctx->width * avctx->height;\n\n    uint32_t *pal;\n\n    int i, j, height = avctx->height;\n\n\n\n    if (bfi->frame.data[0])\n\n        avctx->release_buffer(avctx, &bfi->frame);\n\n\n\n    bfi->frame.reference = 1;\n\n\n\n    if (avctx->get_buffer(avctx, &bfi->frame) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    /* Set frame parameters and palette, if necessary */\n\n    if (!avctx->frame_number) {\n\n        bfi->frame.pict_type = AV_PICTURE_TYPE_I;\n\n        bfi->frame.key_frame = 1;\n\n        /* Setting the palette */\n\n        if (avctx->extradata_size > 768) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Palette is too large.\\n\");\n\n            return -1;\n\n        }\n\n        pal = (uint32_t *)bfi->frame.data[1];\n\n        for (i = 0; i < avctx->extradata_size / 3; i++) {\n\n            int shift = 16;\n\n            *pal = 0;\n\n            for (j = 0; j < 3; j++, shift -= 8)\n\n                *pal +=\n\n                    ((avctx->extradata[i * 3 + j] << 2) |\n\n                    (avctx->extradata[i * 3 + j] >> 4)) << shift;\n\n            pal++;\n\n        }\n\n        bfi->frame.palette_has_changed = 1;\n\n    } else {\n\n        bfi->frame.pict_type = AV_PICTURE_TYPE_P;\n\n        bfi->frame.key_frame = 0;\n\n    }\n\n\n\n    buf += 4; // Unpacked size, not required.\n\n\n\n    while (dst != frame_end) {\n\n        static const uint8_t lentab[4] = { 0, 2, 0, 1 };\n\n        unsigned int byte   = *buf++, av_uninit(offset);\n\n        unsigned int code   = byte >> 6;\n\n        unsigned int length = byte & ~0xC0;\n\n\n\n        if (buf >= buf_end) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"Input resolution larger than actual frame.\\n\");\n\n            return -1;\n\n        }\n\n\n\n        /* Get length and offset(if required) */\n\n        if (length == 0) {\n\n            if (code == 1) {\n\n                length = bytestream_get_byte(&buf);\n\n                offset = bytestream_get_le16(&buf);\n\n            } else {\n\n                length = bytestream_get_le16(&buf);\n\n                if (code == 2 && length == 0)\n\n                    break;\n\n            }\n\n        } else {\n\n            if (code == 1)\n\n                offset = bytestream_get_byte(&buf);\n\n        }\n\n\n\n        /* Do boundary check */\n\n        if (dst + (length << lentab[code]) > frame_end)\n\n            break;\n\n\n\n        switch (code) {\n\n\n\n        case 0:                //Normal Chain\n\n            if (length >= buf_end - buf) {\n\n                av_log(avctx, AV_LOG_ERROR, \"Frame larger than buffer.\\n\");\n\n                return -1;\n\n            }\n\n            bytestream_get_buffer(&buf, dst, length);\n\n            dst += length;\n\n            break;\n\n\n\n        case 1:                //Back Chain\n\n            dst_offset = dst - offset;\n\n            length *= 4;        //Convert dwords to bytes.\n\n            if (dst_offset < bfi->dst)\n\n                break;\n\n            while (length--)\n\n                *dst++ = *dst_offset++;\n\n            break;\n\n\n\n        case 2:                //Skip Chain\n\n            dst += length;\n\n            break;\n\n\n\n        case 3:                //Fill Chain\n\n            colour1 = bytestream_get_byte(&buf);\n\n            colour2 = bytestream_get_byte(&buf);\n\n            while (length--) {\n\n                *dst++ = colour1;\n\n                *dst++ = colour2;\n\n            }\n\n            break;\n\n\n\n        }\n\n    }\n\n\n\n    src = bfi->dst;\n\n    dst = bfi->frame.data[0];\n\n    while (height--) {\n\n        memcpy(dst, src, avctx->width);\n\n        src += avctx->width;\n\n        dst += bfi->frame.linesize[0];\n\n    }\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame *)data = bfi->frame;\n\n    return buf_size;\n\n}\n", "idx": 490}, {"project": "test", "commit_id": "test", "target": 1, "func": "int cpu_exec(CPUState *cpu)\n\n{\n\n    CPUClass *cc = CPU_GET_CLASS(cpu);\n\n    int ret;\n\n    SyncClocks sc;\n\n\n\n    /* replay_interrupt may need current_cpu */\n\n    current_cpu = cpu;\n\n\n\n    if (cpu_handle_halt(cpu)) {\n\n        return EXCP_HALTED;\n\n    }\n\n\n\n    rcu_read_lock();\n\n\n\n    cc->cpu_exec_enter(cpu);\n\n\n\n    /* Calculate difference between guest clock and host clock.\n\n     * This delay includes the delay of the last cycle, so\n\n     * what we have to do is sleep until it is 0. As for the\n\n     * advance/delay we gain here, we try to fix it next time.\n\n     */\n\n    init_delay_params(&sc, cpu);\n\n\n\n    /* prepare setjmp context for exception handling */\n\n    if (sigsetjmp(cpu->jmp_env, 0) != 0) {\n\n#if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6)\n\n        /* Some compilers wrongly smash all local variables after\n\n         * siglongjmp. There were bug reports for gcc 4.5.0 and clang.\n\n         * Reload essential local variables here for those compilers.\n\n         * Newer versions of gcc would complain about this code (-Wclobbered). */\n\n        cpu = current_cpu;\n\n        cc = CPU_GET_CLASS(cpu);\n\n#else /* buggy compiler */\n\n        /* Assert that the compiler does not smash local variables. */\n\n        g_assert(cpu == current_cpu);\n\n        g_assert(cc == CPU_GET_CLASS(cpu));\n\n#endif /* buggy compiler */\n\n        cpu->can_do_io = 1;\n\n        tb_lock_reset();\n\n        if (qemu_mutex_iothread_locked()) {\n\n            qemu_mutex_unlock_iothread();\n\n        }\n\n    }\n\n\n\n    /* if an exception is pending, we execute it here */\n\n    while (!cpu_handle_exception(cpu, &ret)) {\n\n        TranslationBlock *last_tb = NULL;\n\n        int tb_exit = 0;\n\n\n\n        while (!cpu_handle_interrupt(cpu, &last_tb)) {\n\n            TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit);\n\n            cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc);\n\n            /* Try to align the host and virtual clocks\n\n               if the guest is in advance */\n\n            align_clocks(&sc, cpu);\n\n        }\n\n    }\n\n\n\n    cc->cpu_exec_exit(cpu);\n\n    rcu_read_unlock();\n\n\n\n    /* fail safe : never use current_cpu outside cpu_exec() */\n\n    current_cpu = NULL;\n\n\n\n    return ret;\n\n}\n", "idx": 539}, {"project": "test", "commit_id": "test", "target": 1, "func": "CommandInfoList *qmp_query_commands(Error **errp)\n\n{\n\n    CommandInfoList *list = NULL;\n\n\n\n    qmp_for_each_command(&qmp_commands, query_commands_cb, &list);\n\n\n\n    return list;\n\n}\n", "idx": 574}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame,\n\n                         unsigned int c, const unsigned int *div_blocks,\n\n                         unsigned int *js_blocks)\n\n{\n\n    ALSSpecificConfig *sconf = &ctx->sconf;\n\n    unsigned int offset = 0;\n\n    unsigned int b;\n\n    ALSBlockData bd[2] = { { 0 } };\n\n\n\n    bd[0].ra_block         = ra_frame;\n\n    bd[0].const_block      = ctx->const_block;\n\n    bd[0].shift_lsbs       = ctx->shift_lsbs;\n\n    bd[0].opt_order        = ctx->opt_order;\n\n    bd[0].store_prev_samples = ctx->store_prev_samples;\n\n    bd[0].use_ltp          = ctx->use_ltp;\n\n    bd[0].ltp_lag          = ctx->ltp_lag;\n\n    bd[0].ltp_gain         = ctx->ltp_gain[0];\n\n    bd[0].quant_cof        = ctx->quant_cof[0];\n\n    bd[0].lpc_cof          = ctx->lpc_cof[0];\n\n    bd[0].prev_raw_samples = ctx->prev_raw_samples;\n\n    bd[0].js_blocks        = *js_blocks;\n\n\n\n    bd[1].ra_block         = ra_frame;\n\n    bd[1].const_block      = ctx->const_block;\n\n    bd[1].shift_lsbs       = ctx->shift_lsbs;\n\n    bd[1].opt_order        = ctx->opt_order;\n\n    bd[1].store_prev_samples = ctx->store_prev_samples;\n\n    bd[1].use_ltp          = ctx->use_ltp;\n\n    bd[1].ltp_lag          = ctx->ltp_lag;\n\n    bd[1].ltp_gain         = ctx->ltp_gain[0];\n\n    bd[1].quant_cof        = ctx->quant_cof[0];\n\n    bd[1].lpc_cof          = ctx->lpc_cof[0];\n\n    bd[1].prev_raw_samples = ctx->prev_raw_samples;\n\n    bd[1].js_blocks        = *(js_blocks + 1);\n\n\n\n    // decode all blocks\n\n    for (b = 0; b < ctx->num_blocks; b++) {\n\n        unsigned int s;\n\n\n\n        bd[0].block_length = div_blocks[b];\n\n        bd[1].block_length = div_blocks[b];\n\n\n\n        bd[0].raw_samples  = ctx->raw_samples[c    ] + offset;\n\n        bd[1].raw_samples  = ctx->raw_samples[c + 1] + offset;\n\n\n\n        bd[0].raw_other    = bd[1].raw_samples;\n\n        bd[1].raw_other    = bd[0].raw_samples;\n\n\n\n        if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) {\n\n            // damaged block, write zero for the rest of the frame\n\n            zero_remaining(b, ctx->num_blocks, div_blocks, bd[0].raw_samples);\n\n            zero_remaining(b, ctx->num_blocks, div_blocks, bd[1].raw_samples);\n\n            return -1;\n\n        }\n\n\n\n        // reconstruct joint-stereo blocks\n\n        if (bd[0].js_blocks) {\n\n            if (bd[1].js_blocks)\n\n                av_log(ctx->avctx, AV_LOG_WARNING, \"Invalid channel pair!\\n\");\n\n\n\n            for (s = 0; s < div_blocks[b]; s++)\n\n                bd[0].raw_samples[s] = bd[1].raw_samples[s] - bd[0].raw_samples[s];\n\n        } else if (bd[1].js_blocks) {\n\n            for (s = 0; s < div_blocks[b]; s++)\n\n                bd[1].raw_samples[s] = bd[1].raw_samples[s] + bd[0].raw_samples[s];\n\n        }\n\n\n\n        offset  += div_blocks[b];\n\n        bd[0].ra_block = 0;\n\n        bd[1].ra_block = 0;\n\n    }\n\n\n\n    // store carryover raw samples,\n\n    // the others channel raw samples are stored by the calling function.\n\n    memmove(ctx->raw_samples[c] - sconf->max_order,\n\n            ctx->raw_samples[c] - sconf->max_order + sconf->frame_length,\n\n            sizeof(*ctx->raw_samples[c]) * sconf->max_order);\n\n\n\n    return 0;\n\n}\n", "idx": 585}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int libopenjpeg_copy_packed12(AVCodecContext *avctx, const AVFrame *frame, opj_image_t *image)\n\n{\n\n    int compno;\n\n    int x, y;\n\n    int *image_line;\n\n    int frame_index;\n\n    const int numcomps  = image->numcomps;\n\n    uint16_t *frame_ptr = (uint16_t *)frame->data[0];\n\n\n\n    for (compno = 0; compno < numcomps; ++compno) {\n\n        if (image->comps[compno].w > frame->linesize[0] / numcomps) {\n\n            av_log(avctx, AV_LOG_ERROR, \"Error: frame's linesize is too small for the image\\n\");\n\n            return 0;\n\n        }\n\n    }\n\n\n\n    for (compno = 0; compno < numcomps; ++compno) {\n\n        for (y = 0; y < avctx->height; ++y) {\n\n            image_line = image->comps[compno].data + y * image->comps[compno].w;\n\n            frame_index = y * (frame->linesize[0] / 2) + compno;\n\n            for (x = 0; x < avctx->width; ++x) {\n\n                image_line[x] = frame_ptr[frame_index] >> 4;\n\n                frame_index += numcomps;\n\n            }\n\n            for (; x < image->comps[compno].w; ++x) {\n\n                image_line[x] = image_line[x - 1];\n\n            }\n\n        }\n\n        for (; y < image->comps[compno].h; ++y) {\n\n            image_line = image->comps[compno].data + y * image->comps[compno].w;\n\n            for (x = 0; x < image->comps[compno].w; ++x) {\n\n                image_line[x] = image_line[x - image->comps[compno].w];\n\n            }\n\n        }\n\n    }\n\n\n\n    return 1;\n\n}\n", "idx": 657}, {"project": "test", "commit_id": "test", "target": 1, "func": "void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)\n\n{\n\n\tlong i;\n\n/*\n\n\twrites 1 byte o much and might cause alignment issues on some architectures?\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t\t((unsigned *)(&dst[i*3])) = ((unsigned *)palette)[ src[i] ];\n\n*/\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t\t//FIXME slow?\n\n\t\tdst[0]= palette[ src[i]*4+0 ];\n\n\t\tdst[1]= palette[ src[i]*4+1 ];\n\n\t\tdst[2]= palette[ src[i]*4+2 ];\n\n\t\tdst+= 3;\n\n\t}\n\n}\n", "idx": 674}, {"project": "test", "commit_id": "test", "target": 1, "func": "void do_POWER_maskg (void)\n\n{\n\n    uint32_t ret;\n\n\n\n    if ((uint32_t)T0 == (uint32_t)(T1 + 1)) {\n\n        ret = -1;\n\n    } else {\n\n        ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^\n\n            (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1);\n\n        if ((uint32_t)T0 > (uint32_t)T1)\n\n            ret = ~ret;\n\n    }\n\n    T0 = ret;\n\n}\n", "idx": 686}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void qed_aio_read_data(void *opaque, int ret,\n\n                              uint64_t offset, size_t len)\n\n{\n\n    QEDAIOCB *acb = opaque;\n\n    BDRVQEDState *s = acb_to_s(acb);\n\n    BlockDriverState *bs = acb->common.bs;\n\n\n\n    /* Adjust offset into cluster */\n\n    offset += qed_offset_into_cluster(s, acb->cur_pos);\n\n\n\n    trace_qed_aio_read_data(s, acb, ret, offset, len);\n\n\n\n    if (ret < 0) {\n\n        goto err;\n\n    }\n\n\n\n    qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len);\n\n\n\n    /* Handle zero cluster and backing file reads */\n\n    if (ret == QED_CLUSTER_ZERO) {\n\n        qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size);\n\n        qed_aio_next_io(acb, 0);\n\n        return;\n\n    } else if (ret != QED_CLUSTER_FOUND) {\n\n        qed_read_backing_file(s, acb->cur_pos, &acb->cur_qiov,\n\n                              qed_aio_next_io, acb);\n\n        return;\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO);\n\n    bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE,\n\n                   &acb->cur_qiov, acb->cur_qiov.size / BDRV_SECTOR_SIZE,\n\n                   qed_aio_next_io, acb);\n\n    return;\n\n\n\nerr:\n\n    qed_aio_complete(acb, ret);\n\n}\n", "idx": 707}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int read_major_sync(MLPDecodeContext *m, GetBitContext *gb)\n\n{\n\n    MLPHeaderInfo mh;\n\n    int substr, ret;\n\n\n\n    if ((ret = ff_mlp_read_major_sync(m->avctx, &mh, gb)) != 0)\n\n        return ret;\n\n\n\n    if (mh.group1_bits == 0) {\n\n        av_log(m->avctx, AV_LOG_ERROR, \"invalid/unknown bits per sample\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.group2_bits > mh.group1_bits) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Channel group 2 cannot have more bits per sample than group 1.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n    if (mh.group2_samplerate && mh.group2_samplerate != mh.group1_samplerate) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Channel groups with differing sample rates are not currently supported.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n    if (mh.group1_samplerate == 0) {\n\n        av_log(m->avctx, AV_LOG_ERROR, \"invalid/unknown sampling rate\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.group1_samplerate > MAX_SAMPLERATE) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Sampling rate %d is greater than the supported maximum (%d).\\n\",\n\n               mh.group1_samplerate, MAX_SAMPLERATE);\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.access_unit_size > MAX_BLOCKSIZE) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Block size %d is greater than the supported maximum (%d).\\n\",\n\n               mh.access_unit_size, MAX_BLOCKSIZE);\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.access_unit_size_pow2 > MAX_BLOCKSIZE_POW2) {\n\n        av_log(m->avctx, AV_LOG_ERROR,\n\n               \"Block size pow2 %d is greater than the supported maximum (%d).\\n\",\n\n               mh.access_unit_size_pow2, MAX_BLOCKSIZE_POW2);\n\n        return AVERROR_INVALIDDATA;\n\n\n\n\n    if (mh.num_substreams == 0)\n\n        return AVERROR_INVALIDDATA;\n\n    if (m->avctx->codec_id == AV_CODEC_ID_MLP && mh.num_substreams > 2) {\n\n        av_log(m->avctx, AV_LOG_ERROR, \"MLP only supports up to 2 substreams.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n\n    if (mh.num_substreams > MAX_SUBSTREAMS) {\n\n\n                              \"%d substreams (more than the \"\n\n                              \"maximum supported by the decoder)\",\n\n                              mh.num_substreams);\n\n\n\n\n\n    m->access_unit_size      = mh.access_unit_size;\n\n    m->access_unit_size_pow2 = mh.access_unit_size_pow2;\n\n\n\n    m->num_substreams        = mh.num_substreams;\n\n    m->max_decoded_substream = m->num_substreams - 1;\n\n\n\n    m->avctx->sample_rate    = mh.group1_samplerate;\n\n    m->avctx->frame_size     = mh.access_unit_size;\n\n\n\n    m->avctx->bits_per_raw_sample = mh.group1_bits;\n\n    if (mh.group1_bits > 16)\n\n        m->avctx->sample_fmt = AV_SAMPLE_FMT_S32;\n\n    else\n\n        m->avctx->sample_fmt = AV_SAMPLE_FMT_S16;\n\n\n\n    m->params_valid = 1;\n\n    for (substr = 0; substr < MAX_SUBSTREAMS; substr++)\n\n        m->substream[substr].restart_seen = 0;\n\n\n\n    /* Set the layout for each substream. When there's more than one, the first\n\n     * substream is Stereo. Subsequent substreams' layouts are indicated in the\n\n     * major sync. */\n\n    if (m->avctx->codec_id == AV_CODEC_ID_MLP) {\n\n\n\n\n\n\n\n        if ((substr = (mh.num_substreams > 1)))\n\n            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;\n\n        m->substream[substr].ch_layout = mh.channel_layout_mlp;\n\n    } else {\n\n\n\n\n\n\n\n        if ((substr = (mh.num_substreams > 1)))\n\n            m->substream[0].ch_layout = AV_CH_LAYOUT_STEREO;\n\n        if (mh.num_substreams > 2)\n\n            if (mh.channel_layout_thd_stream2)\n\n                m->substream[2].ch_layout = mh.channel_layout_thd_stream2;\n\n            else\n\n                m->substream[2].ch_layout = mh.channel_layout_thd_stream1;\n\n        m->substream[substr].ch_layout = mh.channel_layout_thd_stream1;\n\n\n\n        if (m->avctx->channels<=2 && m->substream[substr].ch_layout == AV_CH_LAYOUT_MONO && m->max_decoded_substream == 1) {\n\n            av_log(m->avctx, AV_LOG_DEBUG, \"Mono stream with 2 substreams, ignoring 2nd\\n\");\n\n            m->max_decoded_substream = 0;\n\n            if (m->avctx->channels==2)\n\n                m->avctx->channel_layout = AV_CH_LAYOUT_STEREO;\n\n\n\n\n\n    m->needs_reordering = mh.channel_arrangement >= 18 && mh.channel_arrangement <= 20;\n\n\n\n    return 0;\n", "idx": 748}, {"project": "test", "commit_id": "test", "target": 1, "func": "static AVStream * init_stream(AVFormatContext *s)\n\n{\n\n    BinDemuxContext *bin = s->priv_data;\n\n    AVStream *st = avformat_new_stream(s, NULL);\n\n    if (!st)\n\n        return NULL;\n\n    st->codec->codec_tag   = 0;\n\n    st->codec->codec_type  = AVMEDIA_TYPE_VIDEO;\n\n\n\n    if (!bin->width) {\n\n        st->codec->width  = (80<<3);\n\n        st->codec->height = (25<<4);\n\n    }\n\n\n\n    avpriv_set_pts_info(st, 60, bin->framerate.den, bin->framerate.num);\n\n\n\n    /* simulate tty display speed */\n\n    bin->chars_per_frame = FFMAX(av_q2d(st->time_base) * bin->chars_per_frame, 1);\n\n\n\n    return st;\n\n}\n", "idx": 767}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b)\n\n{\n\n    int sa, sb;\n\n    sa = ((int64_t)*phigh < 0);\n\n    if (sa)\n\n        neg128(plow, phigh);\n\n    sb = (b < 0);\n\n    if (sb)\n\n        b = -b;\n\n    div64(plow, phigh, b);\n\n    if (sa ^ sb)\n\n        *plow = - *plow;\n\n    if (sa)\n\n        *phigh = - *phigh;\n\n}\n", "idx": 848}, {"project": "test", "commit_id": "test", "target": 1, "func": "MigrationState *exec_start_outgoing_migration(const char *command,\n\n                                             int64_t bandwidth_limit,\n\n                                             int async)\n\n{\n\n    FdMigrationState *s;\n\n    FILE *f;\n\n\n\n    s = qemu_mallocz(sizeof(*s));\n\n    if (s == NULL) {\n\n        dprintf(\"Unable to allocate FdMigrationState\\n\");\n\n        goto err;\n\n    }\n\n\n\n    f = popen(command, \"w\");\n\n    if (f == NULL) {\n\n        dprintf(\"Unable to popen exec target\\n\");\n\n        goto err_after_alloc;\n\n    }\n\n\n\n    s->fd = fileno(f);\n\n    if (s->fd == -1) {\n\n        dprintf(\"Unable to retrieve file descriptor for popen'd handle\\n\");\n\n        goto err_after_open;\n\n    }\n\n\n\n    if (fcntl(s->fd, F_SETFD, O_NONBLOCK) == -1) {\n\n        dprintf(\"Unable to set nonblocking mode on file descriptor\\n\");\n\n        goto err_after_open;\n\n    }\n\n\n\n    s->opaque = qemu_popen(f, \"w\");\n\n\n\n\n    s->get_error = file_errno;\n\n    s->write = file_write;\n\n    s->mig_state.cancel = migrate_fd_cancel;\n\n    s->mig_state.get_status = migrate_fd_get_status;\n\n    s->mig_state.release = migrate_fd_release;\n\n\n\n    s->state = MIG_STATE_ACTIVE;\n\n    s->detach = !async;\n\n    s->bandwidth_limit = bandwidth_limit;\n\n\n\n    if (s->detach == 1) {\n\n        dprintf(\"detaching from monitor\\n\");\n\n        monitor_suspend();\n\n        s->detach = 2;\n\n    }\n\n\n\n    migrate_fd_connect(s);\n\n    return &s->mig_state;\n\n\n\nerr_after_open:\n\n    pclose(f);\n\nerr_after_alloc:\n\n    qemu_free(s);\n\nerr:\n\n    return NULL;\n\n}", "idx": 921}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void register_core_rtas(void)\n\n{\n\n    spapr_rtas_register(\"display-character\", rtas_display_character);\n\n    spapr_rtas_register(\"get-time-of-day\", rtas_get_time_of_day);\n\n    spapr_rtas_register(\"power-off\", rtas_power_off);\n\n\n\n\n}", "idx": 924}, {"project": "test", "commit_id": "test", "target": 1, "func": "Object *object_resolve_path_component(Object *parent, const gchar *part)\n\n{\n\n    ObjectProperty *prop = object_property_find(parent, part, NULL);\n\n    if (prop == NULL) {\n\n        return NULL;\n\n    }\n\n\n\n    if (object_property_is_link(prop)) {\n\n        return *(Object **)prop->opaque;\n\n    } else if (object_property_is_child(prop)) {\n\n        return prop->opaque;\n\n    } else {\n\n        return NULL;\n\n    }\n\n}\n", "idx": 946}, {"project": "test", "commit_id": "test", "target": 1, "func": "void commit_start(const char *job_id, BlockDriverState *bs,\n\n                  BlockDriverState *base, BlockDriverState *top, int64_t speed,\n\n                  BlockdevOnError on_error, const char *backing_file_str,\n\n                  const char *filter_node_name, Error **errp)\n\n{\n\n    CommitBlockJob *s;\n\n    BlockReopenQueue *reopen_queue = NULL;\n\n    int orig_overlay_flags;\n\n    int orig_base_flags;\n\n    BlockDriverState *iter;\n\n    BlockDriverState *overlay_bs;\n\n    BlockDriverState *commit_top_bs = NULL;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    assert(top != bs);\n\n    if (top == base) {\n\n        error_setg(errp, \"Invalid files for merge: top and base are the same\");\n\n        return;\n\n\n\n\n    overlay_bs = bdrv_find_overlay(bs, top);\n\n\n\n    if (overlay_bs == NULL) {\n\n        error_setg(errp, \"Could not find overlay image for %s:\", top->filename);\n\n        return;\n\n\n\n\n    s = block_job_create(job_id, &commit_job_driver, bs, 0, BLK_PERM_ALL,\n\n                         speed, BLOCK_JOB_DEFAULT, NULL, NULL, errp);\n\n    if (!s) {\n\n        return;\n\n\n\n\n    orig_base_flags    = bdrv_get_flags(base);\n\n    orig_overlay_flags = bdrv_get_flags(overlay_bs);\n\n\n\n    /* convert base & overlay_bs to r/w, if necessary */\n\n    if (!(orig_base_flags & BDRV_O_RDWR)) {\n\n        reopen_queue = bdrv_reopen_queue(reopen_queue, base, NULL,\n\n                                         orig_base_flags | BDRV_O_RDWR);\n\n\n    if (!(orig_overlay_flags & BDRV_O_RDWR)) {\n\n        reopen_queue = bdrv_reopen_queue(reopen_queue, overlay_bs, NULL,\n\n                                         orig_overlay_flags | BDRV_O_RDWR);\n\n\n    if (reopen_queue) {\n\n        bdrv_reopen_multiple(bdrv_get_aio_context(bs), reopen_queue, &local_err);\n\n        if (local_err != NULL) {\n\n            error_propagate(errp, local_err);\n\n            goto fail;\n\n\n\n\n\n    /* Insert commit_top block node above top, so we can block consistent read\n\n     * on the backing chain below it */\n\n    commit_top_bs = bdrv_new_open_driver(&bdrv_commit_top, filter_node_name, 0,\n\n                                         errp);\n\n    if (commit_top_bs == NULL) {\n\n        goto fail;\n\n\n\n\n\n    commit_top_bs->total_sectors = top->total_sectors;\n\n    bdrv_set_aio_context(commit_top_bs, bdrv_get_aio_context(top));\n\n\n\n    bdrv_set_backing_hd(commit_top_bs, top, &local_err);\n\n    if (local_err) {\n\n        bdrv_unref(commit_top_bs);\n\n        commit_top_bs = NULL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n    bdrv_set_backing_hd(overlay_bs, commit_top_bs, &local_err);\n\n    if (local_err) {\n\n        bdrv_unref(commit_top_bs);\n\n        commit_top_bs = NULL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    s->commit_top_bs = commit_top_bs;\n\n    bdrv_unref(commit_top_bs);\n\n\n\n    /* Block all nodes between top and base, because they will\n\n     * disappear from the chain after this operation. */\n\n    assert(bdrv_chain_contains(top, base));\n\n    for (iter = top; iter != base; iter = backing_bs(iter)) {\n\n        /* XXX BLK_PERM_WRITE needs to be allowed so we don't block ourselves\n\n         * at s->base (if writes are blocked for a node, they are also blocked\n\n         * for its backing file). The other options would be a second filter\n\n         * driver above s->base. */\n\n        ret = block_job_add_bdrv(&s->common, \"intermediate node\", iter, 0,\n\n                                 BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE,\n\n                                 errp);\n\n        if (ret < 0) {\n\n            goto fail;\n\n\n\n\n\n    ret = block_job_add_bdrv(&s->common, \"base\", base, 0, BLK_PERM_ALL, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    /* overlay_bs must be blocked because it needs to be modified to\n\n     * update the backing image string. */\n\n    ret = block_job_add_bdrv(&s->common, \"overlay of top\", overlay_bs,\n\n                             BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    s->base = blk_new(BLK_PERM_CONSISTENT_READ\n\n                      | BLK_PERM_WRITE\n\n                      | BLK_PERM_RESIZE,\n\n                      BLK_PERM_CONSISTENT_READ\n\n                      | BLK_PERM_GRAPH_MOD\n\n                      | BLK_PERM_WRITE_UNCHANGED);\n\n    ret = blk_insert_bs(s->base, base, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    /* Required permissions are already taken with block_job_add_bdrv() */\n\n    s->top = blk_new(0, BLK_PERM_ALL);\n\n    ret = blk_insert_bs(s->top, top, errp);\n\n    if (ret < 0) {\n\n        goto fail;\n\n\n\n\n    s->active = bs;\n\n\n\n    s->base_flags          = orig_base_flags;\n\n    s->orig_overlay_flags  = orig_overlay_flags;\n\n\n\n    s->backing_file_str = g_strdup(backing_file_str);\n\n\n\n    s->on_error = on_error;\n\n\n\n    trace_commit_start(bs, base, top, s);\n\n    block_job_start(&s->common);\n\n    return;\n\n\n\nfail:\n\n    if (s->base) {\n\n        blk_unref(s->base);\n\n\n    if (s->top) {\n\n        blk_unref(s->top);\n\n\n    if (commit_top_bs) {\n\n        bdrv_set_backing_hd(overlay_bs, top, &error_abort);\n\n\n    block_job_early_fail(&s->common);\n", "idx": 971}, {"project": "test", "commit_id": "test", "target": 1, "func": "void do_divwuo (void)\n\n{\n\n    if (likely((uint32_t)T1 != 0)) {\n\n        xer_ov = 0;\n\n        T0 = (uint32_t)T0 / (uint32_t)T1;\n\n    } else {\n\n        xer_so = 1;\n\n        xer_ov = 1;\n\n        T0 = 0;\n\n    }\n\n}\n", "idx": 1040}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void handle_satn(ESPState *s)\n\n{\n\n    uint8_t buf[32];\n\n    int len;\n\n\n\n    if (s->dma && !s->dma_enabled) {\n\n        s->dma_cb = handle_satn;\n\n        return;\n\n    }\n\n    len = get_cmd(s, buf);\n\n    if (len)\n\n        do_cmd(s, buf);\n\n}\n", "idx": 1056}, {"project": "test", "commit_id": "test", "target": 1, "func": "int vhost_backend_invalidate_device_iotlb(struct vhost_dev *dev,\n\n                                                 uint64_t iova, uint64_t len)\n\n{\n\n    struct vhost_iotlb_msg imsg;\n\n\n\n    imsg.iova = iova;\n\n    imsg.size = len;\n\n    imsg.type = VHOST_IOTLB_INVALIDATE;\n\n\n\n    return dev->vhost_ops->vhost_send_device_iotlb_msg(dev, &imsg);\n\n}\n", "idx": 1089}, {"project": "test", "commit_id": "test", "target": 1, "func": "FFTContext *av_fft_init(int nbits, int inverse)\n\n{\n\n    FFTContext *s = av_malloc(sizeof(*s));\n\n\n\n    if (s && ff_fft_init(s, nbits, inverse))\n\n        av_freep(&s);\n\n\n\n    return s;\n\n}\n", "idx": 1307}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void gen_set_CF_bit31(TCGv var)\n\n{\n\n    TCGv tmp = new_tmp();\n\n    tcg_gen_shri_i32(tmp, var, 31);\n\n    gen_set_CF(tmp);\n\n    dead_tmp(tmp);\n\n}\n", "idx": 1308}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int get_siz(Jpeg2000DecoderContext *s)\n{\n    int i;\n    int ncomponents;\n    uint32_t log2_chroma_wh = 0;\n    const enum AVPixelFormat *possible_fmts = NULL;\n    int possible_fmts_nb = 0;\n    if (bytestream2_get_bytes_left(&s->g) < 36) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Insufficient space for SIZ\\n\");\n    s->avctx->profile = bytestream2_get_be16u(&s->g); // Rsiz\n    s->width          = bytestream2_get_be32u(&s->g); // Width\n    s->height         = bytestream2_get_be32u(&s->g); // Height\n    s->image_offset_x = bytestream2_get_be32u(&s->g); // X0Siz\n    s->image_offset_y = bytestream2_get_be32u(&s->g); // Y0Siz\n    s->tile_width     = bytestream2_get_be32u(&s->g); // XTSiz\n    s->tile_height    = bytestream2_get_be32u(&s->g); // YTSiz\n    s->tile_offset_x  = bytestream2_get_be32u(&s->g); // XT0Siz\n    s->tile_offset_y  = bytestream2_get_be32u(&s->g); // YT0Siz\n    ncomponents       = bytestream2_get_be16u(&s->g); // CSiz\n    if (s->image_offset_x || s->image_offset_y) {\n        avpriv_request_sample(s->avctx, \"Support for image offsets\");\n        return AVERROR_PATCHWELCOME;\n    if (av_image_check_size(s->width, s->height, 0, s->avctx)) {\n        avpriv_request_sample(s->avctx, \"Large Dimensions\");\n        return AVERROR_PATCHWELCOME;\n    if (ncomponents <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid number of components: %d\\n\",\n    if (ncomponents > 4) {\n        avpriv_request_sample(s->avctx, \"Support for %d components\",\n                              ncomponents);\n        return AVERROR_PATCHWELCOME;\n    s->ncomponents = ncomponents;\n    if (s->tile_width <= 0 || s->tile_height <= 0) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Invalid tile dimension %dx%d.\\n\",\n               s->tile_width, s->tile_height);\n    if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents) {\n        av_log(s->avctx, AV_LOG_ERROR, \"Insufficient space for %d components in SIZ\\n\", s->ncomponents);\n    for (i = 0; i < s->ncomponents; i++) { // Ssiz_i XRsiz_i, YRsiz_i\n        uint8_t x    = bytestream2_get_byteu(&s->g);\n        s->cbps[i]   = (x & 0x7f) + 1;\n        s->precision = FFMAX(s->cbps[i], s->precision);\n        s->sgnd[i]   = !!(x & 0x80);\n        s->cdx[i]    = bytestream2_get_byteu(&s->g);\n        s->cdy[i]    = bytestream2_get_byteu(&s->g);\n        if (   !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4\n            || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) {\n            av_log(s->avctx, AV_LOG_ERROR, \"Invalid sample separation %d/%d\\n\", s->cdx[i], s->cdy[i]);\n        log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2;\n    s->numXtiles = ff_jpeg2000_ceildiv(s->width  - s->tile_offset_x, s->tile_width);\n    s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height);\n    if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(EINVAL);\n    s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile));\n    if (!s->tile) {\n        s->numXtiles = s->numYtiles = 0;\n        return AVERROR(ENOMEM);\n    for (i = 0; i < s->numXtiles * s->numYtiles; i++) {\n        Jpeg2000Tile *tile = s->tile + i;\n        tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp));\n        if (!tile->comp)\n            return AVERROR(ENOMEM);\n    /* compute image size with reduction factor */\n    s->avctx->width  = ff_jpeg2000_ceildivpow2(s->width  - s->image_offset_x,\n                                               s->reduction_factor);\n    s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y,\n                                               s->reduction_factor);\n    if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K ||\n        s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) {\n        possible_fmts = xyz_pix_fmts;\n        possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts);\n    } else {\n        switch (s->colour_space) {\n        case 16:\n            possible_fmts = rgb_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts);\n            break;\n        case 17:\n            possible_fmts = gray_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts);\n            break;\n        case 18:\n            possible_fmts = yuv_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts);\n            break;\n        default:\n            possible_fmts = all_pix_fmts;\n            possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts);\n            break;\n    for (i = 0; i < possible_fmts_nb; ++i) {\n        if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) {\n            s->avctx->pix_fmt = possible_fmts[i];\n            break;\n    if (i == possible_fmts_nb) {\n        if (ncomponents == 4 &&\n            s->cdy[0] == 1 && s->cdx[0] == 1 &&\n            s->cdy[1] == 1 && s->cdx[1] == 1 &&\n            s->cdy[2] == s->cdy[3] && s->cdx[2] == s->cdx[3]) {\n            if (s->precision == 8 && s->cdy[2] == 2 && s->cdx[2] == 2 && !s->pal8) {\n                s->avctx->pix_fmt = AV_PIX_FMT_YUVA420P;\n                s->cdef[0] = 0;\n                s->cdef[1] = 1;\n                s->cdef[2] = 2;\n                s->cdef[3] = 3;\n                i = 0;\n    if (i == possible_fmts_nb) {\n        av_log(s->avctx, AV_LOG_ERROR,\n               \"Unknown pix_fmt, profile: %d, colour_space: %d, \"\n               \"components: %d, precision: %d\\n\"\n               \"cdx[0]: %d, cdy[0]: %d\\n\"\n               \"cdx[1]: %d, cdy[1]: %d\\n\"\n               \"cdx[2]: %d, cdy[2]: %d\\n\"\n               \"cdx[3]: %d, cdy[3]: %d\\n\",\n               s->avctx->profile, s->colour_space, ncomponents, s->precision,\n               s->cdx[0],\n               s->cdy[0],\n               ncomponents > 1 ? s->cdx[1] : 0,\n               ncomponents > 1 ? s->cdy[1] : 0,\n               ncomponents > 2 ? s->cdx[2] : 0,\n               ncomponents > 2 ? s->cdy[2] : 0,\n               ncomponents > 3 ? s->cdx[3] : 0,\n               ncomponents > 3 ? s->cdy[3] : 0);\n        return AVERROR_PATCHWELCOME;\n    s->avctx->bits_per_raw_sample = s->precision;\n    return 0;", "idx": 1318}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void sd_1d97_int(int *p, int i0, int i1)\n\n{\n\n    int i;\n\n\n\n    if (i1 <= i0 + 1) {\n\n        if (i0 == 1)\n\n            p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16;\n\n        else\n\n            p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16;\n\n        return;\n\n    }\n\n\n\n    extend97_int(p, i0, i1);\n\n    i0++; i1++;\n\n\n\n    for (i = i0/2 - 2; i < i1/2 + 1; i++)\n\n        p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;\n\n    for (i = i0/2 - 1; i < i1/2 + 1; i++)\n\n        p[2 * i]     -= (I_LFTG_BETA  * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;\n\n    for (i = i0/2 - 1; i < i1/2; i++)\n\n        p[2 * i + 1] += (I_LFTG_GAMMA * (p[2 * i]     + p[2 * i + 2]) + (1 << 15)) >> 16;\n\n    for (i = i0/2; i < i1/2; i++)\n\n        p[2 * i]     += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16;\n\n}\n", "idx": 1338}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int width)\n\n{\n\n\tint i;\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tint r=  ((uint32_t*)src)[i]&0xFF;\n\n\t\tint g= (((uint32_t*)src)[i]>>8)&0xFF;\n\n\t\tint b= (((uint32_t*)src)[i]>>16)&0xFF;\n\n\n\n\t\tdst[i]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT);\n\n\t}\n\n}\n", "idx": 1341}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int ipmovie_read_packet(AVFormatContext *s,\n\n                               AVPacket *pkt)\n\n{\n\n    IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data;\n\n    ByteIOContext *pb = &s->pb;\n\n    int ret;\n\n\n\n    ret = process_ipmovie_chunk(ipmovie, pb, pkt);\n\n    if (ret == CHUNK_BAD)\n\n        ret = AVERROR_INVALIDDATA;\n\n    else if (ret == CHUNK_EOF)\n\n        ret = AVERROR_IO;\n\n    else if (ret == CHUNK_NOMEM)\n\n        ret = AVERROR_NOMEM;\n\n    else\n\n        ret = 0;\n\n\n\n    return ret;\n\n}\n", "idx": 1373}, {"project": "test", "commit_id": "test", "target": 1, "func": "bool qemu_co_enter_next(CoQueue *queue)\n\n{\n\n    Coroutine *next;\n\n\n\n    next = QSIMPLEQ_FIRST(&queue->entries);\n\n    if (!next) {\n\n        return false;\n\n    }\n\n\n\n    QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next);\n\n    qemu_coroutine_enter(next, NULL);\n\n    return true;\n\n}\n", "idx": 1381}, {"project": "test", "commit_id": "test", "target": 1, "func": "static target_long monitor_get_reg(const struct MonitorDef *md, int val)\n\n{\n\n    CPUState *env = mon_get_cpu();\n\n    if (!env)\n\n        return 0;\n\n    return env->regwptr[val];\n\n}\n", "idx": 1420}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void set_vlan(Object *obj, Visitor *v, void *opaque,\n\n                     const char *name, Error **errp)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop = opaque;\n\n    NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);\n\n    NetClientState **ptr = &peers_ptr->ncs[0];\n\n    Error *local_err = NULL;\n\n    int32_t id;\n\n    NetClientState *hubport;\n\n\n\n    if (dev->realized) {\n\n        qdev_prop_set_after_realize(dev, name, errp);\n\n\n\n\n\n    visit_type_int32(v, &id, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n\n\n    if (id == -1) {\n\n        *ptr = NULL;\n\n\n\n\n\n\n\n\n\n    hubport = net_hub_port_find(id);\n\n    if (!hubport) {\n\n        error_set(errp, QERR_INVALID_PARAMETER_VALUE,\n\n                  name, prop->info->name);\n\n\n\n    *ptr = hubport;\n", "idx": 1435}, {"project": "test", "commit_id": "test", "target": 1, "func": "static av_cold int png_dec_end(AVCodecContext *avctx)\n\n{\n\n    PNGDecContext *s = avctx->priv_data;\n\n\n\n    ff_thread_release_buffer(avctx, &s->previous_picture);\n\n    av_frame_free(&s->previous_picture.f);\n\n    ff_thread_release_buffer(avctx, &s->last_picture);\n\n    av_frame_free(&s->last_picture.f);\n\n    ff_thread_release_buffer(avctx, &s->picture);\n\n    av_frame_free(&s->picture.f);\n\n    av_freep(&s->buffer);\n\n    s->buffer_size = 0;\n\n    av_freep(&s->last_row);\n\n    s->last_row_size = 0;\n\n    av_freep(&s->tmp_row);\n\n    s->tmp_row_size = 0;\n\n    av_freep(&s->extra_data);\n\n    s->extra_data_size = 0;\n\n\n\n    return 0;\n\n}\n", "idx": 1439}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void filter(USPPContext *p, uint8_t *dst[3], uint8_t *src[3],\n\n                   int dst_stride[3], int src_stride[3], int width,\n\n                   int height, uint8_t *qp_store, int qp_stride)\n\n{\n\n    int x, y, i, j;\n\n    const int count = 1<<p->log2_count;\n\n\n\n    for (i = 0; i < 3; i++) {\n\n        int is_chroma = !!i;\n\n        int w = width  >> (is_chroma ? p->hsub : 0);\n\n        int h = height >> (is_chroma ? p->vsub : 0);\n\n        int stride = p->temp_stride[i];\n\n        int block = BLOCK >> (is_chroma ? p->hsub : 0);\n\n\n\n        if (!src[i] || !dst[i])\n\n            continue;\n\n        for (y = 0; y < h; y++) {\n\n            int index = block + block * stride + y * stride;\n\n\n\n            memcpy(p->src[i] + index, src[i] + y * src_stride[i], w );\n\n            for (x = 0; x < block; x++) {\n\n                p->src[i][index     - x - 1] = p->src[i][index +     x    ];\n\n                p->src[i][index + w + x    ] = p->src[i][index + w - x - 1];\n\n            }\n\n        }\n\n        for (y = 0; y < block; y++) {\n\n            memcpy(p->src[i] + (  block-1-y) * stride, p->src[i] + (  y+block  ) * stride, stride);\n\n            memcpy(p->src[i] + (h+block  +y) * stride, p->src[i] + (h-y+block-1) * stride, stride);\n\n        }\n\n\n\n        p->frame->linesize[i] = stride;\n\n        memset(p->temp[i], 0, (h + 2 * block) * stride * sizeof(int16_t));\n\n    }\n\n\n\n    if (p->qp)\n\n        p->frame->quality = p->qp * FF_QP2LAMBDA;\n\n    else {\n\n        int qpsum=0;\n\n        int qpcount = (height>>4) * (height>>4);\n\n\n\n        for (y = 0; y < (height>>4); y++) {\n\n            for (x = 0; x < (width>>4); x++)\n\n                qpsum += qp_store[x + y * qp_stride];\n\n        }\n\n        p->frame->quality = norm_qscale((qpsum + qpcount/2) / qpcount, p->qscale_type) * FF_QP2LAMBDA;\n\n    }\n\n//    init per MB qscale stuff FIXME\n\n    p->frame->height = height;\n\n    p->frame->width  = width;\n\n\n\n    for (i = 0; i < count; i++) {\n\n        const int x1 = offset[i+count-1][0];\n\n        const int y1 = offset[i+count-1][1];\n\n        const int x1c = x1 >> p->hsub;\n\n        const int y1c = y1 >> p->vsub;\n\n        const int BLOCKc = BLOCK >> p->hsub;\n\n        int offset;\n\n        AVPacket pkt;\n\n        int got_pkt_ptr;\n\n\n\n        av_init_packet(&pkt);\n\n        pkt.data = p->outbuf;\n\n        pkt.size = p->outbuf_size;\n\n\n\n        p->frame->data[0] = p->src[0] + x1   + y1   * p->frame->linesize[0];\n\n        p->frame->data[1] = p->src[1] + x1c  + y1c  * p->frame->linesize[1];\n\n        p->frame->data[2] = p->src[2] + x1c  + y1c  * p->frame->linesize[2];\n\n        p->frame->format  = p->avctx_enc[i]->pix_fmt;\n\n\n\n        avcodec_encode_video2(p->avctx_enc[i], &pkt, p->frame, &got_pkt_ptr);\n\n        p->frame_dec = p->avctx_enc[i]->coded_frame;\n\n\n\n        offset = (BLOCK-x1) + (BLOCK-y1) * p->frame_dec->linesize[0];\n\n\n\n        for (y = 0; y < height; y++)\n\n            for (x = 0; x < width; x++)\n\n                p->temp[0][x + y * p->temp_stride[0]] += p->frame_dec->data[0][x + y * p->frame_dec->linesize[0] + offset];\n\n\n\n        if (!src[2] || !dst[2])\n\n            continue;\n\n\n\n        offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p->frame_dec->linesize[1];\n\n\n\n        for (y = 0; y < height>>p->vsub; y++) {\n\n            for (x = 0; x < width>>p->hsub; x++) {\n\n                p->temp[1][x + y * p->temp_stride[1]] += p->frame_dec->data[1][x + y * p->frame_dec->linesize[1] + offset];\n\n                p->temp[2][x + y * p->temp_stride[2]] += p->frame_dec->data[2][x + y * p->frame_dec->linesize[2] + offset];\n\n            }\n\n        }\n\n    }\n\n\n\n    for (j = 0; j < 3; j++) {\n\n        int is_chroma = !!j;\n\n        if (!dst[j])\n\n            continue;\n\n        store_slice_c(dst[j], p->temp[j], dst_stride[j], p->temp_stride[j],\n\n                      width  >> (is_chroma ? p->hsub : 0),\n\n                      height >> (is_chroma ? p->vsub : 0),\n\n                      8-p->log2_count);\n\n    }\n\n}\n", "idx": 1476}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1,\n\n                                    TCGv arg2, int add_ca, int compute_ca,\n\n                                    int compute_ov)\n\n{\n\n    TCGv t0, t1;\n\n\n\n    if ((!compute_ca && !compute_ov) ||\n\n        (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2)))  {\n\n        t0 = ret;\n\n    } else {\n\n        t0 = tcg_temp_local_new();\n\n    }\n\n\n\n    if (add_ca) {\n\n        t1 = tcg_temp_local_new();\n\n        tcg_gen_mov_tl(t1, cpu_ca);\n\n    } else {\n\n        TCGV_UNUSED(t1);\n\n    }\n\n\n\n    if (compute_ca) {\n\n        /* Start with XER CA disabled, the most likely case */\n\n        tcg_gen_movi_tl(cpu_ca, 0);\n\n    }\n\n    if (compute_ov) {\n\n        /* Start with XER OV disabled, the most likely case */\n\n        tcg_gen_movi_tl(cpu_ov, 0);\n\n    }\n\n\n\n    tcg_gen_add_tl(t0, arg1, arg2);\n\n\n\n    if (compute_ca) {\n\n        gen_op_arith_compute_ca(ctx, t0, arg1, 0);\n\n    }\n\n    if (add_ca) {\n\n        tcg_gen_add_tl(t0, t0, t1);\n\n        gen_op_arith_compute_ca(ctx, t0, t1, 0);\n\n        tcg_temp_free(t1);\n\n    }\n\n    if (compute_ov) {\n\n        gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0);\n\n    }\n\n\n\n    if (unlikely(Rc(ctx->opcode) != 0))\n\n        gen_set_Rc0(ctx, t0);\n\n\n\n    if (!TCGV_EQUAL(t0, ret)) {\n\n        tcg_gen_mov_tl(ret, t0);\n\n        tcg_temp_free(t0);\n\n    }\n\n}\n", "idx": 1507}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void RENAME(rgb15tobgr24)(const uint8_t *src, uint8_t *dst, int src_size)\n\n{\n\n    const uint16_t *end;\n\n    const uint16_t *mm_end;\n\n    uint8_t *d = dst;\n\n    const uint16_t *s = (const uint16_t*)src;\n\n    end = s + src_size/2;\n\n    __asm__ volatile(PREFETCH\"    %0\"::\"m\"(*s):\"memory\");\n\n    mm_end = end - 7;\n\n    while (s < mm_end) {\n\n        __asm__ volatile(\n\n            PREFETCH\"    32%1           \\n\\t\"\n\n            \"movq          %1, %%mm0    \\n\\t\"\n\n            \"movq          %1, %%mm1    \\n\\t\"\n\n            \"movq          %1, %%mm2    \\n\\t\"\n\n            \"pand          %2, %%mm0    \\n\\t\"\n\n            \"pand          %3, %%mm1    \\n\\t\"\n\n            \"pand          %4, %%mm2    \\n\\t\"\n\n            \"psllq         $3, %%mm0    \\n\\t\"\n\n            \"psrlq         $2, %%mm1    \\n\\t\"\n\n            \"psrlq         $7, %%mm2    \\n\\t\"\n\n            \"movq       %%mm0, %%mm3    \\n\\t\"\n\n            \"movq       %%mm1, %%mm4    \\n\\t\"\n\n            \"movq       %%mm2, %%mm5    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm0    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm1    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm2    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm3    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm4    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm5    \\n\\t\"\n\n            \"psllq         $8, %%mm1    \\n\\t\"\n\n            \"psllq        $16, %%mm2    \\n\\t\"\n\n            \"por        %%mm1, %%mm0    \\n\\t\"\n\n            \"por        %%mm2, %%mm0    \\n\\t\"\n\n            \"psllq         $8, %%mm4    \\n\\t\"\n\n            \"psllq        $16, %%mm5    \\n\\t\"\n\n            \"por        %%mm4, %%mm3    \\n\\t\"\n\n            \"por        %%mm5, %%mm3    \\n\\t\"\n\n\n\n            \"movq       %%mm0, %%mm6    \\n\\t\"\n\n            \"movq       %%mm3, %%mm7    \\n\\t\"\n\n\n\n            \"movq         8%1, %%mm0    \\n\\t\"\n\n            \"movq         8%1, %%mm1    \\n\\t\"\n\n            \"movq         8%1, %%mm2    \\n\\t\"\n\n            \"pand          %2, %%mm0    \\n\\t\"\n\n            \"pand          %3, %%mm1    \\n\\t\"\n\n            \"pand          %4, %%mm2    \\n\\t\"\n\n            \"psllq         $3, %%mm0    \\n\\t\"\n\n            \"psrlq         $2, %%mm1    \\n\\t\"\n\n            \"psrlq         $7, %%mm2    \\n\\t\"\n\n            \"movq       %%mm0, %%mm3    \\n\\t\"\n\n            \"movq       %%mm1, %%mm4    \\n\\t\"\n\n            \"movq       %%mm2, %%mm5    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm0    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm1    \\n\\t\"\n\n            \"punpcklwd     %5, %%mm2    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm3    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm4    \\n\\t\"\n\n            \"punpckhwd     %5, %%mm5    \\n\\t\"\n\n            \"psllq         $8, %%mm1    \\n\\t\"\n\n            \"psllq        $16, %%mm2    \\n\\t\"\n\n            \"por        %%mm1, %%mm0    \\n\\t\"\n\n            \"por        %%mm2, %%mm0    \\n\\t\"\n\n            \"psllq         $8, %%mm4    \\n\\t\"\n\n            \"psllq        $16, %%mm5    \\n\\t\"\n\n            \"por        %%mm4, %%mm3    \\n\\t\"\n\n            \"por        %%mm5, %%mm3    \\n\\t\"\n\n\n\n            :\"=m\"(*d)\n\n            :\"m\"(*s),\"m\"(mask15b),\"m\"(mask15g),\"m\"(mask15r), \"m\"(mmx_null)\n\n            :\"memory\");\n\n        /* borrowed 32 to 24 */\n\n        __asm__ volatile(\n\n            \"movq       %%mm0, %%mm4    \\n\\t\"\n\n            \"movq       %%mm3, %%mm5    \\n\\t\"\n\n            \"movq       %%mm6, %%mm0    \\n\\t\"\n\n            \"movq       %%mm7, %%mm1    \\n\\t\"\n\n\n\n            \"movq       %%mm4, %%mm6    \\n\\t\"\n\n            \"movq       %%mm5, %%mm7    \\n\\t\"\n\n            \"movq       %%mm0, %%mm2    \\n\\t\"\n\n            \"movq       %%mm1, %%mm3    \\n\\t\"\n\n\n\n            STORE_BGR24_MMX\n\n\n\n            :\"=m\"(*d)\n\n            :\"m\"(*s)\n\n            :\"memory\");\n\n        d += 24;\n\n        s += 8;\n\n    }\n\n    __asm__ volatile(SFENCE:::\"memory\");\n\n    __asm__ volatile(EMMS:::\"memory\");\n\n    while (s < end) {\n\n        register uint16_t bgr;\n\n        bgr = *s++;\n\n        *d++ = (bgr&0x1F)<<3;\n\n        *d++ = (bgr&0x3E0)>>2;\n\n        *d++ = (bgr&0x7C00)>>7;\n\n    }\n\n}\n", "idx": 1508}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void test_qemu_strtoll_whitespace(void)\n\n{\n\n    const char *str = \"  \\t  \";\n\n    char f = 'X';\n\n    const char *endptr = &f;\n\n    int64_t res = 999;\n\n    int err;\n\n\n\n    err = qemu_strtoll(str, &endptr, 0, &res);\n\n\n\n    g_assert_cmpint(err, ==, 0);\n\n    g_assert_cmpint(res, ==, 0);\n\n    g_assert(endptr == str);\n\n}\n", "idx": 1736}, {"project": "test", "commit_id": "test", "target": 1, "func": "int ff_schro_queue_push_back(FFSchroQueue *queue, void *p_data)\n\n{\n\n    FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement));\n\n\n\n    if (!p_new)\n\n        return -1;\n\n\n\n    p_new->data = p_data;\n\n\n\n    if (!queue->p_head)\n\n        queue->p_head = p_new;\n\n    else\n\n        queue->p_tail->next = p_new;\n\n    queue->p_tail = p_new;\n\n\n\n    ++queue->size;\n\n    return 0;\n\n}\n", "idx": 1791}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n\n                            AVPacket *avpkt) {\n\n    const uint8_t *buf = avpkt->data;\n\n\n    PTXContext * const s = avctx->priv_data;\n\n    AVFrame *picture = data;\n\n    AVFrame * const p = &s->picture;\n\n    unsigned int offset, w, h, y, stride, bytes_per_pixel;\n\n    uint8_t *ptr;\n\n\n\n\n\n    offset          = AV_RL16(buf);\n\n    w               = AV_RL16(buf+8);\n\n    h               = AV_RL16(buf+10);\n\n    bytes_per_pixel = AV_RL16(buf+12) >> 3;\n\n\n\n    if (bytes_per_pixel != 2) {\n\n        av_log_ask_for_sample(avctx, \"Image format is not RGB15.\\n\");\n\n        return -1;\n\n    }\n\n\n\n    avctx->pix_fmt = PIX_FMT_RGB555;\n\n\n\n    if (buf_end - buf < offset)\n\n\n    if (offset != 0x2c)\n\n        av_log_ask_for_sample(avctx, \"offset != 0x2c\\n\");\n\n\n\n    buf += offset;\n\n\n\n    if (p->data[0])\n\n        avctx->release_buffer(avctx, p);\n\n\n\n    if (av_image_check_size(w, h, 0, avctx))\n\n        return -1;\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n    if (avctx->get_buffer(avctx, p) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    ptr    = p->data[0];\n\n    stride = p->linesize[0];\n\n\n\n    for (y=0; y<h; y++) {\n\n        if (buf_end - buf < w * bytes_per_pixel)\n\n            break;\n\n#if HAVE_BIGENDIAN\n\n        unsigned int x;\n\n        for (x=0; x<w*bytes_per_pixel; x+=bytes_per_pixel)\n\n            AV_WN16(ptr+x, AV_RL16(buf+x));\n\n#else\n\n        memcpy(ptr, buf, w*bytes_per_pixel);\n\n#endif\n\n        ptr += stride;\n\n        buf += w*bytes_per_pixel;\n\n    }\n\n\n\n    *picture = s->picture;\n\n    *data_size = sizeof(AVPicture);\n\n\n\n    return offset + w*h*bytes_per_pixel;\n\n}", "idx": 1804}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void vpc_close(BlockDriverState *bs)\n\n{\n\n    BDRVVPCState *s = bs->opaque;\n\n    g_free(s->pagetable);\n\n#ifdef CACHE\n\n    g_free(s->pageentry_u8);\n\n#endif\n\n\n\n    migrate_del_blocker(s->migration_blocker);\n\n    error_free(s->migration_blocker);\n\n}\n", "idx": 1817}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int mxf_read_header(AVFormatContext *s, AVFormatParameters *ap)\n\n{\n\n    MXFContext *mxf = s->priv_data;\n\n    KLVPacket klv;\n\n    int64_t essence_offset = 0;\n\n\n\n    mxf->last_forward_tell = INT64_MAX;\n\n\n\n    if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find header partition pack key\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, -14, SEEK_CUR);\n\n    mxf->fc = s;\n\n    mxf->run_in = avio_tell(s->pb);\n\n\n\n    while (!s->pb->eof_reached) {\n\n        const MXFMetadataReadTableEntry *metadata;\n\n\n\n        if (klv_read_packet(&klv, s->pb) < 0) {\n\n            /* EOF - seek to previous partition or stop */\n\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n\n                break;\n\n            else\n\n                continue;\n\n        }\n\n\n\n        PRINT_KEY(s, \"read header\", klv.key);\n\n        av_dlog(s, \"size %\"PRIu64\" offset %#\"PRIx64\"\\n\", klv.length, klv.offset);\n\n        if (IS_KLV_KEY(klv.key, mxf_encrypted_triplet_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_essence_element_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_avid_essence_element_key) ||\n\n            IS_KLV_KEY(klv.key, mxf_system_item_key)) {\n\n            if (!mxf->current_partition->essence_offset) {\n\n                compute_partition_essence_offset(s, mxf, &klv);\n\n            }\n\n\n\n            if (!essence_offset)\n\n                essence_offset = klv.offset;\n\n\n\n            /* seek to footer, previous partition or stop */\n\n            if (mxf_parse_handle_essence(mxf) <= 0)\n\n                break;\n\n            continue;\n\n        } else if (!memcmp(klv.key, mxf_header_partition_pack_key, 13) &&\n\n                   klv.key[13] >= 2 && klv.key[13] <= 4 && mxf->current_partition) {\n\n            /* next partition pack - keep going, seek to previous partition or stop */\n\n            if(mxf_parse_handle_partition_or_eof(mxf) <= 0)\n\n                break;\n\n        }\n\n\n\n        for (metadata = mxf_metadata_read_table; metadata->read; metadata++) {\n\n            if (IS_KLV_KEY(klv.key, metadata->key)) {\n\n                int res;\n\n                if (klv.key[5] == 0x53) {\n\n                    res = mxf_read_local_tags(mxf, &klv, metadata->read, metadata->ctx_size, metadata->type);\n\n                } else {\n\n                    uint64_t next = avio_tell(s->pb) + klv.length;\n\n                    res = metadata->read(mxf, s->pb, 0, klv.length, klv.key, klv.offset);\n\n                    avio_seek(s->pb, next, SEEK_SET);\n\n                }\n\n                if (res < 0) {\n\n                    av_log(s, AV_LOG_ERROR, \"error reading header metadata\\n\");\n\n                    return res;\n\n                }\n\n                break;\n\n            }\n\n        }\n\n        if (!metadata->read)\n\n            avio_skip(s->pb, klv.length);\n\n    }\n\n    /* FIXME avoid seek */\n\n    if (!essence_offset)  {\n\n        av_log(s, AV_LOG_ERROR, \"no essence\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    avio_seek(s->pb, essence_offset, SEEK_SET);\n\n\n\n    mxf_compute_essence_containers(mxf);\n\n\n\n    return mxf_parse_structural_metadata(mxf);\n\n}\n", "idx": 1878}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int parse_uint8(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    uint8_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    const char *fmt;\n\n\n\n    /* accept both hex and decimal */\n\n    fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx8 : \"%\" PRIu8;\n\n    if (sscanf(str, fmt, ptr) != 1)\n\n        return -EINVAL;\n\n    return 0;\n\n}\n", "idx": 1994}, {"project": "test", "commit_id": "test", "target": 1, "func": "DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)\n\n{\n\n    DeviceClass *dc;\n\n    const char *driver, *path;\n\n    DeviceState *dev;\n\n    BusState *bus = NULL;\n\n    Error *err = NULL;\n\n\n\n    driver = qemu_opt_get(opts, \"driver\");\n\n    if (!driver) {\n\n        error_setg(errp, QERR_MISSING_PARAMETER, \"driver\");\n\n        return NULL;\n\n    }\n\n\n\n    /* find driver */\n\n    dc = qdev_get_device_class(&driver, errp);\n\n    if (!dc) {\n\n        return NULL;\n\n    }\n\n\n\n    /* find bus */\n\n    path = qemu_opt_get(opts, \"bus\");\n\n    if (path != NULL) {\n\n        bus = qbus_find(path, errp);\n\n        if (!bus) {\n\n            return NULL;\n\n        }\n\n        if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) {\n\n            error_setg(errp, \"Device '%s' can't go on %s bus\",\n\n                       driver, object_get_typename(OBJECT(bus)));\n\n            return NULL;\n\n        }\n\n    } else if (dc->bus_type != NULL) {\n\n        bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type);\n\n        if (!bus || qbus_is_full(bus)) {\n\n            error_setg(errp, \"No '%s' bus found for device '%s'\",\n\n                       dc->bus_type, driver);\n\n            return NULL;\n\n        }\n\n    }\n\n    if (qdev_hotplug && bus && !qbus_is_hotpluggable(bus)) {\n\n        error_setg(errp, QERR_BUS_NO_HOTPLUG, bus->name);\n\n        return NULL;\n\n    }\n\n\n\n    if (!migration_is_idle()) {\n\n        error_setg(errp, \"device_add not allowed while migrating\");\n\n        return NULL;\n\n    }\n\n\n\n    /* create device */\n\n    dev = DEVICE(object_new(driver));\n\n\n\n    if (bus) {\n\n        qdev_set_parent_bus(dev, bus);\n\n\n\n\n\n\n    }\n\n\n\n    qdev_set_id(dev, qemu_opts_id(opts));\n\n\n\n    /* set properties */\n\n    if (qemu_opt_foreach(opts, set_property, dev, &err)) {\n\n\n    }\n\n\n\n    dev->opts = opts;\n\n    object_property_set_bool(OBJECT(dev), true, \"realized\", &err);\n\n    if (err != NULL) {\n\n        dev->opts = NULL;\n\n\n    }\n\n    return dev;\n\n\n\nerr_del_dev:\n\n    error_propagate(errp, err);\n\n    object_unparent(OBJECT(dev));\n\n    object_unref(OBJECT(dev));\n\n    return NULL;\n\n}", "idx": 2124}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign)\n\n{\n\n    unsigned nz = idx >> 12;\n\n\n\n    dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1));\n\n    sign <<= nz & 1;\n\n    nz >>= 1;\n\n    dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1));\n\n    sign <<= nz & 1;\n\n    nz >>= 1;\n\n    dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1));\n\n    sign <<= nz & 1;\n\n    nz >>= 1;\n\n    dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1));\n\n\n\n    return dst + 4;\n\n}\n", "idx": 2142}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void gen_mfrom(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC);\n\n        return;\n\n    }\n\n    gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]);\n\n#endif\n\n}\n", "idx": 2229}, {"project": "test", "commit_id": "test", "target": 1, "func": "static av_cold int init_bundles(BinkContext *c)\n\n{\n\n    int bw, bh, blocks;\n\n    int i;\n\n\n\n    bw = (c->avctx->width  + 7) >> 3;\n\n    bh = (c->avctx->height + 7) >> 3;\n\n    blocks = bw * bh;\n\n\n\n    for (i = 0; i < BINKB_NB_SRC; i++) {\n\n        c->bundle[i].data = av_malloc(blocks * 64);\n\n        if (!c->bundle[i].data)\n\n            return AVERROR(ENOMEM);\n\n        c->bundle[i].data_end = c->bundle[i].data + blocks * 64;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 2325}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n\tlong width, long height,\n\n\tlong lumStride, long chromStride, long dstStride)\n\n{\n\n\tRENAME(yuvPlanartoyuy2)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1);\n\n}\n", "idx": 2348}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int vqa_decode_init(AVCodecContext *avctx)\n\n{\n\n    VqaContext *s = (VqaContext *)avctx->priv_data;\n\n    unsigned char *vqa_header;\n\n    int i, j, codebook_index;;\n\n\n\n    s->avctx = avctx;\n\n    avctx->pix_fmt = PIX_FMT_PAL8;\n\n    avctx->has_b_frames = 0;\n\n    dsputil_init(&s->dsp, avctx);\n\n\n\n    /* make sure the extradata made it */\n\n    if (s->avctx->extradata_size != VQA_HEADER_SIZE) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"  VQA video: expected extradata size of %d\\n\", VQA_HEADER_SIZE);\n\n\n\n\n\n    /* load up the VQA parameters from the header */\n\n    vqa_header = (unsigned char *)s->avctx->extradata;\n\n    s->vqa_version = vqa_header[0];\n\n    s->width = LE_16(&vqa_header[6]);\n\n    s->height = LE_16(&vqa_header[8]);\n\n\n\n\n\n    s->vector_width = vqa_header[10];\n\n    s->vector_height = vqa_header[11];\n\n    s->partial_count = s->partial_countdown = vqa_header[13];\n\n\n\n    /* the vector dimensions have to meet very stringent requirements */\n\n    if ((s->vector_width != 4) ||\n\n        ((s->vector_height != 2) && (s->vector_height != 4))) {\n\n        /* return without further initialization */\n\n\n\n\n\n    /* allocate codebooks */\n\n    s->codebook_size = MAX_CODEBOOK_SIZE;\n\n    s->codebook = av_malloc(s->codebook_size);\n\n    s->next_codebook_buffer = av_malloc(s->codebook_size);\n\n\n\n    /* initialize the solid-color vectors */\n\n    if (s->vector_height == 4) {\n\n        codebook_index = 0xFF00 * 16;\n\n        for (i = 0; i < 256; i++)\n\n            for (j = 0; j < 16; j++)\n\n                s->codebook[codebook_index++] = i;\n\n    } else {\n\n        codebook_index = 0xF00 * 8;\n\n        for (i = 0; i < 256; i++)\n\n            for (j = 0; j < 8; j++)\n\n                s->codebook[codebook_index++] = i;\n\n\n    s->next_codebook_buffer_index = 0;\n\n\n\n    /* allocate decode buffer */\n\n    s->decode_buffer_size = (s->width / s->vector_width) *\n\n        (s->height / s->vector_height) * 2;\n\n    s->decode_buffer = av_malloc(s->decode_buffer_size);\n\n\n\n    s->frame.data[0] = NULL;\n\n\n\n    return 0;\n", "idx": 2358}, {"project": "test", "commit_id": "test", "target": 1, "func": "static bool logic_imm_decode_wmask(uint64_t *result, unsigned int immn,\n\n                                   unsigned int imms, unsigned int immr)\n\n{\n\n    uint64_t mask;\n\n    unsigned e, levels, s, r;\n\n    int len;\n\n\n\n    assert(immn < 2 && imms < 64 && immr < 64);\n\n\n\n    /* The bit patterns we create here are 64 bit patterns which\n\n     * are vectors of identical elements of size e = 2, 4, 8, 16, 32 or\n\n     * 64 bits each. Each element contains the same value: a run\n\n     * of between 1 and e-1 non-zero bits, rotated within the\n\n     * element by between 0 and e-1 bits.\n\n     *\n\n     * The element size and run length are encoded into immn (1 bit)\n\n     * and imms (6 bits) as follows:\n\n     * 64 bit elements: immn = 1, imms = <length of run - 1>\n\n     * 32 bit elements: immn = 0, imms = 0 : <length of run - 1>\n\n     * 16 bit elements: immn = 0, imms = 10 : <length of run - 1>\n\n     *  8 bit elements: immn = 0, imms = 110 : <length of run - 1>\n\n     *  4 bit elements: immn = 0, imms = 1110 : <length of run - 1>\n\n     *  2 bit elements: immn = 0, imms = 11110 : <length of run - 1>\n\n     * Notice that immn = 0, imms = 11111x is the only combination\n\n     * not covered by one of the above options; this is reserved.\n\n     * Further, <length of run - 1> all-ones is a reserved pattern.\n\n     *\n\n     * In all cases the rotation is by immr % e (and immr is 6 bits).\n\n     */\n\n\n\n    /* First determine the element size */\n\n    len = 31 - clz32((immn << 6) | (~imms & 0x3f));\n\n    if (len < 1) {\n\n        /* This is the immn == 0, imms == 0x11111x case */\n\n        return false;\n\n    }\n\n    e = 1 << len;\n\n\n\n    levels = e - 1;\n\n    s = imms & levels;\n\n    r = immr & levels;\n\n\n\n    if (s == levels) {\n\n        /* <length of run - 1> mustn't be all-ones. */\n\n        return false;\n\n    }\n\n\n\n    /* Create the value of one element: s+1 set bits rotated\n\n     * by r within the element (which is e bits wide)...\n\n     */\n\n    mask = bitmask64(s + 1);\n\n    mask = (mask >> r) | (mask << (e - r));\n\n    /* ...then replicate the element over the whole 64 bit value */\n\n    mask = bitfield_replicate(mask, e);\n\n    *result = mask;\n\n    return true;\n\n}\n", "idx": 2395}, {"project": "test", "commit_id": "test", "target": 1, "func": "blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes,\n                   QEMUIOVector *qiov, int flags)\n{\n    BDRVBlkdebugState *s = bs->opaque;\n    BlkdebugRule *rule = NULL;\n    QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) {\n        uint64_t inject_offset = rule->options.inject.offset;\n        if (inject_offset == -1 ||\n            (inject_offset >= offset && inject_offset < offset + bytes))\n        {\n            break;\n    if (rule && rule->options.inject.error) {\n        return inject_error(bs, rule);\n    return bdrv_co_preadv(bs->file, offset, bytes, qiov, flags);", "idx": 2622}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int idreg_init1(SysBusDevice *dev)\n\n{\n\n    IDRegState *s = MACIO_ID_REGISTER(dev);\n\n\n\n    memory_region_init_ram(&s->mem, OBJECT(s),\n\n                           \"sun4m.idreg\", sizeof(idreg_data), &error_abort);\n\n    vmstate_register_ram_global(&s->mem);\n\n    memory_region_set_readonly(&s->mem, true);\n\n    sysbus_init_mmio(dev, &s->mem);\n\n    return 0;\n\n}\n", "idx": 2624}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void RENAME(hyscale)(uint16_t *dst, int dstWidth, uint8_t *src, int srcW, int xInc)\n\n{\n\n#ifdef HAVE_MMX\n\n\t// use the new MMX scaler if th mmx2 cant be used (its faster than the x86asm one)\n\n    if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed))\n\n#else\n\n    if(sws_flags != SWS_FAST_BILINEAR)\n\n#endif\n\n    {\n\n    \tRENAME(hScale)(dst, dstWidth, src, srcW, xInc, hLumFilter, hLumFilterPos, hLumFilterSize);\n\n    }\n\n    else // Fast Bilinear upscale / crap downscale\n\n    {\n\n#ifdef ARCH_X86\n\n#ifdef HAVE_MMX2\n\n\tint i;\n\n\tif(canMMX2BeUsed)\n\n\t{\n\n\t\tasm volatile(\n\n\t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"pxor %%mm2, %%mm2\t\t\\n\\t\" // 2*xalpha\n\n\t\t\t\"movd %5, %%mm6\t\t\t\\n\\t\" // xInc&0xFFFF\n\n\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"movq %%mm6, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"psllq $16, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"paddw %%mm6, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"psllq $16, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"paddw %%mm6, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"psllq $16, %%mm2\t\t\\n\\t\" //0,t,2t,3t\t\tt=xInc&0xFF\n\n\t\t\t\"movq %%mm2, \"MANGLE(temp0)\"\t\\n\\t\"\n\n\t\t\t\"movd %4, %%mm6\t\t\t\\n\\t\" //(xInc*4)&0xFFFF\n\n\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"punpcklwd %%mm6, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"xorl %%eax, %%eax\t\t\\n\\t\" // i\n\n\t\t\t\"movl %0, %%esi\t\t\t\\n\\t\" // src\n\n\t\t\t\"movl %1, %%edi\t\t\t\\n\\t\" // buf1\n\n\t\t\t\"movl %3, %%edx\t\t\t\\n\\t\" // (xInc*4)>>16\n\n\t\t\t\"xorl %%ecx, %%ecx\t\t\\n\\t\"\n\n\t\t\t\"xorl %%ebx, %%ebx\t\t\\n\\t\"\n\n\t\t\t\"movw %4, %%bx\t\t\t\\n\\t\" // (xInc*4)&0xFFFF\n\n\n\n#define FUNNY_Y_CODE \\\n\n\t\t\tPREFETCH\" 1024(%%esi)\t\t\\n\\t\"\\\n\n\t\t\tPREFETCH\" 1056(%%esi)\t\t\\n\\t\"\\\n\n\t\t\tPREFETCH\" 1088(%%esi)\t\t\\n\\t\"\\\n\n\t\t\t\"call \"MANGLE(funnyYCode)\"\t\\n\\t\"\\\n\n\t\t\t\"movq \"MANGLE(temp0)\", %%mm2\t\\n\\t\"\\\n\n\t\t\t\"xorl %%ecx, %%ecx\t\t\\n\\t\"\n\n\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\nFUNNY_Y_CODE\n\n\n\n\t\t\t:: \"m\" (src), \"m\" (dst), \"m\" (dstWidth), \"m\" ((xInc*4)>>16),\n\n\t\t\t\"m\" ((xInc*4)&0xFFFF), \"m\" (xInc&0xFFFF)\n\n\t\t\t: \"%eax\", \"%ebx\", \"%ecx\", \"%edx\", \"%esi\", \"%edi\"\n\n\t\t);\n\n\t\tfor(i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) dst[i] = src[srcW-1]*128;\n\n\t}\n\n\telse\n\n\t{\n\n#endif\n\n\t//NO MMX just normal asm ...\n\n\tasm volatile(\n\n\t\t\"xorl %%eax, %%eax\t\t\\n\\t\" // i\n\n\t\t\"xorl %%ebx, %%ebx\t\t\\n\\t\" // xx\n\n\t\t\"xorl %%ecx, %%ecx\t\t\\n\\t\" // 2*xalpha\n\n\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\"movzbl  (%0, %%ebx), %%edi\t\\n\\t\" //src[xx]\n\n\t\t\"movzbl 1(%0, %%ebx), %%esi\t\\n\\t\" //src[xx+1]\n\n\t\t\"subl %%edi, %%esi\t\t\\n\\t\" //src[xx+1] - src[xx]\n\n\t\t\"imull %%ecx, %%esi\t\t\\n\\t\" //(src[xx+1] - src[xx])*2*xalpha\n\n\t\t\"shll $16, %%edi\t\t\\n\\t\"\n\n\t\t\"addl %%edi, %%esi\t\t\\n\\t\" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)\n\n\t\t\"movl %1, %%edi\t\t\t\\n\\t\"\n\n\t\t\"shrl $9, %%esi\t\t\t\\n\\t\"\n\n\t\t\"movw %%si, (%%edi, %%eax, 2)\t\\n\\t\"\n\n\t\t\"addw %4, %%cx\t\t\t\\n\\t\" //2*xalpha += xInc&0xFF\n\n\t\t\"adcl %3, %%ebx\t\t\t\\n\\t\" //xx+= xInc>>8 + carry\n\n\n\n\t\t\"movzbl (%0, %%ebx), %%edi\t\\n\\t\" //src[xx]\n\n\t\t\"movzbl 1(%0, %%ebx), %%esi\t\\n\\t\" //src[xx+1]\n\n\t\t\"subl %%edi, %%esi\t\t\\n\\t\" //src[xx+1] - src[xx]\n\n\t\t\"imull %%ecx, %%esi\t\t\\n\\t\" //(src[xx+1] - src[xx])*2*xalpha\n\n\t\t\"shll $16, %%edi\t\t\\n\\t\"\n\n\t\t\"addl %%edi, %%esi\t\t\\n\\t\" //src[xx+1]*2*xalpha + src[xx]*(1-2*xalpha)\n\n\t\t\"movl %1, %%edi\t\t\t\\n\\t\"\n\n\t\t\"shrl $9, %%esi\t\t\t\\n\\t\"\n\n\t\t\"movw %%si, 2(%%edi, %%eax, 2)\t\\n\\t\"\n\n\t\t\"addw %4, %%cx\t\t\t\\n\\t\" //2*xalpha += xInc&0xFF\n\n\t\t\"adcl %3, %%ebx\t\t\t\\n\\t\" //xx+= xInc>>8 + carry\n\n\n\n\n\n\t\t\"addl $2, %%eax\t\t\t\\n\\t\"\n\n\t\t\"cmpl %2, %%eax\t\t\t\\n\\t\"\n\n\t\t\" jb 1b\t\t\t\t\\n\\t\"\n\n\n\n\n\n\t\t:: \"r\" (src), \"m\" (dst), \"m\" (dstWidth), \"m\" (xInc>>16), \"m\" (xInc&0xFFFF)\n\n\t\t: \"%eax\", \"%ebx\", \"%ecx\", \"%edi\", \"%esi\"\n\n\t\t);\n\n#ifdef HAVE_MMX2\n\n\t} //if MMX2 cant be used\n\n#endif\n\n#else\n\n\tint i;\n\n\tunsigned int xpos=0;\n\n\tfor(i=0;i<dstWidth;i++)\n\n\t{\n\n\t\tregister unsigned int xx=xpos>>16;\n\n\t\tregister unsigned int xalpha=(xpos&0xFFFF)>>9;\n\n\t\tdst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;\n\n\t\txpos+=xInc;\n\n\t}\n\n#endif\n\n    }\n\n}\n", "idx": 2677}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int get_uint16_equal(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint16_t *v = pv;\n\n    uint16_t v2;\n\n    qemu_get_be16s(f, &v2);\n\n\n\n    if (*v == v2) {\n\n        return 0;\n\n    }\n\n    return -EINVAL;\n\n}\n", "idx": 2680}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int h264_handle_packet(AVFormatContext *ctx, PayloadContext *data,\n\n                              AVStream *st, AVPacket *pkt, uint32_t *timestamp,\n\n                              const uint8_t *buf, int len, uint16_t seq,\n\n                              int flags)\n\n{\n\n    uint8_t nal;\n\n    uint8_t type;\n\n    int result = 0;\n\n\n\n    if (!len) {\n\n        av_log(ctx, AV_LOG_ERROR, \"Empty H264 RTP packet\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n    nal  = buf[0];\n\n    type = nal & 0x1f;\n\n\n\n    assert(data);\n\n    assert(buf);\n\n\n\n    /* Simplify the case (these are all the nal types used internally by\n\n     * the h264 codec). */\n\n    if (type >= 1 && type <= 23)\n\n        type = 1;\n\n    switch (type) {\n\n    case 0:                    // undefined, but pass them through\n\n    case 1:\n\n        av_new_packet(pkt, len + sizeof(start_sequence));\n\n        memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n\n        memcpy(pkt->data + sizeof(start_sequence), buf, len);\n\n        COUNT_NAL_TYPE(data, nal);\n\n        break;\n\n\n\n    case 24:                   // STAP-A (one packet, multiple nals)\n\n        // consume the STAP-A NAL\n\n        buf++;\n\n        len--;\n\n        // first we are going to figure out the total size\n\n        {\n\n            int pass         = 0;\n\n            int total_length = 0;\n\n            uint8_t *dst     = NULL;\n\n\n\n            for (pass = 0; pass < 2; pass++) {\n\n                const uint8_t *src = buf;\n\n                int src_len        = len;\n\n\n\n                while (src_len > 2) {\n\n                    uint16_t nal_size = AV_RB16(src);\n\n\n\n                    // consume the length of the aggregate\n\n                    src     += 2;\n\n                    src_len -= 2;\n\n\n\n                    if (nal_size <= src_len) {\n\n                        if (pass == 0) {\n\n                            // counting\n\n                            total_length += sizeof(start_sequence) + nal_size;\n\n                        } else {\n\n                            // copying\n\n                            assert(dst);\n\n                            memcpy(dst, start_sequence, sizeof(start_sequence));\n\n                            dst += sizeof(start_sequence);\n\n                            memcpy(dst, src, nal_size);\n\n                            COUNT_NAL_TYPE(data, *src);\n\n                            dst += nal_size;\n\n                        }\n\n                    } else {\n\n                        av_log(ctx, AV_LOG_ERROR,\n\n                               \"nal size exceeds length: %d %d\\n\", nal_size, src_len);\n\n                    }\n\n\n\n                    // eat what we handled\n\n                    src     += nal_size;\n\n                    src_len -= nal_size;\n\n\n\n                    if (src_len < 0)\n\n                        av_log(ctx, AV_LOG_ERROR,\n\n                               \"Consumed more bytes than we got! (%d)\\n\", src_len);\n\n                }\n\n\n\n                if (pass == 0) {\n\n                    /* now we know the total size of the packet (with the\n\n                     * start sequences added) */\n\n                    av_new_packet(pkt, total_length);\n\n                    dst = pkt->data;\n\n                } else {\n\n                    assert(dst - pkt->data == total_length);\n\n                }\n\n            }\n\n        }\n\n        break;\n\n\n\n    case 25:                   // STAP-B\n\n    case 26:                   // MTAP-16\n\n    case 27:                   // MTAP-24\n\n    case 29:                   // FU-B\n\n        av_log(ctx, AV_LOG_ERROR,\n\n               \"Unhandled type (%d) (See RFC for implementation details\\n\",\n\n               type);\n\n        result = AVERROR(ENOSYS);\n\n        break;\n\n\n\n    case 28:                   // FU-A (fragmented nal)\n\n        buf++;\n\n        len--;                 // skip the fu_indicator\n\n        if (len > 1) {\n\n            // these are the same as above, we just redo them here for clarity\n\n            uint8_t fu_indicator      = nal;\n\n            uint8_t fu_header         = *buf;\n\n            uint8_t start_bit         = fu_header >> 7;\n\n            uint8_t av_unused end_bit = (fu_header & 0x40) >> 6;\n\n            uint8_t nal_type          = fu_header & 0x1f;\n\n            uint8_t reconstructed_nal;\n\n\n\n            // Reconstruct this packet's true nal; only the data follows.\n\n            /* The original nal forbidden bit and NRI are stored in this\n\n             * packet's nal. */\n\n            reconstructed_nal  = fu_indicator & 0xe0;\n\n            reconstructed_nal |= nal_type;\n\n\n\n            // skip the fu_header\n\n            buf++;\n\n            len--;\n\n\n\n            if (start_bit)\n\n                COUNT_NAL_TYPE(data, nal_type);\n\n            if (start_bit) {\n\n                /* copy in the start sequence, and the reconstructed nal */\n\n                av_new_packet(pkt, sizeof(start_sequence) + sizeof(nal) + len);\n\n                memcpy(pkt->data, start_sequence, sizeof(start_sequence));\n\n                pkt->data[sizeof(start_sequence)] = reconstructed_nal;\n\n                memcpy(pkt->data + sizeof(start_sequence) + sizeof(nal), buf, len);\n\n            } else {\n\n                av_new_packet(pkt, len);\n\n                memcpy(pkt->data, buf, len);\n\n            }\n\n        } else {\n\n            av_log(ctx, AV_LOG_ERROR, \"Too short data for FU-A H264 RTP packet\\n\");\n\n            result = AVERROR_INVALIDDATA;\n\n        }\n\n        break;\n\n\n\n    case 30:                   // undefined\n\n    case 31:                   // undefined\n\n    default:\n\n        av_log(ctx, AV_LOG_ERROR, \"Undefined type (%d)\\n\", type);\n\n        result = AVERROR_INVALIDDATA;\n\n        break;\n\n    }\n\n\n\n    pkt->stream_index = st->index;\n\n\n\n    return result;\n\n}\n", "idx": 2704}, {"project": "test", "commit_id": "test", "target": 1, "func": "uint64_t helper_addlv (uint64_t op1, uint64_t op2)\n\n{\n\n    uint64_t tmp = op1;\n\n    op1 = (uint32_t)(op1 + op2);\n\n    if (unlikely((tmp ^ op2 ^ (-1UL)) & (tmp ^ op1) & (1UL << 31))) {\n\n        arith_excp(env, GETPC(), EXC_M_IOV, 0);\n\n    }\n\n    return op1;\n\n}\n", "idx": 2832}, {"project": "test", "commit_id": "test", "target": 1, "func": "uint32_t div32(uint32_t *q_ptr, uint64_t num, uint32_t den)\n\n{\n\n    *q_ptr = num / den;\n\n    return num % den;\n\n}\n", "idx": 3162}, {"project": "test", "commit_id": "test", "target": 1, "func": "uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t shift)\n\n{\n\n    uint64_t temp;\n\n    uint32_t result;\n\n\n\n    shift &= 63;\n\n    temp = (uint64_t)val << 32 >> shift;\n\n    result = temp >> 32;\n\n\n\n    env->cc_c = (temp >> 31) & 1;\n\n    env->cc_n = result;\n\n    env->cc_z = result;\n\n    env->cc_v = 0;\n\n    env->cc_x = shift ? env->cc_c : env->cc_x;\n\n\n\n    return result;\n\n}\n", "idx": 3184}, {"project": "test", "commit_id": "test", "target": 1, "func": "target_ulong helper_sdiv(target_ulong a, target_ulong b)\n\n{\n\n    int64_t x0;\n\n    int32_t x1;\n\n\n\n    x0 = (a & 0xffffffff) | ((int64_t) (env->y) << 32);\n\n    x1 = (b & 0xffffffff);\n\n\n\n    if (x1 == 0) {\n\n        raise_exception(TT_DIV_ZERO);\n\n    }\n\n\n\n    x0 = x0 / x1;\n\n    if ((int32_t) x0 != x0) {\n\n        env->cc_src2 = 1;\n\n        return x0 < 0? 0x80000000: 0x7fffffff;\n\n    } else {\n\n        env->cc_src2 = 0;\n\n        return x0;\n\n    }\n\n}\n", "idx": 3228}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int blkverify_open(BlockDriverState *bs, QDict *options, int flags,\n\n                          Error **errp)\n\n{\n\n    BDRVBlkverifyState *s = bs->opaque;\n\n    QemuOpts *opts;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n\n\n    opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);\n\n    qemu_opts_absorb_qdict(opts, options, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        ret = -EINVAL;\n\n        goto fail;\n\n\n\n\n    /* Open the raw file */\n\n    bs->file = bdrv_open_child(qemu_opt_get(opts, \"x-raw\"), options, \"raw\",\n\n                               bs, &child_file, false, &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    /* Open the test file */\n\n    s->test_file = bdrv_open_child(qemu_opt_get(opts, \"x-image\"), options,\n\n                                   \"test\", bs, &child_format, false,\n\n                                   &local_err);\n\n    if (local_err) {\n\n        ret = -EINVAL;\n\n        error_propagate(errp, local_err);\n\n        goto fail;\n\n\n\n\n    ret = 0;\n\nfail:\n\n\n\n\n    qemu_opts_del(opts);\n\n    return ret;\n", "idx": 3279}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void hScale8To15_c(SwsContext *c, int16_t *dst, int dstW, const uint8_t *src,\n\n                          const int16_t *filter, const int16_t *filterPos,\n\n                          int filterSize)\n\n{\n\n    int i;\n\n    for (i=0; i<dstW; i++) {\n\n        int j;\n\n        int srcPos= filterPos[i];\n\n        int val=0;\n\n        for (j=0; j<filterSize; j++) {\n\n            val += ((int)src[srcPos + j])*filter[filterSize*i + j];\n\n        }\n\n        //filter += hFilterSize;\n\n        dst[i] = FFMIN(val>>7, (1<<15)-1); // the cubic equation does overflow ...\n\n        //dst[i] = val>>7;\n\n    }\n\n}\n", "idx": 3293}, {"project": "test", "commit_id": "test", "target": 1, "func": "qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt,\n\n                    size_t offset, size_t bytes, bool do_send)\n\n{\n\n    size_t done = 0;\n\n    ssize_t ret;\n\n    while (done < bytes) {\n\n        ret = iov_send_recv(sockfd, iov,\n\n                            offset + done, bytes - done, do_send);\n\n        if (ret > 0) {\n\n            done += ret;\n\n        } else if (ret < 0) {\n\n            if (errno == EAGAIN) {\n\n                qemu_coroutine_yield();\n\n            } else if (done == 0) {\n\n                return -1;\n\n            } else {\n\n                break;\n\n            }\n\n        } else if (ret == 0 && !do_send) {\n\n            /* write (send) should never return 0.\n\n             * read (recv) returns 0 for end-of-file (-data).\n\n             * In both cases there's little point retrying,\n\n             * but we do for write anyway, just in case */\n\n            break;\n\n        }\n\n    }\n\n    return done;\n\n}\n", "idx": 3322}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void RENAME(rgb15to32)(const uint8_t *src, uint8_t *dst, int src_size)\n\n{\n\n    const uint16_t *end;\n\n    const uint16_t *mm_end;\n\n    uint8_t *d = dst;\n\n    const uint16_t *s = (const uint16_t *)src;\n\n    end = s + src_size/2;\n\n    __asm__ volatile(PREFETCH\"    %0\"::\"m\"(*s):\"memory\");\n\n    __asm__ volatile(\"pxor    %%mm7,%%mm7    \\n\\t\":::\"memory\");\n\n    __asm__ volatile(\"pcmpeqd %%mm6,%%mm6    \\n\\t\":::\"memory\");\n\n    mm_end = end - 3;\n\n    while (s < mm_end) {\n\n        __asm__ volatile(\n\n            PREFETCH\"    32%1           \\n\\t\"\n\n            \"movq          %1, %%mm0    \\n\\t\"\n\n            \"movq          %1, %%mm1    \\n\\t\"\n\n            \"movq          %1, %%mm2    \\n\\t\"\n\n            \"pand          %2, %%mm0    \\n\\t\"\n\n            \"pand          %3, %%mm1    \\n\\t\"\n\n            \"pand          %4, %%mm2    \\n\\t\"\n\n            \"psllq         $3, %%mm0    \\n\\t\"\n\n            \"psrlq         $2, %%mm1    \\n\\t\"\n\n            \"psrlq         $7, %%mm2    \\n\\t\"\n\n            PACK_RGB32\n\n            :\"=m\"(*d)\n\n            :\"m\"(*s),\"m\"(mask15b),\"m\"(mask15g),\"m\"(mask15r)\n\n            :\"memory\");\n\n        d += 16;\n\n        s += 4;\n\n    }\n\n    __asm__ volatile(SFENCE:::\"memory\");\n\n    __asm__ volatile(EMMS:::\"memory\");\n\n    while (s < end) {\n\n        register uint16_t bgr;\n\n        bgr = *s++;\n\n        *d++ = (bgr&0x1F)<<3;\n\n        *d++ = (bgr&0x3E0)>>2;\n\n        *d++ = (bgr&0x7C00)>>7;\n\n        *d++ = 255;\n\n    }\n\n}\n", "idx": 3375}, {"project": "test", "commit_id": "test", "target": 1, "func": "static av_always_inline void hcscale(SwsContext *c, int16_t *dst1, int16_t *dst2, int dstWidth,\n\n                                     const uint8_t *src_in[4],\n\n                                     int srcW, int xInc, const int16_t *hChrFilter,\n\n                                     const int16_t *hChrFilterPos, int hChrFilterSize,\n\n                                     uint8_t *formatConvBuffer, uint32_t *pal)\n\n{\n\n    const uint8_t *src1 = src_in[1], *src2 = src_in[2];\n\n    if (c->chrToYV12) {\n\n        uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16);\n\n        c->chrToYV12(formatConvBuffer, buf2, src1, src2, srcW, pal);\n\n        src1= formatConvBuffer;\n\n        src2= buf2;\n\n    } else if (c->readChrPlanar) {\n\n        uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16);\n\n        c->readChrPlanar(formatConvBuffer, buf2, src_in, srcW);\n\n        src1= formatConvBuffer;\n\n        src2= buf2;\n\n    }\n\n\n\n    if (!c->hcscale_fast) {\n\n        c->hcScale(c, dst1, dstWidth, src1, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n        c->hcScale(c, dst2, dstWidth, src2, hChrFilter, hChrFilterPos, hChrFilterSize);\n\n    } else { // fast bilinear upscale / crap downscale\n\n        c->hcscale_fast(c, dst1, dst2, dstWidth, src1, src2, srcW, xInc);\n\n    }\n\n\n\n    if (c->chrConvertRange)\n\n        c->chrConvertRange(dst1, dst2, dstWidth);\n\n}\n", "idx": 3397}, {"project": "test", "commit_id": "test", "target": 1, "func": "void h263_decode_init_vlc(MpegEncContext *s)\n\n{\n\n    static int done = 0;\n\n\n\n    if (!done) {\n\n        done = 1;\n\n\n\n        init_vlc(&intra_MCBPC_vlc, INTRA_MCBPC_VLC_BITS, 9, \n\n                 intra_MCBPC_bits, 1, 1,\n\n                 intra_MCBPC_code, 1, 1);\n\n        init_vlc(&inter_MCBPC_vlc, INTER_MCBPC_VLC_BITS, 28, \n\n                 inter_MCBPC_bits, 1, 1,\n\n                 inter_MCBPC_code, 1, 1);\n\n        init_vlc(&cbpy_vlc, CBPY_VLC_BITS, 16,\n\n                 &cbpy_tab[0][1], 2, 1,\n\n                 &cbpy_tab[0][0], 2, 1);\n\n        init_vlc(&mv_vlc, MV_VLC_BITS, 33,\n\n                 &mvtab[0][1], 2, 1,\n\n                 &mvtab[0][0], 2, 1);\n\n        init_rl(&rl_inter);\n\n        init_rl(&rl_intra);\n\n        init_rl(&rvlc_rl_inter);\n\n        init_rl(&rvlc_rl_intra);\n\n        init_rl(&rl_intra_aic);\n\n        init_vlc_rl(&rl_inter);\n\n        init_vlc_rl(&rl_intra);\n\n        init_vlc_rl(&rvlc_rl_inter);\n\n        init_vlc_rl(&rvlc_rl_intra);\n\n        init_vlc_rl(&rl_intra_aic);\n\n        init_vlc(&dc_lum, DC_VLC_BITS, 10 /* 13 */,\n\n                 &DCtab_lum[0][1], 2, 1,\n\n                 &DCtab_lum[0][0], 2, 1);\n\n        init_vlc(&dc_chrom, DC_VLC_BITS, 10 /* 13 */,\n\n                 &DCtab_chrom[0][1], 2, 1,\n\n                 &DCtab_chrom[0][0], 2, 1);\n\n        init_vlc(&sprite_trajectory, SPRITE_TRAJ_VLC_BITS, 15,\n\n                 &sprite_trajectory_tab[0][1], 4, 2,\n\n                 &sprite_trajectory_tab[0][0], 4, 2);\n\n        init_vlc(&mb_type_b_vlc, MB_TYPE_B_VLC_BITS, 4,\n\n                 &mb_type_b_tab[0][1], 2, 1,\n\n                 &mb_type_b_tab[0][0], 2, 1);\n\n        init_vlc(&h263_mbtype_b_vlc, H263_MBTYPE_B_VLC_BITS, 15,\n\n                 &h263_mbtype_b_tab[0][1], 2, 1,\n\n                 &h263_mbtype_b_tab[0][0], 2, 1);\n\n        init_vlc(&cbpc_b_vlc, CBPC_B_VLC_BITS, 4,\n\n                 &cbpc_b_tab[0][1], 2, 1,\n\n                 &cbpc_b_tab[0][0], 2, 1);\n\n    }\n\n}\n", "idx": 3476}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int mpeg1_decode_sequence(AVCodecContext *avctx, \n\n                                 UINT8 *buf, int buf_size)\n\n{\n\n    Mpeg1Context *s1 = avctx->priv_data;\n\n    MpegEncContext *s = &s1->mpeg_enc_ctx;\n\n    int width, height, i, v, j;\n\n    \n\n    init_get_bits(&s->gb, buf, buf_size);\n\n\n\n    width = get_bits(&s->gb, 12);\n\n    height = get_bits(&s->gb, 12);\n\n    skip_bits(&s->gb, 4);\n\n    s->frame_rate_index = get_bits(&s->gb, 4);\n\n    if (s->frame_rate_index == 0)\n\n        return -1;\n\n    s->bit_rate = get_bits(&s->gb, 18) * 400;\n\n    if (get_bits1(&s->gb) == 0) /* marker */\n\n        return -1;\n\n    if (width <= 0 || height <= 0 ||\n\n        (width % 2) != 0 || (height % 2) != 0)\n\n        return -1;\n\n    if (width != s->width ||\n\n        height != s->height) {\n\n        /* start new mpeg1 context decoding */\n\n        s->out_format = FMT_MPEG1;\n\n        if (s1->mpeg_enc_ctx_allocated) {\n\n            MPV_common_end(s);\n\n        }\n\n        s->width = width;\n\n        s->height = height;\n\n        s->has_b_frames = 1;\n\n        s->avctx = avctx;\n\n        avctx->width = width;\n\n        avctx->height = height;\n\n        avctx->frame_rate = frame_rate_tab[s->frame_rate_index];\n\n        s->frame_rate = avctx->frame_rate;\n\n        avctx->bit_rate = s->bit_rate;\n\n        \n\n        if (MPV_common_init(s) < 0)\n\n            return -1;\n\n        mpeg1_init_vlc(s);\n\n        s1->mpeg_enc_ctx_allocated = 1;\n\n    }\n\n\n\n    skip_bits(&s->gb, 10); /* vbv_buffer_size */\n\n    skip_bits(&s->gb, 1);\n\n\n\n    /* get matrix */\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = zigzag_direct[i];\n\n            s->intra_matrix[j] = v;\n\n            s->chroma_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->intra_matrix[zigzag_direct[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            v = default_intra_matrix[i];\n\n            s->intra_matrix[i] = v;\n\n            s->chroma_intra_matrix[i] = v;\n\n        }\n\n    }\n\n    if (get_bits1(&s->gb)) {\n\n        for(i=0;i<64;i++) {\n\n            v = get_bits(&s->gb, 8);\n\n            j = zigzag_direct[i];\n\n            s->non_intra_matrix[j] = v;\n\n            s->chroma_non_intra_matrix[j] = v;\n\n        }\n\n#ifdef DEBUG\n\n        dprintf(\"non intra matrix present\\n\");\n\n        for(i=0;i<64;i++)\n\n            dprintf(\" %d\", s->non_intra_matrix[zigzag_direct[i]]);\n\n        printf(\"\\n\");\n\n#endif\n\n    } else {\n\n        for(i=0;i<64;i++) {\n\n            v = default_non_intra_matrix[i];\n\n            s->non_intra_matrix[i] = v;\n\n            s->chroma_non_intra_matrix[i] = v;\n\n        }\n\n    }\n\n\n\n    /* we set mpeg2 parameters so that it emulates mpeg1 */\n\n    s->progressive_sequence = 1;\n\n    s->progressive_frame = 1;\n\n    s->picture_structure = PICT_FRAME;\n\n    s->frame_pred_frame_dct = 1;\n\n    s->mpeg2 = 0;\n\n    return 0;\n\n}\n", "idx": 3499}, {"project": "test", "commit_id": "test", "target": 1, "func": "void ff_rfps_calculate(AVFormatContext *ic)\n{\n    int i, j;\n    for (i = 0; i<ic->nb_streams; i++) {\n        AVStream *st = ic->streams[i];\n        if (st->codec->codec_type != AVMEDIA_TYPE_VIDEO)\n        // the check for tb_unreliable() is not completely correct, since this is not about handling\n        // a unreliable/inexact time base, but a time base that is finer than necessary, as e.g.\n        // ipmovie.c produces.\n        if (tb_unreliable(st->codec) && st->info->duration_count > 15 && st->info->duration_gcd > FFMAX(1, st->time_base.den/(500LL*st->time_base.num)) && !st->r_frame_rate.num)\n            av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, st->time_base.den, st->time_base.num * st->info->duration_gcd, INT_MAX);\n        if (st->info->duration_count>1 && !st->r_frame_rate.num\n            && tb_unreliable(st->codec)) {\n            int num = 0;\n            double best_error= 0.01;\n            for (j=0; j<MAX_STD_TIMEBASES; j++) {\n                int k;\n                if(st->info->codec_info_duration && st->info->codec_info_duration*av_q2d(st->time_base) < (1001*12.0)/get_std_framerate(j))\n                if(!st->info->codec_info_duration && 1.0 < (1001*12.0)/get_std_framerate(j))\n                for(k=0; k<2; k++){\n                    int n= st->info->duration_count;\n                    double a= st->info->duration_error[k][0][j] / n;\n                    double error= st->info->duration_error[k][1][j]/n - a*a;\n                    if(error < best_error && best_error> 0.000000001){\n                        best_error= error;\n                        num = get_std_framerate(j);\n                    }\n                    if(error < 0.02)\n                        av_log(NULL, AV_LOG_DEBUG, \"rfps: %f %f\\n\", get_std_framerate(j) / 12.0/1001, error);\n                }\n            }\n            // do not increase frame rate by more than 1 % in order to match a standard rate.\n            if (num && (!st->r_frame_rate.num || (double)num/(12*1001) < 1.01 * av_q2d(st->r_frame_rate)))\n                av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num, 12*1001, INT_MAX);\n        }\n        av_freep(&st->info->duration_error);\n        st->info->last_dts = AV_NOPTS_VALUE;\n        st->info->duration_count = 0;\n        st->info->rfps_duration_sum = 0;\n    }\n}", "idx": 3502}, {"project": "test", "commit_id": "test", "target": 1, "func": "void cpu_loop(CPUMIPSState *env)\n\n{\n\n    target_siginfo_t info;\n\n    int trapnr, ret;\n\n    unsigned int syscall_num;\n\n\n\n    for(;;) {\n\n        trapnr = cpu_mips_exec(env);\n\n        switch(trapnr) {\n\n        case EXCP_SYSCALL:\n\n            syscall_num = env->active_tc.gpr[2] - 4000;\n\n            env->active_tc.PC += 4;\n\n            if (syscall_num >= sizeof(mips_syscall_args)) {\n\n                ret = -ENOSYS;\n\n            } else {\n\n                int nb_args;\n\n                abi_ulong sp_reg;\n\n                abi_ulong arg5 = 0, arg6 = 0, arg7 = 0, arg8 = 0;\n\n\n\n                nb_args = mips_syscall_args[syscall_num];\n\n                sp_reg = env->active_tc.gpr[29];\n\n                switch (nb_args) {\n\n                /* these arguments are taken from the stack */\n\n                /* FIXME - what to do if get_user() fails? */\n\n                case 8: get_user_ual(arg8, sp_reg + 28);\n\n                case 7: get_user_ual(arg7, sp_reg + 24);\n\n                case 6: get_user_ual(arg6, sp_reg + 20);\n\n                case 5: get_user_ual(arg5, sp_reg + 16);\n\n                default:\n\n\n\n                ret = do_syscall(env, env->active_tc.gpr[2],\n\n                                 env->active_tc.gpr[4],\n\n                                 env->active_tc.gpr[5],\n\n                                 env->active_tc.gpr[6],\n\n                                 env->active_tc.gpr[7],\n\n                                 arg5, arg6/*, arg7, arg8*/);\n\n\n\n\n\n\n\n            if ((unsigned int)ret >= (unsigned int)(-1133)) {\n\n                env->active_tc.gpr[7] = 1; /* error flag */\n\n                ret = -ret;\n\n            } else {\n\n                env->active_tc.gpr[7] = 0; /* error flag */\n\n\n            env->active_tc.gpr[2] = ret;\n\n\n        case EXCP_TLBL:\n\n        case EXCP_TLBS:\n\n            info.si_signo = TARGET_SIGSEGV;\n\n            info.si_errno = 0;\n\n            /* XXX: check env->error_code */\n\n            info.si_code = TARGET_SEGV_MAPERR;\n\n            info._sifields._sigfault._addr = env->CP0_BadVAddr;\n\n            queue_signal(env, info.si_signo, &info);\n\n\n        case EXCP_CpU:\n\n        case EXCP_RI:\n\n            info.si_signo = TARGET_SIGILL;\n\n            info.si_errno = 0;\n\n            info.si_code = 0;\n\n            queue_signal(env, info.si_signo, &info);\n\n\n        case EXCP_INTERRUPT:\n\n            /* just indicate that signals should be handled asap */\n\n\n        case EXCP_DEBUG:\n\n            {\n\n                int sig;\n\n\n\n                sig = gdb_handlesig (env, TARGET_SIGTRAP);\n\n                if (sig)\n\n                  {\n\n                    info.si_signo = sig;\n\n                    info.si_errno = 0;\n\n                    info.si_code = TARGET_TRAP_BRKPT;\n\n                    queue_signal(env, info.si_signo, &info);\n\n\n\n\n        default:\n\n            //        error:\n\n            fprintf(stderr, \"qemu: unhandled CPU exception 0x%x - aborting\\n\",\n\n                    trapnr);\n\n            cpu_dump_state(env, stderr, fprintf, 0);\n\n            abort();\n\n\n        process_pending_signals(env);\n\n", "idx": 3540}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int tmv_read_seek(AVFormatContext *s, int stream_index,\n\n                         int64_t timestamp, int flags)\n\n{\n\n    TMVContext *tmv = s->priv_data;\n\n    int64_t pos;\n\n\n\n    if (stream_index)\n\n        return -1;\n\n\n\n    pos = timestamp *\n\n          (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding);\n\n\n\n    avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET);\n\n    tmv->stream_index = 0;\n\n    return 0;\n\n}\n", "idx": 3551}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void bonito_ldma_writel(void *opaque, hwaddr addr,\n                               uint64_t val, unsigned size)\n{\n    PCIBonitoState *s = opaque;\n    ((uint32_t *)(&s->bonldma))[addr/sizeof(uint32_t)] = val & 0xffffffff;", "idx": 3555}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int jpeg2000_decode_packet(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, int *tp_index,\n\n                                  Jpeg2000CodingStyle *codsty,\n\n                                  Jpeg2000ResLevel *rlevel, int precno,\n\n                                  int layno, uint8_t *expn, int numgbits)\n\n{\n\n    int bandno, cblkno, ret, nb_code_blocks;\n\n    int cwsno;\n\n\n\n    if (layno < rlevel->band[0].prec[precno].decoded_layers)\n\n        return 0;\n\n    rlevel->band[0].prec[precno].decoded_layers = layno + 1;\n\n\n\n    if (bytestream2_get_bytes_left(&s->g) == 0 && s->bit_index == 8) {\n\n        if (*tp_index < FF_ARRAY_ELEMS(tile->tile_part) - 1) {\n\n            s->g = tile->tile_part[++(*tp_index)].tpg;\n\n        }\n\n    }\n\n\n\n    if (bytestream2_peek_be32(&s->g) == JPEG2000_SOP_FIXED_BYTES)\n\n        bytestream2_skip(&s->g, JPEG2000_SOP_BYTE_LENGTH);\n\n\n\n    if (!(ret = get_bits(s, 1))) {\n\n        jpeg2000_flush(s);\n\n        return 0;\n\n    } else if (ret < 0)\n\n        return ret;\n\n\n\n    for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n\n        Jpeg2000Band *band = rlevel->band + bandno;\n\n        Jpeg2000Prec *prec = band->prec + precno;\n\n\n\n        if (band->coord[0][0] == band->coord[0][1] ||\n\n            band->coord[1][0] == band->coord[1][1])\n\n            continue;\n\n        nb_code_blocks =  prec->nb_codeblocks_height *\n\n                          prec->nb_codeblocks_width;\n\n        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {\n\n            Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n\n            int incl, newpasses, llen;\n\n\n\n            if (cblk->npasses)\n\n                incl = get_bits(s, 1);\n\n            else\n\n                incl = tag_tree_decode(s, prec->cblkincl + cblkno, layno + 1) == layno;\n\n            if (!incl)\n\n                continue;\n\n            else if (incl < 0)\n\n                return incl;\n\n\n\n            if (!cblk->npasses) {\n\n                int v = expn[bandno] + numgbits - 1 -\n\n                        tag_tree_decode(s, prec->zerobits + cblkno, 100);\n\n                if (v < 0 || v > 30) {\n\n                    av_log(s->avctx, AV_LOG_ERROR,\n\n                           \"nonzerobits %d invalid or unsupported\\n\", v);\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n                cblk->nonzerobits = v;\n\n            }\n\n            if ((newpasses = getnpasses(s)) < 0)\n\n                return newpasses;\n\n            av_assert2(newpasses > 0);\n\n            if (cblk->npasses + newpasses >= JPEG2000_MAX_PASSES) {\n\n                avpriv_request_sample(s->avctx, \"Too many passes\");\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n            if ((llen = getlblockinc(s)) < 0)\n\n                return llen;\n\n            if (cblk->lblock + llen + av_log2(newpasses) > 16) {\n\n                avpriv_request_sample(s->avctx,\n\n                                      \"Block with length beyond 16 bits\");\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n\n\n            cblk->lblock += llen;\n\n\n\n            cblk->nb_lengthinc = 0;\n\n            cblk->nb_terminationsinc = 0;\n\n            do {\n\n                int newpasses1 = 0;\n\n\n\n                while (newpasses1 < newpasses) {\n\n                    newpasses1 ++;\n\n                    if (needs_termination(codsty->cblk_style, cblk->npasses + newpasses1 - 1)) {\n\n                        cblk->nb_terminationsinc ++;\n\n                        break;\n\n                    }\n\n                }\n\n\n\n                if ((ret = get_bits(s, av_log2(newpasses1) + cblk->lblock)) < 0)\n\n                    return ret;\n\n                if (ret > sizeof(cblk->data)) {\n\n                    avpriv_request_sample(s->avctx,\n\n                                        \"Block with lengthinc greater than %\"SIZE_SPECIFIER\"\",\n\n                                        sizeof(cblk->data));\n\n                    return AVERROR_PATCHWELCOME;\n\n                }\n\n                cblk->lengthinc[cblk->nb_lengthinc++] = ret;\n\n                cblk->npasses  += newpasses1;\n\n                newpasses -= newpasses1;\n\n            } while(newpasses);\n\n        }\n\n    }\n\n    jpeg2000_flush(s);\n\n\n\n    if (codsty->csty & JPEG2000_CSTY_EPH) {\n\n        if (bytestream2_peek_be16(&s->g) == JPEG2000_EPH)\n\n            bytestream2_skip(&s->g, 2);\n\n        else\n\n            av_log(s->avctx, AV_LOG_ERROR, \"EPH marker not found. instead %X\\n\", bytestream2_peek_be32(&s->g));\n\n    }\n\n\n\n    for (bandno = 0; bandno < rlevel->nbands; bandno++) {\n\n        Jpeg2000Band *band = rlevel->band + bandno;\n\n        Jpeg2000Prec *prec = band->prec + precno;\n\n\n\n        nb_code_blocks = prec->nb_codeblocks_height * prec->nb_codeblocks_width;\n\n        for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) {\n\n            Jpeg2000Cblk *cblk = prec->cblk + cblkno;\n\n            for (cwsno = 0; cwsno < cblk->nb_lengthinc; cwsno ++) {\n\n                if (   bytestream2_get_bytes_left(&s->g) < cblk->lengthinc[cwsno]\n\n                    || sizeof(cblk->data) < cblk->length + cblk->lengthinc[cwsno] + 4\n\n                ) {\n\n                    av_log(s->avctx, AV_LOG_ERROR,\n\n                        \"Block length %\"PRIu16\" or lengthinc %d is too large, left %d\\n\",\n\n                        cblk->length, cblk->lengthinc[cwsno], bytestream2_get_bytes_left(&s->g));\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                bytestream2_get_bufferu(&s->g, cblk->data + cblk->length, cblk->lengthinc[cwsno]);\n\n                cblk->length   += cblk->lengthinc[cwsno];\n\n                cblk->lengthinc[cwsno] = 0;\n\n                if (cblk->nb_terminationsinc) {\n\n                    cblk->nb_terminationsinc--;\n\n                    cblk->nb_terminations++;\n\n                    cblk->data[cblk->length++] = 0xFF;\n\n                    cblk->data[cblk->length++] = 0xFF;\n\n                    cblk->data_start[cblk->nb_terminations] = cblk->length;\n\n                }\n\n            }\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 3561}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int64_t read_ts(char **line, int *duration)\n\n{\n\n    int64_t start, end;\n\n\n\n    if (sscanf(*line, \"%\"SCNd64\",%\"SCNd64, &start, &end) == 2) {\n\n        *line += strcspn(*line, \"\\\"\") + 1;\n\n        *duration = end - start;\n\n        return start;\n\n    }\n\n    return AV_NOPTS_VALUE;\n\n}\n", "idx": 3596}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void raven_class_init(ObjectClass *klass, void *data)\n\n{\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    k->init = raven_init;\n\n    k->vendor_id = PCI_VENDOR_ID_MOTOROLA;\n\n    k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN;\n\n    k->revision = 0x00;\n\n    k->class_id = PCI_CLASS_BRIDGE_HOST;\n\n    dc->desc = \"PReP Host Bridge - Motorola Raven\";\n\n    dc->vmsd = &vmstate_raven;\n\n    dc->no_user = 1;\n\n}\n", "idx": 3598}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize,\n\n                                int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize,\n\n                                uint8_t *dest, uint8_t *uDest, int dstW, int chrDstW, int dstFormat)\n\n{\n\n    //FIXME Optimize (just quickly writen not opti..)\n\n    int i;\n\n    for (i=0; i<dstW; i++)\n\n    {\n\n        int val=1<<18;\n\n        int j;\n\n        for (j=0; j<lumFilterSize; j++)\n\n            val += lumSrc[j][i] * lumFilter[j];\n\n\n\n        dest[i]= av_clip_uint8(val>>19);\n\n    }\n\n\n\n    if (!uDest)\n\n        return;\n\n\n\n    if (dstFormat == PIX_FMT_NV12)\n\n        for (i=0; i<chrDstW; i++)\n\n        {\n\n            int u=1<<18;\n\n            int v=1<<18;\n\n            int j;\n\n            for (j=0; j<chrFilterSize; j++)\n\n            {\n\n                u += chrSrc[j][i] * chrFilter[j];\n\n                v += chrSrc[j][i + 2048] * chrFilter[j];\n\n            }\n\n\n\n            uDest[2*i]= av_clip_uint8(u>>19);\n\n            uDest[2*i+1]= av_clip_uint8(v>>19);\n\n        }\n\n    else\n\n        for (i=0; i<chrDstW; i++)\n\n        {\n\n            int u=1<<18;\n\n            int v=1<<18;\n\n            int j;\n\n            for (j=0; j<chrFilterSize; j++)\n\n            {\n\n                u += chrSrc[j][i] * chrFilter[j];\n\n                v += chrSrc[j][i + 2048] * chrFilter[j];\n\n            }\n\n\n\n            uDest[2*i]= av_clip_uint8(v>>19);\n\n            uDest[2*i+1]= av_clip_uint8(u>>19);\n\n        }\n\n}\n", "idx": 3621}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int val)\n\n{\n\n    uint32_t qid;\n\n\n\n    if (addr & ((1 << 2) - 1)) {\n\n        return;\n\n    }\n\n\n\n    if (((addr - 0x1000) >> 2) & 1) {\n\n        uint16_t new_head = val & 0xffff;\n\n        int start_sqs;\n\n        NvmeCQueue *cq;\n\n\n\n        qid = (addr - (0x1000 + (1 << 2))) >> 3;\n\n        if (nvme_check_cqid(n, qid)) {\n\n            return;\n\n        }\n\n\n\n        cq = n->cq[qid];\n\n        if (new_head >= cq->size) {\n\n            return;\n\n        }\n\n\n\n        start_sqs = nvme_cq_full(cq) ? 1 : 0;\n\n        cq->head = new_head;\n\n        if (start_sqs) {\n\n            NvmeSQueue *sq;\n\n            QTAILQ_FOREACH(sq, &cq->sq_list, entry) {\n\n                timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);\n\n            }\n\n            timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);\n\n        }\n\n\n\n        if (cq->tail != cq->head) {\n\n            nvme_isr_notify(n, cq);\n\n        }\n\n    } else {\n\n        uint16_t new_tail = val & 0xffff;\n\n        NvmeSQueue *sq;\n\n\n\n        qid = (addr - 0x1000) >> 3;\n\n        if (nvme_check_sqid(n, qid)) {\n\n            return;\n\n        }\n\n\n\n        sq = n->sq[qid];\n\n        if (new_tail >= sq->size) {\n\n            return;\n\n        }\n\n\n\n        sq->tail = new_tail;\n\n        timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500);\n\n    }\n\n}\n", "idx": 3634}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void gen_storeq_reg(DisasContext *s, int rlow, int rhigh, TCGv_i64 val)\n\n{\n\n    TCGv tmp;\n\n    tmp = new_tmp();\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rlow, tmp);\n\n    tmp = new_tmp();\n\n    tcg_gen_shri_i64(val, val, 32);\n\n    tcg_gen_trunc_i64_i32(tmp, val);\n\n    store_reg(s, rhigh, tmp);\n\n}\n", "idx": 3681}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void lms_update(WmallDecodeCtx *s, int ich, int ilms, int16_t input, int16_t pred)\n\n{\n\n    int16_t icoef;\n\n    int recent = s->cdlms[ich][ilms].recent;\n\n    int16_t range = 1 << (s->bits_per_sample - 1);\n\n    int bps = s->bits_per_sample > 16 ? 4 : 2; // bytes per sample\n\n\n\n    if (input > pred) {\n\n        for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)\n\n            s->cdlms[ich][ilms].coefs[icoef] +=\n\n                s->cdlms[ich][ilms].lms_updates[icoef + recent];\n\n    } else {\n\n        for (icoef = 0; icoef < s->cdlms[ich][ilms].order; icoef++)\n\n            s->cdlms[ich][ilms].coefs[icoef] -=\n\n                s->cdlms[ich][ilms].lms_updates[icoef];     // XXX: [icoef + recent] ?\n\n    }\n\n    s->cdlms[ich][ilms].recent--;\n\n    s->cdlms[ich][ilms].lms_prevvalues[recent] = av_clip(input, -range, range - 1);\n\n\n\n    if (input > pred)\n\n        s->cdlms[ich][ilms].lms_updates[recent] = s->update_speed[ich];\n\n    else if (input < pred)\n\n        s->cdlms[ich][ilms].lms_updates[recent] = -s->update_speed[ich];\n\n\n\n    /* XXX: spec says:\n\n    cdlms[iCh][ilms].updates[iRecent + cdlms[iCh][ilms].order >> 4] >>= 2;\n\n    lms_updates[iCh][ilms][iRecent + cdlms[iCh][ilms].order >> 3] >>= 1;\n\n\n\n        Questions is - are cdlms[iCh][ilms].updates[] and lms_updates[][][] two\n\n        seperate buffers? Here I've assumed that the two are same which makes\n\n        more sense to me.\n\n    */\n\n    s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 4] >>= 2;\n\n    s->cdlms[ich][ilms].lms_updates[recent + s->cdlms[ich][ilms].order >> 3] >>= 1;\n\n    /* XXX: recent + (s->cdlms[ich][ilms].order >> 4) ? */\n\n\n\n    if (s->cdlms[ich][ilms].recent == 0) {\n\n        /* XXX: This memcpy()s will probably fail if a fixed 32-bit buffer is used.\n\n                follow kshishkov's suggestion of using a union. */\n\n        memcpy(s->cdlms[ich][ilms].lms_prevvalues + s->cdlms[ich][ilms].order,\n\n               s->cdlms[ich][ilms].lms_prevvalues,\n\n               bps * s->cdlms[ich][ilms].order);\n\n        memcpy(s->cdlms[ich][ilms].lms_updates + s->cdlms[ich][ilms].order,\n\n               s->cdlms[ich][ilms].lms_updates,\n\n               bps * s->cdlms[ich][ilms].order);\n\n        s->cdlms[ich][ilms].recent = s->cdlms[ich][ilms].order;\n\n    }\n\n}\n", "idx": 3714}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void decode_mclms(WmallDecodeCtx *s)\n\n{\n\n    s->mclms_order = (get_bits(&s->gb, 4) + 1) * 2;\n\n    s->mclms_scaling = get_bits(&s->gb, 4);\n\n    if(get_bits1(&s->gb)) {\n\n\t// mclms_send_coef\n\n\tint i;\n\n\tint send_coef_bits;\n\n\tint cbits = av_log2(s->mclms_scaling + 1);\n\n\tassert(cbits == my_log2(s->mclms_scaling + 1));\n\n\tif(1 << cbits < s->mclms_scaling + 1)\n\n\t    cbits++;\n\n\n\n\tsend_coef_bits = (cbits ? get_bits(&s->gb, cbits) : 0) + 2;\n\n\n\n\tfor(i = 0; i < s->mclms_order * s->num_channels * s->num_channels; i++) {\n\n\t    s->mclms_coeffs[i] = get_bits(&s->gb, send_coef_bits);\n\n\t}\n\n\n\n\tfor(i = 0; i < s->num_channels; i++) {\n\n\t    int c;\n\n\t    for(c = 0; c < i; c++) {\n\n\t\ts->mclms_coeffs_cur[i * s->num_channels + c] = get_bits(&s->gb, send_coef_bits);\n\n\t    }\n\n\t}\n\n    }\n\n}\n", "idx": 3722}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int cow_create(const char *filename, QemuOpts *opts, Error **errp)\n\n{\n\n    struct cow_header_v2 cow_header;\n\n    struct stat st;\n\n    int64_t image_sectors = 0;\n\n    char *image_filename = NULL;\n\n    Error *local_err = NULL;\n\n    int ret;\n\n    BlockDriverState *cow_bs;\n\n\n\n    /* Read out options */\n\n    image_sectors = qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0) / 512;\n\n    image_filename = qemu_opt_get_del(opts, BLOCK_OPT_BACKING_FILE);\n\n\n\n    ret = bdrv_create_file(filename, opts, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto exit;\n\n    }\n\n\n\n    cow_bs = NULL;\n\n    ret = bdrv_open(&cow_bs, filename, NULL, NULL,\n\n                    BDRV_O_RDWR | BDRV_O_PROTOCOL, NULL, &local_err);\n\n    if (ret < 0) {\n\n        error_propagate(errp, local_err);\n\n        goto exit;\n\n    }\n\n\n\n    memset(&cow_header, 0, sizeof(cow_header));\n\n    cow_header.magic = cpu_to_be32(COW_MAGIC);\n\n    cow_header.version = cpu_to_be32(COW_VERSION);\n\n    if (image_filename) {\n\n        /* Note: if no file, we put a dummy mtime */\n\n        cow_header.mtime = cpu_to_be32(0);\n\n\n\n        if (stat(image_filename, &st) != 0) {\n\n            goto mtime_fail;\n\n        }\n\n        cow_header.mtime = cpu_to_be32(st.st_mtime);\n\n    mtime_fail:\n\n        pstrcpy(cow_header.backing_file, sizeof(cow_header.backing_file),\n\n                image_filename);\n\n    }\n\n    cow_header.sectorsize = cpu_to_be32(512);\n\n    cow_header.size = cpu_to_be64(image_sectors * 512);\n\n    ret = bdrv_pwrite(cow_bs, 0, &cow_header, sizeof(cow_header));\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\n    /* resize to include at least all the bitmap */\n\n    ret = bdrv_truncate(cow_bs,\n\n        sizeof(cow_header) + ((image_sectors + 7) >> 3));\n\n    if (ret < 0) {\n\n        goto exit;\n\n    }\n\n\n\nexit:\n\n    g_free(image_filename);\n\n    bdrv_unref(cow_bs);\n\n    return ret;\n\n}\n", "idx": 3824}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int smacker_read_header(AVFormatContext *s)\n{\n    AVIOContext *pb = s->pb;\n    SmackerContext *smk = s->priv_data;\n    AVStream *st, *ast[7];\n    int i, ret;\n    int tbase;\n    /* read and check header */\n    smk->magic = avio_rl32(pb);\n    if (smk->magic != MKTAG('S', 'M', 'K', '2') && smk->magic != MKTAG('S', 'M', 'K', '4'))\n    smk->width = avio_rl32(pb);\n    smk->height = avio_rl32(pb);\n    smk->frames = avio_rl32(pb);\n    smk->pts_inc = (int32_t)avio_rl32(pb);\n    smk->flags = avio_rl32(pb);\n    if(smk->flags & SMACKER_FLAG_RING_FRAME)\n        smk->frames++;\n    for(i = 0; i < 7; i++)\n        smk->audio[i] = avio_rl32(pb);\n    smk->treesize = avio_rl32(pb);\n    if(smk->treesize >= UINT_MAX/4){ // smk->treesize + 16 must not overflow (this check is probably redundant)\n        av_log(s, AV_LOG_ERROR, \"treesize too large\\n\");\n//FIXME remove extradata \"rebuilding\"\n    smk->mmap_size = avio_rl32(pb);\n    smk->mclr_size = avio_rl32(pb);\n    smk->full_size = avio_rl32(pb);\n    smk->type_size = avio_rl32(pb);\n    for(i = 0; i < 7; i++) {\n        smk->rates[i]  = avio_rl24(pb);\n        smk->aflags[i] = avio_r8(pb);\n    smk->pad = avio_rl32(pb);\n    /* setup data */\n    if(smk->frames > 0xFFFFFF) {\n        av_log(s, AV_LOG_ERROR, \"Too many frames: %\"PRIu32\"\\n\", smk->frames);\n    smk->frm_size = av_malloc_array(smk->frames, sizeof(*smk->frm_size));\n    smk->frm_flags = av_malloc(smk->frames);\n    if (!smk->frm_size || !smk->frm_flags) {\n        av_freep(&smk->frm_size);\n        av_freep(&smk->frm_flags);\n        return AVERROR(ENOMEM);\n    smk->is_ver4 = (smk->magic != MKTAG('S', 'M', 'K', '2'));\n    /* read frame info */\n    for(i = 0; i < smk->frames; i++) {\n        smk->frm_size[i] = avio_rl32(pb);\n    for(i = 0; i < smk->frames; i++) {\n        smk->frm_flags[i] = avio_r8(pb);\n    /* init video codec */\n    st = avformat_new_stream(s, NULL);\n    if (!st)\n        return AVERROR(ENOMEM);\n    smk->videoindex = st->index;\n    st->codec->width = smk->width;\n    st->codec->height = smk->height;\n    st->codec->pix_fmt = AV_PIX_FMT_PAL8;\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n    st->codec->codec_id = AV_CODEC_ID_SMACKVIDEO;\n    st->codec->codec_tag = smk->magic;\n    /* Smacker uses 100000 as internal timebase */\n    if(smk->pts_inc < 0)\n        smk->pts_inc = -smk->pts_inc;\n    else\n        smk->pts_inc *= 100;\n    tbase = 100000;\n    av_reduce(&tbase, &smk->pts_inc, tbase, smk->pts_inc, (1UL<<31)-1);\n    avpriv_set_pts_info(st, 33, smk->pts_inc, tbase);\n    st->duration = smk->frames;\n    /* handle possible audio streams */\n    for(i = 0; i < 7; i++) {\n        smk->indexes[i] = -1;\n        if (smk->rates[i]) {\n            ast[i] = avformat_new_stream(s, NULL);\n            if (!ast[i])\n                return AVERROR(ENOMEM);\n            smk->indexes[i] = ast[i]->index;\n            ast[i]->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n            if (smk->aflags[i] & SMK_AUD_BINKAUD) {\n                ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_RDFT;\n            } else if (smk->aflags[i] & SMK_AUD_USEDCT) {\n                ast[i]->codec->codec_id = AV_CODEC_ID_BINKAUDIO_DCT;\n            } else if (smk->aflags[i] & SMK_AUD_PACKED){\n                ast[i]->codec->codec_id = AV_CODEC_ID_SMACKAUDIO;\n                ast[i]->codec->codec_tag = MKTAG('S', 'M', 'K', 'A');\n            } else {\n                ast[i]->codec->codec_id = AV_CODEC_ID_PCM_U8;\n            if (smk->aflags[i] & SMK_AUD_STEREO) {\n                ast[i]->codec->channels       = 2;\n                ast[i]->codec->channel_layout = AV_CH_LAYOUT_STEREO;\n            } else {\n                ast[i]->codec->channels       = 1;\n                ast[i]->codec->channel_layout = AV_CH_LAYOUT_MONO;\n            ast[i]->codec->sample_rate = smk->rates[i];\n            ast[i]->codec->bits_per_coded_sample = (smk->aflags[i] & SMK_AUD_16BITS) ? 16 : 8;\n            if(ast[i]->codec->bits_per_coded_sample == 16 && ast[i]->codec->codec_id == AV_CODEC_ID_PCM_U8)\n                ast[i]->codec->codec_id = AV_CODEC_ID_PCM_S16LE;\n            avpriv_set_pts_info(ast[i], 64, 1, ast[i]->codec->sample_rate\n                    * ast[i]->codec->channels * ast[i]->codec->bits_per_coded_sample / 8);\n    /* load trees to extradata, they will be unpacked by decoder */\n    if(ff_alloc_extradata(st->codec, smk->treesize + 16)){\n        av_log(s, AV_LOG_ERROR,\n               \"Cannot allocate %\"PRIu32\" bytes of extradata\\n\",\n               smk->treesize + 16);\n        av_freep(&smk->frm_size);\n        av_freep(&smk->frm_flags);\n        return AVERROR(ENOMEM);\n    ret = avio_read(pb, st->codec->extradata + 16, st->codec->extradata_size - 16);\n    if(ret != st->codec->extradata_size - 16){\n        av_freep(&smk->frm_size);\n        av_freep(&smk->frm_flags);\n        return AVERROR(EIO);\n    ((int32_t*)st->codec->extradata)[0] = av_le2ne32(smk->mmap_size);\n    ((int32_t*)st->codec->extradata)[1] = av_le2ne32(smk->mclr_size);\n    ((int32_t*)st->codec->extradata)[2] = av_le2ne32(smk->full_size);\n    ((int32_t*)st->codec->extradata)[3] = av_le2ne32(smk->type_size);\n    smk->curstream = -1;\n    smk->nextpos = avio_tell(pb);\n    return 0;", "idx": 3913}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int lag_decode_zero_run_line(LagarithContext *l, uint8_t *dst,\n\n                                    const uint8_t *src, const uint8_t *src_end,\n\n                                    int width, int esc_count)\n\n{\n\n    int i = 0;\n\n    int count;\n\n    uint8_t zero_run = 0;\n\n    const uint8_t *src_start = src;\n\n    uint8_t mask1 = -(esc_count < 2);\n\n    uint8_t mask2 = -(esc_count < 3);\n\n    uint8_t *end = dst + (width - 2);\n\n\n\n    avpriv_request_sample(l->avctx, \"zero_run_line\");\n\n    return AVERROR_PATCHWELCOME;\n\n\n\noutput_zeros:\n\n    if (l->zeros_rem) {\n\n        count = FFMIN(l->zeros_rem, width - i);\n\n        if (end - dst < count) {\n\n            av_log(l->avctx, AV_LOG_ERROR, \"Too many zeros remaining.\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        memset(dst, 0, count);\n\n        l->zeros_rem -= count;\n\n        dst += count;\n\n    }\n\n\n\n    while (dst < end) {\n\n        i = 0;\n\n        while (!zero_run && dst + i < end) {\n\n            i++;\n\n            if (i+2 >= src_end - src)\n\n                return AVERROR_INVALIDDATA;\n\n            zero_run =\n\n                !(src[i] | (src[i + 1] & mask1) | (src[i + 2] & mask2));\n\n        }\n\n        if (zero_run) {\n\n            zero_run = 0;\n\n            i += esc_count;\n\n            memcpy(dst, src, i);\n\n            dst += i;\n\n            l->zeros_rem = lag_calc_zero_run(src[i]);\n\n\n\n            src += i + 1;\n\n            goto output_zeros;\n\n        } else {\n\n            memcpy(dst, src, i);\n\n            src += i;\n\n            dst += i;\n\n        }\n\n    }\n\n    return  src - src_start;\n\n}\n", "idx": 4009}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int ram_init_all(RAMState **rsp)\n\n{\n\n    Error *local_err = NULL;\n\n\n\n    if (ram_state_init(rsp)) {\n\n        return -1;\n\n    }\n\n\n\n    if (migrate_use_xbzrle()) {\n\n        XBZRLE_cache_lock();\n\n        XBZRLE.zero_target_page = g_malloc0(TARGET_PAGE_SIZE);\n\n        XBZRLE.cache = cache_init(migrate_xbzrle_cache_size(),\n\n                                  TARGET_PAGE_SIZE, &local_err);\n\n        if (!XBZRLE.cache) {\n\n            XBZRLE_cache_unlock();\n\n            error_report_err(local_err);\n\n            g_free(*rsp);\n\n            *rsp = NULL;\n\n            return -1;\n\n        }\n\n        XBZRLE_cache_unlock();\n\n\n\n        /* We prefer not to abort if there is no memory */\n\n        XBZRLE.encoded_buf = g_try_malloc0(TARGET_PAGE_SIZE);\n\n        if (!XBZRLE.encoded_buf) {\n\n            error_report(\"Error allocating encoded_buf\");\n\n            g_free(*rsp);\n\n            *rsp = NULL;\n\n            return -1;\n\n        }\n\n\n\n        XBZRLE.current_buf = g_try_malloc(TARGET_PAGE_SIZE);\n\n        if (!XBZRLE.current_buf) {\n\n            error_report(\"Error allocating current_buf\");\n\n            g_free(XBZRLE.encoded_buf);\n\n            XBZRLE.encoded_buf = NULL;\n\n            g_free(*rsp);\n\n            *rsp = NULL;\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    /* For memory_global_dirty_log_start below.  */\n\n    qemu_mutex_lock_iothread();\n\n\n\n    qemu_mutex_lock_ramlist();\n\n    rcu_read_lock();\n\n\n\n    /* Skip setting bitmap if there is no RAM */\n\n    if (ram_bytes_total()) {\n\n        RAMBlock *block;\n\n\n\n        QLIST_FOREACH_RCU(block, &ram_list.blocks, next) {\n\n            unsigned long pages = block->max_length >> TARGET_PAGE_BITS;\n\n\n\n            block->bmap = bitmap_new(pages);\n\n            bitmap_set(block->bmap, 0, pages);\n\n            if (migrate_postcopy_ram()) {\n\n                block->unsentmap = bitmap_new(pages);\n\n                bitmap_set(block->unsentmap, 0, pages);\n\n            }\n\n        }\n\n    }\n\n\n\n    memory_global_dirty_log_start();\n\n    migration_bitmap_sync(*rsp);\n\n    qemu_mutex_unlock_ramlist();\n\n    qemu_mutex_unlock_iothread();\n\n    rcu_read_unlock();\n\n\n\n    return 0;\n\n}\n", "idx": 4017}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int decode_entropy_coded_image(WebPContext *s, enum ImageRole role,\n\n                                      int w, int h)\n\n{\n\n    ImageContext *img;\n\n    HuffReader *hg;\n\n    int i, j, ret, x, y, width;\n\n\n\n    img       = &s->image[role];\n\n    img->role = role;\n\n\n\n    if (!img->frame) {\n\n        img->frame = av_frame_alloc();\n\n        if (!img->frame)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    img->frame->format = AV_PIX_FMT_ARGB;\n\n    img->frame->width  = w;\n\n    img->frame->height = h;\n\n\n\n    if (role == IMAGE_ROLE_ARGB && !img->is_alpha_primary) {\n\n        ThreadFrame pt = { .f = img->frame };\n\n        ret = ff_thread_get_buffer(s->avctx, &pt, 0);\n\n    } else\n\n        ret = av_frame_get_buffer(img->frame, 1);\n\n    if (ret < 0)\n\n        return ret;\n\n\n\n    if (get_bits1(&s->gb)) {\n\n        img->color_cache_bits = get_bits(&s->gb, 4);\n\n        if (img->color_cache_bits < 1 || img->color_cache_bits > 11) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"invalid color cache bits: %d\\n\",\n\n                   img->color_cache_bits);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        img->color_cache = av_mallocz_array(1 << img->color_cache_bits,\n\n                                            sizeof(*img->color_cache));\n\n        if (!img->color_cache)\n\n            return AVERROR(ENOMEM);\n\n    } else {\n\n        img->color_cache_bits = 0;\n\n    }\n\n\n\n    img->nb_huffman_groups = 1;\n\n    if (role == IMAGE_ROLE_ARGB && get_bits1(&s->gb)) {\n\n        ret = decode_entropy_image(s);\n\n        if (ret < 0)\n\n            return ret;\n\n        img->nb_huffman_groups = s->nb_huffman_groups;\n\n    }\n\n    img->huffman_groups = av_mallocz_array(img->nb_huffman_groups *\n\n                                           HUFFMAN_CODES_PER_META_CODE,\n\n                                           sizeof(*img->huffman_groups));\n\n    if (!img->huffman_groups)\n\n        return AVERROR(ENOMEM);\n\n\n\n    for (i = 0; i < img->nb_huffman_groups; i++) {\n\n        hg = &img->huffman_groups[i * HUFFMAN_CODES_PER_META_CODE];\n\n        for (j = 0; j < HUFFMAN_CODES_PER_META_CODE; j++) {\n\n            int alphabet_size = alphabet_sizes[j];\n\n            if (!j && img->color_cache_bits > 0)\n\n                alphabet_size += 1 << img->color_cache_bits;\n\n\n\n            if (get_bits1(&s->gb)) {\n\n                read_huffman_code_simple(s, &hg[j]);\n\n            } else {\n\n                ret = read_huffman_code_normal(s, &hg[j], alphabet_size);\n\n                if (ret < 0)\n\n                    return ret;\n\n            }\n\n        }\n\n    }\n\n\n\n    width = img->frame->width;\n\n    if (role == IMAGE_ROLE_ARGB && s->reduced_width > 0)\n\n        width = s->reduced_width;\n\n\n\n    x = 0; y = 0;\n\n    while (y < img->frame->height) {\n\n        int v;\n\n\n\n        hg = get_huffman_group(s, img, x, y);\n\n        v = huff_reader_get_symbol(&hg[HUFF_IDX_GREEN], &s->gb);\n\n        if (v < NUM_LITERAL_CODES) {\n\n            /* literal pixel values */\n\n            uint8_t *p = GET_PIXEL(img->frame, x, y);\n\n            p[2] = v;\n\n            p[1] = huff_reader_get_symbol(&hg[HUFF_IDX_RED],   &s->gb);\n\n            p[3] = huff_reader_get_symbol(&hg[HUFF_IDX_BLUE],  &s->gb);\n\n            p[0] = huff_reader_get_symbol(&hg[HUFF_IDX_ALPHA], &s->gb);\n\n            if (img->color_cache_bits)\n\n                color_cache_put(img, AV_RB32(p));\n\n            x++;\n\n            if (x == width) {\n\n                x = 0;\n\n                y++;\n\n            }\n\n        } else if (v < NUM_LITERAL_CODES + NUM_LENGTH_CODES) {\n\n            /* LZ77 backwards mapping */\n\n            int prefix_code, length, distance, ref_x, ref_y;\n\n\n\n            /* parse length and distance */\n\n            prefix_code = v - NUM_LITERAL_CODES;\n\n            if (prefix_code < 4) {\n\n                length = prefix_code + 1;\n\n            } else {\n\n                int extra_bits = (prefix_code - 2) >> 1;\n\n                int offset     = 2 + (prefix_code & 1) << extra_bits;\n\n                length = offset + get_bits(&s->gb, extra_bits) + 1;\n\n            }\n\n            prefix_code = huff_reader_get_symbol(&hg[HUFF_IDX_DIST], &s->gb);\n\n            if (prefix_code > 39) {\n\n                av_log(s->avctx, AV_LOG_ERROR,\n\n                       \"distance prefix code too large: %d\\n\", prefix_code);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            if (prefix_code < 4) {\n\n                distance = prefix_code + 1;\n\n            } else {\n\n                int extra_bits = prefix_code - 2 >> 1;\n\n                int offset     = 2 + (prefix_code & 1) << extra_bits;\n\n                distance = offset + get_bits(&s->gb, extra_bits) + 1;\n\n            }\n\n\n\n            /* find reference location */\n\n            if (distance <= NUM_SHORT_DISTANCES) {\n\n                int xi = lz77_distance_offsets[distance - 1][0];\n\n                int yi = lz77_distance_offsets[distance - 1][1];\n\n                distance = FFMAX(1, xi + yi * width);\n\n            } else {\n\n                distance -= NUM_SHORT_DISTANCES;\n\n            }\n\n            ref_x = x;\n\n            ref_y = y;\n\n            if (distance <= x) {\n\n                ref_x -= distance;\n\n                distance = 0;\n\n            } else {\n\n                ref_x = 0;\n\n                distance -= x;\n\n            }\n\n            while (distance >= width) {\n\n                ref_y--;\n\n                distance -= width;\n\n            }\n\n            if (distance > 0) {\n\n                ref_x = width - distance;\n\n                ref_y--;\n\n            }\n\n            ref_x = FFMAX(0, ref_x);\n\n            ref_y = FFMAX(0, ref_y);\n\n\n\n            /* copy pixels\n\n             * source and dest regions can overlap and wrap lines, so just\n\n             * copy per-pixel */\n\n            for (i = 0; i < length; i++) {\n\n                uint8_t *p_ref = GET_PIXEL(img->frame, ref_x, ref_y);\n\n                uint8_t *p     = GET_PIXEL(img->frame,     x,     y);\n\n\n\n                AV_COPY32(p, p_ref);\n\n                if (img->color_cache_bits)\n\n                    color_cache_put(img, AV_RB32(p));\n\n                x++;\n\n                ref_x++;\n\n                if (x == width) {\n\n                    x = 0;\n\n                    y++;\n\n                }\n\n                if (ref_x == width) {\n\n                    ref_x = 0;\n\n                    ref_y++;\n\n                }\n\n                if (y == img->frame->height || ref_y == img->frame->height)\n\n                    break;\n\n            }\n\n        } else {\n\n            /* read from color cache */\n\n            uint8_t *p = GET_PIXEL(img->frame, x, y);\n\n            int cache_idx = v - (NUM_LITERAL_CODES + NUM_LENGTH_CODES);\n\n\n\n            if (!img->color_cache_bits) {\n\n                av_log(s->avctx, AV_LOG_ERROR, \"color cache not found\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            if (cache_idx >= 1 << img->color_cache_bits) {\n\n                av_log(s->avctx, AV_LOG_ERROR,\n\n                       \"color cache index out-of-bounds\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            AV_WB32(p, img->color_cache[cache_idx]);\n\n            x++;\n\n            if (x == width) {\n\n                x = 0;\n\n                y++;\n\n            }\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 4029}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int svq1_encode_plane(SVQ1Context *s, int plane,\n\n                             unsigned char *src_plane,\n\n                             unsigned char *ref_plane,\n\n                             unsigned char *decoded_plane,\n\n                             int width, int height, int src_stride, int stride)\n\n{\n\n    const AVFrame *f = s->avctx->coded_frame;\n\n    int x, y;\n\n    int i;\n\n    int block_width, block_height;\n\n    int level;\n\n    int threshold[6];\n\n    uint8_t *src     = s->scratchbuf + stride * 16;\n\n    const int lambda = (f->quality * f->quality) >>\n\n                       (2 * FF_LAMBDA_SHIFT);\n\n\n\n    /* figure out the acceptable level thresholds in advance */\n\n    threshold[5] = QUALITY_THRESHOLD;\n\n    for (level = 4; level >= 0; level--)\n\n        threshold[level] = threshold[level + 1] * THRESHOLD_MULTIPLIER;\n\n\n\n    block_width  = (width  + 15) / 16;\n\n    block_height = (height + 15) / 16;\n\n\n\n    if (f->pict_type == AV_PICTURE_TYPE_P) {\n\n        s->m.avctx                         = s->avctx;\n\n        s->m.current_picture_ptr           = &s->m.current_picture;\n\n        s->m.last_picture_ptr              = &s->m.last_picture;\n\n        s->m.last_picture.f.data[0]        = ref_plane;\n\n        s->m.linesize                      =\n\n        s->m.last_picture.f.linesize[0]    =\n\n        s->m.new_picture.f.linesize[0]     =\n\n        s->m.current_picture.f.linesize[0] = stride;\n\n        s->m.width                         = width;\n\n        s->m.height                        = height;\n\n        s->m.mb_width                      = block_width;\n\n        s->m.mb_height                     = block_height;\n\n        s->m.mb_stride                     = s->m.mb_width + 1;\n\n        s->m.b8_stride                     = 2 * s->m.mb_width + 1;\n\n        s->m.f_code                        = 1;\n\n        s->m.pict_type                     = f->pict_type;\n\n        s->m.me_method                     = s->avctx->me_method;\n\n        s->m.me.scene_change_score         = 0;\n\n        s->m.flags                         = s->avctx->flags;\n\n        // s->m.out_format                    = FMT_H263;\n\n        // s->m.unrestricted_mv               = 1;\n\n        s->m.lambda                        = f->quality;\n\n        s->m.qscale                        = s->m.lambda * 139 +\n\n                                             FF_LAMBDA_SCALE * 64 >>\n\n                                             FF_LAMBDA_SHIFT + 7;\n\n        s->m.lambda2                       = s->m.lambda * s->m.lambda +\n\n                                             FF_LAMBDA_SCALE / 2 >>\n\n                                             FF_LAMBDA_SHIFT;\n\n\n\n        if (!s->motion_val8[plane]) {\n\n            s->motion_val8[plane]  = av_mallocz((s->m.b8_stride *\n\n                                                 block_height * 2 + 2) *\n\n                                                2 * sizeof(int16_t));\n\n            s->motion_val16[plane] = av_mallocz((s->m.mb_stride *\n\n                                                 (block_height + 2) + 1) *\n\n                                                2 * sizeof(int16_t));\n\n        }\n\n\n\n        s->m.mb_type = s->mb_type;\n\n\n\n        // dummies, to avoid segfaults\n\n        s->m.current_picture.mb_mean   = (uint8_t *)s->dummy;\n\n        s->m.current_picture.mb_var    = (uint16_t *)s->dummy;\n\n        s->m.current_picture.mc_mb_var = (uint16_t *)s->dummy;\n\n        s->m.current_picture.mb_type = s->dummy;\n\n\n\n        s->m.current_picture.motion_val[0]   = s->motion_val8[plane] + 2;\n\n        s->m.p_mv_table                      = s->motion_val16[plane] +\n\n                                               s->m.mb_stride + 1;\n\n        s->m.dsp                             = s->dsp; // move\n\n        ff_init_me(&s->m);\n\n\n\n        s->m.me.dia_size      = s->avctx->dia_size;\n\n        s->m.first_slice_line = 1;\n\n        for (y = 0; y < block_height; y++) {\n\n            s->m.new_picture.f.data[0] = src - y * 16 * stride; // ugly\n\n            s->m.mb_y                  = y;\n\n\n\n            for (i = 0; i < 16 && i + 16 * y < height; i++) {\n\n                memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],\n\n                       width);\n\n                for (x = width; x < 16 * block_width; x++)\n\n                    src[i * stride + x] = src[i * stride + x - 1];\n\n            }\n\n            for (; i < 16 && i + 16 * y < 16 * block_height; i++)\n\n                memcpy(&src[i * stride], &src[(i - 1) * stride],\n\n                       16 * block_width);\n\n\n\n            for (x = 0; x < block_width; x++) {\n\n                s->m.mb_x = x;\n\n                ff_init_block_index(&s->m);\n\n                ff_update_block_index(&s->m);\n\n\n\n                ff_estimate_p_frame_motion(&s->m, x, y);\n\n            }\n\n            s->m.first_slice_line = 0;\n\n        }\n\n\n\n        ff_fix_long_p_mvs(&s->m);\n\n        ff_fix_long_mvs(&s->m, NULL, 0, s->m.p_mv_table, s->m.f_code,\n\n                        CANDIDATE_MB_TYPE_INTER, 0);\n\n    }\n\n\n\n    s->m.first_slice_line = 1;\n\n    for (y = 0; y < block_height; y++) {\n\n        for (i = 0; i < 16 && i + 16 * y < height; i++) {\n\n            memcpy(&src[i * stride], &src_plane[(i + 16 * y) * src_stride],\n\n                   width);\n\n            for (x = width; x < 16 * block_width; x++)\n\n                src[i * stride + x] = src[i * stride + x - 1];\n\n        }\n\n        for (; i < 16 && i + 16 * y < 16 * block_height; i++)\n\n            memcpy(&src[i * stride], &src[(i - 1) * stride], 16 * block_width);\n\n\n\n        s->m.mb_y = y;\n\n        for (x = 0; x < block_width; x++) {\n\n            uint8_t reorder_buffer[3][6][7 * 32];\n\n            int count[3][6];\n\n            int offset       = y * 16 * stride + x * 16;\n\n            uint8_t *decoded = decoded_plane + offset;\n\n            uint8_t *ref     = ref_plane + offset;\n\n            int score[4]     = { 0, 0, 0, 0 }, best;\n\n            uint8_t *temp    = s->scratchbuf;\n\n\n\n            if (s->pb.buf_end - s->pb.buf -\n\n                (put_bits_count(&s->pb) >> 3) < 3000) { // FIXME: check size\n\n                av_log(s->avctx, AV_LOG_ERROR, \"encoded frame too large\\n\");\n\n                return -1;\n\n            }\n\n\n\n            s->m.mb_x = x;\n\n            ff_init_block_index(&s->m);\n\n            ff_update_block_index(&s->m);\n\n\n\n            if (f->pict_type == AV_PICTURE_TYPE_I ||\n\n                (s->m.mb_type[x + y * s->m.mb_stride] &\n\n                 CANDIDATE_MB_TYPE_INTRA)) {\n\n                for (i = 0; i < 6; i++)\n\n                    init_put_bits(&s->reorder_pb[i], reorder_buffer[0][i],\n\n                                  7 * 32);\n\n                if (f->pict_type == AV_PICTURE_TYPE_P) {\n\n                    const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTRA];\n\n                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);\n\n                    score[0] = vlc[1] * lambda;\n\n                }\n\n                score[0] += encode_block(s, src + 16 * x, NULL, temp, stride,\n\n                                         5, 64, lambda, 1);\n\n                for (i = 0; i < 6; i++) {\n\n                    count[0][i] = put_bits_count(&s->reorder_pb[i]);\n\n                    flush_put_bits(&s->reorder_pb[i]);\n\n                }\n\n            } else\n\n                score[0] = INT_MAX;\n\n\n\n            best = 0;\n\n\n\n            if (f->pict_type == AV_PICTURE_TYPE_P) {\n\n                const uint8_t *vlc = ff_svq1_block_type_vlc[SVQ1_BLOCK_INTER];\n\n                int mx, my, pred_x, pred_y, dxy;\n\n                int16_t *motion_ptr;\n\n\n\n                motion_ptr = ff_h263_pred_motion(&s->m, 0, 0, &pred_x, &pred_y);\n\n                if (s->m.mb_type[x + y * s->m.mb_stride] &\n\n                    CANDIDATE_MB_TYPE_INTER) {\n\n                    for (i = 0; i < 6; i++)\n\n                        init_put_bits(&s->reorder_pb[i], reorder_buffer[1][i],\n\n                                      7 * 32);\n\n\n\n                    put_bits(&s->reorder_pb[5], vlc[1], vlc[0]);\n\n\n\n                    s->m.pb = s->reorder_pb[5];\n\n                    mx      = motion_ptr[0];\n\n                    my      = motion_ptr[1];\n\n                    assert(mx     >= -32 && mx     <= 31);\n\n                    assert(my     >= -32 && my     <= 31);\n\n                    assert(pred_x >= -32 && pred_x <= 31);\n\n                    assert(pred_y >= -32 && pred_y <= 31);\n\n                    ff_h263_encode_motion(&s->m, mx - pred_x, 1);\n\n                    ff_h263_encode_motion(&s->m, my - pred_y, 1);\n\n                    s->reorder_pb[5] = s->m.pb;\n\n                    score[1]        += lambda * put_bits_count(&s->reorder_pb[5]);\n\n\n\n                    dxy = (mx & 1) + 2 * (my & 1);\n\n\n\n                    s->hdsp.put_pixels_tab[0][dxy](temp + 16,\n\n                                                   ref + (mx >> 1) +\n\n                                                   stride * (my >> 1),\n\n                                                   stride, 16);\n\n\n\n                    score[1] += encode_block(s, src + 16 * x, temp + 16,\n\n                                             decoded, stride, 5, 64, lambda, 0);\n\n                    best      = score[1] <= score[0];\n\n\n\n                    vlc       = ff_svq1_block_type_vlc[SVQ1_BLOCK_SKIP];\n\n                    score[2]  = s->dsp.sse[0](NULL, src + 16 * x, ref,\n\n                                              stride, 16);\n\n                    score[2] += vlc[1] * lambda;\n\n                    if (score[2] < score[best] && mx == 0 && my == 0) {\n\n                        best = 2;\n\n                        s->hdsp.put_pixels_tab[0][0](decoded, ref, stride, 16);\n\n                        for (i = 0; i < 6; i++)\n\n                            count[2][i] = 0;\n\n                        put_bits(&s->pb, vlc[1], vlc[0]);\n\n                    }\n\n                }\n\n\n\n                if (best == 1) {\n\n                    for (i = 0; i < 6; i++) {\n\n                        count[1][i] = put_bits_count(&s->reorder_pb[i]);\n\n                        flush_put_bits(&s->reorder_pb[i]);\n\n                    }\n\n                } else {\n\n                    motion_ptr[0]                      =\n\n                    motion_ptr[1]                      =\n\n                    motion_ptr[2]                      =\n\n                    motion_ptr[3]                      =\n\n                    motion_ptr[0 + 2 * s->m.b8_stride] =\n\n                    motion_ptr[1 + 2 * s->m.b8_stride] =\n\n                    motion_ptr[2 + 2 * s->m.b8_stride] =\n\n                    motion_ptr[3 + 2 * s->m.b8_stride] = 0;\n\n                }\n\n            }\n\n\n\n            s->rd_total += score[best];\n\n\n\n            for (i = 5; i >= 0; i--)\n\n                avpriv_copy_bits(&s->pb, reorder_buffer[best][i],\n\n                                 count[best][i]);\n\n            if (best == 0)\n\n                s->hdsp.put_pixels_tab[0][0](decoded, temp, stride, 16);\n\n        }\n\n        s->m.first_slice_line = 0;\n\n    }\n\n    return 0;\n\n}\n", "idx": 4062}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int ffmmal_add_packet(AVCodecContext *avctx, AVPacket *avpkt,\n\n                             int is_extradata)\n\n{\n\n    MMALDecodeContext *ctx = avctx->priv_data;\n\n    AVBufferRef *buf = NULL;\n\n    int size = 0;\n\n    uint8_t *data = (uint8_t *)\"\";\n\n    uint8_t *start;\n\n    int ret = 0;\n\n\n\n    if (avpkt->size) {\n\n        if (avpkt->buf) {\n\n            buf = av_buffer_ref(avpkt->buf);\n\n            size = avpkt->size;\n\n            data = avpkt->data;\n\n        } else {\n\n            buf = av_buffer_alloc(avpkt->size);\n\n            if (buf) {\n\n                memcpy(buf->data, avpkt->data, avpkt->size);\n\n                size = buf->size;\n\n                data = buf->data;\n\n            }\n\n        }\n\n        if (!buf) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto done;\n\n        }\n\n        if (!is_extradata)\n\n            ctx->packets_sent++;\n\n    } else {\n\n        if (!ctx->packets_sent) {\n\n            // Short-cut the flush logic to avoid upsetting MMAL.\n\n            ctx->eos_sent = 1;\n\n            ctx->eos_received = 1;\n\n            goto done;\n\n        }\n\n    }\n\n\n\n    start = data;\n\n\n\n    do {\n\n        FFBufferEntry *buffer = av_mallocz(sizeof(*buffer));\n\n        if (!buffer) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto done;\n\n        }\n\n\n\n        buffer->data = data;\n\n        buffer->length = FFMIN(size, ctx->decoder->input[0]->buffer_size);\n\n\n\n        if (is_extradata)\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_CONFIG;\n\n\n\n        if (data == start)\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_START;\n\n\n\n        data += buffer->length;\n\n        size -= buffer->length;\n\n\n\n        buffer->pts = avpkt->pts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->pts;\n\n        buffer->dts = avpkt->dts == AV_NOPTS_VALUE ? MMAL_TIME_UNKNOWN : avpkt->dts;\n\n\n\n        if (!size)\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_FRAME_END;\n\n\n\n        if (!buffer->length) {\n\n            buffer->flags |= MMAL_BUFFER_HEADER_FLAG_EOS;\n\n            ctx->eos_sent = 1;\n\n        }\n\n\n\n        if (buf) {\n\n            buffer->ref = av_buffer_ref(buf);\n\n            if (!buffer->ref) {\n\n                av_free(buffer);\n\n                ret = AVERROR(ENOMEM);\n\n                goto done;\n\n            }\n\n        }\n\n\n\n        // Insert at end of the list\n\n        if (!ctx->waiting_buffers)\n\n            ctx->waiting_buffers = buffer;\n\n        if (ctx->waiting_buffers_tail)\n\n            ctx->waiting_buffers_tail->next = buffer;\n\n        ctx->waiting_buffers_tail = buffer;\n\n    } while (size);\n\n\n\ndone:\n\n    av_buffer_unref(&buf);\n\n    return ret;\n\n}\n", "idx": 4064}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void write_frame(AVFormatContext *s, AVPacket *pkt, OutputStream *ost)\n\n{\n\n    AVBitStreamFilterContext *bsfc = ost->bitstream_filters;\n\n    AVCodecContext          *avctx = ost->st->codec;\n\n    int ret;\n\n\n\n    if ((avctx->codec_type == AVMEDIA_TYPE_VIDEO && video_sync_method == VSYNC_DROP) ||\n\n        (avctx->codec_type == AVMEDIA_TYPE_AUDIO && audio_sync_method < 0))\n\n        pkt->pts = pkt->dts = AV_NOPTS_VALUE;\n\n\n\n    if (avctx->codec_type == AVMEDIA_TYPE_AUDIO && pkt->dts != AV_NOPTS_VALUE) {\n\n        int64_t max = ost->st->cur_dts + !(s->oformat->flags & AVFMT_TS_NONSTRICT);\n\n        if (ost->st->cur_dts && ost->st->cur_dts != AV_NOPTS_VALUE &&  max > pkt->dts) {\n\n            av_log(s, max - pkt->dts > 2 ? AV_LOG_WARNING : AV_LOG_DEBUG, \"Audio timestamp %\"PRId64\" < %\"PRId64\" invalid, cliping\\n\", pkt->dts, max);\n\n            pkt->pts = pkt->dts = max;\n\n\n\n\n\n    /*\n\n     * Audio encoders may split the packets --  #frames in != #packets out.\n\n     * But there is no reordering, so we can limit the number of output packets\n\n     * by simply dropping them here.\n\n     * Counting encoded video frames needs to be done separately because of\n\n     * reordering, see do_video_out()\n\n     */\n\n    if (!(avctx->codec_type == AVMEDIA_TYPE_VIDEO && avctx->codec)) {\n\n        if (ost->frame_number >= ost->max_frames) {\n\n            av_free_packet(pkt);\n\n            return;\n\n\n        ost->frame_number++;\n\n\n\n\n    while (bsfc) {\n\n        AVPacket new_pkt = *pkt;\n\n        int a = av_bitstream_filter_filter(bsfc, avctx, NULL,\n\n                                           &new_pkt.data, &new_pkt.size,\n\n                                           pkt->data, pkt->size,\n\n                                           pkt->flags & AV_PKT_FLAG_KEY);\n\n\n\n\n\n\n\n\n\n\n\n        if (a > 0) {\n\n            av_free_packet(pkt);\n\n            new_pkt.destruct = av_destruct_packet;\n\n        } else if (a < 0) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Failed to open bitstream filter %s for stream %d with codec %s\",\n\n                   bsfc->filter->name, pkt->stream_index,\n\n                   avctx->codec ? avctx->codec->name : \"copy\");\n\n            print_error(\"\", a);\n\n            if (exit_on_error)\n\n                exit_program(1);\n\n\n        *pkt = new_pkt;\n\n\n\n        bsfc = bsfc->next;\n\n\n\n\n    pkt->stream_index = ost->index;\n\n    ret = av_interleaved_write_frame(s, pkt);\n\n    if (ret < 0) {\n\n        print_error(\"av_interleaved_write_frame()\", ret);\n\n        exit_program(1);\n\n", "idx": 4070}, {"project": "test", "commit_id": "test", "target": 1, "func": "void qed_commit_l2_cache_entry(L2TableCache *l2_cache, CachedL2Table *l2_table)\n\n{\n\n    CachedL2Table *entry;\n\n\n\n    entry = qed_find_l2_cache_entry(l2_cache, l2_table->offset);\n\n    if (entry) {\n\n        qed_unref_l2_cache_entry(entry);\n\n        qed_unref_l2_cache_entry(l2_table);\n\n        return;\n\n    }\n\n\n\n    if (l2_cache->n_entries >= MAX_L2_CACHE_SIZE) {\n\n        entry = QTAILQ_FIRST(&l2_cache->entries);\n\n        QTAILQ_REMOVE(&l2_cache->entries, entry, node);\n\n        l2_cache->n_entries--;\n\n        qed_unref_l2_cache_entry(entry);\n\n    }\n\n\n\n    l2_cache->n_entries++;\n\n    QTAILQ_INSERT_TAIL(&l2_cache->entries, l2_table, node);\n\n}\n", "idx": 4080}, {"project": "test", "commit_id": "test", "target": 1, "func": "static USBDevice *usb_net_init(const char *cmdline)\n\n{\n\n    USBDevice *dev;\n\n    QemuOpts *opts;\n\n    int idx;\n\n\n\n    opts = qemu_opts_parse(&qemu_net_opts, cmdline, NULL);\n\n    if (!opts) {\n\n\n\n    qemu_opt_set(opts, \"type\", \"nic\");\n\n    qemu_opt_set(opts, \"model\", \"usb\");\n\n\n\n    idx = net_client_init(NULL, opts, 0);\n\n    if (idx == -1) {\n\n\n\n\n\n    dev = usb_create(NULL /* FIXME */, \"usb-net\");\n\n\n\n\n    qdev_set_nic_properties(&dev->qdev, &nd_table[idx]);\n\n    qdev_init_nofail(&dev->qdev);\n\n    return dev;\n", "idx": 4093}, {"project": "test", "commit_id": "test", "target": 1, "func": "int av_packet_split_side_data(AVPacket *pkt){\n\n    if (!pkt->side_data_elems && pkt->size >12 && AV_RB64(pkt->data + pkt->size - 8) == FF_MERGE_MARKER){\n\n        int i;\n\n        unsigned int size;\n\n        uint8_t *p;\n\n\n\n        p = pkt->data + pkt->size - 8 - 5;\n\n        for (i=1; ; i++){\n\n            size = AV_RB32(p);\n\n            if (size>INT_MAX || p - pkt->data < size)\n\n                return 0;\n\n            if (p[4]&128)\n\n                break;\n\n            p-= size+5;\n\n        }\n\n\n\n        pkt->side_data = av_malloc_array(i, sizeof(*pkt->side_data));\n\n        if (!pkt->side_data)\n\n            return AVERROR(ENOMEM);\n\n\n\n        p= pkt->data + pkt->size - 8 - 5;\n\n        for (i=0; ; i++){\n\n            size= AV_RB32(p);\n\n            av_assert0(size<=INT_MAX && p - pkt->data >= size);\n\n            pkt->side_data[i].data = av_mallocz(size + AV_INPUT_BUFFER_PADDING_SIZE);\n\n            pkt->side_data[i].size = size;\n\n            pkt->side_data[i].type = p[4]&127;\n\n            if (!pkt->side_data[i].data)\n\n                return AVERROR(ENOMEM);\n\n            memcpy(pkt->side_data[i].data, p-size, size);\n\n            pkt->size -= size + 5;\n\n            if(p[4]&128)\n\n                break;\n\n            p-= size+5;\n\n        }\n\n        pkt->size -= 8;\n\n        pkt->side_data_elems = i+1;\n\n        return 1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 4159}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int parse_adaptation_sets(AVFormatContext *s)\n\n{\n\n    WebMDashMuxContext *w = s->priv_data;\n\n    char *p = w->adaptation_sets;\n\n    char *q;\n\n    enum { new_set, parsed_id, parsing_streams } state;\n\n    if (!w->adaptation_sets) {\n\n        av_log(s, AV_LOG_ERROR, \"The 'adaptation_sets' option must be set.\\n\");\n\n        return AVERROR(EINVAL);\n\n    }\n\n    // syntax id=0,streams=0,1,2 id=1,streams=3,4 and so on\n\n    state = new_set;\n\n    while (p < w->adaptation_sets + strlen(w->adaptation_sets)) {\n\n        if (*p == ' ')\n\n            continue;\n\n        else if (state == new_set && !strncmp(p, \"id=\", 3)) {\n\n            void *mem = av_realloc(w->as, sizeof(*w->as) * (w->nb_as + 1));\n\n            if (mem == NULL)\n\n                return AVERROR(ENOMEM);\n\n            w->as = mem;\n\n            ++w->nb_as;\n\n            w->as[w->nb_as - 1].nb_streams = 0;\n\n            w->as[w->nb_as - 1].streams = NULL;\n\n            p += 3; // consume \"id=\"\n\n            q = w->as[w->nb_as - 1].id;\n\n            while (*p != ',') *q++ = *p++;\n\n            *q = 0;\n\n            p++;\n\n            state = parsed_id;\n\n        } else if (state == parsed_id && !strncmp(p, \"streams=\", 8)) {\n\n            p += 8; // consume \"streams=\"\n\n            state = parsing_streams;\n\n        } else if (state == parsing_streams) {\n\n            struct AdaptationSet *as = &w->as[w->nb_as - 1];\n\n            q = p;\n\n            while (*q != '\\0' && *q != ',' && *q != ' ') q++;\n\n            as->streams = av_realloc(as->streams, sizeof(*as->streams) * ++as->nb_streams);\n\n            if (as->streams == NULL)\n\n                return AVERROR(ENOMEM);\n\n            as->streams[as->nb_streams - 1] = to_integer(p, q - p + 1);\n\n            if (as->streams[as->nb_streams - 1] < 0) return -1;\n\n            if (*q == '\\0') break;\n\n            if (*q == ' ') state = new_set;\n\n            p = ++q;\n\n        } else {\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 4255}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void i440fx_update_memory_mappings(PCII440FXState *d)\n\n{\n\n    int i, r;\n\n    uint32_t smram;\n\n    bool smram_enabled;\n\n\n\n    memory_region_transaction_begin();\n\n    update_pam(d, 0xf0000, 0x100000, (d->dev.config[I440FX_PAM] >> 4) & 3,\n\n               &d->pam_regions[0]);\n\n    for(i = 0; i < 12; i++) {\n\n        r = (d->dev.config[(i >> 1) + (I440FX_PAM + 1)] >> ((i & 1) * 4)) & 3;\n\n        update_pam(d, 0xc0000 + 0x4000 * i, 0xc0000 + 0x4000 * (i + 1), r,\n\n                   &d->pam_regions[i+1]);\n\n    }\n\n    smram = d->dev.config[I440FX_SMRAM];\n\n    smram_enabled = (d->smm_enabled && (smram & 0x08)) || (smram & 0x40);\n\n    memory_region_set_enabled(&d->smram_region, !smram_enabled);\n\n    memory_region_transaction_commit();\n\n}\n", "idx": 4360}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void control_to_network(RDMAControlHeader *control)\n\n{\n\n    control->type = htonl(control->type);\n\n    control->len = htonl(control->len);\n\n    control->repeat = htonl(control->repeat);\n\n}\n", "idx": 4385}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void RENAME(rgb24tobgr15)(const uint8_t *src, uint8_t *dst, int src_size)\n\n{\n\n    const uint8_t *s = src;\n\n    const uint8_t *end;\n\n    const uint8_t *mm_end;\n\n    uint16_t *d = (uint16_t *)dst;\n\n    end = s + src_size;\n\n    __asm__ volatile(PREFETCH\"    %0\"::\"m\"(*src):\"memory\");\n\n    __asm__ volatile(\n\n        \"movq          %0, %%mm7    \\n\\t\"\n\n        \"movq          %1, %%mm6    \\n\\t\"\n\n        ::\"m\"(red_15mask),\"m\"(green_15mask));\n\n    mm_end = end - 11;\n\n    while (s < mm_end) {\n\n        __asm__ volatile(\n\n            PREFETCH\"    32%1           \\n\\t\"\n\n            \"movd          %1, %%mm0    \\n\\t\"\n\n            \"movd         3%1, %%mm3    \\n\\t\"\n\n            \"punpckldq    6%1, %%mm0    \\n\\t\"\n\n            \"punpckldq    9%1, %%mm3    \\n\\t\"\n\n            \"movq       %%mm0, %%mm1    \\n\\t\"\n\n            \"movq       %%mm0, %%mm2    \\n\\t\"\n\n            \"movq       %%mm3, %%mm4    \\n\\t\"\n\n            \"movq       %%mm3, %%mm5    \\n\\t\"\n\n            \"psrlq         $3, %%mm0    \\n\\t\"\n\n            \"psrlq         $3, %%mm3    \\n\\t\"\n\n            \"pand          %2, %%mm0    \\n\\t\"\n\n            \"pand          %2, %%mm3    \\n\\t\"\n\n            \"psrlq         $6, %%mm1    \\n\\t\"\n\n            \"psrlq         $6, %%mm4    \\n\\t\"\n\n            \"pand       %%mm6, %%mm1    \\n\\t\"\n\n            \"pand       %%mm6, %%mm4    \\n\\t\"\n\n            \"psrlq         $9, %%mm2    \\n\\t\"\n\n            \"psrlq         $9, %%mm5    \\n\\t\"\n\n            \"pand       %%mm7, %%mm2    \\n\\t\"\n\n            \"pand       %%mm7, %%mm5    \\n\\t\"\n\n            \"por        %%mm1, %%mm0    \\n\\t\"\n\n            \"por        %%mm4, %%mm3    \\n\\t\"\n\n            \"por        %%mm2, %%mm0    \\n\\t\"\n\n            \"por        %%mm5, %%mm3    \\n\\t\"\n\n            \"psllq        $16, %%mm3    \\n\\t\"\n\n            \"por        %%mm3, %%mm0    \\n\\t\"\n\n            MOVNTQ\"     %%mm0, %0       \\n\\t\"\n\n            :\"=m\"(*d):\"m\"(*s),\"m\"(blue_15mask):\"memory\");\n\n        d += 4;\n\n        s += 12;\n\n    }\n\n    __asm__ volatile(SFENCE:::\"memory\");\n\n    __asm__ volatile(EMMS:::\"memory\");\n\n    while (s < end) {\n\n        const int b = *s++;\n\n        const int g = *s++;\n\n        const int r = *s++;\n\n        *d++ = (b>>3) | ((g&0xF8)<<2) | ((r&0xF8)<<7);\n\n    }\n\n}\n", "idx": 4519}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void blockCopy(uint8_t dst[], int dstStride, uint8_t src[], int srcStride,\n\n\tint numLines, int levelFix)\n\n{\n\n\tint i;\n\n\tif(levelFix)\n\n\t{\n\n#ifdef HAVE_MMX\n\n\t\t\t\t\tasm volatile(\n\n\t\t\t\t\t\t\"movl %4, %%eax \\n\\t\"\n\n\t\t\t\t\t\t\"movl %%eax, temp0\\n\\t\"\n\n\t\t\t\t\t\t\"pushl %0 \\n\\t\"\n\n\t\t\t\t\t\t\"pushl %1 \\n\\t\"\n\n\t\t\t\t\t\t\"leal (%2,%2), %%eax\t\\n\\t\"\n\n\t\t\t\t\t\t\"leal (%3,%3), %%ebx\t\\n\\t\"\n\n\t\t\t\t\t\t\"movq packedYOffset, %%mm2\t\\n\\t\"\n\n\t\t\t\t\t\t\"movq packedYScale, %%mm3\t\\n\\t\"\n\n\t\t\t\t\t\t\"pxor %%mm4, %%mm4\t\\n\\t\"\n\n\n\n#define SCALED_CPY\t\t\t\t\t\\\n\n\t\t\t\t\t\t\"movq (%0), %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq (%0,%2), %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"psubusb %%mm2, %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"psubusb %%mm2, %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm0, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"punpcklbw %%mm4, %%mm0 \\n\\t\"\\\n\n\t\t\t\t\t\t\"punpckhbw %%mm4, %%mm5 \\n\\t\"\\\n\n\t\t\t\t\t\t\"psllw $7, %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"psllw $7, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"pmulhw %%mm3, %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"pmulhw %%mm3, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"packuswb %%mm5, %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm0, (%1)\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm1, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"punpcklbw %%mm4, %%mm1 \\n\\t\"\\\n\n\t\t\t\t\t\t\"punpckhbw %%mm4, %%mm5 \\n\\t\"\\\n\n\t\t\t\t\t\t\"psllw $7, %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"psllw $7, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"pmulhw %%mm3, %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"pmulhw %%mm3, %%mm5\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"packuswb %%mm5, %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm1, (%1, %3)\t\\n\\t\"\\\n\n\n\n\t\t\t\t\t\t\"1:\t\t\t\\n\\t\"\n\nSCALED_CPY\n\n\t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\"\n\nSCALED_CPY\n\n\t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"decl temp0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"jnz 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t\t\t\t\"popl %1 \\n\\t\"\n\n\t\t\t\t\t\t\"popl %0 \\n\\t\"\n\n\t\t\t\t\t\t: : \"r\" (src),\n\n\t\t\t\t\t\t\"r\" (dst),\n\n\t\t\t\t\t\t\"r\" (srcStride),\n\n\t\t\t\t\t\t\"r\" (dstStride),\n\n\t\t\t\t\t\t\"m\" (numLines>>2)\n\n\t\t\t\t\t\t: \"%eax\", \"%ebx\"\n\n\t\t\t\t\t);\n\n#else\n\n\t\t\t\tfor(i=0; i<numLines; i++)\n\n\t\t\t\t\tmemcpy(\t&(dst[dstStride*i]),\n\n\t\t\t\t\t\t&(src[srcStride*i]), BLOCK_SIZE);\n\n#endif\n\n\t}\n\n\telse\n\n\t{\n\n#ifdef HAVE_MMX\n\n\t\t\t\t\tasm volatile(\n\n\t\t\t\t\t\t\"movl %4, %%eax \\n\\t\"\n\n\t\t\t\t\t\t\"movl %%eax, temp0\\n\\t\"\n\n\t\t\t\t\t\t\"pushl %0 \\n\\t\"\n\n\t\t\t\t\t\t\"pushl %1 \\n\\t\"\n\n\t\t\t\t\t\t\"leal (%2,%2), %%eax\t\\n\\t\"\n\n\t\t\t\t\t\t\"leal (%3,%3), %%ebx\t\\n\\t\"\n\n\t\t\t\t\t\t\"movq packedYOffset, %%mm2\t\\n\\t\"\n\n\t\t\t\t\t\t\"movq packedYScale, %%mm3\t\\n\\t\"\n\n\n\n#define SIMPLE_CPY\t\t\t\t\t\\\n\n\t\t\t\t\t\t\"movq (%0), %%mm0\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq (%0,%2), %%mm1\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm0, (%1)\t\\n\\t\"\\\n\n\t\t\t\t\t\t\"movq %%mm1, (%1, %3)\t\\n\\t\"\\\n\n\n\n\t\t\t\t\t\t\"1:\t\t\t\\n\\t\"\n\nSIMPLE_CPY\n\n\t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\"\n\nSIMPLE_CPY\n\n\t\t\t\t\t\t\"addl %%eax, %0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"addl %%ebx, %1\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"decl temp0\t\t\\n\\t\"\n\n\t\t\t\t\t\t\"jnz 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t\t\t\t\"popl %1 \\n\\t\"\n\n\t\t\t\t\t\t\"popl %0 \\n\\t\"\n\n\t\t\t\t\t\t: : \"r\" (src),\n\n\t\t\t\t\t\t\"r\" (dst),\n\n\t\t\t\t\t\t\"r\" (srcStride),\n\n\t\t\t\t\t\t\"r\" (dstStride),\n\n\t\t\t\t\t\t\"m\" (numLines>>2)\n\n\t\t\t\t\t\t: \"%eax\", \"%ebx\"\n\n\t\t\t\t\t);\n\n#else\n\n\t\t\t\tfor(i=0; i<numLines; i++)\n\n\t\t\t\t\tmemcpy(\t&(dst[dstStride*i]),\n\n\t\t\t\t\t\t&(src[srcStride*i]), BLOCK_SIZE);\n\n#endif\n\n\t}\n\n}\n", "idx": 4639}, {"project": "test", "commit_id": "test", "target": 1, "func": "void ff_vp3_idct_dc_add_c(uint8_t *dest/*align 8*/, int line_size, const DCTELEM *block/*align 16*/){\n\n    int i, dc = (block[0] + 15) >> 5;\n\n    const uint8_t *cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n\n\n    for(i = 0; i < 8; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += line_size;\n\n    }\n\n}\n", "idx": 4766}, {"project": "test", "commit_id": "test", "target": 1, "func": "void object_property_add_bool(Object *obj, const char *name,\n\n                              bool (*get)(Object *, Error **),\n\n                              void (*set)(Object *, bool, Error **),\n\n                              Error **errp)\n\n{\n\n    BoolProperty *prop = g_malloc0(sizeof(*prop));\n\n\n\n    prop->get = get;\n\n    prop->set = set;\n\n\n\n    object_property_add(obj, name, \"bool\",\n\n                        get ? property_get_bool : NULL,\n\n                        set ? property_set_bool : NULL,\n\n                        property_release_bool,\n\n                        prop, errp);\n\n}\n", "idx": 4768}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline int mirror(int v, int m){\n\n    if     (v<0) return -v;\n\n    else if(v>m) return 2*m-v;\n\n    else         return v;\n\n}\n", "idx": 4769}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int vobsub_read_seek(AVFormatContext *s, int stream_index,\n\n                            int64_t min_ts, int64_t ts, int64_t max_ts, int flags)\n\n{\n\n    MpegDemuxContext *vobsub = s->priv_data;\n\n\n\n    /* Rescale requested timestamps based on the first stream (timebase is the\n\n     * same for all subtitles stream within a .idx/.sub). Rescaling is done just\n\n     * like in avformat_seek_file(). */\n\n    if (stream_index == -1 && s->nb_streams != 1) {\n\n        int i, ret = 0;\n\n        AVRational time_base = s->streams[0]->time_base;\n\n        ts = av_rescale_q(ts, AV_TIME_BASE_Q, time_base);\n\n        min_ts = av_rescale_rnd(min_ts, time_base.den,\n\n                                time_base.num * (int64_t)AV_TIME_BASE,\n\n                                AV_ROUND_UP   | AV_ROUND_PASS_MINMAX);\n\n        max_ts = av_rescale_rnd(max_ts, time_base.den,\n\n                                time_base.num * (int64_t)AV_TIME_BASE,\n\n                                AV_ROUND_DOWN | AV_ROUND_PASS_MINMAX);\n\n        for (i = 0; i < s->nb_streams; i++) {\n\n            int r = ff_subtitles_queue_seek(&vobsub->q[i], s, stream_index,\n\n                                            min_ts, ts, max_ts, flags);\n\n            if (r < 0)\n\n                ret = r;\n\n        }\n\n        return ret;\n\n    }\n\n\n\n\n\n    return ff_subtitles_queue_seek(&vobsub->q[stream_index], s, stream_index,\n\n                                   min_ts, ts, max_ts, flags);\n\n}", "idx": 4798}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int vorbis_floor1_decode(vorbis_context *vc,\n\n                                vorbis_floor_data *vfu, float *vec)\n\n{\n\n    vorbis_floor1 *vf = &vfu->t1;\n\n    GetBitContext *gb = &vc->gb;\n\n    uint16_t range_v[4] = { 256, 128, 86, 64 };\n\n    unsigned range = range_v[vf->multiplier - 1];\n\n    uint16_t floor1_Y[258];\n\n    uint16_t floor1_Y_final[258];\n\n    int floor1_flag[258];\n\n    unsigned class, cdim, cbits, csub, cval, offset, i, j;\n\n    int book, adx, ady, dy, off, predicted, err;\n\n\n\n\n\n    if (!get_bits1(gb)) // silence\n\n        return 1;\n\n\n\n// Read values (or differences) for the floor's points\n\n\n\n    floor1_Y[0] = get_bits(gb, ilog(range - 1));\n\n    floor1_Y[1] = get_bits(gb, ilog(range - 1));\n\n\n\n    av_dlog(NULL, \"floor 0 Y %d floor 1 Y %d \\n\", floor1_Y[0], floor1_Y[1]);\n\n\n\n    offset = 2;\n\n    for (i = 0; i < vf->partitions; ++i) {\n\n        class = vf->partition_class[i];\n\n        cdim   = vf->class_dimensions[class];\n\n        cbits  = vf->class_subclasses[class];\n\n        csub = (1 << cbits) - 1;\n\n        cval = 0;\n\n\n\n        av_dlog(NULL, \"Cbits %u\\n\", cbits);\n\n\n\n        if (cbits) // this reads all subclasses for this partition's class\n\n            cval = get_vlc2(gb, vc->codebooks[vf->class_masterbook[class]].vlc.table,\n\n                            vc->codebooks[vf->class_masterbook[class]].nb_bits, 3);\n\n\n\n        for (j = 0; j < cdim; ++j) {\n\n            book = vf->subclass_books[class][cval & csub];\n\n\n\n            av_dlog(NULL, \"book %d Cbits %u cval %u  bits:%d\\n\",\n\n                    book, cbits, cval, get_bits_count(gb));\n\n\n\n            cval = cval >> cbits;\n\n            if (book > -1) {\n\n                floor1_Y[offset+j] = get_vlc2(gb, vc->codebooks[book].vlc.table,\n\n                vc->codebooks[book].nb_bits, 3);\n\n            } else {\n\n                floor1_Y[offset+j] = 0;\n\n            }\n\n\n\n            av_dlog(NULL, \" floor(%d) = %d \\n\",\n\n                    vf->list[offset+j].x, floor1_Y[offset+j]);\n\n        }\n\n        offset+=cdim;\n\n    }\n\n\n\n// Amplitude calculation from the differences\n\n\n\n    floor1_flag[0] = 1;\n\n    floor1_flag[1] = 1;\n\n    floor1_Y_final[0] = floor1_Y[0];\n\n    floor1_Y_final[1] = floor1_Y[1];\n\n\n\n    for (i = 2; i < vf->x_list_dim; ++i) {\n\n        unsigned val, highroom, lowroom, room, high_neigh_offs, low_neigh_offs;\n\n\n\n        low_neigh_offs  = vf->list[i].low;\n\n        high_neigh_offs = vf->list[i].high;\n\n        dy  = floor1_Y_final[high_neigh_offs] - floor1_Y_final[low_neigh_offs];  // render_point begin\n\n        adx = vf->list[high_neigh_offs].x - vf->list[low_neigh_offs].x;\n\n        ady = FFABS(dy);\n\n        err = ady * (vf->list[i].x - vf->list[low_neigh_offs].x);\n\n        off = err / adx;\n\n        if (dy < 0) {\n\n            predicted = floor1_Y_final[low_neigh_offs] - off;\n\n        } else {\n\n            predicted = floor1_Y_final[low_neigh_offs] + off;\n\n        } // render_point end\n\n\n\n        val = floor1_Y[i];\n\n        highroom = range-predicted;\n\n        lowroom  = predicted;\n\n        if (highroom < lowroom) {\n\n            room = highroom * 2;\n\n        } else {\n\n            room = lowroom * 2;   // SPEC mispelling\n\n        }\n\n        if (val) {\n\n            floor1_flag[low_neigh_offs]  = 1;\n\n            floor1_flag[high_neigh_offs] = 1;\n\n            floor1_flag[i]               = 1;\n\n            if (val >= room) {\n\n                if (highroom > lowroom) {\n\n                    floor1_Y_final[i] = val - lowroom + predicted;\n\n                } else {\n\n                    floor1_Y_final[i] = predicted - val + highroom - 1;\n\n                }\n\n            } else {\n\n                if (val & 1) {\n\n                    floor1_Y_final[i] = predicted - (val + 1) / 2;\n\n                } else {\n\n                    floor1_Y_final[i] = predicted + val / 2;\n\n                }\n\n            }\n\n        } else {\n\n            floor1_flag[i]    = 0;\n\n            floor1_Y_final[i] = predicted;\n\n        }\n\n\n\n        av_dlog(NULL, \" Decoded floor(%d) = %u / val %u\\n\",\n\n                vf->list[i].x, floor1_Y_final[i], val);\n\n    }\n\n\n\n// Curve synth - connect the calculated dots and convert from dB scale FIXME optimize ?\n\n\n\n    ff_vorbis_floor1_render_list(vf->list, vf->x_list_dim, floor1_Y_final, floor1_flag, vf->multiplier, vec, vf->list[1].x);\n\n\n\n    av_dlog(NULL, \" Floor decoded\\n\");\n\n\n\n    return 0;\n\n}\n", "idx": 4801}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void colo_process_checkpoint(MigrationState *s)\n{\n    QIOChannelBuffer *bioc;\n    QEMUFile *fb = NULL;\n    int64_t current_time, checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n    Error *local_err = NULL;\n    int ret;\n    failover_init_state();\n    s->rp_state.from_dst_file = qemu_file_get_return_path(s->to_dst_file);\n    if (!s->rp_state.from_dst_file) {\n        error_report(\"Open QEMUFile from_dst_file failed\");\n    /*\n     * Wait for Secondary finish loading VM states and enter COLO\n     * restore.\n     */\n    colo_receive_check_message(s->rp_state.from_dst_file,\n                       COLO_MESSAGE_CHECKPOINT_READY, &local_err);\n    if (local_err) {\n    bioc = qio_channel_buffer_new(COLO_BUFFER_BASE_SIZE);\n    fb = qemu_fopen_channel_output(QIO_CHANNEL(bioc));\n    object_unref(OBJECT(bioc));\n    qemu_mutex_lock_iothread();\n    vm_start();\n    qemu_mutex_unlock_iothread();\n    trace_colo_vm_state_change(\"stop\", \"run\");\n    while (s->state == MIGRATION_STATUS_COLO) {\n        current_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\n        if (current_time - checkpoint_time <\n            s->parameters.x_checkpoint_delay) {\n            int64_t delay_ms;\n            delay_ms = s->parameters.x_checkpoint_delay -\n                       (current_time - checkpoint_time);\n            g_usleep(delay_ms * 1000);\n        ret = colo_do_checkpoint_transaction(s, bioc, fb);\n        if (ret < 0) {\n        checkpoint_time = qemu_clock_get_ms(QEMU_CLOCK_HOST);\nout:\n    /* Throw the unreported error message after exited from loop */\n    if (local_err) {\n        error_report_err(local_err);\n    if (fb) {\n        qemu_fclose(fb);\n    if (s->rp_state.from_dst_file) {\n        qemu_fclose(s->rp_state.from_dst_file);", "idx": 4815}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void bonito_pcihost_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    SysBusDeviceClass *k = SYS_BUS_DEVICE_CLASS(klass);\n\n\n\n    k->init = bonito_pcihost_initfn;\n\n    dc->no_user = 1;\n\n}\n", "idx": 4874}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int ipvideo_decode_block_opcode_0xD(IpvideoContext *s, AVFrame *frame)\n{\n    int y;\n    unsigned char P[2];\n    /* 4-color block encoding: each 4x4 block is a different color */\n    for (y = 0; y < 8; y++) {\n        if (!(y & 3)) {\n            P[0] = bytestream2_get_byte(&s->stream_ptr);\n            P[1] = bytestream2_get_byte(&s->stream_ptr);\n        memset(s->pixel_ptr,     P[0], 4);\n        memset(s->pixel_ptr + 4, P[1], 4);\n        s->pixel_ptr += s->stride;\n    /* report success */\n    return 0;", "idx": 4995}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void pred8x8_top_dc_rv40_c(uint8_t *src, int stride){\n\n    int i;\n\n    int dc0;\n\n\n\n    dc0=0;\n\n    for(i=0;i<8; i++)\n\n        dc0+= src[i-stride];\n\n    dc0= 0x01010101*((dc0 + 4)>>3);\n\n\n\n    for(i=0; i<8; i++){\n\n        ((uint32_t*)(src+i*stride))[0]=\n\n        ((uint32_t*)(src+i*stride))[1]= dc0;\n\n    }\n\n}\n", "idx": 5071}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int vc1_init_common(VC1Context *v)\n\n{\n\n    static int done = 0;\n\n    int i = 0;\n\n\n\n    v->hrd_rate = v->hrd_buffer = NULL;\n\n\n\n    /* VLC tables */\n\n    if(!done)\n\n    {\n\n        done = 1;\n\n        init_vlc(&ff_vc1_bfraction_vlc, VC1_BFRACTION_VLC_BITS, 23,\n\n                 ff_vc1_bfraction_bits, 1, 1,\n\n                 ff_vc1_bfraction_codes, 1, 1, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_vc1_norm2_vlc, VC1_NORM2_VLC_BITS, 4,\n\n                 ff_vc1_norm2_bits, 1, 1,\n\n                 ff_vc1_norm2_codes, 1, 1, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_vc1_norm6_vlc, VC1_NORM6_VLC_BITS, 64,\n\n                 ff_vc1_norm6_bits, 1, 1,\n\n                 ff_vc1_norm6_codes, 2, 2, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_vc1_imode_vlc, VC1_IMODE_VLC_BITS, 7,\n\n                 ff_vc1_imode_bits, 1, 1,\n\n                 ff_vc1_imode_codes, 1, 1, INIT_VLC_USE_STATIC);\n\n        for (i=0; i<3; i++)\n\n        {\n\n            init_vlc(&ff_vc1_ttmb_vlc[i], VC1_TTMB_VLC_BITS, 16,\n\n                     ff_vc1_ttmb_bits[i], 1, 1,\n\n                     ff_vc1_ttmb_codes[i], 2, 2, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_ttblk_vlc[i], VC1_TTBLK_VLC_BITS, 8,\n\n                     ff_vc1_ttblk_bits[i], 1, 1,\n\n                     ff_vc1_ttblk_codes[i], 1, 1, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_subblkpat_vlc[i], VC1_SUBBLKPAT_VLC_BITS, 15,\n\n                     ff_vc1_subblkpat_bits[i], 1, 1,\n\n                     ff_vc1_subblkpat_codes[i], 1, 1, INIT_VLC_USE_STATIC);\n\n        }\n\n        for(i=0; i<4; i++)\n\n        {\n\n            init_vlc(&ff_vc1_4mv_block_pattern_vlc[i], VC1_4MV_BLOCK_PATTERN_VLC_BITS, 16,\n\n                     ff_vc1_4mv_block_pattern_bits[i], 1, 1,\n\n                     ff_vc1_4mv_block_pattern_codes[i], 1, 1, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_cbpcy_p_vlc[i], VC1_CBPCY_P_VLC_BITS, 64,\n\n                     ff_vc1_cbpcy_p_bits[i], 1, 1,\n\n                     ff_vc1_cbpcy_p_codes[i], 2, 2, INIT_VLC_USE_STATIC);\n\n            init_vlc(&ff_vc1_mv_diff_vlc[i], VC1_MV_DIFF_VLC_BITS, 73,\n\n                     ff_vc1_mv_diff_bits[i], 1, 1,\n\n                     ff_vc1_mv_diff_codes[i], 2, 2, INIT_VLC_USE_STATIC);\n\n        }\n\n        for(i=0; i<8; i++)\n\n            init_vlc(&ff_vc1_ac_coeff_table[i], AC_VLC_BITS, vc1_ac_sizes[i],\n\n                     &vc1_ac_tables[i][0][1], 8, 4,\n\n                     &vc1_ac_tables[i][0][0], 8, 4, INIT_VLC_USE_STATIC);\n\n        init_vlc(&ff_msmp4_mb_i_vlc, MB_INTRA_VLC_BITS, 64,\n\n                 &ff_msmp4_mb_i_table[0][1], 4, 2,\n\n                 &ff_msmp4_mb_i_table[0][0], 4, 2, INIT_VLC_USE_STATIC);\n\n    }\n\n\n\n    /* Other defaults */\n\n    v->pq = -1;\n\n    v->mvrange = 0; /* 7.1.1.18, p80 */\n\n\n\n    return 0;\n\n}\n", "idx": 5138}, {"project": "test", "commit_id": "test", "target": 1, "func": "int av_read_packet(AVFormatContext *s, AVPacket *pkt)\n{\n    int ret, i;\n    AVStream *st;\n    for(;;){\n        AVPacketList *pktl = s->raw_packet_buffer;\n        if (pktl) {\n            *pkt = pktl->pkt;\n            if(s->streams[pkt->stream_index]->codec->codec_id != CODEC_ID_PROBE ||\n               !s->streams[pkt->stream_index]->probe_packets ||\n               s->raw_packet_buffer_remaining_size < pkt->size){\n                AVProbeData *pd = &s->streams[pkt->stream_index]->probe_data;\n                av_freep(&pd->buf);\n                pd->buf_size = 0;\n                s->raw_packet_buffer = pktl->next;\n                s->raw_packet_buffer_remaining_size += pkt->size;\n                av_free(pktl);\n                return 0;\n        av_init_packet(pkt);\n        ret= s->iformat->read_packet(s, pkt);\n        if (ret < 0) {\n            if (!pktl || ret == AVERROR(EAGAIN))\n                return ret;\n            for (i = 0; i < s->nb_streams; i++)\n                s->streams[i]->probe_packets = 0;\n        st= s->streams[pkt->stream_index];\n        switch(st->codec->codec_type){\n        case AVMEDIA_TYPE_VIDEO:\n            if(s->video_codec_id)   st->codec->codec_id= s->video_codec_id;\n            break;\n        case AVMEDIA_TYPE_AUDIO:\n            if(s->audio_codec_id)   st->codec->codec_id= s->audio_codec_id;\n            break;\n        case AVMEDIA_TYPE_SUBTITLE:\n            if(s->subtitle_codec_id)st->codec->codec_id= s->subtitle_codec_id;\n            break;\n        if(!pktl && (st->codec->codec_id != CODEC_ID_PROBE ||\n                     !st->probe_packets))\n            return ret;\n        add_to_pktbuf(&s->raw_packet_buffer, pkt, &s->raw_packet_buffer_end);\n        s->raw_packet_buffer_remaining_size -= pkt->size;\n        if(st->codec->codec_id == CODEC_ID_PROBE){\n            AVProbeData *pd = &st->probe_data;\n            av_log(s, AV_LOG_DEBUG, \"probing stream %d\\n\", st->index);\n            --st->probe_packets;\n            pd->buf = av_realloc(pd->buf, pd->buf_size+pkt->size+AVPROBE_PADDING_SIZE);\n            memcpy(pd->buf+pd->buf_size, pkt->data, pkt->size);\n            pd->buf_size += pkt->size;\n            memset(pd->buf+pd->buf_size, 0, AVPROBE_PADDING_SIZE);\n            if(av_log2(pd->buf_size) != av_log2(pd->buf_size - pkt->size)){\n                //FIXME we dont reduce score to 0 for the case of running out of buffer space in bytes\n                set_codec_from_probe_data(s, st, pd, st->probe_packets > 0 ? AVPROBE_SCORE_MAX/4 : 0);\n                if(st->codec->codec_id != CODEC_ID_PROBE){\n                    pd->buf_size=0;\n                    av_freep(&pd->buf);\n                    av_log(s, AV_LOG_DEBUG, \"probed stream %d\\n\", st->index);", "idx": 5146}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int mxf_read_track(MXFTrack *track, ByteIOContext *pb, int tag)\n\n{\n\n    switch(tag) {\n\n    case 0x4801:\n\n        track->track_id = get_be32(pb);\n\n        break;\n\n    case 0x4804:\n\n        get_buffer(pb, track->track_number, 4);\n\n        break;\n\n    case 0x4B01:\n\n        track->edit_rate.den = get_be32(pb);\n\n        track->edit_rate.num = get_be32(pb);\n\n        break;\n\n    case 0x4803:\n\n        get_buffer(pb, track->sequence_ref, 16);\n\n        break;\n\n    }\n\n    return 0;\n\n}\n", "idx": 5430}, {"project": "test", "commit_id": "test", "target": 1, "func": "int ff_wms_parse_sdp_a_line(AVFormatContext *s, const char *p)\n\n{\n\n    int ret = 0;\n\n    if (av_strstart(p, \"pgmpu:data:application/vnd.ms.wms-hdr.asfv1;base64,\", &p)) {\n\n        AVIOContext pb;\n\n        RTSPState *rt = s->priv_data;\n\n        AVDictionary *opts = NULL;\n\n        int len = strlen(p) * 6 / 8;\n\n        char *buf = av_mallocz(len);\n\n        AVInputFormat *iformat;\n\n\n\n        if (!buf)\n\n            return AVERROR(ENOMEM);\n\n        av_base64_decode(buf, p, len);\n\n\n\n        if (rtp_asf_fix_header(buf, len) < 0)\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"Failed to fix invalid RTSP-MS/ASF min_pktsize\\n\");\n\n        init_packetizer(&pb, buf, len);\n\n        if (rt->asf_ctx) {\n\n            avformat_close_input(&rt->asf_ctx);\n\n        }\n\n\n\n        if (!(iformat = av_find_input_format(\"asf\")))\n\n            return AVERROR_DEMUXER_NOT_FOUND;\n\n\n\n        rt->asf_ctx = avformat_alloc_context();\n\n        if (!rt->asf_ctx) {\n\n            av_free(buf);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        rt->asf_ctx->pb      = &pb;\n\n        av_dict_set(&opts, \"no_resync_search\", \"1\", 0);\n\n\n\n        if ((ret = ff_copy_whiteblacklists(rt->asf_ctx, s)) < 0) {\n\n            av_dict_free(&opts);\n\n            return ret;\n\n        }\n\n\n\n        ret = avformat_open_input(&rt->asf_ctx, \"\", iformat, &opts);\n\n        av_dict_free(&opts);\n\n        if (ret < 0) {\n\n            av_free(buf);\n\n            return ret;\n\n        }\n\n        av_dict_copy(&s->metadata, rt->asf_ctx->metadata, 0);\n\n        rt->asf_pb_pos = avio_tell(&pb);\n\n        av_free(buf);\n\n        rt->asf_ctx->pb = NULL;\n\n    }\n\n    return ret;\n\n}\n", "idx": 5437}, {"project": "test", "commit_id": "test", "target": 1, "func": "static Visitor *validate_test_init_raw(TestInputVisitorData *data,\n\n                                       const char *json_string)\n\n{\n\n    Visitor *v;\n\n\n\n    data->obj = qobject_from_json(json_string);\n\n    g_assert(data->obj != NULL);\n\n\n\n    data->qiv = qmp_input_visitor_new_strict(data->obj);\n\n    g_assert(data->qiv != NULL);\n\n\n\n    v = qmp_input_get_visitor(data->qiv);\n\n    g_assert(v != NULL);\n\n\n\n    return v;\n\n}\n", "idx": 5500}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void ehci_mem_writel(void *ptr, target_phys_addr_t addr, uint32_t val)\n{\n    EHCIState *s = ptr;\n    uint32_t *mmio = (uint32_t *)(&s->mmio[addr]);\n    uint32_t old = *mmio;\n    int i;\n    trace_usb_ehci_mmio_writel(addr, addr2str(addr), val);\n    /* Only aligned reads are allowed on OHCI */\n    if (addr & 3) {\n        fprintf(stderr, \"usb-ehci: Mis-aligned write to addr 0x\"\n                TARGET_FMT_plx \"\\n\", addr);\n        return;\n    if (addr >= PORTSC && addr < PORTSC + 4 * NB_PORTS) {\n        handle_port_status_write(s, (addr-PORTSC)/4, val);\n        trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);\n        return;\n    if (addr < OPREGBASE) {\n        fprintf(stderr, \"usb-ehci: write attempt to read-only register\"\n                TARGET_FMT_plx \"\\n\", addr);\n        return;\n    /* Do any register specific pre-write processing here.  */\n    switch(addr) {\n    case USBCMD:\n        if (val & USBCMD_HCRESET) {\n            ehci_reset(s);\n            val = s->usbcmd;\n            break;\n        /* not supporting dynamic frame list size at the moment */\n        if ((val & USBCMD_FLS) && !(s->usbcmd & USBCMD_FLS)) {\n            fprintf(stderr, \"attempt to set frame list size -- value %d\\n\",\n                    val & USBCMD_FLS);\n            val &= ~USBCMD_FLS;\n        if (((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & val) !=\n            ((USBCMD_RUNSTOP | USBCMD_PSE | USBCMD_ASE) & s->usbcmd)) {\n            if (s->pstate == EST_INACTIVE) {\n                SET_LAST_RUN_CLOCK(s);\n            s->usbcmd = val; /* Set usbcmd for ehci_update_halt() */\n            ehci_update_halt(s);\n            qemu_mod_timer(s->frame_timer, qemu_get_clock_ns(vm_clock));\n        break;\n    case USBSTS:\n        val &= USBSTS_RO_MASK;              // bits 6 through 31 are RO\n        ehci_clear_usbsts(s, val);          // bits 0 through 5 are R/WC\n        val = s->usbsts;\n        ehci_update_irq(s);\n        break;\n    case USBINTR:\n        val &= USBINTR_MASK;\n        break;\n    case FRINDEX:\n        val &= 0x00003ff8; /* frindex is 14bits and always a multiple of 8 */\n        break;\n    case CONFIGFLAG:\n        val &= 0x1;\n        if (val) {\n            for(i = 0; i < NB_PORTS; i++)\n                handle_port_owner_write(s, i, 0);\n        break;\n    case PERIODICLISTBASE:\n        if (ehci_periodic_enabled(s)) {\n            fprintf(stderr,\n              \"ehci: PERIODIC list base register set while periodic schedule\\n\"\n              \"      is enabled and HC is enabled\\n\");\n        break;\n    case ASYNCLISTADDR:\n        if (ehci_async_enabled(s)) {\n            fprintf(stderr,\n              \"ehci: ASYNC list address register set while async schedule\\n\"\n              \"      is enabled and HC is enabled\\n\");\n        break;\n    *mmio = val;\n    trace_usb_ehci_mmio_change(addr, addr2str(addr), *mmio, old);", "idx": 5509}, {"project": "test", "commit_id": "test", "target": 1, "func": "static float get_band_cost_UPAIR7_mips(struct AACEncContext *s,\n\n                                       PutBitContext *pb, const float *in,\n\n                                       const float *scaled, int size, int scale_idx,\n\n                                       int cb, const float lambda, const float uplim,\n\n                                       int *bits)\n\n{\n\n    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];\n\n    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];\n\n    int i;\n\n    float cost = 0;\n\n    int qc1, qc2, qc3, qc4;\n\n    int curbits = 0;\n\n\n\n    uint8_t *p_bits  = (uint8_t *)ff_aac_spectral_bits[cb-1];\n\n    float   *p_codes = (float   *)ff_aac_codebook_vectors[cb-1];\n\n\n\n    for (i = 0; i < size; i += 4) {\n\n        const float *vec, *vec2;\n\n        int curidx, curidx2, sign1, count1, sign2, count2;\n\n        int   *in_int = (int   *)&in[i];\n\n        float *in_pos = (float *)&in[i];\n\n        float di0, di1, di2, di3;\n\n        int t0, t1, t2, t3, t4;\n\n\n\n        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;\n\n        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;\n\n        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;\n\n        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;\n\n\n\n        __asm__ volatile (\n\n            \".set push                                          \\n\\t\"\n\n            \".set noreorder                                     \\n\\t\"\n\n\n\n            \"ori        %[t4],      $zero,      7               \\n\\t\"\n\n            \"ori        %[sign1],   $zero,      0               \\n\\t\"\n\n            \"ori        %[sign2],   $zero,      0               \\n\\t\"\n\n            \"slt        %[t0],      %[t4],      %[qc1]          \\n\\t\"\n\n            \"slt        %[t1],      %[t4],      %[qc2]          \\n\\t\"\n\n            \"slt        %[t2],      %[t4],      %[qc3]          \\n\\t\"\n\n            \"slt        %[t3],      %[t4],      %[qc4]          \\n\\t\"\n\n            \"movn       %[qc1],     %[t4],      %[t0]           \\n\\t\"\n\n            \"movn       %[qc2],     %[t4],      %[t1]           \\n\\t\"\n\n            \"movn       %[qc3],     %[t4],      %[t2]           \\n\\t\"\n\n            \"movn       %[qc4],     %[t4],      %[t3]           \\n\\t\"\n\n            \"lw         %[t0],      0(%[in_int])                \\n\\t\"\n\n            \"lw         %[t1],      4(%[in_int])                \\n\\t\"\n\n            \"lw         %[t2],      8(%[in_int])                \\n\\t\"\n\n            \"lw         %[t3],      12(%[in_int])               \\n\\t\"\n\n            \"slt        %[t0],      %[t0],      $zero           \\n\\t\"\n\n            \"movn       %[sign1],   %[t0],      %[qc1]          \\n\\t\"\n\n            \"slt        %[t2],      %[t2],      $zero           \\n\\t\"\n\n            \"movn       %[sign2],   %[t2],      %[qc3]          \\n\\t\"\n\n            \"slt        %[t1],      %[t1],      $zero           \\n\\t\"\n\n            \"sll        %[t0],      %[sign1],   1               \\n\\t\"\n\n            \"or         %[t0],      %[t0],      %[t1]           \\n\\t\"\n\n            \"movn       %[sign1],   %[t0],      %[qc2]          \\n\\t\"\n\n            \"slt        %[t3],      %[t3],      $zero           \\n\\t\"\n\n            \"sll        %[t0],      %[sign2],   1               \\n\\t\"\n\n            \"or         %[t0],      %[t0],      %[t3]           \\n\\t\"\n\n            \"movn       %[sign2],   %[t0],      %[qc4]          \\n\\t\"\n\n            \"slt        %[count1],  $zero,      %[qc1]          \\n\\t\"\n\n            \"slt        %[t1],      $zero,      %[qc2]          \\n\\t\"\n\n            \"slt        %[count2],  $zero,      %[qc3]          \\n\\t\"\n\n            \"slt        %[t2],      $zero,      %[qc4]          \\n\\t\"\n\n            \"addu       %[count1],  %[count1],  %[t1]           \\n\\t\"\n\n            \"addu       %[count2],  %[count2],  %[t2]           \\n\\t\"\n\n\n\n            \".set pop                                           \\n\\t\"\n\n\n\n            : [qc1]\"+r\"(qc1), [qc2]\"+r\"(qc2),\n\n              [qc3]\"+r\"(qc3), [qc4]\"+r\"(qc4),\n\n              [sign1]\"=&r\"(sign1), [count1]\"=&r\"(count1),\n\n              [sign2]\"=&r\"(sign2), [count2]\"=&r\"(count2),\n\n              [t0]\"=&r\"(t0), [t1]\"=&r\"(t1), [t2]\"=&r\"(t2), [t3]\"=&r\"(t3),\n\n              [t4]\"=&r\"(t4)\n\n            : [in_int]\"r\"(in_int)\n\n            : \"memory\"\n\n        );\n\n\n\n        curidx = 8 * qc1;\n\n        curidx += qc2;\n\n\n\n        curidx2 = 8 * qc3;\n\n        curidx2 += qc4;\n\n\n\n        curbits += p_bits[curidx];\n\n        curbits += upair7_sign_bits[curidx];\n\n        vec     = &p_codes[curidx*2];\n\n\n\n        curbits += p_bits[curidx2];\n\n        curbits += upair7_sign_bits[curidx2];\n\n        vec2    = &p_codes[curidx2*2];\n\n\n\n        __asm__ volatile (\n\n            \".set push                                          \\n\\t\"\n\n            \".set noreorder                                     \\n\\t\"\n\n\n\n            \"lwc1       %[di0],     0(%[in_pos])                \\n\\t\"\n\n            \"lwc1       %[di1],     4(%[in_pos])                \\n\\t\"\n\n            \"lwc1       %[di2],     8(%[in_pos])                \\n\\t\"\n\n            \"lwc1       %[di3],     12(%[in_pos])               \\n\\t\"\n\n            \"abs.s      %[di0],     %[di0]                      \\n\\t\"\n\n            \"abs.s      %[di1],     %[di1]                      \\n\\t\"\n\n            \"abs.s      %[di2],     %[di2]                      \\n\\t\"\n\n            \"abs.s      %[di3],     %[di3]                      \\n\\t\"\n\n            \"lwc1       $f0,        0(%[vec])                   \\n\\t\"\n\n            \"lwc1       $f1,        4(%[vec])                   \\n\\t\"\n\n            \"lwc1       $f2,        0(%[vec2])                  \\n\\t\"\n\n            \"lwc1       $f3,        4(%[vec2])                  \\n\\t\"\n\n            \"nmsub.s    %[di0],     %[di0],     $f0,    %[IQ]   \\n\\t\"\n\n            \"nmsub.s    %[di1],     %[di1],     $f1,    %[IQ]   \\n\\t\"\n\n            \"nmsub.s    %[di2],     %[di2],     $f2,    %[IQ]   \\n\\t\"\n\n            \"nmsub.s    %[di3],     %[di3],     $f3,    %[IQ]   \\n\\t\"\n\n\n\n            \".set pop                                           \\n\\t\"\n\n\n\n            : [di0]\"=&f\"(di0), [di1]\"=&f\"(di1),\n\n              [di2]\"=&f\"(di2), [di3]\"=&f\"(di3)\n\n            : [in_pos]\"r\"(in_pos), [vec]\"r\"(vec),\n\n              [vec2]\"r\"(vec2), [IQ]\"f\"(IQ)\n\n            : \"$f0\", \"$f1\", \"$f2\", \"$f3\",\n\n              \"memory\"\n\n        );\n\n\n\n        cost += di0 * di0 + di1 * di1\n\n                + di2 * di2 + di3 * di3;\n\n    }\n\n\n\n    if (bits)\n\n        *bits = curbits;\n\n    return cost * lambda + curbits;\n\n}\n", "idx": 5621}, {"project": "test", "commit_id": "test", "target": 1, "func": "static av_cold int roq_encode_init(AVCodecContext *avctx)\n{\n    RoqContext *enc = avctx->priv_data;\n    av_lfg_init(&enc->randctx, 1);\n    enc->framesSinceKeyframe = 0;\n    if ((avctx->width & 0xf) || (avctx->height & 0xf)) {\n        av_log(avctx, AV_LOG_ERROR, \"Dimensions must be divisible by 16\\n\");\n        return AVERROR(EINVAL);\n    if (avctx->width > 65535 || avctx->height > 65535) {\n        av_log(avctx, AV_LOG_ERROR, \"Dimensions are max %d\\n\", enc->quake3_compat ? 32768 : 65535);\n        return AVERROR(EINVAL);\n    if (((avctx->width)&(avctx->width-1))||((avctx->height)&(avctx->height-1)))\n        av_log(avctx, AV_LOG_ERROR, \"Warning: dimensions not power of two, this is not supported by quake\\n\");\n    enc->width = avctx->width;\n    enc->height = avctx->height;\n    enc->framesSinceKeyframe = 0;\n    enc->first_frame = 1;\n    enc->last_frame    = av_frame_alloc();\n    enc->current_frame = av_frame_alloc();\n    if (!enc->last_frame || !enc->current_frame) {\n    enc->tmpData      = av_malloc(sizeof(RoqTempdata));\n    enc->this_motion4 =\n        av_mallocz_array((enc->width*enc->height/16), sizeof(motion_vect));\n    enc->last_motion4 =\n        av_malloc_array ((enc->width*enc->height/16), sizeof(motion_vect));\n    enc->this_motion8 =\n        av_mallocz_array((enc->width*enc->height/64), sizeof(motion_vect));\n    enc->last_motion8 =\n        av_malloc_array ((enc->width*enc->height/64), sizeof(motion_vect));\n    return 0;", "idx": 5754}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void vc1_inv_trans_8x4_dc_c(uint8_t *dest, int linesize, DCTELEM *block)\n\n{\n\n    int i;\n\n    int dc = block[0];\n\n    const uint8_t *cm;\n\n    dc = ( 3 * dc +  1) >> 1;\n\n    dc = (17 * dc + 64) >> 7;\n\n    cm = ff_cropTbl + MAX_NEG_CROP + dc;\n\n    for(i = 0; i < 4; i++){\n\n        dest[0] = cm[dest[0]];\n\n        dest[1] = cm[dest[1]];\n\n        dest[2] = cm[dest[2]];\n\n        dest[3] = cm[dest[3]];\n\n        dest[4] = cm[dest[4]];\n\n        dest[5] = cm[dest[5]];\n\n        dest[6] = cm[dest[6]];\n\n        dest[7] = cm[dest[7]];\n\n        dest += linesize;\n\n    }\n\n}\n", "idx": 5781}, {"project": "test", "commit_id": "test", "target": 1, "func": "static always_inline uint8_t vc1_mspel_filter(const uint8_t *src, int stride, int mode, int r)\n\n{\n\n    switch(mode){\n\n    case 0: //no shift\n\n        return src[0];\n\n    case 1: // 1/4 shift\n\n        return (-4*src[-stride] + 53*src[0] + 18*src[stride] - 3*src[stride*2] + 32 - r) >> 6;\n\n    case 2: // 1/2 shift\n\n        return (-src[-stride] + 9*src[0] + 9*src[stride] - src[stride*2] + 8 - r) >> 4;\n\n    case 3: // 3/4 shift\n\n        return (-3*src[-stride] + 18*src[0] + 53*src[stride] - 4*src[stride*2] + 32 - r) >> 6;\n\n    }\n\n    return 0; //should not occur\n\n}\n", "idx": 5789}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int get_int64(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    int64_t *v = pv;\n\n    qemu_get_sbe64s(f, v);\n\n    return 0;\n\n}\n", "idx": 5834}, {"project": "test", "commit_id": "test", "target": 1, "func": "PPC_OP(slw)\n\n{\n\n    if (T1 & 0x20) {\n\n        T0 = 0;\n\n    } else {\n\n        T0 = T0 << T1;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 5855}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int get_num(ByteIOContext *pb, int *len)\n\n{\n\n    int n, n1;\n\n\n\n    n = get_be16(pb);\n\n    (*len)-=2;\n\n//    n &= 0x7FFF;\n\n    if (n >= 0x4000) {\n\n        return n - 0x4000;\n\n    } else {\n\n        n1 = get_be16(pb);\n\n        (*len)-=2;\n\n        return (n << 16) | n1;\n\n    }\n\n}\n", "idx": 5864}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void FUNCC(ff_h264_add_pixels8)(uint8_t *_dst, int16_t *_src, int stride)\n\n{\n\n    int i;\n\n    pixel *dst = (pixel *) _dst;\n\n    dctcoef *src = (dctcoef *) _src;\n\n    stride /= sizeof(pixel);\n\n\n\n    for (i = 0; i < 8; i++) {\n\n        dst[0] += src[0];\n\n        dst[1] += src[1];\n\n        dst[2] += src[2];\n\n        dst[3] += src[3];\n\n        dst[4] += src[4];\n\n        dst[5] += src[5];\n\n        dst[6] += src[6];\n\n        dst[7] += src[7];\n\n\n\n        dst += stride;\n\n        src += 8;\n\n    }\n\n\n\n    memset(_src, 0, sizeof(dctcoef) * 64);\n\n}\n", "idx": 5905}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void gen_addq_lo(DisasContext *s, TCGv_i64 val, int rlow)\n\n{\n\n    TCGv_i64 tmp;\n\n    TCGv tmp2;\n\n\n\n    /* Load value and extend to 64 bits.  */\n\n    tmp = tcg_temp_new_i64();\n\n    tmp2 = load_reg(s, rlow);\n\n    tcg_gen_extu_i32_i64(tmp, tmp2);\n\n    dead_tmp(tmp2);\n\n    tcg_gen_add_i64(val, val, tmp);\n\n    tcg_temp_free_i64(tmp);\n\n}\n", "idx": 5962}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void test_bmdma_simple_rw(void)\n\n{\n\n    QPCIDevice *dev;\n\n    void *bmdma_base, *ide_base;\n\n    uint8_t status;\n\n    uint8_t *buf;\n\n    uint8_t *cmpbuf;\n\n    size_t len = 512;\n\n    uintptr_t guest_buf = guest_alloc(guest_malloc, len);\n\n\n\n    PrdtEntry prdt[] = {\n\n        {\n\n            .addr = cpu_to_le32(guest_buf),\n\n            .size = cpu_to_le32(len | PRDT_EOT),\n\n        },\n\n    };\n\n\n\n    dev = get_pci_device(&bmdma_base, &ide_base);\n\n\n\n    buf = g_malloc(len);\n\n    cmpbuf = g_malloc(len);\n\n\n\n    /* Write 0x55 pattern to sector 0 */\n\n    memset(buf, 0x55, len);\n\n    memwrite(guest_buf, buf, len);\n\n\n\n    status = send_dma_request(CMD_WRITE_DMA, 0, 1, prdt,\n\n                              ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    /* Write 0xaa pattern to sector 1 */\n\n    memset(buf, 0xaa, len);\n\n    memwrite(guest_buf, buf, len);\n\n\n\n    status = send_dma_request(CMD_WRITE_DMA, 1, 1, prdt,\n\n                              ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    /* Read and verify 0x55 pattern in sector 0 */\n\n    memset(cmpbuf, 0x55, len);\n\n\n\n    status = send_dma_request(CMD_READ_DMA, 0, 1, prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    memread(guest_buf, buf, len);\n\n    g_assert(memcmp(buf, cmpbuf, len) == 0);\n\n\n\n    /* Read and verify 0xaa pattern in sector 1 */\n\n    memset(cmpbuf, 0xaa, len);\n\n\n\n    status = send_dma_request(CMD_READ_DMA, 1, 1, prdt, ARRAY_SIZE(prdt), NULL);\n\n    g_assert_cmphex(status, ==, BM_STS_INTR);\n\n    assert_bit_clear(qpci_io_readb(dev, ide_base + reg_status), DF | ERR);\n\n\n\n    memread(guest_buf, buf, len);\n\n    g_assert(memcmp(buf, cmpbuf, len) == 0);\n\n\n\n\n\n    g_free(buf);\n\n    g_free(cmpbuf);\n\n}\n", "idx": 5963}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int idcin_read_packet(AVFormatContext *s,\n\n                             AVPacket *pkt)\n\n{\n\n    int ret;\n\n    unsigned int command;\n\n    unsigned int chunk_size;\n\n    IdcinDemuxContext *idcin = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int i;\n\n    int palette_scale;\n\n    unsigned char r, g, b;\n\n    unsigned char palette_buffer[768];\n\n    uint32_t palette[256];\n\n\n\n    if (s->pb->eof_reached)\n\n        return AVERROR(EIO);\n\n\n\n    if (idcin->next_chunk_is_video) {\n\n        command = avio_rl32(pb);\n\n        if (command == 2) {\n\n            return AVERROR(EIO);\n\n        } else if (command == 1) {\n\n            /* trigger a palette change */\n\n            if (avio_read(pb, palette_buffer, 768) != 768)\n\n                return AVERROR(EIO);\n\n            /* scale the palette as necessary */\n\n            palette_scale = 2;\n\n            for (i = 0; i < 768; i++)\n\n                if (palette_buffer[i] > 63) {\n\n                    palette_scale = 0;\n\n                    break;\n\n\n\n\n            for (i = 0; i < 256; i++) {\n\n                r = palette_buffer[i * 3    ] << palette_scale;\n\n                g = palette_buffer[i * 3 + 1] << palette_scale;\n\n                b = palette_buffer[i * 3 + 2] << palette_scale;\n\n                palette[i] = (r << 16) | (g << 8) | (b);\n\n\n\n\n\n        chunk_size = avio_rl32(pb);\n\n\n\n\n\n        /* skip the number of decoded bytes (always equal to width * height) */\n\n        avio_skip(pb, 4);\n\n        chunk_size -= 4;\n\n        ret= av_get_packet(pb, pkt, chunk_size);\n\n        if (ret < 0)\n\n            return ret;\n\n        if (command == 1) {\n\n            uint8_t *pal;\n\n\n\n            pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE,\n\n                                          AVPALETTE_SIZE);\n\n            if (ret < 0)\n\n                return ret;\n\n            memcpy(pal, palette, AVPALETTE_SIZE);\n\n            pkt->flags |= AV_PKT_FLAG_KEY;\n\n\n        pkt->stream_index = idcin->video_stream_index;\n\n        pkt->duration     = 1;\n\n    } else {\n\n        /* send out the audio chunk */\n\n        if (idcin->current_audio_chunk)\n\n            chunk_size = idcin->audio_chunk_size2;\n\n        else\n\n            chunk_size = idcin->audio_chunk_size1;\n\n        ret= av_get_packet(pb, pkt, chunk_size);\n\n        if (ret < 0)\n\n            return ret;\n\n        pkt->stream_index = idcin->audio_stream_index;\n\n        pkt->duration     = chunk_size / idcin->block_align;\n\n\n\n        idcin->current_audio_chunk ^= 1;\n\n\n\n\n    if (idcin->audio_present)\n\n        idcin->next_chunk_is_video ^= 1;\n\n\n\n    return ret;\n", "idx": 5965}, {"project": "test", "commit_id": "test", "target": 1, "func": "static const void *boston_fdt_filter(void *opaque, const void *fdt_orig,\n\n                                     const void *match_data, hwaddr *load_addr)\n\n{\n\n    BostonState *s = BOSTON(opaque);\n\n    MachineState *machine = s->mach;\n\n    const char *cmdline;\n\n    int err;\n\n    void *fdt;\n\n    size_t fdt_sz, ram_low_sz, ram_high_sz;\n\n\n\n    fdt_sz = fdt_totalsize(fdt_orig) * 2;\n\n    fdt = g_malloc0(fdt_sz);\n\n\n\n    err = fdt_open_into(fdt_orig, fdt, fdt_sz);\n\n    if (err) {\n\n        fprintf(stderr, \"unable to open FDT\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    cmdline = (machine->kernel_cmdline && machine->kernel_cmdline[0])\n\n            ? machine->kernel_cmdline : \" \";\n\n    err = qemu_fdt_setprop_string(fdt, \"/chosen\", \"bootargs\", cmdline);\n\n    if (err < 0) {\n\n        fprintf(stderr, \"couldn't set /chosen/bootargs\\n\");\n\n        return NULL;\n\n    }\n\n\n\n    ram_low_sz = MIN(256 * M_BYTE, machine->ram_size);\n\n    ram_high_sz = machine->ram_size - ram_low_sz;\n\n    qemu_fdt_setprop_sized_cells(fdt, \"/memory@0\", \"reg\",\n\n                                 1, 0x00000000, 1, ram_low_sz,\n\n                                 1, 0x90000000, 1, ram_high_sz);\n\n\n\n    fdt = g_realloc(fdt, fdt_totalsize(fdt));\n\n    qemu_fdt_dumpdtb(fdt, fdt_sz);\n\n\n\n    s->fdt_base = *load_addr;\n\n\n\n    return fdt;\n\n}\n", "idx": 6108}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int read_ffserver_streams(AVFormatContext *s, const char *filename)\n\n{\n\n    int i, err;\n\n    AVFormatContext *ic;\n\n    int nopts = 0;\n\n\n\n    err = av_open_input_file(&ic, filename, NULL, FFM_PACKET_SIZE, NULL);\n\n    if (err < 0)\n\n        return err;\n\n    /* copy stream format */\n\n    s->nb_streams = ic->nb_streams;\n\n    for(i=0;i<ic->nb_streams;i++) {\n\n        AVStream *st;\n\n        AVCodec *codec;\n\n\n\n        // FIXME: a more elegant solution is needed\n\n        st = av_mallocz(sizeof(AVStream));\n\n        memcpy(st, ic->streams[i], sizeof(AVStream));\n\n        st->codec = avcodec_alloc_context();\n\n        if (!st->codec) {\n\n            print_error(filename, AVERROR(ENOMEM));\n\n            ffmpeg_exit(1);\n\n        }\n\n        avcodec_copy_context(st->codec, ic->streams[i]->codec);\n\n        s->streams[i] = st;\n\n\n\n        codec = avcodec_find_encoder(st->codec->codec_id);\n\n        if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) {\n\n            if (audio_stream_copy) {\n\n                st->stream_copy = 1;\n\n            } else\n\n                choose_sample_fmt(st, codec);\n\n        } else if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) {\n\n            if (video_stream_copy) {\n\n                st->stream_copy = 1;\n\n            } else\n\n                choose_pixel_fmt(st, codec);\n\n        }\n\n\n\n        if(!st->codec->thread_count)\n\n            st->codec->thread_count = 1;\n\n        if(st->codec->thread_count>1)\n\n            avcodec_thread_init(st->codec, st->codec->thread_count);\n\n\n\n        if(st->codec->flags & CODEC_FLAG_BITEXACT)\n\n            nopts = 1;\n\n    }\n\n\n\n    if (!nopts)\n\n        s->timestamp = av_gettime();\n\n\n\n    av_close_input_file(ic);\n\n    return 0;\n\n}\n", "idx": 6160}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void uninit(AVFilterContext *ctx)\n\n{\n\n    ZScaleContext *s = ctx->priv;\n\n\n\n    zimg_filter_graph_free(s->graph);\n\n\n    av_freep(&s->tmp);\n\n    s->tmp_size = 0;\n\n}", "idx": 6165}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void gen_st16(TCGv val, TCGv addr, int index)\n\n{\n\n    tcg_gen_qemu_st16(val, addr, index);\n\n    dead_tmp(val);\n\n}\n", "idx": 6335}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void q35_host_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIHostBridgeClass *hc = PCI_HOST_BRIDGE_CLASS(klass);\n\n\n\n    hc->root_bus_path = q35_host_root_bus_path;\n\n    dc->realize = q35_host_realize;\n\n    dc->props = mch_props;\n\n    /* Reason: needs to be wired up by pc_q35_init */\n\n    dc->user_creatable = false;\n\n    set_bit(DEVICE_CATEGORY_BRIDGE, dc->categories);\n\n    dc->fw_name = \"pci\";\n\n}\n", "idx": 6346}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, long width)\n\n{\n\n#ifdef HAVE_MMX\n\n\tasm volatile(\n\n\t\t\"movq \"MANGLE(bm01010101)\", %%mm4\\n\\t\"\n\n\t\t\"mov %0, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\"movq (%1, %%\"REG_a\",4), %%mm0\t\\n\\t\"\n\n\t\t\"movq 8(%1, %%\"REG_a\",4), %%mm1\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\"movq %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm4, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm0, %%mm0\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm1\t\t\\n\\t\"\n\n\t\t\"movd %%mm0, (%3, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"movd %%mm1, (%2, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"add $4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t: : \"g\" (-width), \"r\" (src1+width*4), \"r\" (dstU+width), \"r\" (dstV+width)\n\n\t\t: \"%\"REG_a\n\n\t);\n\n#else\n\n\tint i;\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tdstU[i]= src1[4*i + 1];\n\n\t\tdstV[i]= src1[4*i + 3];\n\n\t}\n\n#endif\n\n        assert(src1 == src2);\n\n}\n", "idx": 6432}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int video_thread(void *arg)\n\n{\n\n    VideoState *is = arg;\n\n    AVFrame *frame = avcodec_alloc_frame();\n\n    int64_t pts_int;\n\n    double pts;\n\n    int ret;\n\n\n\n#if CONFIG_AVFILTER\n\n    AVFilterGraph *graph = avfilter_graph_alloc();\n\n    AVFilterContext *filt_out = NULL;\n\n    int64_t pos;\n\n    int last_w = is->video_st->codec->width;\n\n    int last_h = is->video_st->codec->height;\n\n\n\n    if ((ret = configure_video_filters(graph, is, vfilters)) < 0)\n\n        goto the_end;\n\n    filt_out = is->out_video_filter;\n\n#endif\n\n\n\n    for (;;) {\n\n#if !CONFIG_AVFILTER\n\n        AVPacket pkt;\n\n#else\n\n        AVFilterBufferRef *picref;\n\n        AVRational tb;\n\n#endif\n\n        while (is->paused && !is->videoq.abort_request)\n\n            SDL_Delay(10);\n\n#if CONFIG_AVFILTER\n\n        if (   last_w != is->video_st->codec->width\n\n            || last_h != is->video_st->codec->height) {\n\n            av_dlog(NULL, \"Changing size %dx%d -> %dx%d\\n\", last_w, last_h,\n\n                    is->video_st->codec->width, is->video_st->codec->height);\n\n            avfilter_graph_free(&graph);\n\n            graph = avfilter_graph_alloc();\n\n            if ((ret = configure_video_filters(graph, is, vfilters)) < 0)\n\n                goto the_end;\n\n            filt_out = is->out_video_filter;\n\n            last_w = is->video_st->codec->width;\n\n            last_h = is->video_st->codec->height;\n\n        }\n\n        ret = get_filtered_video_frame(filt_out, frame, &picref, &tb);\n\n        if (picref) {\n\n            pts_int = picref->pts;\n\n            pos     = picref->pos;\n\n            frame->opaque = picref;\n\n        }\n\n\n\n        if (av_cmp_q(tb, is->video_st->time_base)) {\n\n            av_unused int64_t pts1 = pts_int;\n\n            pts_int = av_rescale_q(pts_int, tb, is->video_st->time_base);\n\n            av_dlog(NULL, \"video_thread(): \"\n\n                    \"tb:%d/%d pts:%\"PRId64\" -> tb:%d/%d pts:%\"PRId64\"\\n\",\n\n                    tb.num, tb.den, pts1,\n\n                    is->video_st->time_base.num, is->video_st->time_base.den, pts_int);\n\n        }\n\n#else\n\n        ret = get_video_frame(is, frame, &pts_int, &pkt);\n\n#endif\n\n\n\n        if (ret < 0)\n\n            goto the_end;\n\n\n\n        if (!ret)\n\n            continue;\n\n\n\n        pts = pts_int * av_q2d(is->video_st->time_base);\n\n\n\n#if CONFIG_AVFILTER\n\n        ret = output_picture2(is, frame, pts, pos);\n\n#else\n\n        ret = output_picture2(is, frame, pts,  pkt.pos);\n\n        av_free_packet(&pkt);\n\n#endif\n\n        if (ret < 0)\n\n            goto the_end;\n\n\n\n        if (step)\n\n            if (cur_stream)\n\n                stream_pause(cur_stream);\n\n    }\n\n the_end:\n\n#if CONFIG_AVFILTER\n\n    avfilter_graph_free(&graph);\n\n#endif\n\n    av_free(frame);\n\n    return 0;\n\n}\n", "idx": 6489}, {"project": "test", "commit_id": "test", "target": 1, "func": "int av_aes_init(AVAES *a, const uint8_t *key, int key_bits, int decrypt)\n\n{\n\n    int i, j, t, rconpointer = 0;\n\n    uint8_t tk[8][4];\n\n    int KC = key_bits >> 5;\n\n    int rounds = KC + 6;\n\n    uint8_t log8[256];\n\n    uint8_t alog8[512];\n\n\n\n    if (!enc_multbl[FF_ARRAY_ELEMS(enc_multbl)-1][FF_ARRAY_ELEMS(enc_multbl[0])-1]) {\n\n        j = 1;\n\n        for (i = 0; i < 255; i++) {\n\n            alog8[i] = alog8[i + 255] = j;\n\n            log8[j] = i;\n\n            j ^= j + j;\n\n            if (j > 255)\n\n                j ^= 0x11B;\n\n        }\n\n        for (i = 0; i < 256; i++) {\n\n            j = i ? alog8[255 - log8[i]] : 0;\n\n            j ^= (j << 1) ^ (j << 2) ^ (j << 3) ^ (j << 4);\n\n            j = (j ^ (j >> 8) ^ 99) & 255;\n\n            inv_sbox[j] = i;\n\n            sbox[i] = j;\n\n        }\n\n        init_multbl2(dec_multbl[0], (const int[4]) { 0xe, 0x9, 0xd, 0xb },\n\n                     log8, alog8, inv_sbox);\n\n        init_multbl2(enc_multbl[0], (const int[4]) { 0x2, 0x1, 0x1, 0x3 },\n\n                     log8, alog8, sbox);\n\n    }\n\n\n\n    if (key_bits != 128 && key_bits != 192 && key_bits != 256)\n\n        return -1;\n\n\n\n    a->rounds = rounds;\n\n\n\n    memcpy(tk, key, KC * 4);\n\n\n\n    for (t = 0; t < (rounds + 1) * 16;) {\n\n        memcpy(a->round_key[0].u8 + t, tk, KC * 4);\n\n        t += KC * 4;\n\n\n\n        for (i = 0; i < 4; i++)\n\n            tk[0][i] ^= sbox[tk[KC - 1][(i + 1) & 3]];\n\n        tk[0][0] ^= rcon[rconpointer++];\n\n\n\n        for (j = 1; j < KC; j++) {\n\n            if (KC != 8 || j != KC >> 1)\n\n                for (i = 0; i < 4; i++)\n\n                    tk[j][i] ^= tk[j - 1][i];\n\n            else\n\n                for (i = 0; i < 4; i++)\n\n                    tk[j][i] ^= sbox[tk[j - 1][i]];\n\n        }\n\n    }\n\n\n\n    if (decrypt) {\n\n        for (i = 1; i < rounds; i++) {\n\n            av_aes_block tmp[3];\n\n            tmp[2] = a->round_key[i];\n\n            subshift(&tmp[1], 0, sbox);\n\n            mix(tmp, dec_multbl, 1, 3);\n\n            a->round_key[i] = tmp[0];\n\n        }\n\n    } else {\n\n        for (i = 0; i < (rounds + 1) >> 1; i++) {\n\n            FFSWAP(av_aes_block, a->round_key[i], a->round_key[rounds-i]);\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 6509}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void RENAME(yv12touyvy)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst,\n\n\tunsigned int width, unsigned int height,\n\n\tint lumStride, int chromStride, int dstStride)\n\n{\n\n\t//FIXME interpolate chroma\n\n\tRENAME(yuvPlanartouyvy)(ysrc, usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 2);\n\n}\n", "idx": 6519}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int asf_read_ext_content(AVFormatContext *s, const GUIDParseTable *g)\n\n{\n\n    ASFContext *asf  = s->priv_data;\n\n    AVIOContext *pb  = s->pb;\n\n    uint64_t size    = avio_rl64(pb);\n\n    uint16_t nb_desc = avio_rl16(pb);\n\n    int i, ret;\n\n\n\n    for (i = 0; i < nb_desc; i++) {\n\n        uint16_t name_len, type, val_len;\n\n        uint8_t *name = NULL;\n\n\n\n        name_len = avio_rl16(pb);\n\n        if (!name_len)\n\n            return AVERROR_INVALIDDATA;\n\n        name = av_malloc(name_len);\n\n        if (!name)\n\n            return AVERROR(ENOMEM);\n\n        avio_get_str16le(pb, name_len, name,\n\n                         name_len);\n\n        type    = avio_rl16(pb);\n\n        val_len = avio_rl16(pb);\n\n\n\n        if ((ret = process_metadata(s, name, name_len, val_len, type, &s->metadata)) < 0)\n\n            return ret;\n\n    }\n\n\n\n    align_position(pb, asf->offset, size);\n\n    return 0;\n\n}\n", "idx": 6543}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void vmxnet3_net_uninit(VMXNET3State *s)\n\n{\n\n    g_free(s->mcast_list);\n\n    vmxnet_tx_pkt_reset(s->tx_pkt);\n\n    vmxnet_tx_pkt_uninit(s->tx_pkt);\n\n    vmxnet_rx_pkt_uninit(s->rx_pkt);\n\n    qemu_del_nic(s->nic);\n\n}\n", "idx": 6547}, {"project": "test", "commit_id": "test", "target": 1, "func": "CPUArchState *cpu_copy(CPUArchState *env)\n\n{\n\n    CPUState *cpu = ENV_GET_CPU(env);\n\n    CPUState *new_cpu = cpu_init(cpu_model);\n\n    CPUArchState *new_env = cpu->env_ptr;\n\n    CPUBreakpoint *bp;\n\n    CPUWatchpoint *wp;\n\n\n\n    /* Reset non arch specific state */\n\n    cpu_reset(new_cpu);\n\n\n\n    memcpy(new_env, env, sizeof(CPUArchState));\n\n\n\n    /* Clone all break/watchpoints.\n\n       Note: Once we support ptrace with hw-debug register access, make sure\n\n       BP_CPU break/watchpoints are handled correctly on clone. */\n\n    QTAILQ_INIT(&cpu->breakpoints);\n\n    QTAILQ_INIT(&cpu->watchpoints);\n\n    QTAILQ_FOREACH(bp, &cpu->breakpoints, entry) {\n\n        cpu_breakpoint_insert(new_cpu, bp->pc, bp->flags, NULL);\n\n    }\n\n    QTAILQ_FOREACH(wp, &cpu->watchpoints, entry) {\n\n        cpu_watchpoint_insert(new_cpu, wp->vaddr, wp->len, wp->flags, NULL);\n\n    }\n\n\n\n    return new_env;\n\n}\n", "idx": 6577}, {"project": "test", "commit_id": "test", "target": 1, "func": "target_ulong helper_rdhwr_cpunum(CPUMIPSState *env)\n\n{\n\n    check_hwrena(env, 0);\n\n    return env->CP0_EBase & 0x3ff;\n\n}\n", "idx": 6628}, {"project": "test", "commit_id": "test", "target": 1, "func": "static av_always_inline void rv40_weak_loop_filter(uint8_t *src,\n\n                                                   const int step,\n\n                                                   const int stride,\n\n                                                   const int filter_p1,\n\n                                                   const int filter_q1,\n\n                                                   const int alpha,\n\n                                                   const int beta,\n\n                                                   const int lim_p0q0,\n\n                                                   const int lim_q1,\n\n                                                   const int lim_p1)\n\n{\n\n    uint8_t *cm = ff_cropTbl + MAX_NEG_CROP;\n\n    int i, t, u, diff;\n\n\n\n    for (i = 0; i < 4; i++, src += stride) {\n\n        int diff_p1p0 = src[-2*step] - src[-1*step];\n\n        int diff_q1q0 = src[ 1*step] - src[ 0*step];\n\n        int diff_p1p2 = src[-2*step] - src[-3*step];\n\n        int diff_q1q2 = src[ 1*step] - src[ 2*step];\n\n\n\n        t = src[0*step] - src[-1*step];\n\n        if (!t)\n\n            continue;\n\n\n\n        u = (alpha * FFABS(t)) >> 7;\n\n        if (u > 3 - (filter_p1 && filter_q1))\n\n            continue;\n\n\n\n        t <<= 2;\n\n        if (filter_p1 && filter_q1)\n\n            t += src[-2*step] - src[1*step];\n\n\n\n        diff = CLIP_SYMM((t + 4) >> 3, lim_p0q0);\n\n        src[-1*step] = cm[src[-1*step] + diff];\n\n        src[ 0*step] = cm[src[ 0*step] - diff];\n\n\n\n        if (filter_p1 && FFABS(diff_p1p2) <= beta) {\n\n            t = (diff_p1p0 + diff_p1p2 - diff) >> 1;\n\n            src[-2*step] = cm[src[-2*step] - CLIP_SYMM(t, lim_p1)];\n\n        }\n\n\n\n        if (filter_q1 && FFABS(diff_q1q2) <= beta) {\n\n            t = (diff_q1q0 + diff_q1q2 + diff) >> 1;\n\n            src[ 1*step] = cm[src[ 1*step] - CLIP_SYMM(t, lim_q1)];\n\n        }\n\n    }\n\n}\n", "idx": 6646}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void con_disconnect(struct XenDevice *xendev)\n\n{\n\n    struct XenConsole *con = container_of(xendev, struct XenConsole, xendev);\n\n\n\n    if (con->chr) {\n\n        qemu_chr_add_handlers(con->chr, NULL, NULL, NULL, NULL);\n\n        qemu_chr_fe_release(con->chr);\n\n    }\n\n    xen_be_unbind_evtchn(&con->xendev);\n\n\n\n    if (con->sring) {\n\n        if (!xendev->dev) {\n\n            munmap(con->sring, XC_PAGE_SIZE);\n\n        } else {\n\n            xengnttab_unmap(xendev->gnttabdev, con->sring, 1);\n\n        }\n\n        con->sring = NULL;\n\n    }\n\n}\n", "idx": 6650}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int normalize_bits(int num, int width)\n\n{\n\n    if (!num)\n\n        return 0;\n\n    if (num == -1)\n\n        return width;\n\n    if (num < 0)\n\n        num = ~num;\n\n\n\n    return width - av_log2(num);\n\n}\n", "idx": 6670}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void xen_pci_passthrough_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    k->realize = xen_pt_realize;\n\n    k->exit = xen_pt_unregister_device;\n\n    k->config_read = xen_pt_pci_read_config;\n\n    k->config_write = xen_pt_pci_write_config;\n\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->desc = \"Assign an host PCI device with Xen\";\n\n    dc->props = xen_pci_passthrough_properties;\n\n};", "idx": 6674}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int filter_slice(AVFilterContext *ctx, void *arg, int jobnr, int nb_jobs)\n\n{\n\n    YADIFContext *s = ctx->priv;\n\n    ThreadData *td  = arg;\n\n    int refs = s->cur->linesize[td->plane];\n\n    int df = (s->csp->comp[td->plane].depth_minus1 + 8) / 8;\n\n    int pix_3 = 3 * df;\n\n    int slice_h = td->h / nb_jobs;\n\n    int slice_start = jobnr * slice_h;\n\n    int slice_end   = (jobnr == nb_jobs - 1) ? td->h : (jobnr + 1) * slice_h;\n\n    int y;\n\n\n\n    /* filtering reads 3 pixels to the left/right; to avoid invalid reads,\n\n     * we need to call the c variant which avoids this for border pixels\n\n     */\n\n    for (y = slice_start; y < slice_end; y++) {\n\n        if ((y ^ td->parity) & 1) {\n\n            uint8_t *prev = &s->prev->data[td->plane][y * refs];\n\n            uint8_t *cur  = &s->cur ->data[td->plane][y * refs];\n\n            uint8_t *next = &s->next->data[td->plane][y * refs];\n\n            uint8_t *dst  = &td->frame->data[td->plane][y * td->frame->linesize[td->plane]];\n\n            int     mode  = y == 1 || y + 2 == td->h ? 2 : s->mode;\n\n            s->filter_line(dst + pix_3, prev + pix_3, cur + pix_3,\n\n                           next + pix_3, td->w - 6,\n\n                           y + 1 < td->h ? refs : -refs,\n\n                           y ? -refs : refs,\n\n                           td->parity ^ td->tff, mode);\n\n            s->filter_edges(dst, prev, cur, next, td->w,\n\n                            y + 1 < td->h ? refs : -refs,\n\n                            y ? -refs : refs,\n\n                            td->parity ^ td->tff, mode);\n\n        } else {\n\n            memcpy(&td->frame->data[td->plane][y * td->frame->linesize[td->plane]],\n\n                   &s->cur->data[td->plane][y * refs], td->w * df);\n\n        }\n\n    }\n\n    return 0;\n\n}\n", "idx": 6727}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void quantize_and_encode_band_cost_SPAIR_mips(struct AACEncContext *s,\n\n                                                     PutBitContext *pb, const float *in, float *out,\n\n                                                     const float *scaled, int size, int scale_idx,\n\n                                                     int cb, const float lambda, const float uplim,\n\n                                                     int *bits, const float ROUNDING)\n\n{\n\n    const float Q34 = ff_aac_pow34sf_tab[POW_SF2_ZERO - scale_idx + SCALE_ONE_POS - SCALE_DIV_512];\n\n    const float IQ  = ff_aac_pow2sf_tab [POW_SF2_ZERO + scale_idx - SCALE_ONE_POS + SCALE_DIV_512];\n\n    int i;\n\n    int qc1, qc2, qc3, qc4;\n\n\n\n    uint8_t  *p_bits  = (uint8_t  *)ff_aac_spectral_bits[cb-1];\n\n    uint16_t *p_codes = (uint16_t *)ff_aac_spectral_codes[cb-1];\n\n    float    *p_vec   = (float    *)ff_aac_codebook_vectors[cb-1];\n\n\n\n    abs_pow34_v(s->scoefs, in, size);\n\n    scaled = s->scoefs;\n\n    for (i = 0; i < size; i += 4) {\n\n        int curidx, curidx2;\n\n        int *in_int = (int *)&in[i];\n\n        uint8_t v_bits;\n\n        unsigned int v_codes;\n\n        int t0, t1, t2, t3, t4, t5, t6, t7;\n\n        const float *vec1, *vec2;\n\n\n\n        qc1 = scaled[i  ] * Q34 + ROUND_STANDARD;\n\n        qc2 = scaled[i+1] * Q34 + ROUND_STANDARD;\n\n        qc3 = scaled[i+2] * Q34 + ROUND_STANDARD;\n\n        qc4 = scaled[i+3] * Q34 + ROUND_STANDARD;\n\n\n\n        __asm__ volatile (\n\n            \".set push                      \\n\\t\"\n\n            \".set noreorder                 \\n\\t\"\n\n\n\n            \"ori    %[t4],  $zero,  4       \\n\\t\"\n\n            \"slt    %[t0],  %[t4],  %[qc1]  \\n\\t\"\n\n            \"slt    %[t1],  %[t4],  %[qc2]  \\n\\t\"\n\n            \"slt    %[t2],  %[t4],  %[qc3]  \\n\\t\"\n\n            \"slt    %[t3],  %[t4],  %[qc4]  \\n\\t\"\n\n            \"movn   %[qc1], %[t4],  %[t0]   \\n\\t\"\n\n            \"movn   %[qc2], %[t4],  %[t1]   \\n\\t\"\n\n            \"movn   %[qc3], %[t4],  %[t2]   \\n\\t\"\n\n            \"movn   %[qc4], %[t4],  %[t3]   \\n\\t\"\n\n            \"lw     %[t0],  0(%[in_int])    \\n\\t\"\n\n            \"lw     %[t1],  4(%[in_int])    \\n\\t\"\n\n            \"lw     %[t2],  8(%[in_int])    \\n\\t\"\n\n            \"lw     %[t3],  12(%[in_int])   \\n\\t\"\n\n            \"srl    %[t0],  %[t0],  31      \\n\\t\"\n\n            \"srl    %[t1],  %[t1],  31      \\n\\t\"\n\n            \"srl    %[t2],  %[t2],  31      \\n\\t\"\n\n            \"srl    %[t3],  %[t3],  31      \\n\\t\"\n\n            \"subu   %[t4],  $zero,  %[qc1]  \\n\\t\"\n\n            \"subu   %[t5],  $zero,  %[qc2]  \\n\\t\"\n\n            \"subu   %[t6],  $zero,  %[qc3]  \\n\\t\"\n\n            \"subu   %[t7],  $zero,  %[qc4]  \\n\\t\"\n\n            \"movn   %[qc1], %[t4],  %[t0]   \\n\\t\"\n\n            \"movn   %[qc2], %[t5],  %[t1]   \\n\\t\"\n\n            \"movn   %[qc3], %[t6],  %[t2]   \\n\\t\"\n\n            \"movn   %[qc4], %[t7],  %[t3]   \\n\\t\"\n\n\n\n            \".set pop                       \\n\\t\"\n\n\n\n            : [qc1]\"+r\"(qc1), [qc2]\"+r\"(qc2),\n\n              [qc3]\"+r\"(qc3), [qc4]\"+r\"(qc4),\n\n              [t0]\"=&r\"(t0), [t1]\"=&r\"(t1), [t2]\"=&r\"(t2), [t3]\"=&r\"(t3),\n\n              [t4]\"=&r\"(t4), [t5]\"=&r\"(t5), [t6]\"=&r\"(t6), [t7]\"=&r\"(t7)\n\n            : [in_int]\"r\"(in_int)\n\n            : \"memory\"\n\n        );\n\n\n\n        curidx = 9 * qc1;\n\n        curidx += qc2 + 40;\n\n\n\n        curidx2 = 9 * qc3;\n\n        curidx2 += qc4 + 40;\n\n\n\n        v_codes = (p_codes[curidx] << p_bits[curidx2]) | (p_codes[curidx2]);\n\n        v_bits  = p_bits[curidx] + p_bits[curidx2];\n\n        put_bits(pb, v_bits, v_codes);\n\n\n\n        if (out) {\n\n           vec1 = &p_vec[curidx*2 ];\n\n           vec2 = &p_vec[curidx2*2];\n\n           out[i+0] = vec1[0] * IQ;\n\n           out[i+1] = vec1[1] * IQ;\n\n           out[i+2] = vec2[0] * IQ;\n\n           out[i+3] = vec2[1] * IQ;\n\n        }\n\n    }\n\n}\n", "idx": 6778}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void sdhci_send_command(SDHCIState *s)\n\n{\n\n    SDRequest request;\n\n    uint8_t response[16];\n\n    int rlen;\n\n\n\n    s->errintsts = 0;\n\n    s->acmd12errsts = 0;\n\n    request.cmd = s->cmdreg >> 8;\n\n    request.arg = s->argument;\n\n    DPRINT_L1(\"sending CMD%u ARG[0x%08x]\\n\", request.cmd, request.arg);\n\n    rlen = sdbus_do_command(&s->sdbus, &request, response);\n\n\n\n    if (s->cmdreg & SDHC_CMD_RESPONSE) {\n\n        if (rlen == 4) {\n\n            s->rspreg[0] = (response[0] << 24) | (response[1] << 16) |\n\n                           (response[2] << 8)  |  response[3];\n\n            s->rspreg[1] = s->rspreg[2] = s->rspreg[3] = 0;\n\n            DPRINT_L1(\"Response: RSPREG[31..0]=0x%08x\\n\", s->rspreg[0]);\n\n        } else if (rlen == 16) {\n\n            s->rspreg[0] = (response[11] << 24) | (response[12] << 16) |\n\n                           (response[13] << 8) |  response[14];\n\n            s->rspreg[1] = (response[7] << 24) | (response[8] << 16) |\n\n                           (response[9] << 8)  |  response[10];\n\n            s->rspreg[2] = (response[3] << 24) | (response[4] << 16) |\n\n                           (response[5] << 8)  |  response[6];\n\n            s->rspreg[3] = (response[0] << 16) | (response[1] << 8) |\n\n                            response[2];\n\n            DPRINT_L1(\"Response received:\\n RSPREG[127..96]=0x%08x, RSPREG[95..\"\n\n                  \"64]=0x%08x,\\n RSPREG[63..32]=0x%08x, RSPREG[31..0]=0x%08x\\n\",\n\n                  s->rspreg[3], s->rspreg[2], s->rspreg[1], s->rspreg[0]);\n\n        } else {\n\n            ERRPRINT(\"Timeout waiting for command response\\n\");\n\n            if (s->errintstsen & SDHC_EISEN_CMDTIMEOUT) {\n\n                s->errintsts |= SDHC_EIS_CMDTIMEOUT;\n\n                s->norintsts |= SDHC_NIS_ERR;\n\n            }\n\n        }\n\n\n\n        if ((s->norintstsen & SDHC_NISEN_TRSCMP) &&\n\n            (s->cmdreg & SDHC_CMD_RESPONSE) == SDHC_CMD_RSP_WITH_BUSY) {\n\n            s->norintsts |= SDHC_NIS_TRSCMP;\n\n        }\n\n    }\n\n\n\n    if (s->norintstsen & SDHC_NISEN_CMDCMP) {\n\n        s->norintsts |= SDHC_NIS_CMDCMP;\n\n    }\n\n\n\n    sdhci_update_irq(s);\n\n\n\n    if (s->blksize && (s->cmdreg & SDHC_CMD_DATA_PRESENT)) {\n\n        s->data_count = 0;\n\n        sdhci_data_transfer(s);\n\n    }\n\n}\n", "idx": 6891}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline int mpeg2_fast_decode_block_non_intra(MpegEncContext *s,\n\n                                                    int16_t *block, int n)\n\n{\n\n    int level, i, j, run;\n\n    RLTable *rl = &ff_rl_mpeg1;\n\n    uint8_t * const scantable = s->intra_scantable.permutated;\n\n    const int qscale          = s->qscale;\n\n    OPEN_READER(re, &s->gb);\n\n    i = -1;\n\n\n\n    // special case for first coefficient, no need to add second VLC table\n\n    UPDATE_CACHE(re, &s->gb);\n\n    if (((int32_t)GET_CACHE(re, &s->gb)) < 0) {\n\n        level = (3 * qscale) >> 1;\n\n        if (GET_CACHE(re, &s->gb) & 0x40000000)\n\n            level = -level;\n\n        block[0] = level;\n\n        i++;\n\n        SKIP_BITS(re, &s->gb, 2);\n\n        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)\n\n            goto end;\n\n    }\n\n\n\n    /* now quantify & encode AC coefficients */\n\n    for (;;) {\n\n        GET_RL_VLC(level, run, re, &s->gb, rl->rl_vlc[0], TEX_VLC_BITS, 2, 0);\n\n\n\n        if (level != 0) {\n\n            i += run;\n\n            j  = scantable[i];\n\n            level = ((level * 2 + 1) * qscale) >> 1;\n\n            level = (level ^ SHOW_SBITS(re, &s->gb, 1)) - SHOW_SBITS(re, &s->gb, 1);\n\n            SKIP_BITS(re, &s->gb, 1);\n\n        } else {\n\n            /* escape */\n\n            run = SHOW_UBITS(re, &s->gb, 6) + 1; LAST_SKIP_BITS(re, &s->gb, 6);\n\n            UPDATE_CACHE(re, &s->gb);\n\n            level = SHOW_SBITS(re, &s->gb, 12); SKIP_BITS(re, &s->gb, 12);\n\n\n\n            i += run;\n\n            j  = scantable[i];\n\n            if (level < 0) {\n\n                level = ((-level * 2 + 1) * qscale) >> 1;\n\n                level = -level;\n\n            } else {\n\n                level = ((level * 2 + 1) * qscale) >> 1;\n\n            }\n\n        }\n\n\n\n        block[j] = level;\n\n        if (((int32_t)GET_CACHE(re, &s->gb)) <= (int32_t)0xBFFFFFFF)\n\n            break;\n\n        UPDATE_CACHE(re, &s->gb);\n\n    }\n\nend:\n\n    LAST_SKIP_BITS(re, &s->gb, 2);\n\n    CLOSE_READER(re, &s->gb);\n\n    s->block_last_index[n] = i;\n\n    return 0;\n\n}\n", "idx": 6972}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void qpa_fini_out (HWVoiceOut *hw)\n\n{\n\n    void *ret;\n\n    PAVoiceOut *pa = (PAVoiceOut *) hw;\n\n\n\n    audio_pt_lock (&pa->pt, AUDIO_FUNC);\n\n    pa->done = 1;\n\n    audio_pt_unlock_and_signal (&pa->pt, AUDIO_FUNC);\n\n    audio_pt_join (&pa->pt, &ret, AUDIO_FUNC);\n\n\n\n    if (pa->s) {\n\n        pa_simple_free (pa->s);\n\n        pa->s = NULL;\n\n    }\n\n\n\n    audio_pt_fini (&pa->pt, AUDIO_FUNC);\n\n    g_free (pa->pcm_buf);\n\n    pa->pcm_buf = NULL;\n\n}\n", "idx": 7004}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int get_buffer_sao(HEVCContext *s, AVFrame *frame, const HEVCSPS *sps)\n\n{\n\n    int ret, i;\n\n\n\n    frame->width  = s->avctx->width  + 2;\n\n    frame->height = s->avctx->height + 2;\n\n    if ((ret = ff_get_buffer(s->avctx, frame, AV_GET_BUFFER_FLAG_REF)) < 0)\n\n        return ret;\n\n    for (i = 0; frame->data[i]; i++) {\n\n        int offset = frame->linesize[i] + (1 << sps->pixel_shift);\n\n        frame->data[i] += offset;\n\n    }\n\n    frame->width  = s->avctx->width;\n\n    frame->height = s->avctx->height;\n\n\n\n    return 0;\n\n}\n", "idx": 7048}, {"project": "test", "commit_id": "test", "target": 1, "func": "int qemu_chr_fe_read_all(CharDriverState *s, uint8_t *buf, int len)\n\n{\n\n    int offset = 0, counter = 10;\n\n    int res;\n\n\n\n    if (!s->chr_sync_read) {\n\n        return 0;\n\n    }\n\n    \n\n    if (s->replay && replay_mode == REPLAY_MODE_PLAY) {\n\n        return replay_char_read_all_load(buf);\n\n    }\n\n\n\n    while (offset < len) {\n\n        do {\n\n            res = s->chr_sync_read(s, buf + offset, len - offset);\n\n            if (res == -1 && errno == EAGAIN) {\n\n                g_usleep(100);\n\n            }\n\n        } while (res == -1 && errno == EAGAIN);\n\n\n\n        if (res == 0) {\n\n            break;\n\n        }\n\n\n\n        if (res < 0) {\n\n            if (s->replay && replay_mode == REPLAY_MODE_RECORD) {\n\n                replay_char_read_all_save_error(res);\n\n            }\n\n            return res;\n\n        }\n\n\n\n        offset += res;\n\n\n\n        if (!counter--) {\n\n            break;\n\n        }\n\n    }\n\n\n\n    if (s->replay && replay_mode == REPLAY_MODE_RECORD) {\n\n        replay_char_read_all_save_buf(buf, offset);\n\n    }\n\n    return offset;\n\n}\n", "idx": 7125}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void RENAME(yuy2ToUV)(uint8_t *dstU, uint8_t *dstV, uint8_t *src1, uint8_t *src2, int width)\n\n{\n\n#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n\n\tasm volatile(\n\n\t\t\"movq \"MANGLE(bm01010101)\", %%mm4\\n\\t\"\n\n\t\t\"mov %0, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\"movq (%1, %%\"REG_a\",4), %%mm0\t\\n\\t\"\n\n\t\t\"movq 8(%1, %%\"REG_a\",4), %%mm1\t\\n\\t\"\n\n\t\t\"movq (%2, %%\"REG_a\",4), %%mm2\t\\n\\t\"\n\n\t\t\"movq 8(%2, %%\"REG_a\",4), %%mm3\t\\n\\t\"\n\n\t\tPAVGB(%%mm2, %%mm0)\n\n\t\tPAVGB(%%mm3, %%mm1)\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\"movq %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"psrlw $8, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm4, %%mm1\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm0, %%mm0\t\t\\n\\t\"\n\n\t\t\"packuswb %%mm1, %%mm1\t\t\\n\\t\"\n\n\t\t\"movd %%mm0, (%4, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"movd %%mm1, (%3, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"add $4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t: : \"g\" ((long)-width), \"r\" (src1+width*4), \"r\" (src2+width*4), \"r\" (dstU+width), \"r\" (dstV+width)\n\n\t\t: \"%\"REG_a\n\n\t);\n\n#else\n\n\tint i;\n\n\tfor(i=0; i<width; i++)\n\n\t{\n\n\t\tdstU[i]= (src1[4*i + 1] + src2[4*i + 1])>>1;\n\n\t\tdstV[i]= (src1[4*i + 3] + src2[4*i + 3])>>1;\n\n\t}\n\n#endif\n\n}\n", "idx": 7174}, {"project": "test", "commit_id": "test", "target": 1, "func": "static bool qht_insert__locked(struct qht *ht, struct qht_map *map,\n\n                               struct qht_bucket *head, void *p, uint32_t hash,\n\n                               bool *needs_resize)\n\n{\n\n    struct qht_bucket *b = head;\n\n    struct qht_bucket *prev = NULL;\n\n    struct qht_bucket *new = NULL;\n\n    int i;\n\n\n\n    do {\n\n        for (i = 0; i < QHT_BUCKET_ENTRIES; i++) {\n\n            if (b->pointers[i]) {\n\n                if (unlikely(b->pointers[i] == p)) {\n\n                    return false;\n\n                }\n\n            } else {\n\n                goto found;\n\n            }\n\n        }\n\n        prev = b;\n\n        b = b->next;\n\n    } while (b);\n\n\n\n    b = qemu_memalign(QHT_BUCKET_ALIGN, sizeof(*b));\n\n    memset(b, 0, sizeof(*b));\n\n    new = b;\n\n    i = 0;\n\n    atomic_inc(&map->n_added_buckets);\n\n    if (unlikely(qht_map_needs_resize(map)) && needs_resize) {\n\n        *needs_resize = true;\n\n    }\n\n\n\n found:\n\n    /* found an empty key: acquire the seqlock and write */\n\n    seqlock_write_begin(&head->sequence);\n\n    if (new) {\n\n        atomic_rcu_set(&prev->next, b);\n\n    }\n\n    b->hashes[i] = hash;\n\n    /* smp_wmb() implicit in seqlock_write_begin.  */\n\n    atomic_set(&b->pointers[i], p);\n\n    seqlock_write_end(&head->sequence);\n\n    return true;\n\n}\n", "idx": 7191}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int virtio_blk_device_exit(DeviceState *dev)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n    VirtIOBlock *s = VIRTIO_BLK(dev);\n\n#ifdef CONFIG_VIRTIO_BLK_DATA_PLANE\n\n    remove_migration_state_change_notifier(&s->migration_state_notifier);\n\n    virtio_blk_data_plane_destroy(s->dataplane);\n\n    s->dataplane = NULL;\n\n#endif\n\n    qemu_del_vm_change_state_handler(s->change);\n\n    unregister_savevm(dev, \"virtio-blk\", s);\n\n    blockdev_mark_auto_del(s->bs);\n\n    virtio_cleanup(vdev);\n\n    return 0;\n\n}\n", "idx": 7243}, {"project": "test", "commit_id": "test", "target": 1, "func": "target_ulong spapr_rtas_call(sPAPREnvironment *spapr,\n                             uint32_t token, uint32_t nargs, target_ulong args,\n                             uint32_t nret, target_ulong rets)\n{\n    if ((token >= TOKEN_BASE)\n        && ((token - TOKEN_BASE) < TOKEN_MAX)) {\n        struct rtas_call *call = rtas_table + (token - TOKEN_BASE);\n        if (call->fn) {\n            call->fn(spapr, token, nargs, args, nret, rets);\n    hcall_dprintf(\"Unknown RTAS token 0x%x\\n\", token);\n    rtas_st(rets, 0, -3);\n    return H_PARAMETER;", "idx": 7269}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int bochs_open(BlockDriverState *bs, QDict *options, int flags,\n                      Error **errp)\n{\n    BDRVBochsState *s = bs->opaque;\n    uint32_t i;\n    struct bochs_header bochs;\n    int ret;\n    bs->read_only = 1; // no write support yet\n    ret = bdrv_pread(bs->file, 0, &bochs, sizeof(bochs));\n    if (ret < 0) {\n        return ret;\n    if (strcmp(bochs.magic, HEADER_MAGIC) ||\n        strcmp(bochs.type, REDOLOG_TYPE) ||\n        strcmp(bochs.subtype, GROWING_TYPE) ||\n\t((le32_to_cpu(bochs.version) != HEADER_VERSION) &&\n\t(le32_to_cpu(bochs.version) != HEADER_V1))) {\n        error_setg(errp, \"Image not in Bochs format\");\n        return -EINVAL;\n    if (le32_to_cpu(bochs.version) == HEADER_V1) {\n        bs->total_sectors = le64_to_cpu(bochs.extra.redolog_v1.disk) / 512;\n    } else {\n        bs->total_sectors = le64_to_cpu(bochs.extra.redolog.disk) / 512;\n    s->catalog_size = le32_to_cpu(bochs.catalog);\n    s->catalog_bitmap = g_malloc(s->catalog_size * 4);\n    ret = bdrv_pread(bs->file, le32_to_cpu(bochs.header), s->catalog_bitmap,\n                     s->catalog_size * 4);\n    if (ret < 0) {\n        goto fail;\n    for (i = 0; i < s->catalog_size; i++)\n\tle32_to_cpus(&s->catalog_bitmap[i]);\n    s->data_offset = le32_to_cpu(bochs.header) + (s->catalog_size * 4);\n    s->bitmap_blocks = 1 + (le32_to_cpu(bochs.bitmap) - 1) / 512;\n    s->extent_blocks = 1 + (le32_to_cpu(bochs.extent) - 1) / 512;\n    s->extent_size = le32_to_cpu(bochs.extent);\n    if (s->catalog_size < bs->total_sectors / s->extent_size) {\n        error_setg(errp, \"Catalog size is too small for this disk size\");\n        ret = -EINVAL;\n        goto fail;\n    qemu_co_mutex_init(&s->lock);\n    return 0;\nfail:\n    g_free(s->catalog_bitmap);\n    return ret;", "idx": 7347}, {"project": "test", "commit_id": "test", "target": 1, "func": "void *pl080_init(uint32_t base, qemu_irq irq, int nchannels)\n\n{\n\n    int iomemtype;\n\n    pl080_state *s;\n\n\n\n    s = (pl080_state *)qemu_mallocz(sizeof(pl080_state));\n\n    iomemtype = cpu_register_io_memory(0, pl080_readfn,\n\n                                       pl080_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->nchannels = nchannels;\n\n    /* ??? Save/restore.  */\n\n    return s;\n\n}\n", "idx": 7596}, {"project": "test", "commit_id": "test", "target": 1, "func": "void *g_realloc(void *ptr, size_t size)\n\n{\n\n    size_t old_size, copy;\n\n    void *new_ptr;\n\n\n\n    if (!ptr)\n\n        return g_malloc(size);\n\n    old_size = *(size_t *)((char *)ptr - 16);\n\n    copy = old_size < size ? old_size : size;\n\n    new_ptr = g_malloc(size);\n\n    memcpy(new_ptr, ptr, copy);\n\n    g_free(ptr);\n\n    return new_ptr;\n\n}\n", "idx": 7662}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *got_frame,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size       = avpkt->size;\n    AVFrame *const p   = data;\n    int compressed, xmin, ymin, xmax, ymax;\n    unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x,\n                 bytes_per_scanline;\n    uint8_t *ptr;\n    const uint8_t *buf_end = buf + buf_size;\n    const uint8_t *bufstart = buf;\n    uint8_t *scanline;\n    int ret = -1;\n    if (buf[0] != 0x0a || buf[1] > 5) {\n        av_log(avctx, AV_LOG_ERROR, \"this is not PCX encoded data\\n\");\n    compressed = buf[2];\n    xmin       = AV_RL16(buf + 4);\n    ymin       = AV_RL16(buf + 6);\n    xmax       = AV_RL16(buf + 8);\n    ymax       = AV_RL16(buf + 10);\n    if (xmax < xmin || ymax < ymin) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid image dimensions\\n\");\n    w = xmax - xmin + 1;\n    h = ymax - ymin + 1;\n    bits_per_pixel     = buf[3];\n    bytes_per_line     = AV_RL16(buf + 66);\n    nplanes            = buf[65];\n    bytes_per_scanline = nplanes * bytes_per_line;\n    if (bytes_per_scanline < (w * bits_per_pixel * nplanes + 7) / 8 ||\n        (!compressed && bytes_per_scanline > buf_size / h)) {\n        av_log(avctx, AV_LOG_ERROR, \"PCX data is corrupted\\n\");\n    switch ((nplanes << 8) + bits_per_pixel) {\n    case 0x0308:\n        avctx->pix_fmt = AV_PIX_FMT_RGB24;\n        break;\n    case 0x0108:\n    case 0x0104:\n    case 0x0102:\n    case 0x0101:\n    case 0x0401:\n    case 0x0301:\n    case 0x0201:\n        avctx->pix_fmt = AV_PIX_FMT_PAL8;\n        break;\n    default:\n        av_log(avctx, AV_LOG_ERROR, \"invalid PCX file\\n\");\n    buf += 128;\n    if ((ret = ff_set_dimensions(avctx, w, h)) < 0)\n        return ret;\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0) {\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n        return ret;\n    p->pict_type = AV_PICTURE_TYPE_I;\n    ptr    = p->data[0];\n    stride = p->linesize[0];\n    scanline = av_malloc(bytes_per_scanline + AV_INPUT_BUFFER_PADDING_SIZE);\n    if (!scanline)\n        return AVERROR(ENOMEM);\n    if (nplanes == 3 && bits_per_pixel == 8) {\n        for (y = 0; y < h; y++) {\n            buf = pcx_rle_decode(buf, buf_end,\n                                 scanline, bytes_per_scanline, compressed);\n            for (x = 0; x < w; x++) {\n                ptr[3 * x]     = scanline[x];\n                ptr[3 * x + 1] = scanline[x + bytes_per_line];\n                ptr[3 * x + 2] = scanline[x + (bytes_per_line << 1)];\n            ptr += stride;\n    } else if (nplanes == 1 && bits_per_pixel == 8) {\n        const uint8_t *palstart = bufstart + buf_size - 769;\n        if (buf_size < 769) {\n            av_log(avctx, AV_LOG_ERROR, \"File is too short\\n\");\n            ret = avctx->err_recognition & AV_EF_EXPLODE ?\n                  AVERROR_INVALIDDATA : buf_size;\n            goto end;\n        for (y = 0; y < h; y++, ptr += stride) {\n            buf = pcx_rle_decode(buf, buf_end,\n                                 scanline, bytes_per_scanline, compressed);\n            memcpy(ptr, scanline, w);\n        if (buf != palstart) {\n            av_log(avctx, AV_LOG_WARNING, \"image data possibly corrupted\\n\");\n            buf = palstart;\n        if (*buf++ != 12) {\n            av_log(avctx, AV_LOG_ERROR, \"expected palette after image data\\n\");\n            ret = avctx->err_recognition & AV_EF_EXPLODE ?\n                  AVERROR_INVALIDDATA : buf_size;\n            goto end;\n    } else if (nplanes == 1) {   /* all packed formats, max. 16 colors */\n        GetBitContext s;\n        for (y = 0; y < h; y++) {\n            init_get_bits(&s, scanline, bytes_per_scanline << 3);\n            buf = pcx_rle_decode(buf, buf_end,\n                                 scanline, bytes_per_scanline, compressed);\n            for (x = 0; x < w; x++)\n                ptr[x] = get_bits(&s, bits_per_pixel);\n            ptr += stride;\n    } else {    /* planar, 4, 8 or 16 colors */\n        int i;\n        for (y = 0; y < h; y++) {\n            buf = pcx_rle_decode(buf, buf_end,\n                                 scanline, bytes_per_scanline, compressed);\n            for (x = 0; x < w; x++) {\n                int m = 0x80 >> (x & 7), v = 0;\n                for (i = nplanes - 1; i >= 0; i--) {\n                    v <<= 1;\n                    v  += !!(scanline[i * bytes_per_line + (x >> 3)] & m);\n                ptr[x] = v;\n            ptr += stride;\n    if (nplanes == 1 && bits_per_pixel == 8) {\n        pcx_palette(&buf, (uint32_t *)p->data[1], 256);\n    } else if (bits_per_pixel < 8) {\n        const uint8_t *palette = bufstart + 16;\n        pcx_palette(&palette, (uint32_t *)p->data[1], 16);\n    *got_frame = 1;\n    ret = buf - bufstart;\nend:\n    av_free(scanline);\n    return ret;", "idx": 7670}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void dump_ppc_insns (CPUPPCState *env)\n\n{\n\n    opc_handler_t **table, *handler;\n\n    const char *p, *q;\n\n    uint8_t opc1, opc2, opc3;\n\n\n\n    printf(\"Instructions set:\\n\");\n\n    /* opc1 is 6 bits long */\n\n    for (opc1 = 0x00; opc1 < PPC_CPU_OPCODES_LEN; opc1++) {\n\n        table = env->opcodes;\n\n        handler = table[opc1];\n\n        if (is_indirect_opcode(handler)) {\n\n            /* opc2 is 5 bits long */\n\n            for (opc2 = 0; opc2 < PPC_CPU_INDIRECT_OPCODES_LEN; opc2++) {\n\n                table = env->opcodes;\n\n                handler = env->opcodes[opc1];\n\n                table = ind_table(handler);\n\n                handler = table[opc2];\n\n                if (is_indirect_opcode(handler)) {\n\n                    table = ind_table(handler);\n\n                    /* opc3 is 5 bits long */\n\n                    for (opc3 = 0; opc3 < PPC_CPU_INDIRECT_OPCODES_LEN;\n\n                            opc3++) {\n\n                        handler = table[opc3];\n\n                        if (handler->handler != &gen_invalid) {\n\n                            /* Special hack to properly dump SPE insns */\n\n                            p = strchr(handler->oname, '_');\n\n                            if (p == NULL) {\n\n                                printf(\"INSN: %02x %02x %02x (%02d %04d) : \"\n\n                                       \"%s\\n\",\n\n                                       opc1, opc2, opc3, opc1,\n\n                                       (opc3 << 5) | opc2,\n\n                                       handler->oname);\n\n                            } else {\n\n                                q = \"speundef\";\n\n                                if ((p - handler->oname) != strlen(q) ||\n\n                                    memcmp(handler->oname, q, strlen(q)) != 0) {\n\n                                    /* First instruction */\n\n                                    printf(\"INSN: %02x %02x %02x (%02d %04d) : \"\n\n                                           \"%.*s\\n\",\n\n                                           opc1, opc2 << 1, opc3, opc1,\n\n                                           (opc3 << 6) | (opc2 << 1),\n\n                                           (int)(p - handler->oname),\n\n                                           handler->oname);\n\n                                }\n\n                                if (strcmp(p + 1, q) != 0) {\n\n                                    /* Second instruction */\n\n                                    printf(\"INSN: %02x %02x %02x (%02d %04d) : \"\n\n                                           \"%s\\n\",\n\n                                           opc1, (opc2 << 1) | 1, opc3, opc1,\n\n                                           (opc3 << 6) | (opc2 << 1) | 1,\n\n                                           p + 1);\n\n                                }\n\n                            }\n\n                        }\n\n                    }\n\n                } else {\n\n                    if (handler->handler != &gen_invalid) {\n\n                        printf(\"INSN: %02x %02x -- (%02d %04d) : %s\\n\",\n\n                               opc1, opc2, opc1, opc2, handler->oname);\n\n                    }\n\n                }\n\n            }\n\n        } else {\n\n            if (handler->handler != &gen_invalid) {\n\n                printf(\"INSN: %02x -- -- (%02d ----) : %s\\n\",\n\n                       opc1, opc1, handler->oname);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 7882}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int minimum_frame_bits(VC2EncContext *s)\n\n{\n\n    int slice_x, slice_y, bits = 0;\n\n    s->size_scaler = 64;\n\n    for (slice_y = 0; slice_y < s->num_y; slice_y++) {\n\n        for (slice_x = 0; slice_x < s->num_x; slice_x++) {\n\n            bits += count_hq_slice(s, NULL, slice_x, slice_y, s->q_ceil);\n\n        }\n\n    }\n\n    return bits;\n\n}\n", "idx": 7892}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void fd_coroutine_enter(void *opaque)\n\n{\n\n    FDYieldUntilData *data = opaque;\n\n    qemu_set_fd_handler(data->fd, NULL, NULL, NULL);\n\n    qemu_coroutine_enter(data->co, NULL);\n\n}\n", "idx": 7893}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int get_cpsr(QEMUFile *f, void *opaque, size_t size)\n\n{\n\n    ARMCPU *cpu = opaque;\n\n    CPUARMState *env = &cpu->env;\n\n    uint32_t val = qemu_get_be32(f);\n\n\n\n    env->aarch64 = ((val & PSTATE_nRW) == 0);\n\n\n\n    if (is_a64(env)) {\n\n        pstate_write(env, val);\n\n        return 0;\n\n    }\n\n\n\n    /* Avoid mode switch when restoring CPSR */\n\n    env->uncached_cpsr = val & CPSR_M;\n\n    cpsr_write(env, val, 0xffffffff, CPSRWriteRaw);\n\n    return 0;\n\n}\n", "idx": 7982}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int read_directory(BDRVVVFATState* s, int mapping_index)\n\n{\n\n    mapping_t* mapping = array_get(&(s->mapping), mapping_index);\n\n    direntry_t* direntry;\n\n    const char* dirname = mapping->path;\n\n    int first_cluster = mapping->begin;\n\n    int parent_index = mapping->info.dir.parent_mapping_index;\n\n    mapping_t* parent_mapping = (mapping_t*)\n\n        (parent_index >= 0 ? array_get(&(s->mapping), parent_index) : NULL);\n\n    int first_cluster_of_parent = parent_mapping ? parent_mapping->begin : -1;\n\n\n\n    DIR* dir=opendir(dirname);\n\n    struct dirent* entry;\n\n    int i;\n\n\n\n    assert(mapping->mode & MODE_DIRECTORY);\n\n\n\n    if(!dir) {\n\n        mapping->end = mapping->begin;\n\n        return -1;\n\n    }\n\n\n\n    i = mapping->info.dir.first_dir_index =\n\n            first_cluster == 0 ? 0 : s->directory.next;\n\n\n\n    if (first_cluster != 0) {\n\n        /* create the top entries of a subdirectory */\n\n        (void)create_short_and_long_name(s, i, \".\", 1);\n\n        (void)create_short_and_long_name(s, i, \"..\", 1);\n\n    }\n\n\n\n    /* actually read the directory, and allocate the mappings */\n\n    while((entry=readdir(dir))) {\n\n        unsigned int length=strlen(dirname)+2+strlen(entry->d_name);\n\n        char* buffer;\n\n        direntry_t* direntry;\n\n        struct stat st;\n\n        int is_dot=!strcmp(entry->d_name,\".\");\n\n        int is_dotdot=!strcmp(entry->d_name,\"..\");\n\n\n\n        if(first_cluster == 0 && (is_dotdot || is_dot))\n\n            continue;\n\n\n\n        buffer = g_malloc(length);\n\n        snprintf(buffer,length,\"%s/%s\",dirname,entry->d_name);\n\n\n\n        if(stat(buffer,&st)<0) {\n\n            g_free(buffer);\n\n            continue;\n\n        }\n\n\n\n        /* create directory entry for this file */\n\n        if (!is_dot && !is_dotdot) {\n\n            direntry = create_short_and_long_name(s, i, entry->d_name, 0);\n\n        } else {\n\n            direntry = array_get(&(s->directory), is_dot ? i : i + 1);\n\n        }\n\n        direntry->attributes=(S_ISDIR(st.st_mode)?0x10:0x20);\n\n        direntry->reserved[0]=direntry->reserved[1]=0;\n\n        direntry->ctime=fat_datetime(st.st_ctime,1);\n\n        direntry->cdate=fat_datetime(st.st_ctime,0);\n\n        direntry->adate=fat_datetime(st.st_atime,0);\n\n        direntry->begin_hi=0;\n\n        direntry->mtime=fat_datetime(st.st_mtime,1);\n\n        direntry->mdate=fat_datetime(st.st_mtime,0);\n\n        if(is_dotdot)\n\n            set_begin_of_direntry(direntry, first_cluster_of_parent);\n\n        else if(is_dot)\n\n            set_begin_of_direntry(direntry, first_cluster);\n\n        else\n\n            direntry->begin=0; /* do that later */\n\n        if (st.st_size > 0x7fffffff) {\n\n            fprintf(stderr, \"File %s is larger than 2GB\\n\", buffer);\n\n            g_free(buffer);\n\n            closedir(dir);\n\n            return -2;\n\n        }\n\n        direntry->size=cpu_to_le32(S_ISDIR(st.st_mode)?0:st.st_size);\n\n\n\n        /* create mapping for this file */\n\n        if(!is_dot && !is_dotdot && (S_ISDIR(st.st_mode) || st.st_size)) {\n\n            s->current_mapping = array_get_next(&(s->mapping));\n\n            s->current_mapping->begin=0;\n\n            s->current_mapping->end=st.st_size;\n\n            /*\n\n             * we get the direntry of the most recent direntry, which\n\n             * contains the short name and all the relevant information.\n\n             */\n\n            s->current_mapping->dir_index=s->directory.next-1;\n\n            s->current_mapping->first_mapping_index = -1;\n\n            if (S_ISDIR(st.st_mode)) {\n\n                s->current_mapping->mode = MODE_DIRECTORY;\n\n                s->current_mapping->info.dir.parent_mapping_index =\n\n                    mapping_index;\n\n            } else {\n\n                s->current_mapping->mode = MODE_UNDEFINED;\n\n                s->current_mapping->info.file.offset = 0;\n\n            }\n\n            s->current_mapping->path=buffer;\n\n            s->current_mapping->read_only =\n\n                (st.st_mode & (S_IWUSR | S_IWGRP | S_IWOTH)) == 0;\n\n        } else {\n\n            g_free(buffer);\n\n        }\n\n    }\n\n    closedir(dir);\n\n\n\n    /* fill with zeroes up to the end of the cluster */\n\n    while(s->directory.next%(0x10*s->sectors_per_cluster)) {\n\n        direntry_t* direntry=array_get_next(&(s->directory));\n\n        memset(direntry,0,sizeof(direntry_t));\n\n    }\n\n\n\n/* TODO: if there are more entries, bootsector has to be adjusted! */\n\n#define ROOT_ENTRIES (0x02 * 0x10 * s->sectors_per_cluster)\n\n    if (mapping_index == 0 && s->directory.next < ROOT_ENTRIES) {\n\n        /* root directory */\n\n        int cur = s->directory.next;\n\n        array_ensure_allocated(&(s->directory), ROOT_ENTRIES - 1);\n\n        s->directory.next = ROOT_ENTRIES;\n\n        memset(array_get(&(s->directory), cur), 0,\n\n                (ROOT_ENTRIES - cur) * sizeof(direntry_t));\n\n    }\n\n\n\n    /* re-get the mapping, since s->mapping was possibly realloc()ed */\n\n    mapping = array_get(&(s->mapping), mapping_index);\n\n    first_cluster += (s->directory.next - mapping->info.dir.first_dir_index)\n\n        * 0x20 / s->cluster_size;\n\n    mapping->end = first_cluster;\n\n\n\n    direntry = array_get(&(s->directory), mapping->dir_index);\n\n    set_begin_of_direntry(direntry, mapping->begin);\n\n\n\n    return 0;\n\n}\n", "idx": 8021}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void diff_pixels_altivec(int16_t *restrict block, const uint8_t *s1,\n\n                                const uint8_t *s2, int stride)\n\n{\n\n    int i;\n\n    vec_u8 perm1 = vec_lvsl(0, s1);\n\n    vec_u8 perm2 = vec_lvsl(0, s2);\n\n    const vec_u8 zero = (const vec_u8)vec_splat_u8(0);\n\n    vec_s16 shorts1, shorts2;\n\n\n\n    for (i = 0; i < 4; i++) {\n\n        /* Read potentially unaligned pixels.\n\n         * We're reading 16 pixels, and actually only want 8,\n\n         * but we simply ignore the extras. */\n\n        vec_u8 pixl  = vec_ld(0,  s1);\n\n        vec_u8 pixr  = vec_ld(15, s1);\n\n        vec_u8 bytes = vec_perm(pixl, pixr, perm1);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts1 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the same for the second block of pixels.\n\n        pixl  = vec_ld(0,  s2);\n\n        pixr  = vec_ld(15, s2);\n\n        bytes = vec_perm(pixl, pixr, perm2);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts2 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the subtraction.\n\n        shorts1 = vec_sub(shorts1, shorts2);\n\n\n\n        // Save the data to the block, we assume the block is 16-byte aligned.\n\n        vec_st(shorts1, 0, (vec_s16 *)block);\n\n\n\n        s1    += stride;\n\n        s2    += stride;\n\n        block += 8;\n\n\n\n        /* The code below is a copy of the code above...\n\n         * This is a manual unroll. */\n\n\n\n        /* Read potentially unaligned pixels.\n\n         * We're reading 16 pixels, and actually only want 8,\n\n         * but we simply ignore the extras. */\n\n        pixl  = vec_ld(0,  s1);\n\n        pixr  = vec_ld(15, s1);\n\n        bytes = vec_perm(pixl, pixr, perm1);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts1 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the same for the second block of pixels.\n\n        pixl  = vec_ld(0,  s2);\n\n        pixr  = vec_ld(15, s2);\n\n        bytes = vec_perm(pixl, pixr, perm2);\n\n\n\n        // Convert the bytes into shorts.\n\n        shorts2 = (vec_s16)vec_mergeh(zero, bytes);\n\n\n\n        // Do the subtraction.\n\n        shorts1 = vec_sub(shorts1, shorts2);\n\n\n\n        // Save the data to the block, we assume the block is 16-byte aligned.\n\n        vec_st(shorts1, 0, (vec_s16 *)block);\n\n\n\n        s1    += stride;\n\n        s2    += stride;\n\n        block += 8;\n\n    }\n\n}\n", "idx": 8103}, {"project": "test", "commit_id": "test", "target": 1, "func": "int ff_thread_get_buffer(AVCodecContext *avctx, AVFrame *f)\n\n{\n\n    PerThreadContext *p = avctx->thread_opaque;\n\n    int *progress, err;\n\n\n\n    f->owner = avctx;\n\n\n\n    ff_init_buffer_info(avctx, f);\n\n\n\n    if (!(avctx->active_thread_type&FF_THREAD_FRAME)) {\n\n        f->thread_opaque = NULL;\n\n        return avctx->get_buffer(avctx, f);\n\n    }\n\n\n\n    if (p->state != STATE_SETTING_UP &&\n\n        (avctx->codec->update_thread_context || (!avctx->thread_safe_callbacks &&\n\n                avctx->get_buffer != avcodec_default_get_buffer))) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() cannot be called after ff_thread_finish_setup()\\n\");\n\n        return -1;\n\n    }\n\n\n\n    pthread_mutex_lock(&p->parent->buffer_mutex);\n\n    f->thread_opaque = progress = allocate_progress(p);\n\n\n\n    if (!progress) {\n\n        pthread_mutex_unlock(&p->parent->buffer_mutex);\n\n        return -1;\n\n    }\n\n\n\n    progress[0] =\n\n    progress[1] = -1;\n\n\n\n    if (avctx->thread_safe_callbacks ||\n\n        avctx->get_buffer == avcodec_default_get_buffer) {\n\n        err = avctx->get_buffer(avctx, f);\n\n    } else {\n\n        p->requested_frame = f;\n\n        p->state = STATE_GET_BUFFER;\n\n        pthread_mutex_lock(&p->progress_mutex);\n\n        pthread_cond_signal(&p->progress_cond);\n\n\n\n        while (p->state != STATE_SETTING_UP)\n\n            pthread_cond_wait(&p->progress_cond, &p->progress_mutex);\n\n\n\n        err = p->result;\n\n\n\n        pthread_mutex_unlock(&p->progress_mutex);\n\n\n\n        if (!avctx->codec->update_thread_context)\n\n            ff_thread_finish_setup(avctx);\n\n    }\n\n\n\n    pthread_mutex_unlock(&p->parent->buffer_mutex);\n\n\n\n    return err;\n\n}\n", "idx": 8105}, {"project": "test", "commit_id": "test", "target": 1, "func": "bool qio_task_propagate_error(QIOTask *task,\n\n                              Error **errp)\n\n{\n\n    if (task->err) {\n\n        error_propagate(errp, task->err);\n\n\n        return true;\n\n    }\n\n\n\n    return false;\n\n}", "idx": 8111}, {"project": "test", "commit_id": "test", "target": 1, "func": "yuv2ya8_2_c(SwsContext *c, const int16_t *buf[2],\n\n            const int16_t *ubuf[2], const int16_t *vbuf[2],\n\n            const int16_t *abuf[2], uint8_t *dest, int dstW,\n\n            int yalpha, int uvalpha, int y)\n\n{\n\n    int hasAlpha = abuf[0] && abuf[1];\n\n    const int16_t *buf0  = buf[0],  *buf1  = buf[1],\n\n                  *abuf0 = hasAlpha ? abuf[0] : NULL,\n\n                  *abuf1 = hasAlpha ? abuf[1] : NULL;\n\n    int  yalpha1 = 4096 - yalpha;\n\n    int i;\n\n\n\n    for (i = 0; i < dstW; i++) {\n\n        int Y = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19;\n\n        int A;\n\n\n\n        Y = av_clip_uint8(Y);\n\n\n\n        if (hasAlpha) {\n\n            A = (abuf0[i * 2] * yalpha1 + abuf1[i * 2] * yalpha) >> 19;\n\n            A = av_clip_uint8(A);\n\n        }\n\n\n\n        dest[i * 2    ] = Y;\n\n        dest[i * 2 + 1] = hasAlpha ? A : 255;\n\n    }\n\n}\n", "idx": 8124}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void device_unparent(Object *obj)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    BusState *bus;\n\n\n\n    if (dev->realized) {\n\n        object_property_set_bool(obj, false, \"realized\", NULL);\n\n    }\n\n    while (dev->num_child_bus) {\n\n        bus = QLIST_FIRST(&dev->child_bus);\n\n        object_unparent(OBJECT(bus));\n\n    }\n\n    if (dev->parent_bus) {\n\n        bus_remove_child(dev->parent_bus, dev);\n\n        object_unref(OBJECT(dev->parent_bus));\n\n        dev->parent_bus = NULL;\n\n    }\n\n\n\n    /* Only send event if the device had been completely realized */\n\n    if (dev->pending_deleted_event) {\n\n        g_assert(dev->canonical_path);\n\n\n\n        qapi_event_send_device_deleted(!!dev->id, dev->id, dev->canonical_path,\n\n                                       &error_abort);\n\n        g_free(dev->canonical_path);\n\n        dev->canonical_path = NULL;\n\n    }\n\n}\n", "idx": 8130}, {"project": "test", "commit_id": "test", "target": 1, "func": "void tap_fd_set_offload(int fd, int csum, int tso4,\n                        int tso6, int ecn, int ufo)\n{\n    unsigned int offload = 0;\n    if (csum) {\n        offload |= TUN_F_CSUM;\n        if (tso4)\n            offload |= TUN_F_TSO4;\n        if (tso6)\n            offload |= TUN_F_TSO6;\n        if ((tso4 || tso6) && ecn)\n            offload |= TUN_F_TSO_ECN;\n        if (ufo)\n            offload |= TUN_F_UFO;\n    if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {\n        offload &= ~TUN_F_UFO;\n        if (ioctl(fd, TUNSETOFFLOAD, offload) != 0) {\n            fprintf(stderr, \"TUNSETOFFLOAD ioctl() failed: %s\\n\",\n                    strerror(errno));", "idx": 8158}, {"project": "test", "commit_id": "test", "target": 1, "func": "void vp8_decode_mvs(VP8Context *s, VP8Macroblock *mb,\n\n                    int mb_x, int mb_y, int layout)\n\n{\n\n    VP8Macroblock *mb_edge[3] = { 0      /* top */,\n\n                                  mb - 1 /* left */,\n\n                                  0      /* top-left */ };\n\n    enum { CNT_ZERO, CNT_NEAREST, CNT_NEAR, CNT_SPLITMV };\n\n    enum { VP8_EDGE_TOP, VP8_EDGE_LEFT, VP8_EDGE_TOPLEFT };\n\n    int idx = CNT_ZERO;\n\n    int cur_sign_bias = s->sign_bias[mb->ref_frame];\n\n    int8_t *sign_bias = s->sign_bias;\n\n    VP56mv near_mv[4];\n\n    uint8_t cnt[4] = { 0 };\n\n    VP56RangeCoder *c = &s->c;\n\n\n\n    if (!layout) { // layout is inlined (s->mb_layout is not)\n\n        mb_edge[0] = mb + 2;\n\n        mb_edge[2] = mb + 1;\n\n    } else {\n\n        mb_edge[0] = mb - s->mb_width - 1;\n\n        mb_edge[2] = mb - s->mb_width - 2;\n\n    }\n\n\n\n    AV_ZERO32(&near_mv[0]);\n\n    AV_ZERO32(&near_mv[1]);\n\n    AV_ZERO32(&near_mv[2]);\n\n\n\n    /* Process MB on top, left and top-left */\n\n#define MV_EDGE_CHECK(n)                                                      \\\n\n    {                                                                         \\\n\n        VP8Macroblock *edge = mb_edge[n];                                     \\\n\n        int edge_ref = edge->ref_frame;                                       \\\n\n        if (edge_ref != VP56_FRAME_CURRENT) {                                 \\\n\n            uint32_t mv = AV_RN32A(&edge->mv);                                \\\n\n            if (mv) {                                                         \\\n\n                if (cur_sign_bias != sign_bias[edge_ref]) {                   \\\n\n                    /* SWAR negate of the values in mv. */                    \\\n\n                    mv = ~mv;                                                 \\\n\n                    mv = ((mv & 0x7fff7fff) +                                 \\\n\n                          0x00010001) ^ (mv & 0x80008000);                    \\\n\n                }                                                             \\\n\n                if (!n || mv != AV_RN32A(&near_mv[idx]))                      \\\n\n                    AV_WN32A(&near_mv[++idx], mv);                            \\\n\n                cnt[idx] += 1 + (n != 2);                                     \\\n\n            } else                                                            \\\n\n                cnt[CNT_ZERO] += 1 + (n != 2);                                \\\n\n        }                                                                     \\\n\n    }\n\n\n\n    MV_EDGE_CHECK(0)\n\n    MV_EDGE_CHECK(1)\n\n    MV_EDGE_CHECK(2)\n\n\n\n    mb->partitioning = VP8_SPLITMVMODE_NONE;\n\n    if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_ZERO]][0])) {\n\n        mb->mode = VP8_MVMODE_MV;\n\n\n\n        /* If we have three distinct MVs, merge first and last if they're the same */\n\n        if (cnt[CNT_SPLITMV] &&\n\n            AV_RN32A(&near_mv[1 + VP8_EDGE_TOP]) == AV_RN32A(&near_mv[1 + VP8_EDGE_TOPLEFT]))\n\n            cnt[CNT_NEAREST] += 1;\n\n\n\n        /* Swap near and nearest if necessary */\n\n        if (cnt[CNT_NEAR] > cnt[CNT_NEAREST]) {\n\n            FFSWAP(uint8_t,     cnt[CNT_NEAREST],     cnt[CNT_NEAR]);\n\n            FFSWAP( VP56mv, near_mv[CNT_NEAREST], near_mv[CNT_NEAR]);\n\n        }\n\n\n\n        if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAREST]][1])) {\n\n            if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_NEAR]][2])) {\n\n                /* Choose the best mv out of 0,0 and the nearest mv */\n\n                clamp_mv(s, &mb->mv, &near_mv[CNT_ZERO + (cnt[CNT_NEAREST] >= cnt[CNT_ZERO])]);\n\n                cnt[CNT_SPLITMV] = ((mb_edge[VP8_EDGE_LEFT]->mode    == VP8_MVMODE_SPLIT) +\n\n                                    (mb_edge[VP8_EDGE_TOP]->mode     == VP8_MVMODE_SPLIT)) * 2 +\n\n                                    (mb_edge[VP8_EDGE_TOPLEFT]->mode == VP8_MVMODE_SPLIT);\n\n\n\n                if (vp56_rac_get_prob_branchy(c, vp8_mode_contexts[cnt[CNT_SPLITMV]][3])) {\n\n                    mb->mode = VP8_MVMODE_SPLIT;\n\n                    mb->mv = mb->bmv[decode_splitmvs(s, c, mb, layout, IS_VP8) - 1];\n\n                } else {\n\n                    mb->mv.y  += vp8_read_mv_component(c, s->prob->mvc[0]);\n\n                    mb->mv.x  += vp8_read_mv_component(c, s->prob->mvc[1]);\n\n                    mb->bmv[0] = mb->mv;\n\n                }\n\n            } else {\n\n                clamp_mv(s, &mb->mv, &near_mv[CNT_NEAR]);\n\n                mb->bmv[0] = mb->mv;\n\n            }\n\n        } else {\n\n            clamp_mv(s, &mb->mv, &near_mv[CNT_NEAREST]);\n\n            mb->bmv[0] = mb->mv;\n\n        }\n\n    } else {\n\n        mb->mode = VP8_MVMODE_ZERO;\n\n        AV_ZERO32(&mb->mv);\n\n        mb->bmv[0] = mb->mv;\n\n    }\n\n}\n", "idx": 8208}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void put_uint8(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint8_t *v = pv;\n\n    qemu_put_8s(f, v);\n\n}\n", "idx": 8431}, {"project": "test", "commit_id": "test", "target": 1, "func": "static AddrRange addrrange_intersection(AddrRange r1, AddrRange r2)\n\n{\n\n    uint64_t start = MAX(r1.start, r2.start);\n\n    /* off-by-one arithmetic to prevent overflow */\n\n    uint64_t end = MIN(addrrange_end(r1) - 1, addrrange_end(r2) - 1);\n\n    return addrrange_make(start, end - start + 1);\n\n}\n", "idx": 8592}, {"project": "test", "commit_id": "test", "target": 1, "func": "static uint32_t dcr_read_pob (void *opaque, int dcrn)\n\n{\n\n    ppc4xx_pob_t *pob;\n\n    uint32_t ret;\n\n\n\n    pob = opaque;\n\n    switch (dcrn) {\n\n    case POB0_BEAR:\n\n        ret = pob->bear;\n\n        break;\n\n    case POB0_BESR0:\n\n    case POB0_BESR1:\n\n        ret = pob->besr[dcrn - POB0_BESR0];\n\n        break;\n\n    default:\n\n        /* Avoid gcc warning */\n\n        ret = 0;\n\n        break;\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 8720}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int default_lockmgr_cb(void **arg, enum AVLockOp op)\n\n{\n\n    void * volatile * mutex = arg;\n\n    int err;\n\n\n\n    switch (op) {\n\n    case AV_LOCK_CREATE:\n\n        return 0;\n\n    case AV_LOCK_OBTAIN:\n\n        if (!*mutex) {\n\n            pthread_mutex_t *tmp = av_malloc(sizeof(pthread_mutex_t));\n\n            if (!tmp)\n\n                return AVERROR(ENOMEM);\n\n            if ((err = pthread_mutex_init(tmp, NULL))) {\n\n                av_free(tmp);\n\n                return AVERROR(err);\n\n            }\n\n            if (avpriv_atomic_ptr_cas(mutex, NULL, tmp)) {\n\n                pthread_mutex_destroy(tmp);\n\n                av_free(tmp);\n\n            }\n\n        }\n\n\n\n        if ((err = pthread_mutex_lock(*mutex)))\n\n            return AVERROR(err);\n\n\n\n        return 0;\n\n    case AV_LOCK_RELEASE:\n\n        if ((err = pthread_mutex_unlock(*mutex)))\n\n            return AVERROR(err);\n\n\n\n        return 0;\n\n    case AV_LOCK_DESTROY:\n\n        if (*mutex)\n\n            pthread_mutex_destroy(*mutex);\n\n        av_free(*mutex);\n\n        avpriv_atomic_ptr_cas(mutex, *mutex, NULL);\n\n        return 0;\n\n    }\n\n    return 1;\n\n}\n", "idx": 8794}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int rle_unpack(const unsigned char *src, int src_len, int src_count,\n\n                      unsigned char *dest, int dest_len)\n\n{\n\n    const unsigned char *ps;\n\n    const unsigned char *ps_end;\n\n    unsigned char *pd;\n\n    int i, l;\n\n    unsigned char *dest_end = dest + dest_len;\n\n\n\n    ps = src;\n\n    ps_end = src + src_len;\n\n    pd = dest;\n\n    if (src_count & 1) {\n\n        if (ps_end - ps < 1)\n\n            return 0;\n\n        *pd++ = *ps++;\n\n    }\n\n\n\n    src_count >>= 1;\n\n    i = 0;\n\n    do {\n\n        if (ps_end - ps < 1)\n\n            break;\n\n        l = *ps++;\n\n        if (l & 0x80) {\n\n            l = (l & 0x7F) * 2;\n\n            if (pd + l > dest_end || ps_end - ps < l)\n\n                return ps - src;\n\n            memcpy(pd, ps, l);\n\n            ps += l;\n\n            pd += l;\n\n        } else {\n\n            if (pd + i > dest_end || ps_end - ps < 2)\n\n                return ps - src;\n\n            for (i = 0; i < l; i++) {\n\n                *pd++ = ps[0];\n\n                *pd++ = ps[1];\n\n            }\n\n            ps += 2;\n\n        }\n\n        i += l;\n\n    } while (i < src_count);\n\n\n\n    return ps - src;\n\n}\n", "idx": 8900}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int s390_virtio_rng_init(VirtIOS390Device *s390_dev)\n\n{\n\n    VirtIORNGS390 *dev = VIRTIO_RNG_S390(s390_dev);\n\n    DeviceState *vdev = DEVICE(&dev->vdev);\n\n\n\n    qdev_set_parent_bus(vdev, BUS(&s390_dev->bus));\n\n    if (qdev_init(vdev) < 0) {\n\n        return -1;\n\n    }\n\n\n\n    object_property_set_link(OBJECT(dev),\n\n                             OBJECT(dev->vdev.conf.default_backend), \"rng\",\n\n                             NULL);\n\n\n\n    return s390_virtio_device_init(s390_dev, VIRTIO_DEVICE(vdev));\n\n}\n", "idx": 8903}, {"project": "test", "commit_id": "test", "target": 1, "func": "static ExitStatus trans_log(DisasContext *ctx, uint32_t insn,\n\n                            const DisasInsn *di)\n\n{\n\n    unsigned r2 = extract32(insn, 21, 5);\n\n    unsigned r1 = extract32(insn, 16, 5);\n\n    unsigned cf = extract32(insn, 12, 4);\n\n    unsigned rt = extract32(insn,  0, 5);\n\n    TCGv tcg_r1, tcg_r2;\n\n    ExitStatus ret;\n\n\n\n    if (cf) {\n\n        nullify_over(ctx);\n\n    }\n\n    tcg_r1 = load_gpr(ctx, r1);\n\n    tcg_r2 = load_gpr(ctx, r2);\n\n    ret = do_log(ctx, rt, tcg_r1, tcg_r2, cf, di->f_ttt);\n\n    return nullify_end(ctx, ret);\n\n}\n", "idx": 9091}, {"project": "test", "commit_id": "test", "target": 1, "func": "VIOsPAPRDevice *vty_lookup(sPAPRMachineState *spapr, target_ulong reg)\n{\n    VIOsPAPRDevice *sdev;\n    sdev = spapr_vio_find_by_reg(spapr->vio_bus, reg);\n    if (!sdev && reg == 0) {\n        /* Hack for kernel early debug, which always specifies reg==0.\n         * We search all VIO devices, and grab the vty with the lowest\n         * reg.  This attempts to mimic existing PowerVM behaviour\n         * (early debug does work there, despite having no vty with\n         * reg==0. */\n        return spapr_vty_get_default(spapr->vio_bus);\n    return sdev;", "idx": 9172}, {"project": "test", "commit_id": "test", "target": 1, "func": "int avpriv_dca_convert_bitstream(const uint8_t *src, int src_size, uint8_t *dst,\n\n                             int max_size)\n\n{\n\n    uint32_t mrk;\n\n    int i, tmp;\n\n    const uint16_t *ssrc = (const uint16_t *) src;\n\n    uint16_t *sdst = (uint16_t *) dst;\n\n    PutBitContext pb;\n\n\n\n    if ((unsigned) src_size > (unsigned) max_size)\n\n        src_size = max_size;\n\n\n\n    mrk = AV_RB32(src);\n\n    switch (mrk) {\n\n    case DCA_SYNCWORD_CORE_BE:\n\n        memcpy(dst, src, src_size);\n\n        return src_size;\n\n    case DCA_SYNCWORD_CORE_LE:\n\n        for (i = 0; i < (src_size + 1) >> 1; i++)\n\n            *sdst++ = av_bswap16(*ssrc++);\n\n        return src_size;\n\n    case DCA_SYNCWORD_CORE_14B_BE:\n\n    case DCA_SYNCWORD_CORE_14B_LE:\n\n        init_put_bits(&pb, dst, max_size);\n\n        for (i = 0; i < (src_size + 1) >> 1; i++, src += 2) {\n\n            tmp = ((mrk == DCA_SYNCWORD_CORE_14B_BE) ? AV_RB16(src) : AV_RL16(src)) & 0x3FFF;\n\n            put_bits(&pb, 14, tmp);\n\n        }\n\n        flush_put_bits(&pb);\n\n        return (put_bits_count(&pb) + 7) >> 3;\n\n    default:\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n}\n", "idx": 9178}, {"project": "test", "commit_id": "test", "target": 1, "func": "static TRBCCode xhci_disable_ep(XHCIState *xhci, unsigned int slotid,\n                               unsigned int epid)\n{\n    XHCISlot *slot;\n    XHCIEPContext *epctx;\n    int i;\n    trace_usb_xhci_ep_disable(slotid, epid);\n    assert(slotid >= 1 && slotid <= xhci->numslots);\n    assert(epid >= 1 && epid <= 31);\n    slot = &xhci->slots[slotid-1];\n    if (!slot->eps[epid-1]) {\n        DPRINTF(\"xhci: slot %d ep %d already disabled\\n\", slotid, epid);\n        return CC_SUCCESS;\n    xhci_ep_nuke_xfers(xhci, slotid, epid);\n    epctx = slot->eps[epid-1];\n    if (epctx->nr_pstreams) {\n        xhci_free_streams(epctx);\n    xhci_set_ep_state(xhci, epctx, NULL, EP_DISABLED);\n    timer_free(epctx->kick_timer);\n    g_free(epctx);\n    slot->eps[epid-1] = NULL;\n    return CC_SUCCESS;", "idx": 9189}, {"project": "test", "commit_id": "test", "target": 1, "func": "int pvpanic_init(ISABus *bus)\n\n{\n\n    isa_create_simple(bus, TYPE_ISA_PVPANIC_DEVICE);\n\n    return 0;\n\n}\n", "idx": 9193}, {"project": "test", "commit_id": "test", "target": 1, "func": "void object_property_allow_set_link(Object *obj, const char *name,\n\n                                    Object *val, Error **errp)\n\n{\n\n    /* Allow the link to be set, always */\n\n}\n", "idx": 9231}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void picmemset(PicContext *s, AVFrame *frame, unsigned value, int run,\n\n                      int *x, int *y, int *plane, int bits_per_plane)\n\n{\n\n    uint8_t *d;\n\n    int shift = *plane * bits_per_plane;\n\n    unsigned mask  = ((1 << bits_per_plane) - 1) << shift;\n\n    value   <<= shift;\n\n\n\n    while (run > 0) {\n\n        int j;\n\n        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {\n\n            d = frame->data[0] + *y * frame->linesize[0];\n\n            d[*x] |= (value >> j) & mask;\n\n            *x += 1;\n\n            if (*x == s->width) {\n\n                *y -= 1;\n\n                *x = 0;\n\n                if (*y < 0) {\n\n                   *y = s->height - 1;\n\n                   *plane += 1;\n\n                   if (*plane >= s->nb_planes)\n\n                       return;\n\n                   value <<= bits_per_plane;\n\n                   mask  <<= bits_per_plane;\n\n                }\n\n            }\n\n        }\n\n        run--;\n\n    }\n\n}\n", "idx": 9347}, {"project": "test", "commit_id": "test", "target": 1, "func": "mp_image_t* vf_get_image(vf_instance_t* vf, unsigned int outfmt, int mp_imgtype, int mp_imgflag, int w, int h){\n\n    MPContext *m= (MPContext*)(((uint8_t*)vf) - offsetof(MPContext, next_vf));\n\n  mp_image_t* mpi=NULL;\n\n  int w2;\n\n  int number = mp_imgtype >> 16;\n\n\n\n  av_assert0(vf->next == NULL); // all existing filters call this just on next\n\n\n\n  //vf_dint needs these as it calls vf_get_image() before configuring the output\n\n  if(vf->w==0 && w>0) vf->w=w;\n\n  if(vf->h==0 && h>0) vf->h=h;\n\n\n\n  av_assert0(w == -1 || w >= vf->w);\n\n  av_assert0(h == -1 || h >= vf->h);\n\n  av_assert0(vf->w > 0);\n\n  av_assert0(vf->h > 0);\n\n\n\n  av_log(m->avfctx, AV_LOG_DEBUG, \"get_image: %d:%d, vf: %d:%d\\n\", w,h,vf->w,vf->h);\n\n\n\n  if (w == -1) w = vf->w;\n\n  if (h == -1) h = vf->h;\n\n\n\n  w2=(mp_imgflag&MP_IMGFLAG_ACCEPT_ALIGNED_STRIDE)?((w+15)&(~15)):w;\n\n\n\n  // Note: we should call libvo first to check if it supports direct rendering\n\n  // and if not, then fallback to software buffers:\n\n  switch(mp_imgtype & 0xff){\n\n  case MP_IMGTYPE_EXPORT:\n\n    if(!vf->imgctx.export_images[0]) vf->imgctx.export_images[0]=new_mp_image(w2,h);\n\n    mpi=vf->imgctx.export_images[0];\n\n    break;\n\n  case MP_IMGTYPE_STATIC:\n\n    if(!vf->imgctx.static_images[0]) vf->imgctx.static_images[0]=new_mp_image(w2,h);\n\n    mpi=vf->imgctx.static_images[0];\n\n    break;\n\n  case MP_IMGTYPE_TEMP:\n\n    if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,h);\n\n    mpi=vf->imgctx.temp_images[0];\n\n    break;\n\n  case MP_IMGTYPE_IPB:\n\n    if(!(mp_imgflag&MP_IMGFLAG_READABLE)){ // B frame:\n\n      if(!vf->imgctx.temp_images[0]) vf->imgctx.temp_images[0]=new_mp_image(w2,h);\n\n      mpi=vf->imgctx.temp_images[0];\n\n      break;\n\n    }\n\n  case MP_IMGTYPE_IP:\n\n    if(!vf->imgctx.static_images[vf->imgctx.static_idx]) vf->imgctx.static_images[vf->imgctx.static_idx]=new_mp_image(w2,h);\n\n    mpi=vf->imgctx.static_images[vf->imgctx.static_idx];\n\n    vf->imgctx.static_idx^=1;\n\n    break;\n\n  case MP_IMGTYPE_NUMBERED:\n\n    if (number == -1) {\n\n      int i;\n\n      for (i = 0; i < NUM_NUMBERED_MPI; i++)\n\n        if (!vf->imgctx.numbered_images[i] || !vf->imgctx.numbered_images[i]->usage_count)\n\n          break;\n\n      number = i;\n\n    }\n\n    if (number < 0 || number >= NUM_NUMBERED_MPI) return NULL;\n\n    if (!vf->imgctx.numbered_images[number]) vf->imgctx.numbered_images[number] = new_mp_image(w2,h);\n\n    mpi = vf->imgctx.numbered_images[number];\n\n    mpi->number = number;\n\n    break;\n\n  }\n\n  if(mpi){\n\n    mpi->type=mp_imgtype;\n\n    mpi->w=vf->w; mpi->h=vf->h;\n\n    // keep buffer allocation status & color flags only:\n\n//    mpi->flags&=~(MP_IMGFLAG_PRESERVE|MP_IMGFLAG_READABLE|MP_IMGFLAG_DIRECT);\n\n    mpi->flags&=MP_IMGFLAG_ALLOCATED|MP_IMGFLAG_TYPE_DISPLAYED|MP_IMGFLAGMASK_COLORS;\n\n    // accept restrictions, draw_slice and palette flags only:\n\n    mpi->flags|=mp_imgflag&(MP_IMGFLAGMASK_RESTRICTIONS|MP_IMGFLAG_DRAW_CALLBACK|MP_IMGFLAG_RGB_PALETTE);\n\n    if(!vf->draw_slice) mpi->flags&=~MP_IMGFLAG_DRAW_CALLBACK;\n\n    if(mpi->width!=w2 || mpi->height!=h){\n\n//      printf(\"vf.c: MPI parameters changed!  %dx%d -> %dx%d   \\n\", mpi->width,mpi->height,w2,h);\n\n        if(mpi->flags&MP_IMGFLAG_ALLOCATED){\n\n            if(mpi->width<w2 || mpi->height<h){\n\n                // need to re-allocate buffer memory:\n\n                av_free(mpi->planes[0]);\n\n                mpi->flags&=~MP_IMGFLAG_ALLOCATED;\n\n                mp_msg(MSGT_VFILTER,MSGL_V,\"vf.c: have to REALLOCATE buffer memory :(\\n\");\n\n            }\n\n//      } else {\n\n        } {\n\n            mpi->width=w2; mpi->chroma_width=(w2 + (1<<mpi->chroma_x_shift) - 1)>>mpi->chroma_x_shift;\n\n            mpi->height=h; mpi->chroma_height=(h + (1<<mpi->chroma_y_shift) - 1)>>mpi->chroma_y_shift;\n\n        }\n\n    }\n\n    if(!mpi->bpp) mp_image_setfmt(mpi,outfmt);\n\n    if(!(mpi->flags&MP_IMGFLAG_ALLOCATED) && mpi->type>MP_IMGTYPE_EXPORT){\n\n\n\n        av_assert0(!vf->get_image);\n\n        // check libvo first!\n\n        if(vf->get_image) vf->get_image(vf,mpi);\n\n\n\n        if(!(mpi->flags&MP_IMGFLAG_DIRECT)){\n\n          // non-direct and not yet allocated image. allocate it!\n\n          if (!mpi->bpp) { // no way we can allocate this\n\n              mp_msg(MSGT_DECVIDEO, MSGL_FATAL,\n\n                     \"vf_get_image: Tried to allocate a format that can not be allocated!\\n\");\n\n              return NULL;\n\n          }\n\n\n\n          // check if codec prefer aligned stride:\n\n          if(mp_imgflag&MP_IMGFLAG_PREFER_ALIGNED_STRIDE){\n\n              int align=(mpi->flags&MP_IMGFLAG_PLANAR &&\n\n                         mpi->flags&MP_IMGFLAG_YUV) ?\n\n                         (8<<mpi->chroma_x_shift)-1 : 15; // -- maybe FIXME\n\n              w2=((w+align)&(~align));\n\n              if(mpi->width!=w2){\n\n#if 0\n\n                  // we have to change width... check if we CAN co it:\n\n                  int flags=vf->query_format(vf,outfmt); // should not fail\n\n                  if(!(flags&3)) mp_msg(MSGT_DECVIDEO,MSGL_WARN,\"??? vf_get_image{vf->query_format(outfmt)} failed!\\n\");\n\n//                printf(\"query -> 0x%X    \\n\",flags);\n\n                  if(flags&VFCAP_ACCEPT_STRIDE){\n\n#endif\n\n                      mpi->width=w2;\n\n                      mpi->chroma_width=(w2 + (1<<mpi->chroma_x_shift) - 1)>>mpi->chroma_x_shift;\n\n//                  }\n\n              }\n\n          }\n\n\n\n          mp_image_alloc_planes(mpi);\n\n//        printf(\"clearing img!\\n\");\n\n          vf_mpi_clear(mpi,0,0,mpi->width,mpi->height);\n\n        }\n\n    }\n\n    av_assert0(!vf->start_slice);\n\n    if(mpi->flags&MP_IMGFLAG_DRAW_CALLBACK)\n\n        if(vf->start_slice) vf->start_slice(vf,mpi);\n\n    if(!(mpi->flags&MP_IMGFLAG_TYPE_DISPLAYED)){\n\n            mp_msg(MSGT_DECVIDEO,MSGL_V,\"*** [%s] %s%s mp_image_t, %dx%dx%dbpp %s %s, %d bytes\\n\",\n\n                  \"NULL\"/*vf->info->name*/,\n\n                  (mpi->type==MP_IMGTYPE_EXPORT)?\"Exporting\":\n\n                  ((mpi->flags&MP_IMGFLAG_DIRECT)?\"Direct Rendering\":\"Allocating\"),\n\n                  (mpi->flags&MP_IMGFLAG_DRAW_CALLBACK)?\" (slices)\":\"\",\n\n                  mpi->width,mpi->height,mpi->bpp,\n\n                  (mpi->flags&MP_IMGFLAG_YUV)?\"YUV\":((mpi->flags&MP_IMGFLAG_SWAPPED)?\"BGR\":\"RGB\"),\n\n                  (mpi->flags&MP_IMGFLAG_PLANAR)?\"planar\":\"packed\",\n\n                  mpi->bpp*mpi->width*mpi->height/8);\n\n            mp_msg(MSGT_DECVIDEO,MSGL_DBG2,\"(imgfmt: %x, planes: %p,%p,%p strides: %d,%d,%d, chroma: %dx%d, shift: h:%d,v:%d)\\n\",\n\n                mpi->imgfmt, mpi->planes[0], mpi->planes[1], mpi->planes[2],\n\n                mpi->stride[0], mpi->stride[1], mpi->stride[2],\n\n                mpi->chroma_width, mpi->chroma_height, mpi->chroma_x_shift, mpi->chroma_y_shift);\n\n            mpi->flags|=MP_IMGFLAG_TYPE_DISPLAYED;\n\n    }\n\n\n\n  mpi->qscale = NULL;\n\n  }\n\n  mpi->usage_count++;\n\n//    printf(\"\\rVF_MPI: %p %p %p %d %d %d    \\n\",\n\n//      mpi->planes[0],mpi->planes[1],mpi->planes[2],\n\n//      mpi->stride[0],mpi->stride[1],mpi->stride[2]);\n\n  return mpi;\n\n}\n", "idx": 9349}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int parse_MP4SLDescrTag(MP4DescrParseContext *d, int64_t off, int len)\n\n{\n\n    Mp4Descr *descr = d->active_descr;\n\n    int predefined;\n\n    if (!descr)\n\n        return -1;\n\n\n\n    predefined = avio_r8(&d->pb);\n\n    if (!predefined) {\n\n        int lengths;\n\n        int flags = avio_r8(&d->pb);\n\n        descr->sl.use_au_start       = !!(flags & 0x80);\n\n        descr->sl.use_au_end         = !!(flags & 0x40);\n\n        descr->sl.use_rand_acc_pt    = !!(flags & 0x20);\n\n        descr->sl.use_padding        = !!(flags & 0x08);\n\n        descr->sl.use_timestamps     = !!(flags & 0x04);\n\n        descr->sl.use_idle           = !!(flags & 0x02);\n\n        descr->sl.timestamp_res      = avio_rb32(&d->pb);\n\n                                       avio_rb32(&d->pb);\n\n        descr->sl.timestamp_len      = avio_r8(&d->pb);\n\n\n\n\n\n\n        descr->sl.ocr_len            = avio_r8(&d->pb);\n\n        descr->sl.au_len             = avio_r8(&d->pb);\n\n        descr->sl.inst_bitrate_len   = avio_r8(&d->pb);\n\n        lengths                      = avio_rb16(&d->pb);\n\n        descr->sl.degr_prior_len     = lengths >> 12;\n\n        descr->sl.au_seq_num_len     = (lengths >> 7) & 0x1f;\n\n        descr->sl.packet_seq_num_len = (lengths >> 2) & 0x1f;\n\n    } else {\n\n        avpriv_report_missing_feature(d->s, \"Predefined SLConfigDescriptor\");\n\n\n    return 0;\n", "idx": 9351}, {"project": "test", "commit_id": "test", "target": 1, "func": "target_ulong helper_mul_suov(CPUTriCoreState *env, target_ulong r1,\n\n                             target_ulong r2)\n\n{\n\n    int64_t t1 = extract64(r1, 0, 32);\n\n    int64_t t2 = extract64(r2, 0, 32);\n\n    int64_t result = t1 * t2;\n\n\n\n    return suov32(env, result);\n\n}\n", "idx": 9352}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void virtio_rng_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VirtioDeviceClass *vdc = VIRTIO_DEVICE_CLASS(klass);\n\n\n\n    dc->props = virtio_rng_properties;\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    vdc->realize = virtio_rng_device_realize;\n\n    vdc->unrealize = virtio_rng_device_unrealize;\n\n    vdc->get_features = get_features;\n\n    vdc->load = virtio_rng_load_device;\n\n}\n", "idx": 9399}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int nut_read_header(AVFormatContext * avf, AVFormatParameters * ap) {\n\n    NUTContext * priv = avf->priv_data;\n\n    AVIOContext * bc = avf->pb;\n\n    nut_demuxer_opts_tt dopts = {\n\n        .input = {\n\n            .priv = bc,\n\n            .seek = av_seek,\n\n            .read = av_read,\n\n            .eof = NULL,\n\n            .file_pos = 0,\n\n        },\n\n        .alloc = { av_malloc, av_realloc, av_free },\n\n        .read_index = 1,\n\n        .cache_syncpoints = 1,\n\n    };\n\n    nut_context_tt * nut = priv->nut = nut_demuxer_init(&dopts);\n\n    nut_stream_header_tt * s;\n\n    int ret, i;\n\n\n\n    if ((ret = nut_read_headers(nut, &s, NULL))) {\n\n        av_log(avf, AV_LOG_ERROR, \" NUT error: %s\\n\", nut_error(ret));\n\n\n        return -1;\n\n\n\n\n    priv->s = s;\n\n\n\n    for (i = 0; s[i].type != -1 && i < 2; i++) {\n\n        AVStream * st = avformat_new_stream(avf, NULL);\n\n        int j;\n\n\n\n        for (j = 0; j < s[i].fourcc_len && j < 8; j++) st->codec->codec_tag |= s[i].fourcc[j]<<(j*8);\n\n\n\n        st->codec->has_b_frames = s[i].decode_delay;\n\n\n\n        st->codec->extradata_size = s[i].codec_specific_len;\n\n        if (st->codec->extradata_size) {\n\n            st->codec->extradata = av_mallocz(st->codec->extradata_size);\n\n\n\n\n\n            memcpy(st->codec->extradata, s[i].codec_specific, st->codec->extradata_size);\n\n\n\n\n        avpriv_set_pts_info(avf->streams[i], 60, s[i].time_base.num, s[i].time_base.den);\n\n        st->start_time = 0;\n\n        st->duration = s[i].max_pts;\n\n\n\n        st->codec->codec_id = ff_codec_get_id(nut_tags, st->codec->codec_tag);\n\n\n\n        switch(s[i].type) {\n\n        case NUT_AUDIO_CLASS:\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n            if (st->codec->codec_id == CODEC_ID_NONE) st->codec->codec_id = ff_codec_get_id(ff_codec_wav_tags, st->codec->codec_tag);\n\n\n\n            st->codec->channels = s[i].channel_count;\n\n            st->codec->sample_rate = s[i].samplerate_num / s[i].samplerate_denom;\n\n            break;\n\n        case NUT_VIDEO_CLASS:\n\n            st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n            if (st->codec->codec_id == CODEC_ID_NONE) st->codec->codec_id = ff_codec_get_id(ff_codec_bmp_tags, st->codec->codec_tag);\n\n\n\n            st->codec->width = s[i].width;\n\n            st->codec->height = s[i].height;\n\n            st->sample_aspect_ratio.num = s[i].sample_width;\n\n            st->sample_aspect_ratio.den = s[i].sample_height;\n\n            break;\n\n\n        if (st->codec->codec_id == CODEC_ID_NONE) av_log(avf, AV_LOG_ERROR, \"Unknown codec?!\\n\");\n\n\n\n\n    return 0;\n", "idx": 9435}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void ppc_cpu_realizefn(DeviceState *dev, Error **errp)\n{\n    CPUState *cs = CPU(dev);\n    PowerPCCPU *cpu = POWERPC_CPU(dev);\n    PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);\n    Error *local_err = NULL;\n#if !defined(CONFIG_USER_ONLY)\n    int max_smt = kvm_enabled() ? kvmppc_smt_threads() : 1;\n#endif\n#if !defined(CONFIG_USER_ONLY)\n    if (smp_threads > max_smt) {\n        error_setg(errp, \"Cannot support more than %d threads on PPC with %s\",\n                   max_smt, kvm_enabled() ? \"KVM\" : \"TCG\");\n    if (!is_power_of_2(smp_threads)) {\n        error_setg(errp, \"Cannot support %d threads on PPC with %s, \"\n                   \"threads count must be a power of 2.\",\n                   smp_threads, kvm_enabled() ? \"KVM\" : \"TCG\");\n#endif\n    cpu_exec_init(cs, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n#if !defined(CONFIG_USER_ONLY)\n    cpu->cpu_dt_id = (cs->cpu_index / smp_threads) * max_smt\n        + (cs->cpu_index % smp_threads);\n#endif\n    if (tcg_enabled()) {\n        if (ppc_fixup_cpu(cpu) != 0) {\n            error_setg(errp, \"Unable to emulate selected CPU with TCG\");\n#if defined(TARGET_PPCEMB)\n    if (!ppc_cpu_is_valid(pcc)) {\n        error_setg(errp, \"CPU does not possess a BookE or 4xx MMU. \"\n                   \"Please use qemu-system-ppc or qemu-system-ppc64 instead \"\n                   \"or choose another CPU model.\");\n#endif\n    create_ppc_opcodes(cpu, &local_err);\n    if (local_err != NULL) {\n        error_propagate(errp, local_err);\n    init_ppc_proc(cpu);\n    if (pcc->insns_flags & PPC_FLOAT) {\n        gdb_register_coprocessor(cs, gdb_get_float_reg, gdb_set_float_reg,\n                                 33, \"power-fpu.xml\", 0);\n    if (pcc->insns_flags & PPC_ALTIVEC) {\n        gdb_register_coprocessor(cs, gdb_get_avr_reg, gdb_set_avr_reg,\n                                 34, \"power-altivec.xml\", 0);\n    if (pcc->insns_flags & PPC_SPE) {\n        gdb_register_coprocessor(cs, gdb_get_spe_reg, gdb_set_spe_reg,\n                                 34, \"power-spe.xml\", 0);\n    if (pcc->insns_flags2 & PPC2_VSX) {\n        gdb_register_coprocessor(cs, gdb_get_vsx_reg, gdb_set_vsx_reg,\n                                 32, \"power-vsx.xml\", 0);\n    qemu_init_vcpu(cs);\n    pcc->parent_realize(dev, errp);\n#if defined(PPC_DUMP_CPU)\n    {\n        CPUPPCState *env = &cpu->env;\n        const char *mmu_model, *excp_model, *bus_model;\n        switch (env->mmu_model) {\n        case POWERPC_MMU_32B:\n            mmu_model = \"PowerPC 32\";\n            break;\n        case POWERPC_MMU_SOFT_6xx:\n            mmu_model = \"PowerPC 6xx/7xx with software driven TLBs\";\n            break;\n        case POWERPC_MMU_SOFT_74xx:\n            mmu_model = \"PowerPC 74xx with software driven TLBs\";\n            break;\n        case POWERPC_MMU_SOFT_4xx:\n            mmu_model = \"PowerPC 4xx with software driven TLBs\";\n            break;\n        case POWERPC_MMU_SOFT_4xx_Z:\n            mmu_model = \"PowerPC 4xx with software driven TLBs \"\n                \"and zones protections\";\n            break;\n        case POWERPC_MMU_REAL:\n            mmu_model = \"PowerPC real mode only\";\n            break;\n        case POWERPC_MMU_MPC8xx:\n            mmu_model = \"PowerPC MPC8xx\";\n            break;\n        case POWERPC_MMU_BOOKE:\n            mmu_model = \"PowerPC BookE\";\n            break;\n        case POWERPC_MMU_BOOKE206:\n            mmu_model = \"PowerPC BookE 2.06\";\n            break;\n        case POWERPC_MMU_601:\n            mmu_model = \"PowerPC 601\";\n            break;\n#if defined (TARGET_PPC64)\n        case POWERPC_MMU_64B:\n            mmu_model = \"PowerPC 64\";\n            break;\n#endif\n        default:\n            mmu_model = \"Unknown or invalid\";\n            break;\n        switch (env->excp_model) {\n        case POWERPC_EXCP_STD:\n            excp_model = \"PowerPC\";\n            break;\n        case POWERPC_EXCP_40x:\n            excp_model = \"PowerPC 40x\";\n            break;\n        case POWERPC_EXCP_601:\n            excp_model = \"PowerPC 601\";\n            break;\n        case POWERPC_EXCP_602:\n            excp_model = \"PowerPC 602\";\n            break;\n        case POWERPC_EXCP_603:\n            excp_model = \"PowerPC 603\";\n            break;\n        case POWERPC_EXCP_603E:\n            excp_model = \"PowerPC 603e\";\n            break;\n        case POWERPC_EXCP_604:\n            excp_model = \"PowerPC 604\";\n            break;\n        case POWERPC_EXCP_7x0:\n            excp_model = \"PowerPC 740/750\";\n            break;\n        case POWERPC_EXCP_7x5:\n            excp_model = \"PowerPC 745/755\";\n            break;\n        case POWERPC_EXCP_74xx:\n            excp_model = \"PowerPC 74xx\";\n            break;\n        case POWERPC_EXCP_BOOKE:\n            excp_model = \"PowerPC BookE\";\n            break;\n#if defined (TARGET_PPC64)\n        case POWERPC_EXCP_970:\n            excp_model = \"PowerPC 970\";\n            break;\n#endif\n        default:\n            excp_model = \"Unknown or invalid\";\n            break;\n        switch (env->bus_model) {\n        case PPC_FLAGS_INPUT_6xx:\n            bus_model = \"PowerPC 6xx\";\n            break;\n        case PPC_FLAGS_INPUT_BookE:\n            bus_model = \"PowerPC BookE\";\n            break;\n        case PPC_FLAGS_INPUT_405:\n            bus_model = \"PowerPC 405\";\n            break;\n        case PPC_FLAGS_INPUT_401:\n            bus_model = \"PowerPC 401/403\";\n            break;\n        case PPC_FLAGS_INPUT_RCPU:\n            bus_model = \"RCPU / MPC8xx\";\n            break;\n#if defined (TARGET_PPC64)\n        case PPC_FLAGS_INPUT_970:\n            bus_model = \"PowerPC 970\";\n            break;\n#endif\n        default:\n            bus_model = \"Unknown or invalid\";\n            break;\n        printf(\"PowerPC %-12s : PVR %08x MSR %016\" PRIx64 \"\\n\"\n               \"    MMU model        : %s\\n\",\n               object_class_get_name(OBJECT_CLASS(pcc)),\n               pcc->pvr, pcc->msr_mask, mmu_model);\n#if !defined(CONFIG_USER_ONLY)\n        if (env->tlb.tlb6) {\n            printf(\"                       %d %s TLB in %d ways\\n\",\n                   env->nb_tlb, env->id_tlbs ? \"splitted\" : \"merged\",\n                   env->nb_ways);\n#endif\n        printf(\"    Exceptions model : %s\\n\"\n               \"    Bus model        : %s\\n\",\n               excp_model, bus_model);\n        printf(\"    MSR features     :\\n\");\n        if (env->flags & POWERPC_FLAG_SPE)\n            printf(\"                        signal processing engine enable\"\n                   \"\\n\");\n        else if (env->flags & POWERPC_FLAG_VRE)\n            printf(\"                        vector processor enable\\n\");\n        if (env->flags & POWERPC_FLAG_TGPR)\n            printf(\"                        temporary GPRs\\n\");\n        else if (env->flags & POWERPC_FLAG_CE)\n            printf(\"                        critical input enable\\n\");\n        if (env->flags & POWERPC_FLAG_SE)\n            printf(\"                        single-step trace mode\\n\");\n        else if (env->flags & POWERPC_FLAG_DWE)\n            printf(\"                        debug wait enable\\n\");\n        else if (env->flags & POWERPC_FLAG_UBLE)\n            printf(\"                        user BTB lock enable\\n\");\n        if (env->flags & POWERPC_FLAG_BE)\n            printf(\"                        branch-step trace mode\\n\");\n        else if (env->flags & POWERPC_FLAG_DE)\n            printf(\"                        debug interrupt enable\\n\");\n        if (env->flags & POWERPC_FLAG_PX)\n            printf(\"                        inclusive protection\\n\");\n        else if (env->flags & POWERPC_FLAG_PMM)\n            printf(\"                        performance monitor mark\\n\");\n        if (env->flags == POWERPC_FLAG_NONE)\n            printf(\"                        none\\n\");\n        printf(\"    Time-base/decrementer clock source: %s\\n\",\n               env->flags & POWERPC_FLAG_RTC_CLK ? \"RTC clock\" : \"bus clock\");\n        dump_ppc_insns(env);\n        dump_ppc_sprs(env);\n        fflush(stdout);\n#endif", "idx": 9437}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void ram_init(target_phys_addr_t addr, ram_addr_t RAM_size)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n    RamDevice *d;\n\n\n\n    /* allocate RAM */\n\n    dev = qdev_create(NULL, \"memory\");\n\n    s = sysbus_from_qdev(dev);\n\n\n\n    d = FROM_SYSBUS(RamDevice, s);\n\n    d->size = RAM_size;\n\n    qdev_init(dev);\n\n\n\n    sysbus_mmio_map(s, 0, addr);\n\n}\n", "idx": 9443}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int qemu_rdma_register_and_get_keys(RDMAContext *rdma,\n\n        RDMALocalBlock *block, uintptr_t host_addr,\n\n        uint32_t *lkey, uint32_t *rkey, int chunk,\n\n        uint8_t *chunk_start, uint8_t *chunk_end)\n\n{\n\n    if (block->mr) {\n\n        if (lkey) {\n\n            *lkey = block->mr->lkey;\n\n        }\n\n        if (rkey) {\n\n            *rkey = block->mr->rkey;\n\n        }\n\n        return 0;\n\n    }\n\n\n\n    /* allocate memory to store chunk MRs */\n\n    if (!block->pmr) {\n\n        block->pmr = g_malloc0(block->nb_chunks * sizeof(struct ibv_mr *));\n\n    }\n\n\n\n    /*\n\n     * If 'rkey', then we're the destination, so grant access to the source.\n\n     *\n\n     * If 'lkey', then we're the source VM, so grant access only to ourselves.\n\n     */\n\n    if (!block->pmr[chunk]) {\n\n        uint64_t len = chunk_end - chunk_start;\n\n\n\n        trace_qemu_rdma_register_and_get_keys(len, chunk_start);\n\n\n\n        block->pmr[chunk] = ibv_reg_mr(rdma->pd,\n\n                chunk_start, len,\n\n                (rkey ? (IBV_ACCESS_LOCAL_WRITE |\n\n                        IBV_ACCESS_REMOTE_WRITE) : 0));\n\n\n\n        if (!block->pmr[chunk]) {\n\n            perror(\"Failed to register chunk!\");\n\n            fprintf(stderr, \"Chunk details: block: %d chunk index %d\"\n\n                            \" start %\" PRIuPTR \" end %\" PRIuPTR\n\n                            \" host %\" PRIuPTR\n\n                            \" local %\" PRIuPTR \" registrations: %d\\n\",\n\n                            block->index, chunk, (uintptr_t)chunk_start,\n\n                            (uintptr_t)chunk_end, host_addr,\n\n                            (uintptr_t)block->local_host_addr,\n\n                            rdma->total_registrations);\n\n            return -1;\n\n        }\n\n        rdma->total_registrations++;\n\n    }\n\n\n\n    if (lkey) {\n\n        *lkey = block->pmr[chunk]->lkey;\n\n    }\n\n    if (rkey) {\n\n        *rkey = block->pmr[chunk]->rkey;\n\n    }\n\n    return 0;\n\n}\n", "idx": 9508}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int protocol_client_auth_sasl_start_len(VncState *vs, uint8_t *data, size_t len)\n\n{\n\n    uint32_t startlen = read_u32(data, 0);\n\n    VNC_DEBUG(\"Got client start len %d\\n\", startlen);\n\n    if (startlen > SASL_DATA_MAX_LEN) {\n\n        VNC_DEBUG(\"Too much SASL data %d\\n\", startlen);\n\n        vnc_client_error(vs);\n\n        return -1;\n\n    }\n\n\n\n    if (startlen == 0)\n\n        return protocol_client_auth_sasl_start(vs, NULL, 0);\n\n\n\n    vnc_read_when(vs, protocol_client_auth_sasl_start, startlen);\n\n    return 0;\n\n}\n", "idx": 9516}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void mv_pred_direct(AVSContext *h, cavs_vector *pmv_fw,\n\n                                  cavs_vector *col_mv)\n\n{\n\n    cavs_vector *pmv_bw = pmv_fw + MV_BWD_OFFS;\n\n    int den = h->direct_den[col_mv->ref];\n\n    int m = FF_SIGNBIT(col_mv->x);\n\n\n\n    pmv_fw->dist = h->dist[1];\n\n    pmv_bw->dist = h->dist[0];\n\n    pmv_fw->ref = 1;\n\n    pmv_bw->ref = 0;\n\n    /* scale the co-located motion vector according to its temporal span */\n\n    pmv_fw->x =     (((den + (den * col_mv->x * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;\n\n    pmv_bw->x = m - (((den + (den * col_mv->x * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);\n\n    m = FF_SIGNBIT(col_mv->y);\n\n    pmv_fw->y =     (((den + (den * col_mv->y * pmv_fw->dist ^ m) - m - 1) >> 14) ^ m) - m;\n\n    pmv_bw->y = m - (((den + (den * col_mv->y * pmv_bw->dist ^ m) - m - 1) >> 14) ^ m);\n\n}\n", "idx": 9528}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void free_geotags(TiffContext *const s)\n\n{\n\n    int i;\n\n    for (i = 0; i < s->geotag_count; i++) {\n\n        if (s->geotags[i].val)\n\n            av_freep(&s->geotags[i].val);\n\n    }\n\n    av_freep(&s->geotags);\n\n\n}", "idx": 9598}, {"project": "test", "commit_id": "test", "target": 1, "func": "void ff_bink_idct_c(DCTELEM *block)\n\n{\n\n    int i;\n\n    DCTELEM temp[64];\n\n\n\n    for (i = 0; i < 8; i++)\n\n        bink_idct_col(&temp[i], &block[i]);\n\n    for (i = 0; i < 8; i++) {\n\n        IDCT_ROW( (&block[8*i]), (&temp[8*i]) );\n\n    }\n\n}\n", "idx": 9607}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void usbredir_interrupt_packet(void *priv, uint32_t id,\n\n    struct usb_redir_interrupt_packet_header *interrupt_packet,\n\n    uint8_t *data, int data_len)\n\n{\n\n    USBRedirDevice *dev = priv;\n\n    uint8_t ep = interrupt_packet->endpoint;\n\n\n\n    DPRINTF(\"interrupt-in status %d ep %02X len %d id %u\\n\",\n\n            interrupt_packet->status, ep, data_len, id);\n\n\n\n    if (dev->endpoint[EP2I(ep)].type != USB_ENDPOINT_XFER_INT) {\n\n        ERROR(\"received int packet for non interrupt endpoint %02X\\n\", ep);\n\n        free(data);\n\n        return;\n\n    }\n\n\n\n    if (ep & USB_DIR_IN) {\n\n        if (dev->endpoint[EP2I(ep)].interrupt_started == 0) {\n\n            DPRINTF(\"received int packet while not started ep %02X\\n\", ep);\n\n            free(data);\n\n            return;\n\n        }\n\n\n\n        /* bufp_alloc also adds the packet to the ep queue */\n\n        bufp_alloc(dev, data, data_len, interrupt_packet->status, ep);\n\n    } else {\n\n        int len = interrupt_packet->length;\n\n\n\n        AsyncURB *aurb = async_find(dev, id);\n\n        if (!aurb) {\n\n            return;\n\n        }\n\n\n\n        if (aurb->interrupt_packet.endpoint != interrupt_packet->endpoint) {\n\n            ERROR(\"return int packet mismatch, please report this!\\n\");\n\n            len = USB_RET_NAK;\n\n        }\n\n\n\n        if (aurb->packet) {\n\n            aurb->packet->len = usbredir_handle_status(dev,\n\n                                               interrupt_packet->status, len);\n\n            usb_packet_complete(&dev->dev, aurb->packet);\n\n        }\n\n        async_free(dev, aurb);\n\n    }\n\n}\n", "idx": 9722}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void RENAME(rgb24tobgr24)(const uint8_t *src, uint8_t *dst, long src_size)\n\n{\n\n\tunsigned i;\n\n#ifdef HAVE_MMX\n\n\tlong mmx_size= 23 - src_size;\n\n\tasm volatile (\n\n\t\t\"test %%\"REG_a\", %%\"REG_a\"\t\\n\\t\"\n\n\t\t\"jns 2f\t\t\t\t\\n\\t\"\n\n\t\t\"movq \"MANGLE(mask24r)\", %%mm5\t\\n\\t\"\n\n\t\t\"movq \"MANGLE(mask24g)\", %%mm6\t\\n\\t\"\n\n\t\t\"movq \"MANGLE(mask24b)\", %%mm7\t\\n\\t\"\n\n\t\tASMALIGN(4)\n\n\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\tPREFETCH\" 32(%1, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\"movq   (%1, %%\"REG_a\"), %%mm0\t\\n\\t\" // BGR BGR BG\n\n\t\t\"movq   (%1, %%\"REG_a\"), %%mm1\t\\n\\t\" // BGR BGR BG\n\n\t\t\"movq  2(%1, %%\"REG_a\"), %%mm2\t\\n\\t\" // R BGR BGR B\n\n\t\t\"psllq $16, %%mm0\t\t\\n\\t\" // 00 BGR BGR\n\n\t\t\"pand %%mm5, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm6, %%mm1\t\t\\n\\t\"\n\n\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\"por %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"por %%mm2, %%mm1\t\t\\n\\t\"\n\n\t\t\"movq  6(%1, %%\"REG_a\"), %%mm0\t\\n\\t\" // BGR BGR BG\n\n\t\tMOVNTQ\" %%mm1,   (%2, %%\"REG_a\")\\n\\t\" // RGB RGB RG\n\n\t\t\"movq  8(%1, %%\"REG_a\"), %%mm1\t\\n\\t\" // R BGR BGR B\n\n\t\t\"movq 10(%1, %%\"REG_a\"), %%mm2\t\\n\\t\" // GR BGR BGR\n\n\t\t\"pand %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm5, %%mm1\t\t\\n\\t\"\n\n\t\t\"pand %%mm6, %%mm2\t\t\\n\\t\"\n\n\t\t\"por %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"por %%mm2, %%mm1\t\t\\n\\t\"\n\n\t\t\"movq 14(%1, %%\"REG_a\"), %%mm0\t\\n\\t\" // R BGR BGR B\n\n\t\tMOVNTQ\" %%mm1,  8(%2, %%\"REG_a\")\\n\\t\" // B RGB RGB R\n\n\t\t\"movq 16(%1, %%\"REG_a\"), %%mm1\t\\n\\t\" // GR BGR BGR\n\n\t\t\"movq 18(%1, %%\"REG_a\"), %%mm2\t\\n\\t\" // BGR BGR BG\n\n\t\t\"pand %%mm6, %%mm0\t\t\\n\\t\"\n\n\t\t\"pand %%mm7, %%mm1\t\t\\n\\t\"\n\n\t\t\"pand %%mm5, %%mm2\t\t\\n\\t\"\n\n\t\t\"por %%mm0, %%mm1\t\t\\n\\t\"\n\n\t\t\"por %%mm2, %%mm1\t\t\\n\\t\"\n\n\t\tMOVNTQ\" %%mm1, 16(%2, %%\"REG_a\")\\n\\t\"\n\n\t\t\"add $24, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t\"2:\t\t\t\t\\n\\t\"\n\n\t\t: \"+a\" (mmx_size)\n\n\t\t: \"r\" (src-mmx_size), \"r\"(dst-mmx_size)\n\n\t);\n\n\n\n\t__asm __volatile(SFENCE:::\"memory\");\n\n\t__asm __volatile(EMMS:::\"memory\");\n\n\n\n\tif(mmx_size==23) return; //finihsed, was multiple of 8\n\n\n\n\tsrc+= src_size;\n\n\tdst+= src_size;\n\n\tsrc_size= 23-mmx_size;\n\n\tsrc-= src_size;\n\n\tdst-= src_size;\n\n#endif\n\n\tfor(i=0; i<src_size; i+=3)\n\n\t{\n\n\t\tregister uint8_t x;\n\n\t\tx          = src[i + 2];\n\n\t\tdst[i + 1] = src[i + 1];\n\n\t\tdst[i + 2] = src[i + 0];\n\n\t\tdst[i + 0] = x;\n\n\t}\n\n}\n", "idx": 9761}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int decode_frame(AVCodecContext *avctx, void *data,\n\n                        int *got_frame, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size       = avpkt->size;\n\n    H264Context *h     = avctx->priv_data;\n\n    AVFrame *pict      = data;\n\n    int buf_index      = 0;\n\n    Picture *out;\n\n    int i, out_idx;\n\n    int ret;\n\n\n\n    h->flags  = avctx->flags;\n\n\n\n    /* end of stream, output what is still in the buffers */\n\n    if (buf_size == 0) {\n\n out:\n\n\n\n        h->cur_pic_ptr = NULL;\n\n        h->first_field = 0;\n\n\n\n        // FIXME factorize this with the output code below\n\n        out     = h->delayed_pic[0];\n\n        out_idx = 0;\n\n        for (i = 1;\n\n             h->delayed_pic[i] &&\n\n             !h->delayed_pic[i]->f.key_frame &&\n\n             !h->delayed_pic[i]->mmco_reset;\n\n             i++)\n\n            if (h->delayed_pic[i]->poc < out->poc) {\n\n                out     = h->delayed_pic[i];\n\n                out_idx = i;\n\n            }\n\n\n\n        for (i = out_idx; h->delayed_pic[i]; i++)\n\n            h->delayed_pic[i] = h->delayed_pic[i + 1];\n\n\n\n        if (out) {\n\n            out->reference &= ~DELAYED_PIC_REF;\n\n            ret = output_frame(h, pict, &out->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n        }\n\n\n\n        return buf_index;\n\n    }\n\n    if(h->is_avc && buf_size >= 9 && buf[0]==1 && buf[2]==0 && (buf[4]&0xFC)==0xFC && (buf[5]&0x1F) && buf[8]==0x67){\n\n        int cnt= buf[5]&0x1f;\n\n        const uint8_t *p= buf+6;\n\n        while(cnt--){\n\n            int nalsize= AV_RB16(p) + 2;\n\n            if(nalsize > buf_size - (p-buf) || p[2]!=0x67)\n\n                goto not_extra;\n\n            p += nalsize;\n\n        }\n\n        cnt = *(p++);\n\n        if(!cnt)\n\n            goto not_extra;\n\n        while(cnt--){\n\n            int nalsize= AV_RB16(p) + 2;\n\n            if(nalsize > buf_size - (p-buf) || p[2]!=0x68)\n\n                goto not_extra;\n\n            p += nalsize;\n\n        }\n\n\n\n        return ff_h264_decode_extradata(h, buf, buf_size);\n\n    }\n\nnot_extra:\n\n\n\n    buf_index = decode_nal_units(h, buf, buf_size, 0);\n\n    if (buf_index < 0)\n\n        return -1;\n\n\n\n    if (!h->cur_pic_ptr && h->nal_unit_type == NAL_END_SEQUENCE) {\n\n        av_assert0(buf_index <= buf_size);\n\n        goto out;\n\n    }\n\n\n\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) && !h->cur_pic_ptr) {\n\n        if (avctx->skip_frame >= AVDISCARD_NONREF ||\n\n            buf_size >= 4 && !memcmp(\"Q264\", buf, 4))\n\n            return buf_size;\n\n        av_log(avctx, AV_LOG_ERROR, \"no frame!\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (!(avctx->flags2 & CODEC_FLAG2_CHUNKS) ||\n\n        (h->mb_y >= h->mb_height && h->mb_height)) {\n\n        if (avctx->flags2 & CODEC_FLAG2_CHUNKS)\n\n            decode_postinit(h, 1);\n\n\n\n        field_end(h, 0);\n\n\n\n        /* Wait for second field. */\n\n        *got_frame = 0;\n\n        if (h->next_output_pic && (h->next_output_pic->sync || h->sync>1)) {\n\n            ret = output_frame(h, pict, &h->next_output_pic->f);\n\n            if (ret < 0)\n\n                return ret;\n\n            *got_frame = 1;\n\n            if (CONFIG_MPEGVIDEO) {\n\n                ff_print_debug_info2(h->avctx, h->next_output_pic, pict, h->er.mbskip_table,\n\n                                    &h->low_delay,\n\n                                    h->mb_width, h->mb_height, h->mb_stride, 1);\n\n            }\n\n        }\n\n    }\n\n\n\n    assert(pict->data[0] || !*got_frame);\n\n\n\n    return get_consumed_bytes(buf_index, buf_size);\n\n}\n", "idx": 9781}, {"project": "test", "commit_id": "test", "target": 1, "func": "PCIBus *pci_prep_init(qemu_irq *pic)\n\n{\n\n    PREPPCIState *s;\n\n    PCIDevice *d;\n\n    int PPC_io_memory;\n\n\n\n    s = qemu_mallocz(sizeof(PREPPCIState));\n\n    s->bus = pci_register_bus(prep_set_irq, prep_map_irq, pic, 0, 2);\n\n\n\n    register_ioport_write(0xcf8, 4, 4, pci_prep_addr_writel, s);\n\n    register_ioport_read(0xcf8, 4, 4, pci_prep_addr_readl, s);\n\n\n\n    register_ioport_write(0xcfc, 4, 1, pci_host_data_writeb, s);\n\n    register_ioport_write(0xcfc, 4, 2, pci_host_data_writew, s);\n\n    register_ioport_write(0xcfc, 4, 4, pci_host_data_writel, s);\n\n    register_ioport_read(0xcfc, 4, 1, pci_host_data_readb, s);\n\n    register_ioport_read(0xcfc, 4, 2, pci_host_data_readw, s);\n\n    register_ioport_read(0xcfc, 4, 4, pci_host_data_readl, s);\n\n\n\n    PPC_io_memory = cpu_register_io_memory(0, PPC_PCIIO_read,\n\n                                           PPC_PCIIO_write, s);\n\n    cpu_register_physical_memory(0x80800000, 0x00400000, PPC_io_memory);\n\n\n\n    /* PCI host bridge */\n\n    d = pci_register_device(s->bus, \"PREP Host Bridge - Motorola Raven\",\n\n                            sizeof(PCIDevice), 0, NULL, NULL);\n\n    d->config[0x00] = 0x57; // vendor_id : Motorola\n\n    d->config[0x01] = 0x10;\n\n    d->config[0x02] = 0x01; // device_id : Raven\n\n    d->config[0x03] = 0x48;\n\n    d->config[0x08] = 0x00; // revision\n\n    d->config[0x0A] = 0x00; // class_sub = pci host\n\n    d->config[0x0B] = 0x06; // class_base = PCI_bridge\n\n    d->config[0x0C] = 0x08; // cache_line_size\n\n    d->config[0x0D] = 0x10; // latency_timer\n\n    d->config[0x0E] = 0x00; // header_type\n\n    d->config[0x34] = 0x00; // capabilities_pointer\n\n\n\n    return s->bus;\n\n}\n", "idx": 10406}, {"project": "test", "commit_id": "test", "target": 1, "func": "void decode_mb_mode(VP8Context *s, VP8Macroblock *mb, int mb_x, int mb_y,\n\n                    uint8_t *segment, uint8_t *ref, int layout)\n\n{\n\n    VP56RangeCoder *c = &s->c;\n\n\n\n    if (s->segmentation.update_map)\n\n        *segment = vp8_rac_get_tree(c, vp8_segmentid_tree, s->prob->segmentid);\n\n    else if (s->segmentation.enabled)\n\n        *segment = ref ? *ref : *segment;\n\n    mb->segment = *segment;\n\n\n\n    mb->skip = s->mbskip_enabled ? vp56_rac_get_prob(c, s->prob->mbskip) : 0;\n\n\n\n    if (s->keyframe) {\n\n        mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_intra,\n\n                                    vp8_pred16x16_prob_intra);\n\n\n\n        if (mb->mode == MODE_I4x4) {\n\n            decode_intra4x4_modes(s, c, mb, mb_x, 1, layout);\n\n        } else {\n\n            const uint32_t modes = vp8_pred4x4_mode[mb->mode] * 0x01010101u;\n\n            if (s->mb_layout == 1)\n\n                AV_WN32A(mb->intra4x4_pred_mode_top, modes);\n\n            else\n\n                AV_WN32A(s->intra4x4_pred_mode_top + 4 * mb_x, modes);\n\n            AV_WN32A(s->intra4x4_pred_mode_left, modes);\n\n        }\n\n\n\n        mb->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree,\n\n                                                vp8_pred8x8c_prob_intra);\n\n        mb->ref_frame        = VP56_FRAME_CURRENT;\n\n    } else if (vp56_rac_get_prob_branchy(c, s->prob->intra)) {\n\n        // inter MB, 16.2\n\n        if (vp56_rac_get_prob_branchy(c, s->prob->last))\n\n            mb->ref_frame =\n\n                vp56_rac_get_prob(c, s->prob->golden) ? VP56_FRAME_GOLDEN2 /* altref */\n\n                                                      : VP56_FRAME_GOLDEN;\n\n        else\n\n            mb->ref_frame = VP56_FRAME_PREVIOUS;\n\n        s->ref_count[mb->ref_frame - 1]++;\n\n\n\n        // motion vectors, 16.3\n\n        decode_mvs(s, mb, mb_x, mb_y, layout);\n\n    } else {\n\n        // intra MB, 16.1\n\n        mb->mode = vp8_rac_get_tree(c, vp8_pred16x16_tree_inter, s->prob->pred16x16);\n\n\n\n        if (mb->mode == MODE_I4x4)\n\n            decode_intra4x4_modes(s, c, mb, mb_x, 0, layout);\n\n\n\n        mb->chroma_pred_mode = vp8_rac_get_tree(c, vp8_pred8x8c_tree,\n\n                                                s->prob->pred8x8c);\n\n        mb->ref_frame        = VP56_FRAME_CURRENT;\n\n        mb->partitioning     = VP8_SPLITMVMODE_NONE;\n\n        AV_ZERO32(&mb->bmv[0]);\n\n    }\n\n}\n", "idx": 10502}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int prepare_packet(AVPacket *pkt,const FailingMuxerPacketData *pkt_data, int64_t pts)\n\n{\n\n    int ret;\n\n    FailingMuxerPacketData *data = av_malloc(sizeof(*data));\n\n\n\n\n    memcpy(data, pkt_data, sizeof(FailingMuxerPacketData));\n\n    ret = av_packet_from_data(pkt, (uint8_t*) data, sizeof(*data));\n\n\n\n    pkt->pts = pkt->dts = pts;\n\n    pkt->duration = 1;\n\n\n\n    return ret;\n", "idx": 10520}, {"project": "test", "commit_id": "test", "target": 1, "func": "static av_always_inline int coeff_abs_level_remaining_decode(HEVCContext *s, int rc_rice_param)\n\n{\n\n    int prefix = 0;\n\n    int suffix = 0;\n\n    int last_coeff_abs_level_remaining;\n\n    int i;\n\n\n\n    while (prefix < CABAC_MAX_BIN && get_cabac_bypass(&s->HEVClc->cc))\n\n        prefix++;\n\n\n\n    if (prefix < 3) {\n\n        for (i = 0; i < rc_rice_param; i++)\n\n            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);\n\n        last_coeff_abs_level_remaining = (prefix << rc_rice_param) + suffix;\n\n    } else {\n\n        int prefix_minus3 = prefix - 3;\n\n\n\n        if (prefix == CABAC_MAX_BIN) {\n\n            av_log(s->avctx, AV_LOG_ERROR, \"CABAC_MAX_BIN : %d\\n\", prefix);\n\n            return 0;\n\n        }\n\n\n\n        for (i = 0; i < prefix_minus3 + rc_rice_param; i++)\n\n            suffix = (suffix << 1) | get_cabac_bypass(&s->HEVClc->cc);\n\n        last_coeff_abs_level_remaining = (((1 << prefix_minus3) + 3 - 1)\n\n                                              << rc_rice_param) + suffix;\n\n    }\n\n    return last_coeff_abs_level_remaining;\n\n}\n", "idx": 10609}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline int cris_addc_pi_m(int a, int **b)\n\n{\n\n\tasm volatile (\"addc [%1+], %0\\n\" : \"+r\" (a), \"+b\" (*b));\n\n\treturn a;\n\n}\n", "idx": 10640}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void vmgenid_query_monitor_test(void)\n\n{\n\n    QemuUUID expected, measured;\n\n    gchar *cmd;\n\n\n\n    g_assert(qemu_uuid_parse(VGID_GUID, &expected) == 0);\n\n\n\n    cmd = g_strdup_printf(\"-machine accel=tcg -device vmgenid,id=testvgid,\"\n\n                          \"guid=%s\", VGID_GUID);\n\n    qtest_start(cmd);\n\n\n\n    /* Read the GUID via the monitor */\n\n    read_guid_from_monitor(&measured);\n\n    g_assert(memcmp(measured.data, expected.data, sizeof(measured.data)) == 0);\n\n\n\n    qtest_quit(global_qtest);\n\n    g_free(cmd);\n\n}\n", "idx": 10648}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int decode_frame_byterun1(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    IffContext *s = avctx->priv_data;\n\n    const uint8_t *buf = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL;\n\n    const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0;\n\n    const uint8_t *buf_end = buf+buf_size;\n\n    int y, plane, res;\n\n\n\n    if ((res = extract_header(avctx, avpkt)) < 0)\n\n        return res;\n\n    if (s->init) {\n\n        if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");\n\n            return res;\n\n        }\n\n    } else if ((res = avctx->get_buffer(avctx, &s->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return res;\n\n    } else if (avctx->bits_per_coded_sample <= 8 && avctx->pix_fmt != PIX_FMT_GRAY8) {\n\n        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)\n\n            return res;\n\n    }\n\n    s->init = 1;\n\n\n\n    if (avctx->codec_tag == MKTAG('I','L','B','M')) { //interleaved\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            for(y = 0; y < avctx->height ; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memset(row, 0, avctx->width);\n\n                for (plane = 0; plane < s->bpp; plane++) {\n\n                    buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);\n\n                    decodeplane8(row, s->planebuf, s->planesize, plane);\n\n                }\n\n            }\n\n        } else if (s->ham) { // HAM to PIX_FMT_BGR32\n\n            for (y = 0; y < avctx->height ; y++) {\n\n                uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n                memset(s->ham_buf, 0, avctx->width);\n\n                for (plane = 0; plane < s->bpp; plane++) {\n\n                    buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);\n\n                    decodeplane8(s->ham_buf, s->planebuf, s->planesize, plane);\n\n                }\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        } else { //PIX_FMT_BGR32\n\n            for(y = 0; y < avctx->height ; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n                memset(row, 0, avctx->width << 2);\n\n                for (plane = 0; plane < s->bpp; plane++) {\n\n                    buf += decode_byterun(s->planebuf, s->planesize, buf, buf_end);\n\n                    decodeplane32((uint32_t *) row, s->planebuf, s->planesize, plane);\n\n                }\n\n            }\n\n        }\n\n    } else if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) { // IFF-PBM\n\n        for(y = 0; y < avctx->height ; y++ ) {\n\n            uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n            buf += decode_byterun(row, avctx->width, buf, buf_end);\n\n        }\n\n    } else { // IFF-PBM: HAM to PIX_FMT_BGR32\n\n        for (y = 0; y < avctx->height ; y++) {\n\n            uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n            buf += decode_byterun(s->ham_buf, avctx->width, buf, buf_end);\n\n            decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, avctx->width);\n\n        }\n\n    }\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame*)data = s->frame;\n\n    return buf_size;\n\n}\n", "idx": 10665}, {"project": "test", "commit_id": "test", "target": 1, "func": "int alloc_picture(MpegEncContext *s, Picture *pic, int shared){\n\n    const int big_mb_num= s->mb_stride*(s->mb_height+1) + 1; //the +1 is needed so memset(,,stride*height) does not sig11\n\n    const int mb_array_size= s->mb_stride*s->mb_height;\n\n    const int b8_array_size= s->b8_stride*s->mb_height*2;\n\n    const int b4_array_size= s->b4_stride*s->mb_height*4;\n\n    int i;\n\n\n\n    if(shared){\n\n        assert(pic->data[0]);\n\n        assert(pic->type == 0 || pic->type == FF_BUFFER_TYPE_SHARED);\n\n        pic->type= FF_BUFFER_TYPE_SHARED;\n\n    }else{\n\n        int r;\n\n\n\n        assert(!pic->data[0]);\n\n\n\n        r= s->avctx->get_buffer(s->avctx, (AVFrame*)pic);\n\n\n\n        if(r<0 || !pic->age || !pic->type || !pic->data[0]){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed (%d %d %d %p)\\n\", r, pic->age, pic->type, pic->data[0]);\n\n            return -1;\n\n        }\n\n\n\n        if(s->linesize && (s->linesize != pic->linesize[0] || s->uvlinesize != pic->linesize[1])){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed (stride changed)\\n\");\n\n            return -1;\n\n        }\n\n\n\n        if(pic->linesize[1] != pic->linesize[2]){\n\n            av_log(s->avctx, AV_LOG_ERROR, \"get_buffer() failed (uv stride mismatch)\\n\");\n\n            return -1;\n\n        }\n\n\n\n        s->linesize  = pic->linesize[0];\n\n        s->uvlinesize= pic->linesize[1];\n\n    }\n\n\n\n    if(pic->qscale_table==NULL){\n\n        if (s->encoding) {\n\n            CHECKED_ALLOCZ(pic->mb_var   , mb_array_size * sizeof(int16_t))\n\n            CHECKED_ALLOCZ(pic->mc_mb_var, mb_array_size * sizeof(int16_t))\n\n            CHECKED_ALLOCZ(pic->mb_mean  , mb_array_size * sizeof(int8_t))\n\n        }\n\n\n\n        CHECKED_ALLOCZ(pic->mbskip_table , mb_array_size * sizeof(uint8_t)+2) //the +2 is for the slice end check\n\n        CHECKED_ALLOCZ(pic->qscale_table , mb_array_size * sizeof(uint8_t))\n\n        CHECKED_ALLOCZ(pic->mb_type_base , big_mb_num    * sizeof(uint32_t))\n\n        pic->mb_type= pic->mb_type_base + s->mb_stride+1;\n\n        if(s->out_format == FMT_H264){\n\n            for(i=0; i<2; i++){\n\n                CHECKED_ALLOCZ(pic->motion_val_base[i], 2 * (b4_array_size+4)  * sizeof(int16_t))\n\n                pic->motion_val[i]= pic->motion_val_base[i]+4;\n\n                CHECKED_ALLOCZ(pic->ref_index[i], b8_array_size * sizeof(uint8_t))\n\n            }\n\n            pic->motion_subsample_log2= 2;\n\n        }else if(s->out_format == FMT_H263 || s->encoding || (s->avctx->debug&FF_DEBUG_MV) || (s->avctx->debug_mv)){\n\n            for(i=0; i<2; i++){\n\n                CHECKED_ALLOCZ(pic->motion_val_base[i], 2 * (b8_array_size+4) * sizeof(int16_t))\n\n                pic->motion_val[i]= pic->motion_val_base[i]+4;\n\n                CHECKED_ALLOCZ(pic->ref_index[i], b8_array_size * sizeof(uint8_t))\n\n            }\n\n            pic->motion_subsample_log2= 3;\n\n        }\n\n        if(s->avctx->debug&FF_DEBUG_DCT_COEFF) {\n\n            CHECKED_ALLOCZ(pic->dct_coeff, 64 * mb_array_size * sizeof(DCTELEM)*6)\n\n        }\n\n        pic->qstride= s->mb_stride;\n\n        CHECKED_ALLOCZ(pic->pan_scan , 1 * sizeof(AVPanScan))\n\n    }\n\n\n\n    /* It might be nicer if the application would keep track of these\n\n     * but it would require an API change. */\n\n    memmove(s->prev_pict_types+1, s->prev_pict_types, PREV_PICT_TYPES_BUFFER_SIZE-1);\n\n    s->prev_pict_types[0]= s->pict_type;\n\n    if(pic->age < PREV_PICT_TYPES_BUFFER_SIZE && s->prev_pict_types[pic->age] == B_TYPE)\n\n        pic->age= INT_MAX; // Skipped MBs in B-frames are quite rare in MPEG-1/2 and it is a bit tricky to skip them anyway.\n\n\n\n    return 0;\n\nfail: //for the CHECKED_ALLOCZ macro\n\n    return -1;\n\n}\n", "idx": 10670}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int decode_pic_hdr(IVI5DecContext *ctx, AVCodecContext *avctx)\n{\n    if (get_bits(&ctx->gb, 5) != 0x1F) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid picture start code!\\n\");\n        return -1;\n    ctx->prev_frame_type = ctx->frame_type;\n    ctx->frame_type      = get_bits(&ctx->gb, 3);\n    if (ctx->frame_type >= 5) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid frame type: %d \\n\", ctx->frame_type);\n        return -1;\n    ctx->frame_num = get_bits(&ctx->gb, 8);\n    if (ctx->frame_type == FRAMETYPE_INTRA) {\n        ctx->gop_invalid = 1;\n        if (decode_gop_header(ctx, avctx))\n            return -1;\n        ctx->gop_invalid = 0;\n    if (ctx->frame_type != FRAMETYPE_NULL) {\n        ctx->frame_flags = get_bits(&ctx->gb, 8);\n        ctx->pic_hdr_size = (ctx->frame_flags & 1) ? get_bits_long(&ctx->gb, 24) : 0;\n        ctx->checksum = (ctx->frame_flags & 0x10) ? get_bits(&ctx->gb, 16) : 0;\n        /* skip unknown extension if any */\n        if (ctx->frame_flags & 0x20)\n            skip_hdr_extension(&ctx->gb); /* XXX: untested */\n        /* decode macroblock huffman codebook */\n        if (ff_ivi_dec_huff_desc(&ctx->gb, ctx->frame_flags & 0x40, IVI_MB_HUFF, &ctx->mb_vlc, avctx))\n            return -1;\n        skip_bits(&ctx->gb, 3); /* FIXME: unknown meaning! */\n    align_get_bits(&ctx->gb);\n    return 0;", "idx": 10671}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void vc1_v_overlap_c(uint8_t* src, int stride)\n\n{\n\n    int i;\n\n    int a, b, c, d;\n\n    int d1, d2;\n\n    int rnd = 1;\n\n    for(i = 0; i < 8; i++) {\n\n        a = src[-2*stride];\n\n        b = src[-stride];\n\n        c = src[0];\n\n        d = src[stride];\n\n        d1 = (a - d + 3 + rnd) >> 3;\n\n        d2 = (a - d + b - c + 4 - rnd) >> 3;\n\n\n\n        src[-2*stride] = a - d1;\n\n        src[-stride] = b - d2;\n\n        src[0] = c + d2;\n\n        src[stride] = d + d1;\n\n        src++;\n\n        rnd = !rnd;\n\n    }\n\n}\n", "idx": 10723}, {"project": "test", "commit_id": "test", "target": 1, "func": "void qvirtio_pci_set_msix_configuration_vector(QVirtioPCIDevice *d,\n\n                                        QGuestAllocator *alloc, uint16_t entry)\n\n{\n\n    uint16_t vector;\n\n    uint32_t control;\n\n    void *addr;\n\n\n\n    g_assert(d->pdev->msix_enabled);\n\n    addr = d->pdev->msix_table + (entry * 16);\n\n\n\n    g_assert_cmpint(entry, >=, 0);\n\n    g_assert_cmpint(entry, <, qpci_msix_table_size(d->pdev));\n\n    d->config_msix_entry = entry;\n\n\n\n    d->config_msix_data = 0x12345678;\n\n    d->config_msix_addr = guest_alloc(alloc, 4);\n\n\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_LOWER_ADDR,\n\n                                                    d->config_msix_addr & ~0UL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_UPPER_ADDR,\n\n                                            (d->config_msix_addr >> 32) & ~0UL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_DATA, d->config_msix_data);\n\n\n\n    control = qpci_io_readl(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL);\n\n    qpci_io_writel(d->pdev, addr + PCI_MSIX_ENTRY_VECTOR_CTRL,\n\n                                        control & ~PCI_MSIX_ENTRY_CTRL_MASKBIT);\n\n\n\n    qpci_io_writew(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR, entry);\n\n    vector = qpci_io_readw(d->pdev, d->addr + VIRTIO_MSI_CONFIG_VECTOR);\n\n    g_assert_cmphex(vector, !=, VIRTIO_MSI_NO_VECTOR);\n\n}\n", "idx": 10727}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void usb_msd_realize_bot(USBDevice *dev, Error **errp)\n\n{\n\n    MSDState *s = DO_UPCAST(MSDState, dev, dev);\n\n\n\n    usb_desc_create_serial(dev);\n\n    usb_desc_init(dev);\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), DEVICE(dev),\n\n                 &usb_msd_scsi_info_bot, NULL);\n\n    s->bus.qbus.allow_hotplug = 0;\n\n    usb_msd_handle_reset(dev);\n\n}\n", "idx": 10735}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline uint8_t *ram_chunk_start(const RDMALocalBlock *rdma_ram_block,\n\n                                       uint64_t i)\n\n{\n\n    return (uint8_t *) (((uintptr_t) rdma_ram_block->local_host_addr)\n\n                                    + (i << RDMA_REG_CHUNK_SHIFT));\n\n}\n", "idx": 10744}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int ahci_populate_sglist(AHCIDevice *ad, QEMUSGList *sglist, int offset)\n\n{\n\n    AHCICmdHdr *cmd = ad->cur_cmd;\n\n    uint32_t opts = le32_to_cpu(cmd->opts);\n\n    uint64_t prdt_addr = le64_to_cpu(cmd->tbl_addr) + 0x80;\n\n    int sglist_alloc_hint = opts >> AHCI_CMD_HDR_PRDT_LEN;\n\n    dma_addr_t prdt_len = (sglist_alloc_hint * sizeof(AHCI_SG));\n\n    dma_addr_t real_prdt_len = prdt_len;\n\n    uint8_t *prdt;\n\n    int i;\n\n    int r = 0;\n\n    int sum = 0;\n\n    int off_idx = -1;\n\n    int off_pos = -1;\n\n    int tbl_entry_size;\n\n    IDEBus *bus = &ad->port;\n\n    BusState *qbus = BUS(bus);\n\n\n\n    if (!sglist_alloc_hint) {\n\n        DPRINTF(ad->port_no, \"no sg list given by guest: 0x%08x\\n\", opts);\n\n        return -1;\n\n    }\n\n\n\n    /* map PRDT */\n\n    if (!(prdt = dma_memory_map(ad->hba->as, prdt_addr, &prdt_len,\n\n                                DMA_DIRECTION_TO_DEVICE))){\n\n        DPRINTF(ad->port_no, \"map failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if (prdt_len < real_prdt_len) {\n\n        DPRINTF(ad->port_no, \"mapped less than expected\\n\");\n\n        r = -1;\n\n        goto out;\n\n    }\n\n\n\n    /* Get entries in the PRDT, init a qemu sglist accordingly */\n\n    if (sglist_alloc_hint > 0) {\n\n        AHCI_SG *tbl = (AHCI_SG *)prdt;\n\n        sum = 0;\n\n        for (i = 0; i < sglist_alloc_hint; i++) {\n\n            /* flags_size is zero-based */\n\n            tbl_entry_size = (le32_to_cpu(tbl[i].flags_size) + 1);\n\n            if (offset <= (sum + tbl_entry_size)) {\n\n                off_idx = i;\n\n                off_pos = offset - sum;\n\n                break;\n\n            }\n\n            sum += tbl_entry_size;\n\n        }\n\n        if ((off_idx == -1) || (off_pos < 0) || (off_pos > tbl_entry_size)) {\n\n            DPRINTF(ad->port_no, \"%s: Incorrect offset! \"\n\n                            \"off_idx: %d, off_pos: %d\\n\",\n\n                            __func__, off_idx, off_pos);\n\n            r = -1;\n\n            goto out;\n\n        }\n\n\n\n        qemu_sglist_init(sglist, qbus->parent, (sglist_alloc_hint - off_idx),\n\n                         ad->hba->as);\n\n        qemu_sglist_add(sglist, le64_to_cpu(tbl[off_idx].addr + off_pos),\n\n                        le32_to_cpu(tbl[off_idx].flags_size) + 1 - off_pos);\n\n\n\n        for (i = off_idx + 1; i < sglist_alloc_hint; i++) {\n\n            /* flags_size is zero-based */\n\n            qemu_sglist_add(sglist, le64_to_cpu(tbl[i].addr),\n\n                            le32_to_cpu(tbl[i].flags_size) + 1);\n\n        }\n\n    }\n\n\n\nout:\n\n    dma_memory_unmap(ad->hba->as, prdt, prdt_len,\n\n                     DMA_DIRECTION_TO_DEVICE, prdt_len);\n\n    return r;\n\n}\n", "idx": 10801}, {"project": "test", "commit_id": "test", "target": 1, "func": "void rgb15tobgr15(const uint8_t *src, uint8_t *dst, unsigned int src_size)\n\n{\n\n\tunsigned i;\n\n\tunsigned num_pixels = src_size >> 1;\n\n\t\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t    unsigned b,g,r;\n\n\t    register uint16_t rgb;\n\n\t    rgb = src[2*i];\n\n\t    r = rgb&0x1F;\n\n\t    g = (rgb&0x3E0)>>5;\n\n\t    b = (rgb&0x7C00)>>10;\n\n\t    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);\n\n\t}\n\n}\n", "idx": 10849}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int lag_decode_prob(GetBitContext *gb, uint32_t *value)\n\n{\n\n    static const uint8_t series[] = { 1, 2, 3, 5, 8, 13, 21 };\n\n    int i;\n\n    int bit     = 0;\n\n    int bits    = 0;\n\n    int prevbit = 0;\n\n    unsigned val;\n\n\n\n    for (i = 0; i < 7; i++) {\n\n        if (prevbit && bit)\n\n            break;\n\n        prevbit = bit;\n\n        bit = get_bits1(gb);\n\n        if (bit && !prevbit)\n\n            bits += series[i];\n\n    }\n\n    bits--;\n\n    if (bits < 0 || bits > 31) {\n\n        *value = 0;\n\n        return -1;\n\n    } else if (bits == 0) {\n\n        *value = 0;\n\n        return 0;\n\n    }\n\n\n\n    val  = get_bits_long(gb, bits);\n\n    val |= 1 << bits;\n\n\n\n    *value = val - 1;\n\n\n\n    return 0;\n\n}\n", "idx": 10868}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void unix_wait_for_connect(int fd, Error *err, void *opaque)\n\n{\n\n    MigrationState *s = opaque;\n\n\n\n    if (fd < 0) {\n\n        DPRINTF(\"migrate connect error: %s\\n\", error_get_pretty(err));\n\n        s->file = NULL;\n\n        migrate_fd_error(s);\n\n    } else {\n\n        DPRINTF(\"migrate connect success\\n\");\n\n        s->file = qemu_fopen_socket(fd, \"wb\");\n\n        migrate_fd_connect(s);\n\n    }\n\n}\n", "idx": 10914}, {"project": "test", "commit_id": "test", "target": 1, "func": "int ff_h264_decode_picture_parameter_set(GetBitContext *gb, AVCodecContext *avctx,\n                                         H264ParamSets *ps, int bit_length)\n{\n    AVBufferRef *pps_buf;\n    const SPS *sps;\n    unsigned int pps_id = get_ue_golomb(gb);\n    PPS *pps;\n    int qp_bd_offset;\n    int bits_left;\n    int ret;\n    if (pps_id >= MAX_PPS_COUNT) {\n        av_log(avctx, AV_LOG_ERROR, \"pps_id %u out of range\\n\", pps_id);\n        return AVERROR_INVALIDDATA;\n    pps_buf = av_buffer_allocz(sizeof(*pps));\n    if (!pps_buf)\n        return AVERROR(ENOMEM);\n    pps = (PPS*)pps_buf->data;\n    pps->data_size = gb->buffer_end - gb->buffer;\n    if (pps->data_size > sizeof(pps->data)) {\n        av_log(avctx, AV_LOG_WARNING, \"Truncating likely oversized PPS \"\n               \"(%\"SIZE_SPECIFIER\" > %\"SIZE_SPECIFIER\")\\n\",\n               pps->data_size, sizeof(pps->data));\n        pps->data_size = sizeof(pps->data);\n    memcpy(pps->data, gb->buffer, pps->data_size);\n    pps->sps_id = get_ue_golomb_31(gb);\n    if ((unsigned)pps->sps_id >= MAX_SPS_COUNT ||\n        !ps->sps_list[pps->sps_id]) {\n        av_log(avctx, AV_LOG_ERROR, \"sps_id %u out of range\\n\", pps->sps_id);\n    sps = (const SPS*)ps->sps_list[pps->sps_id]->data;\n    if (sps->bit_depth_luma > 14) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Invalid luma bit depth=%d\\n\",\n               sps->bit_depth_luma);\n    } else if (sps->bit_depth_luma == 11 || sps->bit_depth_luma == 13) {\n        av_log(avctx, AV_LOG_ERROR,\n               \"Unimplemented luma bit depth=%d\\n\",\n               sps->bit_depth_luma);\n        ret = AVERROR_PATCHWELCOME;\n    pps->cabac             = get_bits1(gb);\n    pps->pic_order_present = get_bits1(gb);\n    pps->slice_group_count = get_ue_golomb(gb) + 1;\n    if (pps->slice_group_count > 1) {\n        pps->mb_slice_group_map_type = get_ue_golomb(gb);\n        av_log(avctx, AV_LOG_ERROR, \"FMO not supported\\n\");\n        switch (pps->mb_slice_group_map_type) {\n        case 0:\n#if 0\n    |       for (i = 0; i <= num_slice_groups_minus1; i++)  |   |      |\n    |           run_length[i]                               |1  |ue(v) |\n#endif\n            break;\n        case 2:\n#if 0\n    |       for (i = 0; i < num_slice_groups_minus1; i++) { |   |      |\n    |           top_left_mb[i]                              |1  |ue(v) |\n    |           bottom_right_mb[i]                          |1  |ue(v) |\n    |       }                                               |   |      |\n#endif\n            break;\n        case 3:\n        case 4:\n        case 5:\n#if 0\n    |       slice_group_change_direction_flag               |1  |u(1)  |\n    |       slice_group_change_rate_minus1                  |1  |ue(v) |\n#endif\n            break;\n        case 6:\n#if 0\n    |       slice_group_id_cnt_minus1                       |1  |ue(v) |\n    |       for (i = 0; i <= slice_group_id_cnt_minus1; i++)|   |      |\n    |           slice_group_id[i]                           |1  |u(v)  |\n#endif\n            break;\n    pps->ref_count[0] = get_ue_golomb(gb) + 1;\n    pps->ref_count[1] = get_ue_golomb(gb) + 1;\n    if (pps->ref_count[0] - 1 > 32 - 1 || pps->ref_count[1] - 1 > 32 - 1) {\n        av_log(avctx, AV_LOG_ERROR, \"reference overflow (pps)\\n\");\n    qp_bd_offset = 6 * (sps->bit_depth_luma - 8);\n    pps->weighted_pred                        = get_bits1(gb);\n    pps->weighted_bipred_idc                  = get_bits(gb, 2);\n    pps->init_qp                              = get_se_golomb(gb) + 26 + qp_bd_offset;\n    pps->init_qs                              = get_se_golomb(gb) + 26 + qp_bd_offset;\n    pps->chroma_qp_index_offset[0]            = get_se_golomb(gb);\n    pps->deblocking_filter_parameters_present = get_bits1(gb);\n    pps->constrained_intra_pred               = get_bits1(gb);\n    pps->redundant_pic_cnt_present            = get_bits1(gb);\n    pps->transform_8x8_mode = 0;\n    memcpy(pps->scaling_matrix4, sps->scaling_matrix4,\n           sizeof(pps->scaling_matrix4));\n    memcpy(pps->scaling_matrix8, sps->scaling_matrix8,\n           sizeof(pps->scaling_matrix8));\n    bits_left = bit_length - get_bits_count(gb);\n    if (bits_left > 0 && more_rbsp_data_in_pps(sps, avctx)) {\n        pps->transform_8x8_mode = get_bits1(gb);\n        decode_scaling_matrices(gb, sps, pps, 0,\n                                pps->scaling_matrix4, pps->scaling_matrix8);\n        // second_chroma_qp_index_offset\n        pps->chroma_qp_index_offset[1] = get_se_golomb(gb);\n        if (pps->chroma_qp_index_offset[1] < -12 || pps->chroma_qp_index_offset[1] > 12) {\n    } else {\n        pps->chroma_qp_index_offset[1] = pps->chroma_qp_index_offset[0];\n    build_qp_table(pps, 0, pps->chroma_qp_index_offset[0],\n                   sps->bit_depth_luma);\n    build_qp_table(pps, 1, pps->chroma_qp_index_offset[1],\n                   sps->bit_depth_luma);\n    init_dequant_tables(pps, sps);\n    if (pps->chroma_qp_index_offset[0] != pps->chroma_qp_index_offset[1])\n        pps->chroma_qp_diff = 1;\n    if (avctx->debug & FF_DEBUG_PICT_INFO) {\n        av_log(avctx, AV_LOG_DEBUG,\n               \"pps:%u sps:%u %s slice_groups:%d ref:%u/%u %s qp:%d/%d/%d/%d %s %s %s %s\\n\",\n               pps_id, pps->sps_id,\n               pps->cabac ? \"CABAC\" : \"CAVLC\",\n               pps->slice_group_count,\n               pps->ref_count[0], pps->ref_count[1],\n               pps->weighted_pred ? \"weighted\" : \"\",\n               pps->init_qp, pps->init_qs, pps->chroma_qp_index_offset[0], pps->chroma_qp_index_offset[1],\n               pps->deblocking_filter_parameters_present ? \"LPAR\" : \"\",\n               pps->constrained_intra_pred ? \"CONSTR\" : \"\",\n               pps->redundant_pic_cnt_present ? \"REDU\" : \"\",\n               pps->transform_8x8_mode ? \"8x8DCT\" : \"\");\n    remove_pps(ps, pps_id);\n    ps->pps_list[pps_id] = pps_buf;\n    return 0;\nfail:\n    av_buffer_unref(&pps_buf);\n    return ret;", "idx": 10971}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void test_flush_nodev(void)\n\n{\n\n    QPCIDevice *dev;\n\n    QPCIBar bmdma_bar, ide_bar;\n\n\n\n    ide_test_start(\"\");\n\n\n\n    dev = get_pci_device(&bmdma_bar, &ide_bar);\n\n\n\n    /* FLUSH CACHE command on device 0*/\n\n    qpci_io_writeb(dev, ide_bar, reg_device, 0);\n\n    qpci_io_writeb(dev, ide_bar, reg_command, CMD_FLUSH_CACHE);\n\n\n\n    /* Just testing that qemu doesn't crash... */\n\n\n\n\n    ide_test_quit();\n\n}", "idx": 11046}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void get_sensor_evt_enable(IPMIBmcSim *ibs,\n\n                                  uint8_t *cmd, unsigned int cmd_len,\n\n                                  uint8_t *rsp, unsigned int *rsp_len,\n\n                                  unsigned int max_rsp_len)\n\n{\n\n    IPMISensor *sens;\n\n\n\n    IPMI_CHECK_CMD_LEN(3);\n\n    if ((cmd[2] > MAX_SENSORS) ||\n\n        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {\n\n        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;\n\n        return;\n\n    }\n\n    sens = ibs->sensors + cmd[2];\n\n    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));\n\n    IPMI_ADD_RSP_DATA(sens->assert_enable & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->assert_enable >> 8) & 0xff);\n\n    IPMI_ADD_RSP_DATA(sens->deassert_enable & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->deassert_enable >> 8) & 0xff);\n\n}\n", "idx": 11202}, {"project": "test", "commit_id": "test", "target": 1, "func": "struct omap_uart_s *omap_uart_init(hwaddr base,\n\n                qemu_irq irq, omap_clk fclk, omap_clk iclk,\n\n                qemu_irq txdma, qemu_irq rxdma,\n\n                const char *label, CharDriverState *chr)\n\n{\n\n    struct omap_uart_s *s = (struct omap_uart_s *)\n\n            g_malloc0(sizeof(struct omap_uart_s));\n\n\n\n    s->base = base;\n\n    s->fclk = fclk;\n\n    s->irq = irq;\n\n    s->serial = serial_mm_init(get_system_memory(), base, 2, irq,\n\n                               omap_clk_getrate(fclk)/16,\n\n                               chr ?: qemu_chr_new(label, \"null\", NULL),\n\n                               DEVICE_NATIVE_ENDIAN);\n\n    return s;\n\n}\n", "idx": 11235}, {"project": "test", "commit_id": "test", "target": 1, "func": "int xbzrle_encode_buffer(uint8_t *old_buf, uint8_t *new_buf, int slen,\n\n                         uint8_t *dst, int dlen)\n\n{\n\n    uint32_t zrun_len = 0, nzrun_len = 0;\n\n    int d = 0, i = 0;\n\n    long res, xor;\n\n    uint8_t *nzrun_start = NULL;\n\n\n\n    g_assert(!(((uintptr_t)old_buf | (uintptr_t)new_buf | slen) %\n\n               sizeof(long)));\n\n\n\n    while (i < slen) {\n\n        /* overflow */\n\n        if (d + 2 > dlen) {\n\n            return -1;\n\n        }\n\n\n\n        /* not aligned to sizeof(long) */\n\n        res = (slen - i) % sizeof(long);\n\n        while (res && old_buf[i] == new_buf[i]) {\n\n            zrun_len++;\n\n            i++;\n\n            res--;\n\n        }\n\n\n\n        /* word at a time for speed */\n\n        if (!res) {\n\n            while (i < slen &&\n\n                   (*(long *)(old_buf + i)) == (*(long *)(new_buf + i))) {\n\n                i += sizeof(long);\n\n                zrun_len += sizeof(long);\n\n            }\n\n\n\n            /* go over the rest */\n\n            while (i < slen && old_buf[i] == new_buf[i]) {\n\n                zrun_len++;\n\n                i++;\n\n            }\n\n        }\n\n\n\n        /* buffer unchanged */\n\n        if (zrun_len == slen) {\n\n            return 0;\n\n        }\n\n\n\n        /* skip last zero run */\n\n        if (i == slen) {\n\n            return d;\n\n        }\n\n\n\n        d += uleb128_encode_small(dst + d, zrun_len);\n\n\n\n        zrun_len = 0;\n\n        nzrun_start = new_buf + i;\n\n\n\n        /* overflow */\n\n        if (d + 2 > dlen) {\n\n            return -1;\n\n        }\n\n        /* not aligned to sizeof(long) */\n\n        res = (slen - i) % sizeof(long);\n\n        while (res && old_buf[i] != new_buf[i]) {\n\n            i++;\n\n            nzrun_len++;\n\n            res--;\n\n        }\n\n\n\n        /* word at a time for speed, use of 32-bit long okay */\n\n        if (!res) {\n\n            /* truncation to 32-bit long okay */\n\n            long mask = (long)0x0101010101010101ULL;\n\n            while (i < slen) {\n\n                xor = *(long *)(old_buf + i) ^ *(long *)(new_buf + i);\n\n                if ((xor - mask) & ~xor & (mask << 7)) {\n\n                    /* found the end of an nzrun within the current long */\n\n                    while (old_buf[i] != new_buf[i]) {\n\n                        nzrun_len++;\n\n                        i++;\n\n                    }\n\n                    break;\n\n                } else {\n\n                    i += sizeof(long);\n\n                    nzrun_len += sizeof(long);\n\n                }\n\n            }\n\n        }\n\n\n\n        d += uleb128_encode_small(dst + d, nzrun_len);\n\n        /* overflow */\n\n        if (d + nzrun_len > dlen) {\n\n            return -1;\n\n        }\n\n        memcpy(dst + d, nzrun_start, nzrun_len);\n\n        d += nzrun_len;\n\n        nzrun_len = 0;\n\n    }\n\n\n\n    return d;\n\n}\n", "idx": 11359}, {"project": "test", "commit_id": "test", "target": 1, "func": "void qmp_migrate_cancel(Error **errp)\n\n{\n\n    migrate_fd_cancel(migrate_get_current());\n\n}\n", "idx": 11449}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline int get_block(GetBitContext *gb, DCTELEM *block, const uint8_t *scan,\n\n                            const uint32_t *quant) {\n\n    int coeff, i, n;\n\n    int8_t ac;\n\n    uint8_t dc = get_bits(gb, 8);\n\n\n\n    // block not coded\n\n    if (dc == 255)\n\n\n\n\n    // number of non-zero coefficients\n\n    coeff = get_bits(gb, 6);\n\n    if (get_bits_count(gb) + (coeff << 1) >= gb->size_in_bits)\n\n\n\n\n    // normally we would only need to clear the (63 - coeff) last values,\n\n    // but since we do not know where they are we just clear the whole block\n\n    memset(block, 0, 64 * sizeof(DCTELEM));\n\n\n\n    // 2 bits per coefficient\n\n    while (coeff) {\n\n        ac = get_sbits(gb, 2);\n\n        if (ac == -2)\n\n            break; // continue with more bits\n\n        PUT_COEFF(ac);\n\n    }\n\n\n\n    // 4 bits per coefficient\n\n    ALIGN(4);\n\n\n\n    while (coeff) {\n\n        ac = get_sbits(gb, 4);\n\n        if (ac == -8)\n\n            break; // continue with more bits\n\n        PUT_COEFF(ac);\n\n    }\n\n\n\n    // 8 bits per coefficient\n\n    ALIGN(8);\n\n    if (get_bits_count(gb) + (coeff << 3) >= gb->size_in_bits)\n\n\n    while (coeff) {\n\n        ac = get_sbits(gb, 8);\n\n        PUT_COEFF(ac);\n\n    }\n\n\n\n    PUT_COEFF(dc);\n\n    return 1;\n\n}", "idx": 11543}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void ehci_free_packet(EHCIPacket *p)\n\n{\n\n    trace_usb_ehci_packet_action(p->queue, p, \"free\");\n\n    if (p->async == EHCI_ASYNC_INFLIGHT) {\n\n        usb_cancel_packet(&p->packet);\n\n        usb_packet_unmap(&p->packet, &p->sgl);\n\n        qemu_sglist_destroy(&p->sgl);\n\n\n\n\n\n\n\n\n\n\n\n\n    QTAILQ_REMOVE(&p->queue->packets, p, next);\n\n    usb_packet_cleanup(&p->packet);\n\n    g_free(p);\n", "idx": 11646}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int pcm_decode_frame(AVCodecContext *avctx,\n                            void *data, int *data_size,\n                            AVPacket *avpkt)\n{\n    const uint8_t *buf = avpkt->data;\n    int buf_size = avpkt->size;\n    PCMDecode *s = avctx->priv_data;\n    int sample_size, c, n, i;\n    short *samples;\n    const uint8_t *src, *src8, *src2[MAX_CHANNELS];\n    uint8_t *dstu8;\n    int16_t *dst_int16_t;\n    int32_t *dst_int32_t;\n    int64_t *dst_int64_t;\n    uint16_t *dst_uint16_t;\n    uint32_t *dst_uint32_t;\n    samples = data;\n    src = buf;\n    if (avctx->sample_fmt!=avctx->codec->sample_fmts[0]) {\n        av_log(avctx, AV_LOG_ERROR, \"invalid sample_fmt\\n\");\n        return -1;\n    if(avctx->channels <= 0 || avctx->channels > MAX_CHANNELS){\n        av_log(avctx, AV_LOG_ERROR, \"PCM channels out of bounds\\n\");\n        return -1;\n    sample_size = av_get_bits_per_sample(avctx->codec_id)/8;\n    /* av_get_bits_per_sample returns 0 for CODEC_ID_PCM_DVD */\n    if (CODEC_ID_PCM_DVD == avctx->codec_id)\n        /* 2 samples are interleaved per block in PCM_DVD */\n        sample_size = avctx->bits_per_coded_sample * 2 / 8;\n    else if (avctx->codec_id == CODEC_ID_PCM_LXF)\n        /* we process 40-bit blocks per channel for LXF */\n        sample_size = 5;\n    n = avctx->channels * sample_size;\n    if(n && buf_size % n){\n        if (buf_size < n) {\n            av_log(avctx, AV_LOG_ERROR, \"invalid PCM packet\\n\");\n            return -1;\n        }else\n            buf_size -= buf_size % n;\n    buf_size= FFMIN(buf_size, *data_size/2);\n    *data_size=0;\n    n = buf_size/sample_size;\n    switch(avctx->codec->id) {\n    case CODEC_ID_PCM_U32LE:\n        DECODE(uint32_t, le32, src, samples, n, 0, 0x80000000)\n        break;\n    case CODEC_ID_PCM_U32BE:\n        DECODE(uint32_t, be32, src, samples, n, 0, 0x80000000)\n        break;\n    case CODEC_ID_PCM_S24LE:\n        DECODE(int32_t, le24, src, samples, n, 8, 0)\n        break;\n    case CODEC_ID_PCM_S24BE:\n        DECODE(int32_t, be24, src, samples, n, 8, 0)\n        break;\n    case CODEC_ID_PCM_U24LE:\n        DECODE(uint32_t, le24, src, samples, n, 8, 0x800000)\n        break;\n    case CODEC_ID_PCM_U24BE:\n        DECODE(uint32_t, be24, src, samples, n, 8, 0x800000)\n        break;\n    case CODEC_ID_PCM_S24DAUD:\n        for(;n>0;n--) {\n          uint32_t v = bytestream_get_be24(&src);\n          v >>= 4; // sync flags are here\n          *samples++ = av_reverse[(v >> 8) & 0xff] +\n                       (av_reverse[v & 0xff] << 8);\n        break;\n    case CODEC_ID_PCM_S16LE_PLANAR:\n        n /= avctx->channels;\n        for(c=0;c<avctx->channels;c++)\n            src2[c] = &src[c*n*2];\n        for(;n>0;n--)\n            for(c=0;c<avctx->channels;c++)\n                *samples++ = bytestream_get_le16(&src2[c]);\n        src = src2[avctx->channels-1];\n        break;\n    case CODEC_ID_PCM_U16LE:\n        DECODE(uint16_t, le16, src, samples, n, 0, 0x8000)\n        break;\n    case CODEC_ID_PCM_U16BE:\n        DECODE(uint16_t, be16, src, samples, n, 0, 0x8000)\n        break;\n    case CODEC_ID_PCM_S8:\n        dstu8= (uint8_t*)samples;\n        for(;n>0;n--) {\n            *dstu8++ = *src++ + 128;\n        samples= (short*)dstu8;\n        break;\n#if HAVE_BIGENDIAN\n    case CODEC_ID_PCM_F64LE:\n        DECODE(int64_t, le64, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_S32LE:\n    case CODEC_ID_PCM_F32LE:\n        DECODE(int32_t, le32, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_S16LE:\n        DECODE(int16_t, le16, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_F64BE:\n    case CODEC_ID_PCM_F32BE:\n    case CODEC_ID_PCM_S32BE:\n    case CODEC_ID_PCM_S16BE:\n#else\n    case CODEC_ID_PCM_F64BE:\n        DECODE(int64_t, be64, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_F32BE:\n    case CODEC_ID_PCM_S32BE:\n        DECODE(int32_t, be32, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_S16BE:\n        DECODE(int16_t, be16, src, samples, n, 0, 0)\n        break;\n    case CODEC_ID_PCM_F64LE:\n    case CODEC_ID_PCM_F32LE:\n    case CODEC_ID_PCM_S32LE:\n    case CODEC_ID_PCM_S16LE:\n#endif /* HAVE_BIGENDIAN */\n    case CODEC_ID_PCM_U8:\n        memcpy(samples, src, n*sample_size);\n        src += n*sample_size;\n        samples = (short*)((uint8_t*)data + n*sample_size);\n        break;\n    case CODEC_ID_PCM_ZORK:\n        for(;n>0;n--) {\n            int x= *src++;\n            if(x&128) x-= 128;\n            else      x = -x;\n            *samples++ = x << 8;\n        break;\n    case CODEC_ID_PCM_ALAW:\n    case CODEC_ID_PCM_MULAW:\n        for(;n>0;n--) {\n            *samples++ = s->table[*src++];\n        break;\n    case CODEC_ID_PCM_DVD:\n        dst_int32_t = data;\n        n /= avctx->channels;\n        switch (avctx->bits_per_coded_sample) {\n        case 20:\n            while (n--) {\n                c = avctx->channels;\n                src8 = src + 4*c;\n                while (c--) {\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8   &0xf0) << 8);\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++ &0x0f) << 12);\n                src = src8;\n            break;\n        case 24:\n            while (n--) {\n                c = avctx->channels;\n                src8 = src + 4*c;\n                while (c--) {\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n                    *dst_int32_t++ = (bytestream_get_be16(&src) << 16) + ((*src8++) << 8);\n                src = src8;\n            break;\n        default:\n            av_log(avctx, AV_LOG_ERROR, \"PCM DVD unsupported sample depth\\n\");\n            return -1;\n            break;\n        samples = (short *) dst_int32_t;\n        break;\n    case CODEC_ID_PCM_LXF:\n        dst_int32_t = data;\n        n /= avctx->channels;\n        //unpack and de-planerize\n        for (i = 0; i < n; i++) {\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n                //extract low 20 bits and expand to 32 bits\n                *dst_int32_t++ = (src8[2] << 28) | (src8[1] << 20) | (src8[0] << 12) |\n                                 ((src8[2] & 0xF) << 8) | src8[1];\n            for (c = 0, src8 = src + i*5; c < avctx->channels; c++, src8 += n*5) {\n                //extract high 20 bits and expand to 32 bits\n                *dst_int32_t++ = (src8[4] << 24) | (src8[3] << 16) |\n                                 ((src8[2] & 0xF0) << 8) | (src8[4] << 4) | (src8[3] >> 4);\n        src += n * avctx->channels * 5;\n        samples = (short *) dst_int32_t;\n        break;\n    default:\n        return -1;\n    *data_size = (uint8_t *)samples - (uint8_t *)data;\n    return src - buf;", "idx": 11712}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int esp_pci_scsi_init(PCIDevice *dev)\n\n{\n\n    PCIESPState *pci = PCI_ESP(dev);\n\n    DeviceState *d = DEVICE(dev);\n\n    ESPState *s = &pci->esp;\n\n    uint8_t *pci_conf;\n\n    Error *err = NULL;\n\n\n\n    pci_conf = dev->config;\n\n\n\n    /* Interrupt pin A */\n\n    pci_conf[PCI_INTERRUPT_PIN] = 0x01;\n\n\n\n    s->dma_memory_read = esp_pci_dma_memory_read;\n\n    s->dma_memory_write = esp_pci_dma_memory_write;\n\n    s->dma_opaque = pci;\n\n    s->chip_id = TCHI_AM53C974;\n\n    memory_region_init_io(&pci->io, OBJECT(pci), &esp_pci_io_ops, pci,\n\n                          \"esp-io\", 0x80);\n\n\n\n    pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &pci->io);\n\n    s->irq = pci_allocate_irq(dev);\n\n\n\n    scsi_bus_new(&s->bus, sizeof(s->bus), d, &esp_pci_scsi_info, NULL);\n\n    if (!d->hotplugged) {\n\n        scsi_bus_legacy_handle_cmdline(&s->bus, &err);\n\n        if (err != NULL) {\n\n\n            error_free(err);\n\n            return -1;\n\n        }\n\n    }\n\n    return 0;\n\n}", "idx": 11748}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void copy_frame(Jpeg2000EncoderContext *s)\n\n{\n\n    int tileno, compno, i, y, x;\n\n    uint8_t *line;\n\n    for (tileno = 0; tileno < s->numXtiles * s->numYtiles; tileno++){\n\n        Jpeg2000Tile *tile = s->tile + tileno;\n\n        if (s->planar){\n\n            for (compno = 0; compno < s->ncomponents; compno++){\n\n                Jpeg2000Component *comp = tile->comp + compno;\n\n                int *dst = comp->data;\n\n                line = s->picture.data[compno]\n\n                       + comp->coord[1][0] * s->picture.linesize[compno]\n\n                       + comp->coord[0][0];\n\n                for (y = comp->coord[1][0]; y < comp->coord[1][1]; y++){\n\n                    uint8_t *ptr = line;\n\n                    for (x = comp->coord[0][0]; x < comp->coord[0][1]; x++)\n\n                        *dst++ = *ptr++ - (1 << 7);\n\n                    line += s->picture.linesize[compno];\n\n                }\n\n            }\n\n        } else{\n\n            line = s->picture.data[0] + tile->comp[0].coord[1][0] * s->picture.linesize[0]\n\n                   + tile->comp[0].coord[0][0] * s->ncomponents;\n\n\n\n            i = 0;\n\n            for (y = tile->comp[0].coord[1][0]; y < tile->comp[0].coord[1][1]; y++){\n\n                uint8_t *ptr = line;\n\n                for (x = tile->comp[0].coord[0][0]; x < tile->comp[0].coord[0][1]; x++, i++){\n\n                    for (compno = 0; compno < s->ncomponents; compno++){\n\n                        tile->comp[compno].data[i] = *ptr++  - (1 << 7);\n\n                    }\n\n                }\n\n                line += s->picture.linesize[0];\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 11749}, {"project": "test", "commit_id": "test", "target": 1, "func": "int64_t av_get_int(void *obj, const char *name, const AVOption **o_out)\n\n{\n\n    int64_t intnum=1;\n\n    double num=1;\n\n    int den=1;\n\n\n\n    av_get_number(obj, name, o_out, &num, &den, &intnum);\n\n    return num*intnum/den;\n\n}\n", "idx": 11806}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int zero12v_decode_frame(AVCodecContext *avctx, void *data,\n\n                                int *got_frame, AVPacket *avpkt)\n\n{\n\n    int line = 0, ret;\n\n    const int width = avctx->width;\n\n    AVFrame *pic = data;\n\n    uint16_t *y, *u, *v;\n\n    const uint8_t *line_end, *src = avpkt->data;\n\n    int stride = avctx->width * 8 / 3;\n\n\n\n    if (width == 1) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Width 1 not supported.\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if (   avctx->codec_tag == MKTAG('0', '1', '2', 'v')\n\n        && avpkt->size % avctx->height == 0\n\n        && avpkt->size / avctx->height * 3 >= width * 8)\n\n        stride = avpkt->size / avctx->height;\n\n\n\n    if (avpkt->size < avctx->height * stride) {\n\n        av_log(avctx, AV_LOG_ERROR, \"Packet too small: %d instead of %d\\n\",\n\n               avpkt->size, avctx->height * stride);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if ((ret = ff_get_buffer(avctx, pic, 0)) < 0)\n\n        return ret;\n\n\n\n    pic->pict_type = AV_PICTURE_TYPE_I;\n\n    pic->key_frame = 1;\n\n\n\n    y = (uint16_t *)pic->data[0];\n\n    u = (uint16_t *)pic->data[1];\n\n    v = (uint16_t *)pic->data[2];\n\n    line_end = avpkt->data + stride;\n\n\n\n    while (line++ < avctx->height) {\n\n        while (1) {\n\n            uint32_t t = AV_RL32(src);\n\n            src += 4;\n\n            *u++ = t <<  6 & 0xFFC0;\n\n            *y++ = t >>  4 & 0xFFC0;\n\n            *v++ = t >> 14 & 0xFFC0;\n\n\n\n            if (src >= line_end - 1) {\n\n                *y = 0x80;\n\n                src++;\n\n                line_end += stride;\n\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n\n                break;\n\n            }\n\n\n\n            t = AV_RL32(src);\n\n            src += 4;\n\n            *y++ = t <<  6 & 0xFFC0;\n\n            *u++ = t >>  4 & 0xFFC0;\n\n            *y++ = t >> 14 & 0xFFC0;\n\n            if (src >= line_end - 2) {\n\n                if (!(width & 1)) {\n\n                    *y = 0x80;\n\n                    src += 2;\n\n                }\n\n                line_end += stride;\n\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n\n                break;\n\n            }\n\n\n\n            t = AV_RL32(src);\n\n            src += 4;\n\n            *v++ = t <<  6 & 0xFFC0;\n\n            *y++ = t >>  4 & 0xFFC0;\n\n            *u++ = t >> 14 & 0xFFC0;\n\n\n\n            if (src >= line_end - 1) {\n\n                *y = 0x80;\n\n                src++;\n\n                line_end += stride;\n\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n\n                break;\n\n            }\n\n\n\n            t = AV_RL32(src);\n\n            src += 4;\n\n            *y++ = t <<  6 & 0xFFC0;\n\n            *v++ = t >>  4 & 0xFFC0;\n\n            *y++ = t >> 14 & 0xFFC0;\n\n\n\n            if (src >= line_end - 2) {\n\n                if (width & 1) {\n\n                    *y = 0x80;\n\n                    src += 2;\n\n                }\n\n                line_end += stride;\n\n                y = (uint16_t *)(pic->data[0] + line * pic->linesize[0]);\n\n                u = (uint16_t *)(pic->data[1] + line * pic->linesize[1]);\n\n                v = (uint16_t *)(pic->data[2] + line * pic->linesize[2]);\n\n                break;\n\n            }\n\n        }\n\n    }\n\n\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 11885}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void piix3_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    PCIDeviceClass *k = PCI_DEVICE_CLASS(klass);\n\n\n\n    dc->desc        = \"ISA bridge\";\n\n    dc->vmsd        = &vmstate_piix3;\n\n    dc->no_user     = 1,\n\n    k->no_hotplug   = 1;\n\n    k->init         = piix3_initfn;\n\n    k->config_write = piix3_write_config;\n\n    k->vendor_id    = PCI_VENDOR_ID_INTEL;\n\n    /* 82371SB PIIX3 PCI-to-ISA bridge (Step A1) */\n\n    k->device_id    = PCI_DEVICE_ID_INTEL_82371SB_0;\n\n    k->class_id     = PCI_CLASS_BRIDGE_ISA;\n\n}\n", "idx": 11933}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void qpci_pc_config_writew(QPCIBus *bus, int devfn, uint8_t offset, uint16_t value)\n\n{\n\n    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);\n\n    outw(0xcfc, value);\n\n}\n", "idx": 11980}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void gen_exception_return(DisasContext *s, TCGv_i32 pc)\n\n{\n\n    TCGv_i32 tmp;\n\n    store_reg(s, 15, pc);\n\n    tmp = load_cpu_field(spsr);\n\n    gen_set_cpsr(tmp, CPSR_ERET_MASK);\n\n    tcg_temp_free_i32(tmp);\n\n    s->is_jmp = DISAS_UPDATE;\n\n}\n", "idx": 11998}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void set_int8(Object *obj, Visitor *v, void *opaque,\n\n                     const char *name, Error **errp)\n\n{\n\n    DeviceState *dev = DEVICE(obj);\n\n    Property *prop = opaque;\n\n    int8_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    Error *local_err = NULL;\n\n    int64_t value;\n\n\n\n    if (dev->state != DEV_STATE_CREATED) {\n\n        error_set(errp, QERR_PERMISSION_DENIED);\n\n        return;\n\n    }\n\n\n\n    visit_type_int(v, &value, name, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    if (value > prop->info->min && value <= prop->info->max) {\n\n        *ptr = value;\n\n    } else {\n\n        error_set(errp, QERR_PROPERTY_VALUE_OUT_OF_RANGE,\n\n                  dev->id?:\"\", name, value, prop->info->min,\n\n                  prop->info->max);\n\n    }\n\n}\n", "idx": 12083}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void enter_migration_coroutine(void *opaque)\n\n{\n\n    Coroutine *co = opaque;\n\n    qemu_coroutine_enter(co, NULL);\n\n}\n", "idx": 12086}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int decode_channel_residues(WmallDecodeCtx *s, int ch, int tile_size)\n\n{\n\n    int i = 0;\n\n    unsigned int ave_mean;\n\n    s->transient[ch] = get_bits1(&s->gb);\n\n    if (s->transient[ch]) {\n\n        s->transient_pos[ch] = get_bits(&s->gb, av_log2(tile_size));\n\n        if (s->transient_pos[ch])\n\n            s->transient[ch] = 0;\n\n        s->channel[ch].transient_counter =\n\n            FFMAX(s->channel[ch].transient_counter, s->samples_per_frame / 2);\n\n    } else if (s->channel[ch].transient_counter)\n\n        s->transient[ch] = 1;\n\n\n\n    if (s->seekable_tile) {\n\n        ave_mean = get_bits(&s->gb, s->bits_per_sample);\n\n        s->ave_sum[ch] = ave_mean << (s->movave_scaling + 1);\n\n    }\n\n\n\n    if (s->seekable_tile) {\n\n        if (s->do_inter_ch_decorr)\n\n            s->channel_residues[ch][0] = get_sbits(&s->gb, s->bits_per_sample + 1);\n\n        else\n\n            s->channel_residues[ch][0] = get_sbits(&s->gb, s->bits_per_sample);\n\n        i++;\n\n    }\n\n    for (; i < tile_size; i++) {\n\n        int quo = 0, rem, rem_bits, residue;\n\n        while(get_bits1(&s->gb)) {\n\n            quo++;\n\n            if (get_bits_left(&s->gb) <= 0)\n\n                return -1;\n\n        }\n\n        if (quo >= 32)\n\n            quo += get_bits_long(&s->gb, get_bits(&s->gb, 5) + 1);\n\n\n\n        ave_mean = (s->ave_sum[ch] + (1 << s->movave_scaling)) >> (s->movave_scaling + 1);\n\n        if (ave_mean <= 1)\n\n            residue = quo;\n\n        else {\n\n            rem_bits = av_ceil_log2(ave_mean);\n\n            rem      = rem_bits ? get_bits(&s->gb, rem_bits) : 0;\n\n            residue  = (quo << rem_bits) + rem;\n\n        }\n\n\n\n        s->ave_sum[ch] = residue + s->ave_sum[ch] -\n\n                         (s->ave_sum[ch] >> s->movave_scaling);\n\n\n\n        if (residue & 1)\n\n            residue = -(residue >> 1) - 1;\n\n        else\n\n            residue = residue >> 1;\n\n        s->channel_residues[ch][i] = residue;\n\n    }\n\n\n\n    return 0;\n\n\n\n}\n", "idx": 12095}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int ram_init1(SysBusDevice *dev)\n\n{\n\n    RamDevice *d = SUN4U_RAM(dev);\n\n\n\n    memory_region_init_ram(&d->ram, OBJECT(d), \"sun4u.ram\", d->size,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&d->ram);\n\n    sysbus_init_mmio(dev, &d->ram);\n\n    return 0;\n\n}\n", "idx": 12200}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void stop_tco(const TestData *d)\n\n{\n\n    uint32_t val;\n\n\n\n    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);\n\n    val |= TCO_TMR_HLT;\n\n    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);\n\n}\n", "idx": 12205}, {"project": "test", "commit_id": "test", "target": 1, "func": "void qemu_put_be32(QEMUFile *f, unsigned int v)\n\n{\n\n    qemu_put_byte(f, v >> 24);\n\n    qemu_put_byte(f, v >> 16);\n\n    qemu_put_byte(f, v >> 8);\n\n    qemu_put_byte(f, v);\n\n}\n", "idx": 12215}, {"project": "test", "commit_id": "test", "target": 1, "func": "int av_parser_parse2(AVCodecParserContext *s, AVCodecContext *avctx,\n                     uint8_t **poutbuf, int *poutbuf_size,\n                     const uint8_t *buf, int buf_size,\n                     int64_t pts, int64_t dts, int64_t pos)\n{\n    int index, i;\n    uint8_t dummy_buf[AV_INPUT_BUFFER_PADDING_SIZE];\n    if (!(s->flags & PARSER_FLAG_FETCHED_OFFSET)) {\n        s->next_frame_offset =\n        s->cur_offset        = pos;\n        s->flags            |= PARSER_FLAG_FETCHED_OFFSET;\n    }\n    if (buf_size == 0) {\n        /* padding is always necessary even if EOF, so we add it here */\n        memset(dummy_buf, 0, sizeof(dummy_buf));\n        buf = dummy_buf;\n    } else if (s->cur_offset + buf_size != s->cur_frame_end[s->cur_frame_start_index]) { /* skip remainder packets */\n        /* add a new packet descriptor */\n        i = (s->cur_frame_start_index + 1) & (AV_PARSER_PTS_NB - 1);\n        s->cur_frame_start_index = i;\n        s->cur_frame_offset[i]   = s->cur_offset;\n        s->cur_frame_end[i]      = s->cur_offset + buf_size;\n        s->cur_frame_pts[i]      = pts;\n        s->cur_frame_dts[i]      = dts;\n        s->cur_frame_pos[i]      = pos;\n    }\n    if (s->fetch_timestamp) {\n        s->fetch_timestamp = 0;\n        s->last_pts        = s->pts;\n        s->last_dts        = s->dts;\n        s->last_pos        = s->pos;\n        ff_fetch_timestamp(s, 0, 0, 0);\n    }\n    /* WARNING: the returned index can be negative */\n    index = s->parser->parser_parse(s, avctx, (const uint8_t **) poutbuf,\n                                    poutbuf_size, buf, buf_size);\n    av_assert0(index > -0x20000000); // The API does not allow returning AVERROR codes\n    /* update the file pointer */\n    if (*poutbuf_size) {\n        /* fill the data for the current frame */\n        s->frame_offset = s->next_frame_offset;\n        /* offset of the next frame */\n        s->next_frame_offset = s->cur_offset + index;\n        s->fetch_timestamp   = 1;\n    }\n    if (index < 0)\n        index = 0;\n    s->cur_offset += index;\n    return index;\n}", "idx": 12255}, {"project": "test", "commit_id": "test", "target": 1, "func": "static AVIOContext * wtvfile_open2(AVFormatContext *s, const uint8_t *buf, int buf_size, const uint8_t *filename, int filename_size)\n\n{\n\n    const uint8_t *buf_end = buf + buf_size;\n\n\n\n    while(buf + 48 <= buf_end) {\n\n        int dir_length, name_size, first_sector, depth;\n\n        uint64_t file_length;\n\n        const uint8_t *name;\n\n        if (ff_guidcmp(buf, dir_entry_guid)) {\n\n            av_log(s, AV_LOG_ERROR, \"unknown guid \"FF_PRI_GUID\", expected dir_entry_guid; \"\n\n                   \"remaining directory entries ignored\\n\", FF_ARG_GUID(buf));\n\n            break;\n\n        }\n\n        dir_length  = AV_RL16(buf + 16);\n\n        file_length = AV_RL64(buf + 24);\n\n        name_size   = 2 * AV_RL32(buf + 32);\n\n        if (buf + 48 + name_size > buf_end) {\n\n            av_log(s, AV_LOG_ERROR, \"filename exceeds buffer size; remaining directory entries ignored\\n\");\n\n            break;\n\n        }\n\n        first_sector = AV_RL32(buf + 40 + name_size);\n\n        depth        = AV_RL32(buf + 44 + name_size);\n\n\n\n        /* compare file name; test optional null terminator */\n\n        name = buf + 40;\n\n        if (name_size >= filename_size &&\n\n            !memcmp(name, filename, filename_size) &&\n\n            (name_size < filename_size + 2 || !AV_RN16(name + filename_size)))\n\n            return wtvfile_open_sector(first_sector, file_length, depth, s);\n\n\n\n        buf += dir_length;\n\n    }\n\n    return 0;\n\n}\n", "idx": 12273}, {"project": "test", "commit_id": "test", "target": 1, "func": "struct omap_mmc_s *omap2_mmc_init(struct omap_target_agent_s *ta,\n\n                BlockDriverState *bd, qemu_irq irq, qemu_irq dma[],\n\n                omap_clk fclk, omap_clk iclk)\n\n{\n\n    struct omap_mmc_s *s = (struct omap_mmc_s *)\n\n            g_malloc0(sizeof(struct omap_mmc_s));\n\n\n\n    s->irq = irq;\n\n    s->dma = dma;\n\n    s->clk = fclk;\n\n    s->lines = 4;\n\n    s->rev = 2;\n\n\n\n    omap_mmc_reset(s);\n\n\n\n    memory_region_init_io(&s->iomem, NULL, &omap_mmc_ops, s, \"omap.mmc\",\n\n                          omap_l4_region_size(ta, 0));\n\n    omap_l4_attach(ta, 0, &s->iomem);\n\n\n\n    /* Instantiate the storage */\n\n    s->card = sd_init(bd, false);\n\n    if (s->card == NULL) {\n\n        exit(1);\n\n    }\n\n\n\n    s->cdet = qemu_allocate_irqs(omap_mmc_cover_cb, s, 1)[0];\n\n    sd_set_cb(s->card, NULL, s->cdet);\n\n\n\n    return s;\n\n}\n", "idx": 12499}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void vmxnet3_update_mcast_filters(VMXNET3State *s)\n\n{\n\n    uint16_t list_bytes =\n\n        VMXNET3_READ_DRV_SHARED16(s->drv_shmem,\n\n                                  devRead.rxFilterConf.mfTableLen);\n\n\n\n    s->mcast_list_len = list_bytes / sizeof(s->mcast_list[0]);\n\n\n\n    s->mcast_list = g_realloc(s->mcast_list, list_bytes);\n\n    if (!s->mcast_list) {\n\n        if (s->mcast_list_len == 0) {\n\n            VMW_CFPRN(\"Current multicast list is empty\");\n\n        } else {\n\n            VMW_ERPRN(\"Failed to allocate multicast list of %d elements\",\n\n                      s->mcast_list_len);\n\n        }\n\n        s->mcast_list_len = 0;\n\n    } else {\n\n        int i;\n\n        hwaddr mcast_list_pa =\n\n            VMXNET3_READ_DRV_SHARED64(s->drv_shmem,\n\n                                      devRead.rxFilterConf.mfTablePA);\n\n\n\n        pci_dma_read(PCI_DEVICE(s), mcast_list_pa, s->mcast_list, list_bytes);\n\n\n\n        VMW_CFPRN(\"Current multicast list len is %d:\", s->mcast_list_len);\n\n        for (i = 0; i < s->mcast_list_len; i++) {\n\n            VMW_CFPRN(\"\\t\" MAC_FMT, MAC_ARG(s->mcast_list[i].a));\n\n        }\n\n    }\n\n}\n", "idx": 12548}, {"project": "test", "commit_id": "test", "target": 1, "func": "int decode_block_coeffs(VP56RangeCoder *c, int16_t block[16],\n\n                        uint8_t probs[16][3][NUM_DCT_TOKENS - 1],\n\n                        int i, int zero_nhood, int16_t qmul[2])\n\n{\n\n    uint8_t *token_prob = probs[i][zero_nhood];\n\n    if (!vp56_rac_get_prob_branchy(c, token_prob[0]))   // DCT_EOB\n\n        return 0;\n\n    return decode_block_coeffs_internal(c, block, probs, i, token_prob, qmul);\n\n}\n", "idx": 12585}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int load_ipmovie_packet(IPMVEContext *s, AVIOContext *pb,\n\n    AVPacket *pkt) {\n\n\n\n    int chunk_type;\n\n\n\n    if (s->audio_chunk_offset) {\n\n\n\n\n\n\n\n\n        /* adjust for PCM audio by skipping chunk header */\n\n        if (s->audio_type != CODEC_ID_INTERPLAY_DPCM) {\n\n            s->audio_chunk_offset += 6;\n\n            s->audio_chunk_size -= 6;\n\n\n\n\n        avio_seek(pb, s->audio_chunk_offset, SEEK_SET);\n\n        s->audio_chunk_offset = 0;\n\n\n\n        if (s->audio_chunk_size != av_get_packet(pb, pkt, s->audio_chunk_size))\n\n            return CHUNK_EOF;\n\n\n\n        pkt->stream_index = s->audio_stream_index;\n\n        pkt->pts = s->audio_frame_count;\n\n\n\n        /* audio frame maintenance */\n\n        if (s->audio_type != CODEC_ID_INTERPLAY_DPCM)\n\n            s->audio_frame_count +=\n\n            (s->audio_chunk_size / s->audio_channels / (s->audio_bits / 8));\n\n        else\n\n            s->audio_frame_count +=\n\n                (s->audio_chunk_size - 6) / s->audio_channels;\n\n\n\n        av_dlog(NULL, \"sending audio frame with pts %\"PRId64\" (%d audio frames)\\n\",\n\n                pkt->pts, s->audio_frame_count);\n\n\n\n        chunk_type = CHUNK_VIDEO;\n\n\n\n    } else if (s->decode_map_chunk_offset) {\n\n\n\n        /* send both the decode map and the video data together */\n\n\n\n        if (av_new_packet(pkt, s->decode_map_chunk_size + s->video_chunk_size))\n\n            return CHUNK_NOMEM;\n\n\n\n        if (s->has_palette) {\n\n            uint8_t *pal;\n\n\n\n            pal = av_packet_new_side_data(pkt, AV_PKT_DATA_PALETTE,\n\n                                          AVPALETTE_SIZE);\n\n            if (pal) {\n\n                memcpy(pal, s->palette, AVPALETTE_SIZE);\n\n                s->has_palette = 0;\n\n\n\n\n\n        pkt->pos= s->decode_map_chunk_offset;\n\n        avio_seek(pb, s->decode_map_chunk_offset, SEEK_SET);\n\n        s->decode_map_chunk_offset = 0;\n\n\n\n        if (avio_read(pb, pkt->data, s->decode_map_chunk_size) !=\n\n            s->decode_map_chunk_size) {\n\n            av_free_packet(pkt);\n\n            return CHUNK_EOF;\n\n\n\n\n        avio_seek(pb, s->video_chunk_offset, SEEK_SET);\n\n        s->video_chunk_offset = 0;\n\n\n\n        if (avio_read(pb, pkt->data + s->decode_map_chunk_size,\n\n            s->video_chunk_size) != s->video_chunk_size) {\n\n            av_free_packet(pkt);\n\n            return CHUNK_EOF;\n\n\n\n\n        pkt->stream_index = s->video_stream_index;\n\n        pkt->pts = s->video_pts;\n\n\n\n        av_dlog(NULL, \"sending video frame with pts %\"PRId64\"\\n\", pkt->pts);\n\n\n\n        s->video_pts += s->frame_pts_inc;\n\n\n\n        chunk_type = CHUNK_VIDEO;\n\n\n\n    } else {\n\n\n\n        avio_seek(pb, s->next_chunk_offset, SEEK_SET);\n\n        chunk_type = CHUNK_DONE;\n\n\n\n\n\n\n    return chunk_type;\n", "idx": 12607}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void blk_delete(BlockBackend *blk)\n\n{\n\n    assert(!blk->refcnt);\n\n    assert(!blk->name);\n\n    assert(!blk->dev);\n\n\n\n\n    if (blk->root) {\n\n        blk_remove_bs(blk);\n\n\n    assert(QLIST_EMPTY(&blk->remove_bs_notifiers.notifiers));\n\n    assert(QLIST_EMPTY(&blk->insert_bs_notifiers.notifiers));\n\n    QTAILQ_REMOVE(&block_backends, blk, link);\n\n    drive_info_del(blk->legacy_dinfo);\n\n    block_acct_cleanup(&blk->stats);\n\n    g_free(blk);\n", "idx": 12780}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int gdbserver_open(int port)\n\n{\n\n    struct sockaddr_in sockaddr;\n\n    int fd, val, ret;\n\n\n\n    fd = socket(PF_INET, SOCK_STREAM, 0);\n\n    if (fd < 0) {\n\n        perror(\"socket\");\n\n        return -1;\n\n    }\n\n#ifndef _WIN32\n\n    fcntl(fd, F_SETFD, FD_CLOEXEC);\n\n#endif\n\n\n\n    /* allow fast reuse */\n\n    val = 1;\n\n    setsockopt(fd, SOL_SOCKET, SO_REUSEADDR, (char *)&val, sizeof(val));\n\n\n\n    sockaddr.sin_family = AF_INET;\n\n    sockaddr.sin_port = htons(port);\n\n    sockaddr.sin_addr.s_addr = 0;\n\n    ret = bind(fd, (struct sockaddr *)&sockaddr, sizeof(sockaddr));\n\n    if (ret < 0) {\n\n        perror(\"bind\");\n\n\n        return -1;\n\n    }\n\n    ret = listen(fd, 0);\n\n    if (ret < 0) {\n\n        perror(\"listen\");\n\n\n        return -1;\n\n    }\n\n    return fd;\n\n}", "idx": 12785}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void spapr_nvram_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    VIOsPAPRDeviceClass *k = VIO_SPAPR_DEVICE_CLASS(klass);\n\n\n\n    k->realize = spapr_nvram_realize;\n\n    k->devnode = spapr_nvram_devnode;\n\n    k->dt_name = \"nvram\";\n\n    k->dt_type = \"nvram\";\n\n    k->dt_compatible = \"qemu,spapr-nvram\";\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->props = spapr_nvram_properties;\n\n    dc->vmsd = &vmstate_spapr_nvram;\n\n\n\n}", "idx": 12786}, {"project": "test", "commit_id": "test", "target": 1, "func": "int qcow2_expand_zero_clusters(BlockDriverState *bs)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t *l1_table = NULL;\n\n    uint64_t nb_clusters;\n\n    uint8_t *expanded_clusters;\n\n    int ret;\n\n    int i, j;\n\n\n\n    nb_clusters = size_to_clusters(s, bs->file->total_sectors *\n\n                                   BDRV_SECTOR_SIZE);\n\n    expanded_clusters = g_malloc0((nb_clusters + 7) / 8);\n\n\n\n    ret = expand_zero_clusters_in_l1(bs, s->l1_table, s->l1_size,\n\n                                     &expanded_clusters, &nb_clusters);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    /* Inactive L1 tables may point to active L2 tables - therefore it is\n\n     * necessary to flush the L2 table cache before trying to access the L2\n\n     * tables pointed to by inactive L1 entries (else we might try to expand\n\n     * zero clusters that have already been expanded); furthermore, it is also\n\n     * necessary to empty the L2 table cache, since it may contain tables which\n\n     * are now going to be modified directly on disk, bypassing the cache.\n\n     * qcow2_cache_empty() does both for us. */\n\n    ret = qcow2_cache_empty(bs, s->l2_table_cache);\n\n    if (ret < 0) {\n\n        goto fail;\n\n    }\n\n\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        int l1_sectors = (s->snapshots[i].l1_size * sizeof(uint64_t) +\n\n                BDRV_SECTOR_SIZE - 1) / BDRV_SECTOR_SIZE;\n\n\n\n        l1_table = g_realloc(l1_table, l1_sectors * BDRV_SECTOR_SIZE);\n\n\n\n        ret = bdrv_read(bs->file, s->snapshots[i].l1_table_offset /\n\n                BDRV_SECTOR_SIZE, (void *)l1_table, l1_sectors);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n\n\n        for (j = 0; j < s->snapshots[i].l1_size; j++) {\n\n            be64_to_cpus(&l1_table[j]);\n\n        }\n\n\n\n        ret = expand_zero_clusters_in_l1(bs, l1_table, s->snapshots[i].l1_size,\n\n                                         &expanded_clusters, &nb_clusters);\n\n        if (ret < 0) {\n\n            goto fail;\n\n        }\n\n    }\n\n\n\n    ret = 0;\n\n\n\nfail:\n\n    g_free(expanded_clusters);\n\n    g_free(l1_table);\n\n    return ret;\n\n}\n", "idx": 12799}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int local_open2(FsContext *fs_ctx, const char *path, int flags,\n\n        FsCred *credp)\n\n{\n\n    int fd = -1;\n\n    int err = -1;\n\n    int serrno = 0;\n\n\n\n    /* Determine the security model */\n\n    if (fs_ctx->fs_sm == SM_MAPPED) {\n\n        fd = open(rpath(fs_ctx, path), flags, SM_LOCAL_MODE_BITS);\n\n        if (fd == -1) {\n\n            return fd;\n\n        }\n\n        credp->fc_mode = credp->fc_mode|S_IFREG;\n\n        /* Set cleint credentials in xattr */\n\n        err = local_set_xattr(rpath(fs_ctx, path), credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    } else if (fs_ctx->fs_sm == SM_PASSTHROUGH) {\n\n        fd = open(rpath(fs_ctx, path), flags, credp->fc_mode);\n\n        if (fd == -1) {\n\n            return fd;\n\n        }\n\n        err = local_post_create_passthrough(fs_ctx, path, credp);\n\n        if (err == -1) {\n\n            serrno = errno;\n\n            goto err_end;\n\n        }\n\n    }\n\n    return fd;\n\n\n\nerr_end:\n\n    close(fd);\n\n    remove(rpath(fs_ctx, path));\n\n    errno = serrno;\n\n    return err;\n\n}\n", "idx": 12805}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int msrle_decode_pal4(AVCodecContext *avctx, AVPicture *pic,\n\n                             GetByteContext *gb)\n\n{\n\n    unsigned char rle_code;\n\n    unsigned char extra_byte, odd_pixel;\n\n    unsigned char stream_byte;\n\n    unsigned int pixel_ptr = 0;\n\n    int row_dec = pic->linesize[0];\n\n    int row_ptr = (avctx->height - 1) * row_dec;\n\n    int frame_size = row_dec * avctx->height;\n\n    int i;\n\n\n\n    while (row_ptr >= 0) {\n\n        if (bytestream2_get_bytes_left(gb) <= 0) {\n\n            av_log(avctx, AV_LOG_ERROR,\n\n                   \"MS RLE: bytestream overrun, %d rows left\\n\",\n\n                   row_ptr);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        rle_code = stream_byte = bytestream2_get_byteu(gb);\n\n        if (rle_code == 0) {\n\n            /* fetch the next byte to see how to handle escape code */\n\n            stream_byte = bytestream2_get_byte(gb);\n\n            if (stream_byte == 0) {\n\n                /* line is done, goto the next one */\n\n                row_ptr -= row_dec;\n\n                pixel_ptr = 0;\n\n            } else if (stream_byte == 1) {\n\n                /* decode is done */\n\n                return 0;\n\n            } else if (stream_byte == 2) {\n\n                /* reposition frame decode coordinates */\n\n                stream_byte = bytestream2_get_byte(gb);\n\n                pixel_ptr += stream_byte;\n\n                stream_byte = bytestream2_get_byte(gb);\n\n                row_ptr -= stream_byte * row_dec;\n\n            } else {\n\n                // copy pixels from encoded stream\n\n                odd_pixel =  stream_byte & 1;\n\n                rle_code = (stream_byte + 1) / 2;\n\n                extra_byte = rle_code & 0x01;\n\n                if (row_ptr + pixel_ptr + stream_byte > frame_size ||\n\n                    bytestream2_get_bytes_left(gb) < rle_code) {\n\n                    av_log(avctx, AV_LOG_ERROR,\n\n                           \"MS RLE: frame/stream ptr just went out of bounds (copy)\\n\");\n\n                    return AVERROR_INVALIDDATA;\n\n                }\n\n\n\n                for (i = 0; i < rle_code; i++) {\n\n                    if (pixel_ptr >= avctx->width)\n\n                        break;\n\n                    stream_byte = bytestream2_get_byteu(gb);\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\n\n                    pixel_ptr++;\n\n                    if (i + 1 == rle_code && odd_pixel)\n\n                        break;\n\n                    if (pixel_ptr >= avctx->width)\n\n                        break;\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\n\n                    pixel_ptr++;\n\n                }\n\n\n\n                // if the RLE code is odd, skip a byte in the stream\n\n                if (extra_byte)\n\n                    bytestream2_skip(gb, 1);\n\n            }\n\n        } else {\n\n            // decode a run of data\n\n            if (row_ptr + pixel_ptr + stream_byte > frame_size) {\n\n                av_log(avctx, AV_LOG_ERROR,\n\n                       \"MS RLE: frame ptr just went out of bounds (run)\\n\");\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            stream_byte = bytestream2_get_byte(gb);\n\n            for (i = 0; i < rle_code; i++) {\n\n                if (pixel_ptr >= avctx->width)\n\n                    break;\n\n                if ((i & 1) == 0)\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte >> 4;\n\n                else\n\n                    pic->data[0][row_ptr + pixel_ptr] = stream_byte & 0x0F;\n\n                pixel_ptr++;\n\n            }\n\n        }\n\n    }\n\n\n\n    /* one last sanity check on the way out */\n\n    if (bytestream2_get_bytes_left(gb)) {\n\n        av_log(avctx, AV_LOG_ERROR,\n\n               \"MS RLE: ended frame decode with %d bytes left over\\n\",\n\n               bytestream2_get_bytes_left(gb));\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 12940}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void test_properties(const char *path, bool recurse)\n\n{\n\n    char *child_path;\n\n    QDict *response, *tuple;\n\n    QList *list;\n\n    QListEntry *entry;\n\n\n\n    g_test_message(\"Obtaining properties of %s\", path);\n\n    response = qmp(\"{ 'execute': 'qom-list',\"\n\n                   \"  'arguments': { 'path': %s } }\", path);\n\n    g_assert(response);\n\n\n\n    if (!recurse) {\n\n        return;\n\n    }\n\n\n\n    g_assert(qdict_haskey(response, \"return\"));\n\n    list = qobject_to_qlist(qdict_get(response, \"return\"));\n\n    QLIST_FOREACH_ENTRY(list, entry) {\n\n        tuple = qobject_to_qdict(qlist_entry_obj(entry));\n\n        bool is_child = strstart(qdict_get_str(tuple, \"type\"), \"child<\", NULL);\n\n        bool is_link = strstart(qdict_get_str(tuple, \"type\"), \"link<\", NULL);\n\n\n\n        if (is_child || is_link) {\n\n            child_path = g_strdup_printf(\"%s/%s\",\n\n                                         path, qdict_get_str(tuple, \"name\"));\n\n            test_properties(child_path, is_child);\n\n            g_free(child_path);\n\n        } else {\n\n            const char *prop = qdict_get_str(tuple, \"name\");\n\n            g_test_message(\"Testing property %s.%s\", path, prop);\n\n            response = qmp(\"{ 'execute': 'qom-get',\"\n\n                           \"  'arguments': { 'path': %s,\"\n\n                           \"                 'property': %s } }\",\n\n                           path, prop);\n\n            /* qom-get may fail but should not, e.g., segfault. */\n\n            g_assert(response);\n\n        }\n\n    }\n\n}\n", "idx": 12949}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int rdma_add_block(RDMAContext *rdma, const char *block_name,\n\n                         void *host_addr,\n\n                         ram_addr_t block_offset, uint64_t length)\n\n{\n\n    RDMALocalBlocks *local = &rdma->local_ram_blocks;\n\n    RDMALocalBlock *block;\n\n    RDMALocalBlock *old = local->block;\n\n\n\n    local->block = g_malloc0(sizeof(RDMALocalBlock) * (local->nb_blocks + 1));\n\n\n\n    if (local->nb_blocks) {\n\n        int x;\n\n\n\n        if (rdma->blockmap) {\n\n            for (x = 0; x < local->nb_blocks; x++) {\n\n                g_hash_table_remove(rdma->blockmap,\n\n                                    (void *)(uintptr_t)old[x].offset);\n\n                g_hash_table_insert(rdma->blockmap,\n\n                                    (void *)(uintptr_t)old[x].offset,\n\n                                    &local->block[x]);\n\n            }\n\n        }\n\n        memcpy(local->block, old, sizeof(RDMALocalBlock) * local->nb_blocks);\n\n        g_free(old);\n\n    }\n\n\n\n    block = &local->block[local->nb_blocks];\n\n\n\n    block->block_name = g_strdup(block_name);\n\n    block->local_host_addr = host_addr;\n\n    block->offset = block_offset;\n\n    block->length = length;\n\n    block->index = local->nb_blocks;\n\n    block->src_index = ~0U; /* Filled in by the receipt of the block list */\n\n    block->nb_chunks = ram_chunk_index(host_addr, host_addr + length) + 1UL;\n\n    block->transit_bitmap = bitmap_new(block->nb_chunks);\n\n    bitmap_clear(block->transit_bitmap, 0, block->nb_chunks);\n\n    block->unregister_bitmap = bitmap_new(block->nb_chunks);\n\n    bitmap_clear(block->unregister_bitmap, 0, block->nb_chunks);\n\n    block->remote_keys = g_malloc0(block->nb_chunks * sizeof(uint32_t));\n\n\n\n    block->is_ram_block = local->init ? false : true;\n\n\n\n    if (rdma->blockmap) {\n\n        g_hash_table_insert(rdma->blockmap, (void *) block_offset, block);\n\n    }\n\n\n\n    trace_rdma_add_block(block_name, local->nb_blocks,\n\n                         (uintptr_t) block->local_host_addr,\n\n                         block->offset, block->length,\n\n                         (uintptr_t) (block->local_host_addr + block->length),\n\n                         BITS_TO_LONGS(block->nb_chunks) *\n\n                             sizeof(unsigned long) * 8,\n\n                         block->nb_chunks);\n\n\n\n    local->nb_blocks++;\n\n\n\n    return 0;\n\n}\n", "idx": 12968}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void RENAME(vu9_to_vu12)(const uint8_t *src1, const uint8_t *src2,\n\n\t\t\tuint8_t *dst1, uint8_t *dst2,\n\n\t\t\tlong width, long height,\n\n\t\t\tlong srcStride1, long srcStride2,\n\n\t\t\tlong dstStride1, long dstStride2)\n\n{\n\n    long y,x,w,h;\n\n    w=width/2; h=height/2;\n\n#ifdef HAVE_MMX\n\n    asm volatile(\n\n\tPREFETCH\" %0\\n\\t\"\n\n\tPREFETCH\" %1\\n\\t\"\n\n\t::\"m\"(*(src1+srcStride1)),\"m\"(*(src2+srcStride2)):\"memory\");\n\n#endif\n\n    for(y=0;y<h;y++){\n\n\tconst uint8_t* s1=src1+srcStride1*(y>>1);\n\n\tuint8_t* d=dst1+dstStride1*y;\n\n\tx=0;\n\n#ifdef HAVE_MMX\n\n\tfor(;x<w-31;x+=32)\n\n\t{\n\n\t    asm volatile(\n\n\t\tPREFETCH\" 32%1\\n\\t\"\n\n\t        \"movq\t%1, %%mm0\\n\\t\"\n\n\t        \"movq\t8%1, %%mm2\\n\\t\"\n\n\t        \"movq\t16%1, %%mm4\\n\\t\"\n\n\t        \"movq\t24%1, %%mm6\\n\\t\"\n\n\t        \"movq\t%%mm0, %%mm1\\n\\t\"\n\n\t        \"movq\t%%mm2, %%mm3\\n\\t\"\n\n\t        \"movq\t%%mm4, %%mm5\\n\\t\"\n\n\t        \"movq\t%%mm6, %%mm7\\n\\t\"\n\n\t\t\"punpcklbw %%mm0, %%mm0\\n\\t\"\n\n\t\t\"punpckhbw %%mm1, %%mm1\\n\\t\"\n\n\t\t\"punpcklbw %%mm2, %%mm2\\n\\t\"\n\n\t\t\"punpckhbw %%mm3, %%mm3\\n\\t\"\n\n\t\t\"punpcklbw %%mm4, %%mm4\\n\\t\"\n\n\t\t\"punpckhbw %%mm5, %%mm5\\n\\t\"\n\n\t\t\"punpcklbw %%mm6, %%mm6\\n\\t\"\n\n\t\t\"punpckhbw %%mm7, %%mm7\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm1, 8%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm2, 16%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm3, 24%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm4, 32%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm5, 40%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm6, 48%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm7, 56%0\"\n\n\t\t:\"=m\"(d[2*x])\n\n\t\t:\"m\"(s1[x])\n\n\t\t:\"memory\");\n\n\t}\n\n#endif\n\n\tfor(;x<w;x++) d[2*x]=d[2*x+1]=s1[x];\n\n    }\n\n    for(y=0;y<h;y++){\n\n\tconst uint8_t* s2=src2+srcStride2*(y>>1);\n\n\tuint8_t* d=dst2+dstStride2*y;\n\n\tx=0;\n\n#ifdef HAVE_MMX\n\n\tfor(;x<w-31;x+=32)\n\n\t{\n\n\t    asm volatile(\n\n\t\tPREFETCH\" 32%1\\n\\t\"\n\n\t        \"movq\t%1, %%mm0\\n\\t\"\n\n\t        \"movq\t8%1, %%mm2\\n\\t\"\n\n\t        \"movq\t16%1, %%mm4\\n\\t\"\n\n\t        \"movq\t24%1, %%mm6\\n\\t\"\n\n\t        \"movq\t%%mm0, %%mm1\\n\\t\"\n\n\t        \"movq\t%%mm2, %%mm3\\n\\t\"\n\n\t        \"movq\t%%mm4, %%mm5\\n\\t\"\n\n\t        \"movq\t%%mm6, %%mm7\\n\\t\"\n\n\t\t\"punpcklbw %%mm0, %%mm0\\n\\t\"\n\n\t\t\"punpckhbw %%mm1, %%mm1\\n\\t\"\n\n\t\t\"punpcklbw %%mm2, %%mm2\\n\\t\"\n\n\t\t\"punpckhbw %%mm3, %%mm3\\n\\t\"\n\n\t\t\"punpcklbw %%mm4, %%mm4\\n\\t\"\n\n\t\t\"punpckhbw %%mm5, %%mm5\\n\\t\"\n\n\t\t\"punpcklbw %%mm6, %%mm6\\n\\t\"\n\n\t\t\"punpckhbw %%mm7, %%mm7\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm0, %0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm1, 8%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm2, 16%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm3, 24%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm4, 32%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm5, 40%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm6, 48%0\\n\\t\"\n\n\t\tMOVNTQ\"\t%%mm7, 56%0\"\n\n\t\t:\"=m\"(d[2*x])\n\n\t\t:\"m\"(s2[x])\n\n\t\t:\"memory\");\n\n\t}\n\n#endif\n\n\tfor(;x<w;x++) d[2*x]=d[2*x+1]=s2[x];\n\n    }\n\n#ifdef HAVE_MMX\n\n\tasm(\n\n\t\tEMMS\" \\n\\t\"\n\n\t\tSFENCE\" \\n\\t\"\n\n\t\t::: \"memory\"\n\n\t\t);\n\n#endif\n\n}\n", "idx": 13068}, {"project": "test", "commit_id": "test", "target": 1, "func": "void pl011_init(uint32_t base, qemu_irq irq,\n\n                CharDriverState *chr)\n\n{\n\n    int iomemtype;\n\n    pl011_state *s;\n\n\n\n    s = (pl011_state *)qemu_mallocz(sizeof(pl011_state));\n\n    iomemtype = cpu_register_io_memory(0, pl011_readfn,\n\n                                       pl011_writefn, s);\n\n    cpu_register_physical_memory(base, 0x00000fff, iomemtype);\n\n    s->base = base;\n\n    s->irq = irq;\n\n    s->chr = chr;\n\n    s->read_trigger = 1;\n\n    s->ifl = 0x12;\n\n    s->cr = 0x300;\n\n    s->flags = 0x90;\n\n    if (chr){ \n\n        qemu_chr_add_handlers(chr, pl011_can_recieve, pl011_recieve,\n\n                              pl011_event, s);\n\n    }\n\n    /* ??? Save/restore.  */\n\n}\n", "idx": 13114}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void spr_read_xer (DisasContext *ctx, int gprn, int sprn)\n\n{\n\n    gen_read_xer(cpu_gpr[gprn]);\n\n}\n", "idx": 13118}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void aml_free(gpointer data, gpointer user_data)\n\n{\n\n    Aml *var = data;\n\n    build_free_array(var->buf);\n\n\n}", "idx": 13140}, {"project": "test", "commit_id": "test", "target": 1, "func": "void FUNC(ff_simple_idct)(DCTELEM *block)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i < 8; i++)\n\n        FUNC(idctRowCondDC)(block + i*8);\n\n\n\n    for (i = 0; i < 8; i++)\n\n        FUNC(idctSparseCol)(block + i);\n\n}\n", "idx": 13230}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void qemu_spice_display_init_one(QemuConsole *con)\n\n{\n\n    SimpleSpiceDisplay *ssd = g_new0(SimpleSpiceDisplay, 1);\n\n\n\n    qemu_spice_display_init_common(ssd);\n\n\n\n    ssd->qxl.base.sif = &dpy_interface.base;\n\n    qemu_spice_add_display_interface(&ssd->qxl, con);\n\n    assert(ssd->worker);\n\n\n\n    qemu_spice_create_host_memslot(ssd);\n\n\n\n    ssd->dcl.ops = &display_listener_ops;\n\n    ssd->dcl.con = con;\n\n    register_displaychangelistener(&ssd->dcl);\n\n}\n", "idx": 13448}, {"project": "test", "commit_id": "test", "target": 1, "func": "uint64_t helper_cvttq_c(CPUAlphaState *env, uint64_t a)\n\n{\n\n    return inline_cvttq(env, a, float_round_to_zero, 0);\n\n}\n", "idx": 13554}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int find_and_decode_index(NUTContext *nut)\n\n{\n\n    AVFormatContext *s = nut->avf;\n\n    AVIOContext *bc    = s->pb;\n\n    uint64_t tmp, end;\n\n    int i, j, syncpoint_count;\n\n    int64_t filesize = avio_size(bc);\n\n    int64_t *syncpoints;\n\n    int8_t *has_keyframe;\n\n    int ret = AVERROR_INVALIDDATA;\n\n\n\n    avio_seek(bc, filesize - 12, SEEK_SET);\n\n    avio_seek(bc, filesize - avio_rb64(bc), SEEK_SET);\n\n    if (avio_rb64(bc) != INDEX_STARTCODE) {\n\n        av_log(s, AV_LOG_ERROR, \"no index at the end\\n\");\n\n        return ret;\n\n    }\n\n\n\n    end  = get_packetheader(nut, bc, 1, INDEX_STARTCODE);\n\n    end += avio_tell(bc);\n\n\n\n    ffio_read_varlen(bc); // max_pts\n\n    GET_V(syncpoint_count, tmp < INT_MAX / 8 && tmp > 0);\n\n    syncpoints   = av_malloc(sizeof(int64_t) *  syncpoint_count);\n\n    has_keyframe = av_malloc(sizeof(int8_t)  * (syncpoint_count + 1));\n\n    if (!syncpoints || !has_keyframe)\n\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < syncpoint_count; i++) {\n\n        syncpoints[i] = ffio_read_varlen(bc);\n\n        if (syncpoints[i] <= 0)\n\n            goto fail;\n\n        if (i)\n\n            syncpoints[i] += syncpoints[i - 1];\n\n    }\n\n\n\n    for (i = 0; i < s->nb_streams; i++) {\n\n        int64_t last_pts = -1;\n\n        for (j = 0; j < syncpoint_count;) {\n\n            uint64_t x = ffio_read_varlen(bc);\n\n            int type   = x & 1;\n\n            int n      = j;\n\n            x >>= 1;\n\n            if (type) {\n\n                int flag = x & 1;\n\n                x >>= 1;\n\n                if (n + x >= syncpoint_count + 1) {\n\n                    av_log(s, AV_LOG_ERROR, \"index overflow A\\n\");\n\n                    goto fail;\n\n                }\n\n                while (x--)\n\n                    has_keyframe[n++] = flag;\n\n                has_keyframe[n++] = !flag;\n\n            } else {\n\n                while (x != 1) {\n\n                    if (n >= syncpoint_count + 1) {\n\n                        av_log(s, AV_LOG_ERROR, \"index overflow B\\n\");\n\n                        goto fail;\n\n                    }\n\n                    has_keyframe[n++] = x & 1;\n\n                    x >>= 1;\n\n                }\n\n            }\n\n            if (has_keyframe[0]) {\n\n                av_log(s, AV_LOG_ERROR, \"keyframe before first syncpoint in index\\n\");\n\n                goto fail;\n\n            }\n\n            assert(n <= syncpoint_count + 1);\n\n            for (; j < n && j < syncpoint_count; j++) {\n\n                if (has_keyframe[j]) {\n\n                    uint64_t B, A = ffio_read_varlen(bc);\n\n                    if (!A) {\n\n                        A = ffio_read_varlen(bc);\n\n                        B = ffio_read_varlen(bc);\n\n                        // eor_pts[j][i] = last_pts + A + B\n\n                    } else\n\n                        B = 0;\n\n                    av_add_index_entry(s->streams[i], 16 * syncpoints[j - 1],\n\n                                       last_pts + A, 0, 0, AVINDEX_KEYFRAME);\n\n                    last_pts += A + B;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    if (skip_reserved(bc, end) || ffio_get_checksum(bc)) {\n\n        av_log(s, AV_LOG_ERROR, \"index checksum mismatch\\n\");\n\n        goto fail;\n\n    }\n\n    ret = 0;\n\n\n\nfail:\n\n    av_free(syncpoints);\n\n    av_free(has_keyframe);\n\n    return ret;\n\n}\n", "idx": 13636}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void menelaus_rtc_stop(struct menelaus_s *s)\n\n{\n\n    qemu_del_timer(s->rtc.hz);\n\n    s->rtc.next =- qemu_get_clock(rt_clock);\n\n    if (s->rtc.next < 1)\n\n        s->rtc.next = 1;\n\n}\n", "idx": 13667}, {"project": "test", "commit_id": "test", "target": 1, "func": "PPC_OP(set_T0)\n\n{\n\n    T0 = PARAM(1);\n\n    RETURN();\n\n}\n", "idx": 13728}, {"project": "test", "commit_id": "test", "target": 1, "func": "static GIOStatus ga_channel_write(GAChannel *c, const char *buf, size_t size,\n\n                                  size_t *count)\n\n{\n\n    GIOStatus status;\n\n    OVERLAPPED ov = {0};\n\n    BOOL ret;\n\n    DWORD written;\n\n\n\n    ov.hEvent = CreateEvent(NULL, FALSE, FALSE, NULL);\n\n    ret = WriteFile(c->handle, buf, size, &written, &ov);\n\n    if (!ret) {\n\n        if (GetLastError() == ERROR_IO_PENDING) {\n\n            /* write is pending */\n\n            ret = GetOverlappedResult(c->handle, &ov, &written, TRUE);\n\n            if (!ret) {\n\n                if (!GetLastError()) {\n\n                    status = G_IO_STATUS_AGAIN;\n\n                } else {\n\n                    status = G_IO_STATUS_ERROR;\n\n\n            } else {\n\n                /* write is complete */\n\n                status = G_IO_STATUS_NORMAL;\n\n                *count = written;\n\n\n        } else {\n\n            status = G_IO_STATUS_ERROR;\n\n\n    } else {\n\n        /* write returned immediately */\n\n        status = G_IO_STATUS_NORMAL;\n\n        *count = written;\n\n\n\n\n\n\n\n\n    return status;\n", "idx": 13739}, {"project": "test", "commit_id": "test", "target": 1, "func": "int ff_jni_exception_get_summary(JNIEnv *env, jthrowable exception, char **error, void *log_ctx)\n\n{\n\n    int ret = 0;\n\n\n\n    AVBPrint bp;\n\n\n\n    char *name = NULL;\n\n    char *message = NULL;\n\n\n\n    jclass class_class = NULL;\n\n    jmethodID get_name_id = NULL;\n\n\n\n    jclass exception_class = NULL;\n\n    jmethodID get_message_id = NULL;\n\n\n\n    jstring string;\n\n\n\n    av_bprint_init(&bp, 0, AV_BPRINT_SIZE_AUTOMATIC);\n\n\n\n    exception_class = (*env)->GetObjectClass(env, exception);\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find Throwable class\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    class_class = (*env)->GetObjectClass(env, exception_class);\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find Throwable class's class\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    get_name_id = (*env)->GetMethodID(env, class_class, \"getName\", \"()Ljava/lang/String;\");\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find method Class.getName()\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    string = (*env)->CallObjectMethod(env, exception_class, get_name_id);\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Class.getName() threw an exception\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    if (string) {\n\n        name = ff_jni_jstring_to_utf_chars(env, string, log_ctx);\n\n        (*env)->DeleteLocalRef(env, string);\n\n        string = NULL;\n\n    }\n\n\n\n    get_message_id = (*env)->GetMethodID(env, exception_class, \"getMessage\", \"()Ljava/lang/String;\");\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Could not find method java/lang/Throwable.getMessage()\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    string = (*env)->CallObjectMethod(env, exception, get_message_id);\n\n    if ((*env)->ExceptionCheck(env)) {\n\n        (*env)->ExceptionClear(env);\n\n        av_log(log_ctx, AV_LOG_ERROR, \"Throwable.getMessage() threw an exception\\n\");\n\n        ret = AVERROR_EXTERNAL;\n\n        goto done;\n\n    }\n\n\n\n    if (string) {\n\n        message = ff_jni_jstring_to_utf_chars(env, string, log_ctx);\n\n        (*env)->DeleteLocalRef(env, string);\n\n        string = NULL;\n\n    }\n\n\n\n    if (name && message) {\n\n        av_bprintf(&bp, \"%s: %s\", name, message);\n\n    } else if (name && !message) {\n\n        av_bprintf(&bp, \"%s occurred\", name);\n\n    } else if (!name && message) {\n\n        av_bprintf(&bp, \"Exception: %s\", message);\n\n    } else {\n\n        av_log(log_ctx, AV_LOG_WARNING, \"Could not retreive exception name and message\\n\");\n\n        av_bprintf(&bp, \"Exception occurred\");\n\n    }\n\n\n\n    ret = av_bprint_finalize(&bp, error);\n\ndone:\n\n\n\n    av_free(name);\n\n    av_free(message);\n\n\n\n    if (class_class) {\n\n        (*env)->DeleteLocalRef(env, class_class);\n\n    }\n\n\n\n    if (exception_class) {\n\n        (*env)->DeleteLocalRef(env, exception_class);\n\n    }\n\n\n\n    if (string) {\n\n        (*env)->DeleteLocalRef(env, string);\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 13740}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void vscsi_command_complete(SCSIBus *bus, int reason, uint32_t tag,\n\n                                   uint32_t arg)\n\n{\n\n    VSCSIState *s = DO_UPCAST(VSCSIState, vdev.qdev, bus->qbus.parent);\n\n    vscsi_req *req = vscsi_find_req(s, tag);\n\n    SCSIDevice *sdev;\n\n    uint8_t *buf;\n\n    int32_t res_in = 0, res_out = 0;\n\n    int len, rc = 0;\n\n\n\n    dprintf(\"VSCSI: SCSI cmd complete, r=0x%x tag=0x%x arg=0x%x, req=%p\\n\",\n\n            reason, tag, arg, req);\n\n    if (req == NULL) {\n\n        fprintf(stderr, \"VSCSI: Can't find request for tag 0x%x\\n\", tag);\n\n        return;\n\n    }\n\n    sdev = req->sdev;\n\n\n\n    if (req->sensing) {\n\n        if (reason == SCSI_REASON_DONE) {\n\n            dprintf(\"VSCSI: Sense done !\\n\");\n\n            vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);\n\n            vscsi_put_req(s, req);\n\n        } else {\n\n            uint8_t *buf = sdev->info->get_buf(sdev, tag);\n\n\n\n            len = MIN(arg, SCSI_SENSE_BUF_SIZE);\n\n            dprintf(\"VSCSI: Sense data, %d bytes:\\n\", len);\n\n            dprintf(\"       %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x\\n\",\n\n                    buf[0], buf[1], buf[2], buf[3],\n\n                    buf[4], buf[5], buf[6], buf[7]);\n\n            dprintf(\"       %02x  %02x  %02x  %02x  %02x  %02x  %02x  %02x\\n\",\n\n                    buf[8], buf[9], buf[10], buf[11],\n\n                    buf[12], buf[13], buf[14], buf[15]);\n\n            memcpy(req->sense, buf, len);\n\n            req->senselen = len;\n\n            sdev->info->read_data(sdev, req->qtag);\n\n        }\n\n        return;\n\n    }\n\n\n\n    if (reason == SCSI_REASON_DONE) {\n\n        dprintf(\"VSCSI: Command complete err=%d\\n\", arg);\n\n        if (arg == 0) {\n\n            /* We handle overflows, not underflows for normal commands,\n\n             * but hopefully nobody cares\n\n             */\n\n            if (req->writing) {\n\n                res_out = req->data_len;\n\n            } else {\n\n                res_in = req->data_len;\n\n            }\n\n            vscsi_send_rsp(s, req, 0, res_in, res_out);\n\n        } else if (arg == CHECK_CONDITION) {\n\n            dprintf(\"VSCSI: Got CHECK_CONDITION, requesting sense...\\n\");\n\n            vscsi_send_request_sense(s, req);\n\n            return;\n\n        } else {\n\n            vscsi_send_rsp(s, req, arg, 0, 0);\n\n        }\n\n        vscsi_put_req(s, req);\n\n        return;\n\n    }\n\n\n\n    /* \"arg\" is how much we have read for reads and how much we want\n\n     * to write for writes (ie, how much is to be DMA'd)\n\n     */\n\n    if (arg) {\n\n        buf = sdev->info->get_buf(sdev, tag);\n\n        rc = vscsi_srp_transfer_data(s, req, req->writing, buf, arg);\n\n    }\n\n    if (rc < 0) {\n\n        fprintf(stderr, \"VSCSI: RDMA error rc=%d!\\n\", rc);\n\n        sdev->info->cancel_io(sdev, req->qtag);\n\n        vscsi_makeup_sense(s, req, HARDWARE_ERROR, 0, 0);\n\n        vscsi_send_rsp(s, req, CHECK_CONDITION, 0, 0);\n\n        vscsi_put_req(s, req);\n\n        return;\n\n    }\n\n\n\n    /* Start next chunk */\n\n    req->data_len -= rc;\n\n    if (req->writing) {\n\n        sdev->info->write_data(sdev, req->qtag);\n\n    } else {\n\n        sdev->info->read_data(sdev, req->qtag);\n\n    }\n\n}\n", "idx": 13748}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int alloc_sequence_buffers(DiracContext *s)\n\n{\n\n    int sbwidth  = DIVRNDUP(s->source.width,  4);\n\n    int sbheight = DIVRNDUP(s->source.height, 4);\n\n    int i, w, h, top_padding;\n\n\n\n    /* todo: think more about this / use or set Plane here */\n\n    for (i = 0; i < 3; i++) {\n\n        int max_xblen = MAX_BLOCKSIZE >> (i ? s->chroma_x_shift : 0);\n\n        int max_yblen = MAX_BLOCKSIZE >> (i ? s->chroma_y_shift : 0);\n\n        w = s->source.width  >> (i ? s->chroma_x_shift : 0);\n\n        h = s->source.height >> (i ? s->chroma_y_shift : 0);\n\n\n\n        /* we allocate the max we support here since num decompositions can\n\n         * change from frame to frame. Stride is aligned to 16 for SIMD, and\n\n         * 1<<MAX_DWT_LEVELS top padding to avoid if(y>0) in arith decoding\n\n         * MAX_BLOCKSIZE padding for MC: blocks can spill up to half of that\n\n         * on each side */\n\n        top_padding = FFMAX(1<<MAX_DWT_LEVELS, max_yblen/2);\n\n        w = FFALIGN(CALC_PADDING(w, MAX_DWT_LEVELS), 8); /* FIXME: Should this be 16 for SSE??? */\n\n        h = top_padding + CALC_PADDING(h, MAX_DWT_LEVELS) + max_yblen/2;\n\n\n\n        s->plane[i].idwt_buf_base = av_mallocz((w+max_xblen)*h * sizeof(IDWTELEM));\n\n        s->plane[i].idwt_tmp      = av_malloc((w+16) * sizeof(IDWTELEM));\n\n        s->plane[i].idwt_buf      = s->plane[i].idwt_buf_base + top_padding*w;\n\n        if (!s->plane[i].idwt_buf_base || !s->plane[i].idwt_tmp)\n\n            return AVERROR(ENOMEM);\n\n    }\n\n\n\n    w = s->source.width;\n\n    h = s->source.height;\n\n\n\n    /* fixme: allocate using real stride here */\n\n    s->sbsplit  = av_malloc(sbwidth * sbheight);\n\n    s->blmotion = av_malloc(sbwidth * sbheight * 16 * sizeof(*s->blmotion));\n\n    s->edge_emu_buffer_base = av_malloc((w+64)*MAX_BLOCKSIZE);\n\n\n\n    s->mctmp     = av_malloc((w+64+MAX_BLOCKSIZE) * (h*MAX_BLOCKSIZE) * sizeof(*s->mctmp));\n\n    s->mcscratch = av_malloc((w+64)*MAX_BLOCKSIZE);\n\n\n\n    if (!s->sbsplit || !s->blmotion)\n\n        return AVERROR(ENOMEM);\n\n    return 0;\n\n}\n", "idx": 13899}, {"project": "test", "commit_id": "test", "target": 1, "func": "int avpriv_lock_avformat(void)\n\n{\n\n    if (lockmgr_cb) {\n\n        if ((*lockmgr_cb)(&avformat_mutex, AV_LOCK_OBTAIN))\n\n            return -1;\n\n    }\n\n    return 0;\n\n}\n", "idx": 13906}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int update_dimensions(VP8Context *s, int width, int height)\n\n{\n\n    if (width  != s->avctx->width ||\n\n        height != s->avctx->height) {\n\n        if (av_image_check_size(width, height, 0, s->avctx))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        vp8_decode_flush_impl(s->avctx, 1, 0, 1);\n\n\n\n        avcodec_set_dimensions(s->avctx, width, height);\n\n    }\n\n\n\n    s->mb_width  = (s->avctx->coded_width +15) / 16;\n\n    s->mb_height = (s->avctx->coded_height+15) / 16;\n\n\n\n    s->macroblocks_base        = av_mallocz((s->mb_width+s->mb_height*2+1)*sizeof(*s->macroblocks));\n\n    s->filter_strength         = av_mallocz(s->mb_width*sizeof(*s->filter_strength));\n\n    s->intra4x4_pred_mode_top  = av_mallocz(s->mb_width*4);\n\n    s->top_nnz                 = av_mallocz(s->mb_width*sizeof(*s->top_nnz));\n\n    s->top_border              = av_mallocz((s->mb_width+1)*sizeof(*s->top_border));\n\n\n\n    if (!s->macroblocks_base || !s->filter_strength || !s->intra4x4_pred_mode_top ||\n\n        !s->top_nnz || !s->top_border)\n\n        return AVERROR(ENOMEM);\n\n\n\n    s->macroblocks        = s->macroblocks_base + 1;\n\n\n\n    return 0;\n\n}\n", "idx": 14014}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int dv_read_seek(AVFormatContext *s, int stream_index,\n\n                       int64_t timestamp, int flags)\n\n{\n\n    RawDVContext *r   = s->priv_data;\n\n    DVDemuxContext *c = r->dv_demux;\n\n    int64_t offset    = dv_frame_offset(s, c, timestamp, flags);\n\n\n\n    dv_offset_reset(c, offset / c->sys->frame_size);\n\n\n\n    offset = avio_seek(s->pb, offset, SEEK_SET);\n\n    return (offset < 0) ? offset : 0;\n\n}\n", "idx": 14144}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void spapr_phb_hot_plug_child(HotplugHandler *plug_handler,\n\n                                     DeviceState *plugged_dev, Error **errp)\n\n{\n\n    sPAPRPHBState *phb = SPAPR_PCI_HOST_BRIDGE(DEVICE(plug_handler));\n\n    PCIDevice *pdev = PCI_DEVICE(plugged_dev);\n\n    sPAPRDRConnector *drc = spapr_phb_get_pci_drc(phb, pdev);\n\n    Error *local_err = NULL;\n\n\n\n    /* if DR is disabled we don't need to do anything in the case of\n\n     * hotplug or coldplug callbacks\n\n     */\n\n    if (!phb->dr_enabled) {\n\n        /* if this is a hotplug operation initiated by the user\n\n         * we need to let them know it's not enabled\n\n         */\n\n        if (plugged_dev->hotplugged) {\n\n            error_setg(errp, QERR_BUS_NO_HOTPLUG,\n\n                       object_get_typename(OBJECT(phb)));\n\n        }\n\n        return;\n\n    }\n\n\n\n    g_assert(drc);\n\n\n\n    spapr_phb_add_pci_device(drc, phb, pdev, &local_err);\n\n    if (local_err) {\n\n        error_propagate(errp, local_err);\n\n        return;\n\n    }\n\n    if (plugged_dev->hotplugged) {\n\n        spapr_hotplug_req_add_by_index(drc);\n\n    }\n\n}\n", "idx": 14162}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int libquvi_read_header(AVFormatContext *s)\n\n{\n\n    int i, ret;\n\n    quvi_t q;\n\n    quvi_media_t m;\n\n    QUVIcode rc;\n\n    LibQuviContext *qc = s->priv_data;\n\n    char *media_url, *pagetitle;\n\n\n\n    rc = quvi_init(&q);\n\n    if (rc != QUVI_OK)\n\n        goto quvi_fail;\n\n\n\n    quvi_setopt(q, QUVIOPT_FORMAT, qc->format);\n\n\n\n    rc = quvi_parse(q, s->filename, &m);\n\n    if (rc != QUVI_OK)\n\n        goto quvi_fail;\n\n\n\n    rc = quvi_getprop(m, QUVIPROP_MEDIAURL, &media_url);\n\n    if (rc != QUVI_OK)\n\n        goto quvi_fail;\n\n\n\n    av_assert0(!qc->fmtctx->codec_whitelist && !qc->fmtctx->format_whitelist);\n\n    qc->fmtctx-> codec_whitelist = av_strdup(s->codec_whitelist);\n\n    qc->fmtctx->format_whitelist = av_strdup(s->format_whitelist);\n\n\n\n    ret = avformat_open_input(&qc->fmtctx, media_url, NULL, NULL);\n\n    if (ret < 0)\n\n        goto end;\n\n\n\n    rc = quvi_getprop(m, QUVIPROP_PAGETITLE, &pagetitle);\n\n    if (rc == QUVI_OK)\n\n        av_dict_set(&s->metadata, \"title\", pagetitle, 0);\n\n\n\n    for (i = 0; i < qc->fmtctx->nb_streams; i++) {\n\n        AVStream *st = avformat_new_stream(s, NULL);\n\n        AVStream *ist = qc->fmtctx->streams[i];\n\n        if (!st) {\n\n            ret = AVERROR(ENOMEM);\n\n            goto end;\n\n        }\n\n        avpriv_set_pts_info(st, ist->pts_wrap_bits, ist->time_base.num, ist->time_base.den);\n\n        avcodec_copy_context(st->codec, qc->fmtctx->streams[i]->codec);\n\n    }\n\n\n\n    return 0;\n\n\n\nquvi_fail:\n\n    av_log(s, AV_LOG_ERROR, \"%s\\n\", quvi_strerror(q, rc));\n\n    ret = AVERROR_EXTERNAL;\n\n\n\nend:\n\n    quvi_parse_close(&m);\n\n    quvi_close(&q);\n\n    return ret;\n\n}\n", "idx": 14199}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int rebuild_refcount_structure(BlockDriverState *bs,\n\n                                      BdrvCheckResult *res,\n\n                                      void **refcount_table,\n\n                                      int64_t *nb_clusters)\n\n{\n\n    BDRVQcow2State *s = bs->opaque;\n\n    int64_t first_free_cluster = 0, reftable_offset = -1, cluster = 0;\n\n    int64_t refblock_offset, refblock_start, refblock_index;\n\n    uint32_t reftable_size = 0;\n\n    uint64_t *on_disk_reftable = NULL;\n\n    void *on_disk_refblock;\n\n    int ret = 0;\n\n    struct {\n\n        uint64_t reftable_offset;\n\n        uint32_t reftable_clusters;\n\n    } QEMU_PACKED reftable_offset_and_clusters;\n\n\n\n    qcow2_cache_empty(bs, s->refcount_block_cache);\n\n\n\nwrite_refblocks:\n\n    for (; cluster < *nb_clusters; cluster++) {\n\n        if (!s->get_refcount(*refcount_table, cluster)) {\n\n            continue;\n\n        }\n\n\n\n        refblock_index = cluster >> s->refcount_block_bits;\n\n        refblock_start = refblock_index << s->refcount_block_bits;\n\n\n\n        /* Don't allocate a cluster in a refblock already written to disk */\n\n        if (first_free_cluster < refblock_start) {\n\n            first_free_cluster = refblock_start;\n\n        }\n\n        refblock_offset = alloc_clusters_imrt(bs, 1, refcount_table,\n\n                                              nb_clusters, &first_free_cluster);\n\n        if (refblock_offset < 0) {\n\n            fprintf(stderr, \"ERROR allocating refblock: %s\\n\",\n\n                    strerror(-refblock_offset));\n\n            res->check_errors++;\n\n            ret = refblock_offset;\n\n            goto fail;\n\n        }\n\n\n\n        if (reftable_size <= refblock_index) {\n\n            uint32_t old_reftable_size = reftable_size;\n\n            uint64_t *new_on_disk_reftable;\n\n\n\n            reftable_size = ROUND_UP((refblock_index + 1) * sizeof(uint64_t),\n\n                                     s->cluster_size) / sizeof(uint64_t);\n\n            new_on_disk_reftable = g_try_realloc(on_disk_reftable,\n\n                                                 reftable_size *\n\n                                                 sizeof(uint64_t));\n\n            if (!new_on_disk_reftable) {\n\n                res->check_errors++;\n\n                ret = -ENOMEM;\n\n                goto fail;\n\n            }\n\n            on_disk_reftable = new_on_disk_reftable;\n\n\n\n            memset(on_disk_reftable + old_reftable_size, 0,\n\n                   (reftable_size - old_reftable_size) * sizeof(uint64_t));\n\n\n\n            /* The offset we have for the reftable is now no longer valid;\n\n             * this will leak that range, but we can easily fix that by running\n\n             * a leak-fixing check after this rebuild operation */\n\n            reftable_offset = -1;\n\n        }\n\n        on_disk_reftable[refblock_index] = refblock_offset;\n\n\n\n        /* If this is apparently the last refblock (for now), try to squeeze the\n\n         * reftable in */\n\n        if (refblock_index == (*nb_clusters - 1) >> s->refcount_block_bits &&\n\n            reftable_offset < 0)\n\n        {\n\n            uint64_t reftable_clusters = size_to_clusters(s, reftable_size *\n\n                                                          sizeof(uint64_t));\n\n            reftable_offset = alloc_clusters_imrt(bs, reftable_clusters,\n\n                                                  refcount_table, nb_clusters,\n\n                                                  &first_free_cluster);\n\n            if (reftable_offset < 0) {\n\n                fprintf(stderr, \"ERROR allocating reftable: %s\\n\",\n\n                        strerror(-reftable_offset));\n\n                res->check_errors++;\n\n                ret = reftable_offset;\n\n                goto fail;\n\n            }\n\n        }\n\n\n\n        ret = qcow2_pre_write_overlap_check(bs, 0, refblock_offset,\n\n                                            s->cluster_size);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR writing refblock: %s\\n\", strerror(-ret));\n\n            goto fail;\n\n        }\n\n\n\n        /* The size of *refcount_table is always cluster-aligned, therefore the\n\n         * write operation will not overflow */\n\n        on_disk_refblock = (void *)((char *) *refcount_table +\n\n                                    refblock_index * s->cluster_size);\n\n\n\n        ret = bdrv_write(bs->file, refblock_offset / BDRV_SECTOR_SIZE,\n\n                         on_disk_refblock, s->cluster_sectors);\n\n        if (ret < 0) {\n\n            fprintf(stderr, \"ERROR writing refblock: %s\\n\", strerror(-ret));\n\n            goto fail;\n\n        }\n\n\n\n        /* Go to the end of this refblock */\n\n        cluster = refblock_start + s->refcount_block_size - 1;\n\n    }\n\n\n\n    if (reftable_offset < 0) {\n\n        uint64_t post_refblock_start, reftable_clusters;\n\n\n\n        post_refblock_start = ROUND_UP(*nb_clusters, s->refcount_block_size);\n\n        reftable_clusters = size_to_clusters(s,\n\n                                             reftable_size * sizeof(uint64_t));\n\n        /* Not pretty but simple */\n\n        if (first_free_cluster < post_refblock_start) {\n\n            first_free_cluster = post_refblock_start;\n\n        }\n\n        reftable_offset = alloc_clusters_imrt(bs, reftable_clusters,\n\n                                              refcount_table, nb_clusters,\n\n                                              &first_free_cluster);\n\n        if (reftable_offset < 0) {\n\n            fprintf(stderr, \"ERROR allocating reftable: %s\\n\",\n\n                    strerror(-reftable_offset));\n\n            res->check_errors++;\n\n            ret = reftable_offset;\n\n            goto fail;\n\n        }\n\n\n\n        goto write_refblocks;\n\n    }\n\n\n\n    assert(on_disk_reftable);\n\n\n\n    for (refblock_index = 0; refblock_index < reftable_size; refblock_index++) {\n\n        cpu_to_be64s(&on_disk_reftable[refblock_index]);\n\n    }\n\n\n\n    ret = qcow2_pre_write_overlap_check(bs, 0, reftable_offset,\n\n                                        reftable_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ERROR writing reftable: %s\\n\", strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\n    assert(reftable_size < INT_MAX / sizeof(uint64_t));\n\n    ret = bdrv_pwrite(bs->file, reftable_offset, on_disk_reftable,\n\n                      reftable_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ERROR writing reftable: %s\\n\", strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\n    /* Enter new reftable into the image header */\n\n    reftable_offset_and_clusters.reftable_offset = cpu_to_be64(reftable_offset);\n\n    reftable_offset_and_clusters.reftable_clusters =\n\n        cpu_to_be32(size_to_clusters(s, reftable_size * sizeof(uint64_t)));\n\n    ret = bdrv_pwrite_sync(bs->file,\n\n                           offsetof(QCowHeader, refcount_table_offset),\n\n                           &reftable_offset_and_clusters,\n\n                           sizeof(reftable_offset_and_clusters));\n\n    if (ret < 0) {\n\n        fprintf(stderr, \"ERROR setting reftable: %s\\n\", strerror(-ret));\n\n        goto fail;\n\n    }\n\n\n\n    for (refblock_index = 0; refblock_index < reftable_size; refblock_index++) {\n\n        be64_to_cpus(&on_disk_reftable[refblock_index]);\n\n    }\n\n    s->refcount_table = on_disk_reftable;\n\n    s->refcount_table_offset = reftable_offset;\n\n    s->refcount_table_size = reftable_size;\n\n    update_max_refcount_table_index(s);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    g_free(on_disk_reftable);\n\n    return ret;\n\n}\n", "idx": 14300}, {"project": "test", "commit_id": "test", "target": 1, "func": "av_cold int ff_ivi_init_planes(IVIPlaneDesc *planes, const IVIPicConfig *cfg,\n\n                               int is_indeo4)\n\n{\n\n    int p, b;\n\n    uint32_t b_width, b_height, align_fac, width_aligned,\n\n             height_aligned, buf_size;\n\n    IVIBandDesc *band;\n\n\n\n    ivi_free_buffers(planes);\n\n\n\n    if (av_image_check_size(cfg->pic_width, cfg->pic_height, 0, NULL) < 0 ||\n\n        cfg->luma_bands < 1 || cfg->chroma_bands < 1)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    /* fill in the descriptor of the luminance plane */\n\n    planes[0].width     = cfg->pic_width;\n\n    planes[0].height    = cfg->pic_height;\n\n    planes[0].num_bands = cfg->luma_bands;\n\n\n\n    /* fill in the descriptors of the chrominance planes */\n\n    planes[1].width     = planes[2].width     = (cfg->pic_width  + 3) >> 2;\n\n    planes[1].height    = planes[2].height    = (cfg->pic_height + 3) >> 2;\n\n    planes[1].num_bands = planes[2].num_bands = cfg->chroma_bands;\n\n\n\n    for (p = 0; p < 3; p++) {\n\n        planes[p].bands = av_mallocz_array(planes[p].num_bands, sizeof(IVIBandDesc));\n\n        if (!planes[p].bands)\n\n            return AVERROR(ENOMEM);\n\n\n\n        /* select band dimensions: if there is only one band then it\n\n         *  has the full size, if there are several bands each of them\n\n         *  has only half size */\n\n        b_width  = planes[p].num_bands == 1 ? planes[p].width\n\n                                            : (planes[p].width  + 1) >> 1;\n\n        b_height = planes[p].num_bands == 1 ? planes[p].height\n\n                                            : (planes[p].height + 1) >> 1;\n\n\n\n        /* luma   band buffers will be aligned on 16x16 (max macroblock size) */\n\n        /* chroma band buffers will be aligned on   8x8 (max macroblock size) */\n\n        align_fac       = p ? 8 : 16;\n\n        width_aligned   = FFALIGN(b_width , align_fac);\n\n        height_aligned  = FFALIGN(b_height, align_fac);\n\n        buf_size        = width_aligned * height_aligned * sizeof(int16_t);\n\n\n\n        for (b = 0; b < planes[p].num_bands; b++) {\n\n            band = &planes[p].bands[b]; /* select appropriate plane/band */\n\n            band->plane    = p;\n\n            band->band_num = b;\n\n            band->width    = b_width;\n\n            band->height   = b_height;\n\n            band->pitch    = width_aligned;\n\n            band->aheight  = height_aligned;\n\n            band->bufs[0]  = av_mallocz(buf_size);\n\n            band->bufs[1]  = av_mallocz(buf_size);\n\n            band->bufsize  = buf_size/2;\n\n            if (!band->bufs[0] || !band->bufs[1])\n\n                return AVERROR(ENOMEM);\n\n\n\n            /* allocate the 3rd band buffer for scalability mode */\n\n            if (cfg->luma_bands > 1) {\n\n                band->bufs[2] = av_mallocz(buf_size);\n\n                if (!band->bufs[2])\n\n                    return AVERROR(ENOMEM);\n\n            }\n\n            if (is_indeo4) {\n\n                band->bufs[3]  = av_mallocz(buf_size);\n\n                if (!band->bufs[3])\n\n                    return AVERROR(ENOMEM);\n\n            }\n\n            /* reset custom vlc */\n\n            planes[p].bands[0].blk_vlc.cust_desc.num_rows = 0;\n\n        }\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14308}, {"project": "test", "commit_id": "test", "target": 1, "func": "static BlockAIOCB *bdrv_co_aio_rw_vector(BdrvChild *child,\n\n                                         int64_t sector_num,\n\n                                         QEMUIOVector *qiov,\n\n                                         int nb_sectors,\n\n                                         BdrvRequestFlags flags,\n\n                                         BlockCompletionFunc *cb,\n\n                                         void *opaque,\n\n                                         bool is_write)\n\n{\n\n    Coroutine *co;\n\n    BlockAIOCBCoroutine *acb;\n\n\n\n    acb = qemu_aio_get(&bdrv_em_co_aiocb_info, child->bs, cb, opaque);\n\n    acb->child = child;\n\n    acb->need_bh = true;\n\n    acb->req.error = -EINPROGRESS;\n\n    acb->req.sector = sector_num;\n\n    acb->req.nb_sectors = nb_sectors;\n\n    acb->req.qiov = qiov;\n\n    acb->req.flags = flags;\n\n    acb->is_write = is_write;\n\n\n\n    co = qemu_coroutine_create(bdrv_co_do_rw);\n\n    qemu_coroutine_enter(co, acb);\n\n\n\n    bdrv_co_maybe_schedule_bh(acb);\n\n    return &acb->common;\n\n}\n", "idx": 14324}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void ccw_machine_class_init(ObjectClass *oc, void *data)\n\n{\n\n    MachineClass *mc = MACHINE_CLASS(oc);\n\n    NMIClass *nc = NMI_CLASS(oc);\n\n    HotplugHandlerClass *hc = HOTPLUG_HANDLER_CLASS(oc);\n\n    S390CcwMachineClass *s390mc = S390_MACHINE_CLASS(mc);\n\n\n\n    s390mc->ri_allowed = true;\n\n    s390mc->cpu_model_allowed = true;\n\n    s390mc->css_migration_enabled = true;\n\n    s390mc->gs_allowed = true;\n\n    mc->init = ccw_init;\n\n    mc->reset = s390_machine_reset;\n\n    mc->hot_add_cpu = s390_hot_add_cpu;\n\n    mc->block_default_type = IF_VIRTIO;\n\n    mc->no_cdrom = 1;\n\n    mc->no_floppy = 1;\n\n    mc->no_serial = 1;\n\n    mc->no_parallel = 1;\n\n    mc->no_sdcard = 1;\n\n    mc->use_sclp = 1;\n\n    mc->max_cpus = S390_MAX_CPUS;\n\n    mc->has_hotpluggable_cpus = true;\n\n    mc->get_hotplug_handler = s390_get_hotplug_handler;\n\n    mc->cpu_index_to_instance_props = s390_cpu_index_to_props;\n\n    mc->possible_cpu_arch_ids = s390_possible_cpu_arch_ids;\n\n    /* it is overridden with 'host' cpu *in kvm_arch_init* */\n\n    mc->default_cpu_type = S390_CPU_TYPE_NAME(\"qemu\");\n\n    hc->plug = s390_machine_device_plug;\n\n    hc->unplug_request = s390_machine_device_unplug_request;\n\n    nc->nmi_monitor_handler = s390_nmi;\n\n}\n", "idx": 14356}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int write_cvid_header(CinepakEncContext *s, unsigned char *buf, int num_strips, int data_size)\n\n{\n\n    buf[0] = 0;\n\n    AV_WB24(&buf[1], data_size + CVID_HEADER_SIZE);\n\n    AV_WB16(&buf[4], s->w);\n\n    AV_WB16(&buf[6], s->h);\n\n    AV_WB16(&buf[8], num_strips);\n\n\n\n    return CVID_HEADER_SIZE;\n\n}\n", "idx": 14359}, {"project": "test", "commit_id": "test", "target": 1, "func": "static av_cold int mpeg4video_parse_init(AVCodecParserContext *s)\n\n{\n\n    ParseContext1 *pc = s->priv_data;\n\n\n\n    pc->enc = av_mallocz(sizeof(MpegEncContext));\n\n    if (!pc->enc)\n\n        return -1;\n\n    pc->first_picture = 1;\n\n\n    return 0;\n\n}", "idx": 14362}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void gen_arm_shift_im(TCGv var, int shiftop, int shift, int flags)\n\n{\n\n    switch (shiftop) {\n\n    case 0: /* LSL */\n\n        if (shift != 0) {\n\n            if (flags)\n\n                shifter_out_im(var, 32 - shift);\n\n            tcg_gen_shli_i32(var, var, shift);\n\n        }\n\n        break;\n\n    case 1: /* LSR */\n\n        if (shift == 0) {\n\n            if (flags) {\n\n                tcg_gen_shri_i32(var, var, 31);\n\n                gen_set_CF(var);\n\n            }\n\n            tcg_gen_movi_i32(var, 0);\n\n        } else {\n\n            if (flags)\n\n                shifter_out_im(var, shift - 1);\n\n            tcg_gen_shri_i32(var, var, shift);\n\n        }\n\n        break;\n\n    case 2: /* ASR */\n\n        if (shift == 0)\n\n            shift = 32;\n\n        if (flags)\n\n            shifter_out_im(var, shift - 1);\n\n        if (shift == 32)\n\n          shift = 31;\n\n        tcg_gen_sari_i32(var, var, shift);\n\n        break;\n\n    case 3: /* ROR/RRX */\n\n        if (shift != 0) {\n\n            if (flags)\n\n                shifter_out_im(var, shift - 1);\n\n            tcg_gen_rotri_i32(var, var, shift); break;\n\n        } else {\n\n            TCGv tmp = load_cpu_field(CF);\n\n            if (flags)\n\n                shifter_out_im(var, 0);\n\n            tcg_gen_shri_i32(var, var, 1);\n\n            tcg_gen_shli_i32(tmp, tmp, 31);\n\n            tcg_gen_or_i32(var, var, tmp);\n\n            dead_tmp(tmp);\n\n        }\n\n    }\n\n};\n", "idx": 14376}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void vmxnet3_update_vlan_filters(VMXNET3State *s)\n\n{\n\n    int i;\n\n\n\n    /* Copy configuration from shared memory */\n\n    VMXNET3_READ_DRV_SHARED(s->drv_shmem,\n\n                            devRead.rxFilterConf.vfTable,\n\n                            s->vlan_table,\n\n                            sizeof(s->vlan_table));\n\n\n\n    /* Invert byte order when needed */\n\n    for (i = 0; i < ARRAY_SIZE(s->vlan_table); i++) {\n\n        s->vlan_table[i] = le32_to_cpu(s->vlan_table[i]);\n\n    }\n\n\n\n    /* Dump configuration for debugging purposes */\n\n    VMW_CFPRN(\"Configured VLANs:\");\n\n    for (i = 0; i < sizeof(s->vlan_table) * 8; i++) {\n\n        if (VMXNET3_VFTABLE_ENTRY_IS_SET(s->vlan_table, i)) {\n\n            VMW_CFPRN(\"\\tVLAN %d is present\", i);\n\n        }\n\n    }\n\n}\n", "idx": 14379}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int vlc_decode_block(MimicContext *ctx, int num_coeffs, int qscale)\n\n{\n\n    int16_t *block = ctx->dct_block;\n\n    unsigned int pos;\n\n\n\n    ctx->bdsp.clear_block(block);\n\n\n\n    block[0] = get_bits(&ctx->gb, 8) << 3;\n\n\n\n    for (pos = 1; pos < num_coeffs; pos++) {\n\n        uint32_t vlc, num_bits;\n\n        int value;\n\n        int coeff;\n\n\n\n        vlc = get_vlc2(&ctx->gb, ctx->vlc.table, ctx->vlc.bits, 3);\n\n        if (!vlc) /* end-of-block code */\n\n            return 0;\n\n        if (vlc == -1)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        /* pos_add and num_bits are coded in the vlc code */\n\n        pos     += vlc & 15; // pos_add\n\n        num_bits = vlc >> 4; // num_bits\n\n\n\n        if (pos >= 64)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        value = get_bits(&ctx->gb, num_bits);\n\n\n\n        /* FFmpeg's IDCT behaves somewhat different from the original code, so\n\n         * a factor of 4 was added to the input */\n\n\n\n        coeff = vlcdec_lookup[num_bits][value];\n\n        if (pos < 3)\n\n            coeff *= 16;\n\n        else /* TODO Use >> 10 instead of / 1001 */\n\n            coeff = (coeff * qscale) / 1001;\n\n\n\n        block[ctx->scantable.permutated[pos]] = coeff;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 14639}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void picmemset(PicContext *s, AVFrame *frame, int value, int run,\n\n                      int *x, int *y, int *plane, int bits_per_plane)\n\n{\n\n    uint8_t *d;\n\n    int shift = *plane * bits_per_plane;\n\n    int mask  = ((1 << bits_per_plane) - 1) << shift;\n\n    value   <<= shift;\n\n\n\n    while (run > 0) {\n\n        int j;\n\n        for (j = 8-bits_per_plane; j >= 0; j -= bits_per_plane) {\n\n            d = frame->data[0] + *y * frame->linesize[0];\n\n            d[*x] |= (value >> j) & mask;\n\n            *x += 1;\n\n            if (*x == s->width) {\n\n                *y -= 1;\n\n                *x = 0;\n\n                if (*y < 0) {\n\n                   *y = s->height - 1;\n\n                   *plane += 1;\n\n                   if (*plane >= s->nb_planes)\n\n                       return;\n\n                   value <<= bits_per_plane;\n\n                   mask  <<= bits_per_plane;\n\n                }\n\n            }\n\n        }\n\n        run--;\n\n    }\n\n}\n", "idx": 14665}, {"project": "test", "commit_id": "test", "target": 1, "func": "vubr_set_vring_addr_exec(VubrDev *dev, VhostUserMsg *vmsg)\n{\n    struct vhost_vring_addr *vra = &vmsg->payload.addr;\n    unsigned int index = vra->index;\n    VubrVirtq *vq = &dev->vq[index];\n    DPRINT(\"vhost_vring_addr:\\n\");\n    DPRINT(\"    index:  %d\\n\", vra->index);\n    DPRINT(\"    flags:  %d\\n\", vra->flags);\n    DPRINT(\"    desc_user_addr:   0x%016llx\\n\", vra->desc_user_addr);\n    DPRINT(\"    used_user_addr:   0x%016llx\\n\", vra->used_user_addr);\n    DPRINT(\"    avail_user_addr:  0x%016llx\\n\", vra->avail_user_addr);\n    DPRINT(\"    log_guest_addr:   0x%016llx\\n\", vra->log_guest_addr);\n    vq->desc = (struct vring_desc *)(uintptr_t)qva_to_va(dev, vra->desc_user_addr);\n    vq->used = (struct vring_used *)(uintptr_t)qva_to_va(dev, vra->used_user_addr);\n    vq->avail = (struct vring_avail *)(uintptr_t)qva_to_va(dev, vra->avail_user_addr);\n    vq->log_guest_addr = vra->log_guest_addr;\n    DPRINT(\"Setting virtq addresses:\\n\");\n    DPRINT(\"    vring_desc  at %p\\n\", vq->desc);\n    DPRINT(\"    vring_used  at %p\\n\", vq->used);\n    DPRINT(\"    vring_avail at %p\\n\", vq->avail);\n    vq->last_used_index = vq->used->idx;\n    return 0;", "idx": 14680}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline TCGv iwmmxt_load_creg(int reg)\n\n{\n\n    TCGv var = new_tmp();\n\n    tcg_gen_ld_i32(var, cpu_env, offsetof(CPUState, iwmmxt.cregs[reg]));\n\n    return var;\n\n}\n", "idx": 14814}, {"project": "test", "commit_id": "test", "target": 1, "func": "void HELPER(set_cp_reg64)(CPUARMState *env, void *rip, uint64_t value)\n\n{\n\n    const ARMCPRegInfo *ri = rip;\n\n\n\n    ri->writefn(env, ri, value);\n\n}\n", "idx": 14816}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void vhost_scsi_stop(VHostSCSI *s)\n\n{\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(s);\n\n    BusState *qbus = BUS(qdev_get_parent_bus(DEVICE(vdev)));\n\n    VirtioBusClass *k = VIRTIO_BUS_GET_CLASS(qbus);\n\n    int ret = 0;\n\n\n\n    if (!k->set_guest_notifiers) {\n\n        ret = k->set_guest_notifiers(qbus->parent, s->dev.nvqs, false);\n\n        if (ret < 0) {\n\n                error_report(\"vhost guest notifier cleanup failed: %d\\n\", ret);\n\n        }\n\n    }\n\n    assert(ret >= 0);\n\n\n\n    vhost_scsi_clear_endpoint(s);\n\n    vhost_dev_stop(&s->dev, vdev);\n\n    vhost_dev_disable_notifiers(&s->dev, vdev);\n\n}\n", "idx": 14822}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void start_tco(const TestData *d)\n\n{\n\n    uint32_t val;\n\n\n\n    val = qpci_io_readw(d->dev, d->tco_io_base + TCO1_CNT);\n\n    val &= ~TCO_TMR_HLT;\n\n    qpci_io_writew(d->dev, d->tco_io_base + TCO1_CNT, val);\n\n}\n", "idx": 14823}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void spatial_decompose53i(DWTELEM *buffer, int width, int height, int stride){\n\n    int y;\n\n    DWTELEM *b0= buffer + mirror(-2-1, height-1)*stride;\n\n    DWTELEM *b1= buffer + mirror(-2  , height-1)*stride;\n\n\n\n    for(y=-2; y<height; y+=2){\n\n        DWTELEM *b2= buffer + mirror(y+1, height-1)*stride;\n\n        DWTELEM *b3= buffer + mirror(y+2, height-1)*stride;\n\n\n\n{START_TIMER\n\n        if(b1 <= b3)     horizontal_decompose53i(b2, width);\n\n        if(y+2 < height) horizontal_decompose53i(b3, width);\n\nSTOP_TIMER(\"horizontal_decompose53i\")}\n\n\n\n{START_TIMER\n\n        if(b1 <= b3) vertical_decompose53iH0(b1, b2, b3, width);\n\n        if(b0 <= b2) vertical_decompose53iL0(b0, b1, b2, width);\n\nSTOP_TIMER(\"vertical_decompose53i*\")}\n\n\n\n        b0=b2;\n\n        b1=b3;\n\n    }\n\n}\n", "idx": 14942}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int vmd_read_header(AVFormatContext *s,\n\n                           AVFormatParameters *ap)\n\n{\n\n    VmdDemuxContext *vmd = (VmdDemuxContext *)s->priv_data;\n\n    ByteIOContext *pb = &s->pb;\n\n    AVStream *st;\n\n    unsigned int toc_offset;\n\n    unsigned char *raw_frame_table;\n\n    int raw_frame_table_size;\n\n    offset_t current_offset;\n\n    int i, j;\n\n    unsigned int total_frames;\n\n    int64_t video_pts_inc = 0;\n\n    int64_t current_video_pts = 0;\n\n    unsigned char chunk[BYTES_PER_FRAME_RECORD];\n\n    int lastframe = 0;\n\n\n\n    /* fetch the main header, including the 2 header length bytes */\n\n    url_fseek(pb, 0, SEEK_SET);\n\n    if (get_buffer(pb, vmd->vmd_header, VMD_HEADER_SIZE) != VMD_HEADER_SIZE)\n\n        return AVERROR_IO;\n\n\n\n    vmd->audio_sample_counter = 0;\n\n    vmd->audio_frame_divisor = 1;\n\n    vmd->audio_block_align = 1;\n\n\n\n    /* start up the decoders */\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR_NOMEM;\n\n    av_set_pts_info(st, 33, 1, 90000);\n\n    vmd->video_stream_index = st->index;\n\n    st->codec->codec_type = CODEC_TYPE_VIDEO;\n\n    st->codec->codec_id = CODEC_ID_VMDVIDEO;\n\n    st->codec->codec_tag = 0;  /* no fourcc */\n\n    st->codec->width = LE_16(&vmd->vmd_header[12]);\n\n    st->codec->height = LE_16(&vmd->vmd_header[14]);\n\n    st->codec->time_base.num = 1;\n\n    st->codec->time_base.den = 10;\n\n    st->codec->extradata_size = VMD_HEADER_SIZE;\n\n    st->codec->extradata = av_mallocz(VMD_HEADER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    memcpy(st->codec->extradata, vmd->vmd_header, VMD_HEADER_SIZE);\n\n\n\n    /* if sample rate is 0, assume no audio */\n\n    vmd->sample_rate = LE_16(&vmd->vmd_header[804]);\n\n    if (vmd->sample_rate) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR_NOMEM;\n\n        av_set_pts_info(st, 33, 1, 90000);\n\n        vmd->audio_stream_index = st->index;\n\n        st->codec->codec_type = CODEC_TYPE_AUDIO;\n\n        st->codec->codec_id = CODEC_ID_VMDAUDIO;\n\n        st->codec->codec_tag = 0;  /* no fourcc */\n\n        st->codec->channels = vmd->audio_channels = (vmd->vmd_header[811] & 0x80) ? 2 : 1;\n\n        st->codec->sample_rate = vmd->sample_rate;\n\n        st->codec->block_align = vmd->audio_block_align =\n\n            LE_16(&vmd->vmd_header[806]);\n\n        if (st->codec->block_align & 0x8000) {\n\n            st->codec->bits_per_sample = 16;\n\n            st->codec->block_align = -(st->codec->block_align - 0x10000);\n\n            vmd->audio_block_align = -(vmd->audio_block_align - 0x10000);\n\n        } else {\n\n            st->codec->bits_per_sample = 8;\n\n\n        st->codec->bit_rate = st->codec->sample_rate *\n\n            st->codec->bits_per_sample * st->codec->channels;\n\n\n\n        /* for calculating pts */\n\n        vmd->audio_frame_divisor = st->codec->channels;\n\n\n\n        video_pts_inc = 90000;\n\n        video_pts_inc *= st->codec->block_align;\n\n        video_pts_inc /= st->codec->sample_rate;\n\n        video_pts_inc /= st->codec->channels;\n\n    } else {\n\n        /* if no audio, assume 10 frames/second */\n\n        video_pts_inc = 90000 / 10;\n\n\n\n\n    toc_offset = LE_32(&vmd->vmd_header[812]);\n\n    vmd->frame_count = LE_16(&vmd->vmd_header[6]);\n\n    vmd->frames_per_block = LE_16(&vmd->vmd_header[18]);\n\n    url_fseek(pb, toc_offset, SEEK_SET);\n\n\n\n    raw_frame_table = NULL;\n\n    vmd->frame_table = NULL;\n\n    raw_frame_table_size = vmd->frame_count * 6;\n\n    raw_frame_table = av_malloc(raw_frame_table_size);\n\n\n\n\n\n    vmd->frame_table = av_malloc(vmd->frame_count * vmd->frames_per_block * sizeof(vmd_frame_t));\n\n    if (!raw_frame_table || !vmd->frame_table) {\n\n        av_free(raw_frame_table);\n\n        av_free(vmd->frame_table);\n\n        return AVERROR_NOMEM;\n\n\n    if (get_buffer(pb, raw_frame_table, raw_frame_table_size) !=\n\n        raw_frame_table_size) {\n\n        av_free(raw_frame_table);\n\n        av_free(vmd->frame_table);\n\n        return AVERROR_IO;\n\n\n\n\n    total_frames = 0;\n\n    for (i = 0; i < vmd->frame_count; i++) {\n\n\n\n        current_offset = LE_32(&raw_frame_table[6 * i + 2]);\n\n\n\n        /* handle each entry in index block */\n\n        for (j = 0; j < vmd->frames_per_block; j++) {\n\n            int type;\n\n            uint32_t size;\n\n\n\n            get_buffer(pb, chunk, BYTES_PER_FRAME_RECORD);\n\n            type = chunk[0];\n\n            size = LE_32(&chunk[2]);\n\n            if(!size)\n\n                continue;\n\n            switch(type) {\n\n            case 1: /* Audio Chunk */\n\n                vmd->frame_table[total_frames].frame_offset = current_offset;\n\n                vmd->frame_table[total_frames].stream_index = vmd->audio_stream_index;\n\n                vmd->frame_table[total_frames].frame_size = size;\n\n                memcpy(vmd->frame_table[total_frames].frame_record, chunk, BYTES_PER_FRAME_RECORD);\n\n                total_frames++;\n\n                break;\n\n            case 2: /* Video Chunk */\n\n                vmd->frame_table[total_frames].frame_offset = current_offset;\n\n                vmd->frame_table[total_frames].frame_size = size;\n\n                vmd->frame_table[total_frames].stream_index = vmd->video_stream_index;\n\n                memcpy(vmd->frame_table[total_frames].frame_record, chunk, BYTES_PER_FRAME_RECORD);\n\n                vmd->frame_table[total_frames].pts = current_video_pts;\n\n                if (lastframe) {\n\n                    vmd->frame_table[lastframe].pts = current_video_pts - video_pts_inc;\n\n\n                lastframe = total_frames;\n\n                total_frames++;\n\n                break;\n\n\n            current_offset += size;\n\n\n        current_video_pts += video_pts_inc;\n\n\n\n\n    av_free(raw_frame_table);\n\n\n\n    vmd->current_frame = 0;\n\n    vmd->frame_count = total_frames;\n\n\n\n    return 0;\n", "idx": 15094}, {"project": "test", "commit_id": "test", "target": 1, "func": "int avcodec_default_reget_buffer(AVCodecContext *s, AVFrame *pic)\n\n{\n\n    av_assert0(0);\n\n\n}", "idx": 15124}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int asf_read_picture(AVFormatContext *s, int len)\n\n{\n\n    ASFContext *asf       = s->priv_data;\n\n    AVPacket pkt          = { 0 };\n\n    const CodecMime *mime = ff_id3v2_mime_tags;\n\n    enum  AVCodecID id    = AV_CODEC_ID_NONE;\n\n    char mimetype[64];\n\n    uint8_t  *desc = NULL;\n\n    AVStream   *st = NULL;\n\n    int ret, type, picsize, desc_len;\n\n    ASFStream *asf_st;\n\n\n\n    /* type + picsize + mime + desc */\n\n    if (len < 1 + 4 + 2 + 2) {\n\n        av_log(s, AV_LOG_ERROR, \"Invalid attached picture size: %d.\\n\", len);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* picture type */\n\n    type = avio_r8(s->pb);\n\n    len--;\n\n    if (type >= FF_ARRAY_ELEMS(ff_id3v2_picture_types) || type < 0) {\n\n        av_log(s, AV_LOG_WARNING, \"Unknown attached picture type: %d.\\n\", type);\n\n        type = 0;\n\n    }\n\n\n\n    /* picture data size */\n\n    picsize = avio_rl32(s->pb);\n\n    len    -= 4;\n\n\n\n    /* picture MIME type */\n\n    len -= avio_get_str16le(s->pb, len, mimetype, sizeof(mimetype));\n\n    while (mime->id != AV_CODEC_ID_NONE) {\n\n        if (!strncmp(mime->str, mimetype, sizeof(mimetype))) {\n\n            id = mime->id;\n\n            break;\n\n        }\n\n        mime++;\n\n    }\n\n    if (id == AV_CODEC_ID_NONE) {\n\n        av_log(s, AV_LOG_ERROR, \"Unknown attached picture mimetype: %s.\\n\",\n\n               mimetype);\n\n        return 0;\n\n    }\n\n\n\n    if (picsize >= len) {\n\n        av_log(s, AV_LOG_ERROR, \"Invalid attached picture data size: %d >= %d.\\n\",\n\n               picsize, len);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    /* picture description */\n\n    desc_len = (len - picsize) * 2 + 1;\n\n    desc     = av_malloc(desc_len);\n\n    if (!desc)\n\n        return AVERROR(ENOMEM);\n\n    len -= avio_get_str16le(s->pb, len - picsize, desc, desc_len);\n\n\n\n    ret = av_get_packet(s->pb, &pkt, picsize);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    st  = avformat_new_stream(s, NULL);\n\n    if (!st) {\n\n        ret = AVERROR(ENOMEM);\n\n        goto fail;\n\n    }\n\n    asf->asf_st[asf->nb_streams] = av_mallocz(sizeof(*asf_st));\n\n    asf_st = asf->asf_st[asf->nb_streams];\n\n    if (!asf_st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    st->disposition              |= AV_DISPOSITION_ATTACHED_PIC;\n\n    st->codec->codec_type         = asf_st->type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id           = id;\n\n    st->attached_pic              = pkt;\n\n    st->attached_pic.stream_index = asf_st->index = st->index;\n\n    st->attached_pic.flags       |= AV_PKT_FLAG_KEY;\n\n\n\n    asf->nb_streams++;\n\n\n\n    if (*desc) {\n\n        if (av_dict_set(&st->metadata, \"title\", desc, AV_DICT_DONT_STRDUP_VAL) < 0)\n\n            av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n\n    } else\n\n        av_freep(&desc);\n\n\n\n    if (av_dict_set(&st->metadata, \"comment\", ff_id3v2_picture_types[type], 0) < 0)\n\n        av_log(s, AV_LOG_WARNING, \"av_dict_set failed.\\n\");\n\n\n\n    return 0;\n\n\n\nfail:\n\n    av_freep(&desc);\n\n    av_free_packet(&pkt);\n\n    return ret;\n\n}\n", "idx": 15206}, {"project": "test", "commit_id": "test", "target": 1, "func": "void HELPER(access_check_cp_reg)(CPUARMState *env, void *rip, uint32_t syndrome)\n{\n    const ARMCPRegInfo *ri = rip;\n    switch (ri->accessfn(env, ri)) {\n    case CP_ACCESS_OK:\n    case CP_ACCESS_TRAP:\n        break;\n    case CP_ACCESS_TRAP_UNCATEGORIZED:\n        env->exception.syndrome = syn_uncategorized();\n        break;\n    default:\n        g_assert_not_reached();", "idx": 15209}, {"project": "test", "commit_id": "test", "target": 1, "func": "void pc_hot_add_cpu(const int64_t id, Error **errp)\n{\n    DeviceState *icc_bridge;\n    int64_t apic_id = x86_cpu_apic_id_from_index(id);\n    if (cpu_exists(apic_id)) {\n        error_setg(errp, \"Unable to add CPU: %\" PRIi64\n                   \", it already exists\", id);\n    if (id >= max_cpus) {\n        error_setg(errp, \"Unable to add CPU: %\" PRIi64\n                   \", max allowed: %d\", id, max_cpus - 1);\n    icc_bridge = DEVICE(object_resolve_path_type(\"icc-bridge\",\n                                                 TYPE_ICC_BRIDGE, NULL));\n    pc_new_cpu(current_cpu_model, apic_id, icc_bridge, errp);", "idx": 15260}, {"project": "test", "commit_id": "test", "target": 1, "func": "void vp8_mc_chroma(VP8Context *s, VP8ThreadData *td, uint8_t *dst1, uint8_t *dst2,\n\n                   ThreadFrame *ref, const VP56mv *mv, int x_off, int y_off,\n\n                   int block_w, int block_h, int width, int height, int linesize,\n\n                   vp8_mc_func mc_func[3][3])\n\n{\n\n    uint8_t *src1 = ref->f->data[1], *src2 = ref->f->data[2];\n\n\n\n    if (AV_RN32A(mv)) {\n\n        int mx = mv->x&7, mx_idx = subpel_idx[0][mx];\n\n        int my = mv->y&7, my_idx = subpel_idx[0][my];\n\n\n\n        x_off += mv->x >> 3;\n\n        y_off += mv->y >> 3;\n\n\n\n        // edge emulation\n\n        src1 += y_off * linesize + x_off;\n\n        src2 += y_off * linesize + x_off;\n\n        ff_thread_await_progress(ref, (3 + y_off + block_h + subpel_idx[2][my]) >> 3, 0);\n\n        if (x_off < mx_idx || x_off >= width  - block_w - subpel_idx[2][mx] ||\n\n            y_off < my_idx || y_off >= height - block_h - subpel_idx[2][my]) {\n\n            s->vdsp.emulated_edge_mc(td->edge_emu_buffer, src1 - my_idx * linesize - mx_idx, linesize,\n\n                                     block_w + subpel_idx[1][mx], block_h + subpel_idx[1][my],\n\n                                     x_off - mx_idx, y_off - my_idx, width, height);\n\n            src1 = td->edge_emu_buffer + mx_idx + linesize * my_idx;\n\n            mc_func[my_idx][mx_idx](dst1, linesize, src1, linesize, block_h, mx, my);\n\n\n\n            s->vdsp.emulated_edge_mc(td->edge_emu_buffer, src2 - my_idx * linesize - mx_idx, linesize,\n\n                                     block_w + subpel_idx[1][mx], block_h + subpel_idx[1][my],\n\n                                     x_off - mx_idx, y_off - my_idx, width, height);\n\n            src2 = td->edge_emu_buffer + mx_idx + linesize * my_idx;\n\n            mc_func[my_idx][mx_idx](dst2, linesize, src2, linesize, block_h, mx, my);\n\n        } else {\n\n            mc_func[my_idx][mx_idx](dst1, linesize, src1, linesize, block_h, mx, my);\n\n            mc_func[my_idx][mx_idx](dst2, linesize, src2, linesize, block_h, mx, my);\n\n        }\n\n    } else {\n\n        ff_thread_await_progress(ref, (3 + y_off + block_h) >> 3, 0);\n\n        mc_func[0][0](dst1, linesize, src1 + y_off * linesize + x_off, linesize, block_h, 0, 0);\n\n        mc_func[0][0](dst2, linesize, src2 + y_off * linesize + x_off, linesize, block_h, 0, 0);\n\n    }\n\n}\n", "idx": 15301}, {"project": "test", "commit_id": "test", "target": 1, "func": "static TCGArg *tcg_constant_folding(TCGContext *s, uint16_t *tcg_opc_ptr,\n                                    TCGArg *args, TCGOpDef *tcg_op_defs)\n{\n    int i, nb_ops, op_index, nb_temps, nb_globals, nb_call_args;\n    TCGOpcode op;\n    const TCGOpDef *def;\n    TCGArg *gen_args;\n    TCGArg tmp;\n    TCGCond cond;\n    /* Array VALS has an element for each temp.\n       If this temp holds a constant then its value is kept in VALS' element.\n       If this temp is a copy of other ones then the other copies are\n       available through the doubly linked circular list. */\n    nb_temps = s->nb_temps;\n    nb_globals = s->nb_globals;\n    memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n    nb_ops = tcg_opc_ptr - gen_opc_buf;\n    gen_args = args;\n    for (op_index = 0; op_index < nb_ops; op_index++) {\n        op = gen_opc_buf[op_index];\n        def = &tcg_op_defs[op];\n        /* Do copy propagation */\n        if (op == INDEX_op_call) {\n            int nb_oargs = args[0] >> 16;\n            int nb_iargs = args[0] & 0xffff;\n            for (i = nb_oargs + 1; i < nb_oargs + nb_iargs + 1; i++) {\n                if (temps[args[i]].state == TCG_TEMP_COPY) {\n                    args[i] = find_better_copy(s, args[i]);\n        } else {\n            for (i = def->nb_oargs; i < def->nb_oargs + def->nb_iargs; i++) {\n                if (temps[args[i]].state == TCG_TEMP_COPY) {\n                    args[i] = find_better_copy(s, args[i]);\n        /* For commutative operations make constant second argument */\n        CASE_OP_32_64(add):\n        CASE_OP_32_64(mul):\n        CASE_OP_32_64(and):\n        CASE_OP_32_64(or):\n        CASE_OP_32_64(eqv):\n        CASE_OP_32_64(nand):\n        CASE_OP_32_64(nor):\n            if (temps[args[1]].state == TCG_TEMP_CONST) {\n                tmp = args[1];\n                args[1] = args[2];\n                args[2] = tmp;\n        CASE_OP_32_64(brcond):\n            if (temps[args[0]].state == TCG_TEMP_CONST\n                && temps[args[1]].state != TCG_TEMP_CONST) {\n                tmp = args[0];\n                args[0] = args[1];\n                args[1] = tmp;\n                args[2] = tcg_swap_cond(args[2]);\n        CASE_OP_32_64(setcond):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state != TCG_TEMP_CONST) {\n                tmp = args[1];\n                args[1] = args[2];\n                args[2] = tmp;\n                args[3] = tcg_swap_cond(args[3]);\n        CASE_OP_32_64(movcond):\n            cond = args[5];\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state != TCG_TEMP_CONST) {\n                tmp = args[1];\n                args[1] = args[2];\n                args[2] = tmp;\n                cond = tcg_swap_cond(cond);\n            /* For movcond, we canonicalize the \"false\" input reg to match\n               the destination reg so that the tcg backend can implement\n               a \"move if true\" operation.  */\n            if (args[0] == args[3]) {\n                tmp = args[3];\n                args[3] = args[4];\n                args[4] = tmp;\n                cond = tcg_invert_cond(cond);\n            args[5] = cond;\n        /* Simplify expressions for \"shift/rot r, 0, a => movi r, 0\" */\n        CASE_OP_32_64(shl):\n        CASE_OP_32_64(shr):\n        CASE_OP_32_64(sar):\n        CASE_OP_32_64(rotl):\n        CASE_OP_32_64(rotr):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[1]].val == 0) {\n        /* Simplify expression for \"op r, a, 0 => mov r, a\" cases */\n        CASE_OP_32_64(add):\n        CASE_OP_32_64(shl):\n        CASE_OP_32_64(shr):\n        CASE_OP_32_64(sar):\n        CASE_OP_32_64(rotl):\n        CASE_OP_32_64(rotr):\n        CASE_OP_32_64(or):\n            if (temps[args[1]].state == TCG_TEMP_CONST) {\n                /* Proceed with possible constant folding. */\n            if (temps[args[2]].state == TCG_TEMP_CONST\n                && temps[args[2]].val == 0) {\n                if (temps_are_copies(args[0], args[1])) {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n                } else {\n                    gen_opc_buf[op_index] = op_to_mov(op);\n                    tcg_opt_gen_mov(s, gen_args, args[0], args[1]);\n        /* Simplify expression for \"op r, a, 0 => movi r, 0\" cases */\n        CASE_OP_32_64(and):\n        CASE_OP_32_64(mul):\n            if ((temps[args[2]].state == TCG_TEMP_CONST\n                && temps[args[2]].val == 0)) {\n        /* Simplify expression for \"op r, a, a => mov r, a\" cases */\n        CASE_OP_32_64(or):\n        CASE_OP_32_64(and):\n                if (temps_are_copies(args[0], args[1])) {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n                } else {\n                    gen_opc_buf[op_index] = op_to_mov(op);\n                    tcg_opt_gen_mov(s, gen_args, args[0], args[1]);\n        /* Propagate constants through copy operations and do constant\n           folding.  Constants will be substituted to arguments by register\n           allocator where needed and possible.  Also detect copies. */\n        CASE_OP_32_64(mov):\n            if (temps_are_copies(args[0], args[1])) {\n                args += 2;\n                gen_opc_buf[op_index] = INDEX_op_nop;\n            if (temps[args[1]].state != TCG_TEMP_CONST) {\n                tcg_opt_gen_mov(s, gen_args, args[0], args[1]);\n                args += 2;\n            /* Source argument is constant.  Rewrite the operation and\n               let movi case handle it. */\n            op = op_to_movi(op);\n            gen_opc_buf[op_index] = op;\n            args[1] = temps[args[1]].val;\n            /* fallthrough */\n        CASE_OP_32_64(movi):\n            tcg_opt_gen_movi(gen_args, args[0], args[1]);\n            args += 2;\n        CASE_OP_32_64(not):\n        CASE_OP_32_64(neg):\n        CASE_OP_32_64(ext8s):\n        CASE_OP_32_64(ext8u):\n        CASE_OP_32_64(ext16s):\n        CASE_OP_32_64(ext16u):\n        case INDEX_op_ext32s_i64:\n        case INDEX_op_ext32u_i64:\n            if (temps[args[1]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding(op, temps[args[1]].val, 0);\n                tcg_opt_gen_movi(gen_args, args[0], tmp);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n            args += 2;\n        CASE_OP_32_64(add):\n        CASE_OP_32_64(mul):\n        CASE_OP_32_64(or):\n        CASE_OP_32_64(and):\n        CASE_OP_32_64(shl):\n        CASE_OP_32_64(shr):\n        CASE_OP_32_64(sar):\n        CASE_OP_32_64(rotl):\n        CASE_OP_32_64(rotr):\n        CASE_OP_32_64(andc):\n        CASE_OP_32_64(orc):\n        CASE_OP_32_64(eqv):\n        CASE_OP_32_64(nand):\n        CASE_OP_32_64(nor):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding(op, temps[args[1]].val,\n                                          temps[args[2]].val);\n                tcg_opt_gen_movi(gen_args, args[0], tmp);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args += 3;\n        CASE_OP_32_64(setcond):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding_cond(op, temps[args[1]].val,\n                                               temps[args[2]].val, args[3]);\n                tcg_opt_gen_movi(gen_args, args[0], tmp);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args[3] = args[3];\n                gen_args += 4;\n            args += 4;\n        CASE_OP_32_64(brcond):\n            if (temps[args[0]].state == TCG_TEMP_CONST\n                && temps[args[1]].state == TCG_TEMP_CONST) {\n                if (do_constant_folding_cond(op, temps[args[0]].val,\n                                             temps[args[1]].val, args[2])) {\n                    memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n                    gen_opc_buf[op_index] = INDEX_op_br;\n                    gen_args[0] = args[3];\n                    gen_args += 1;\n                } else {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n            } else {\n                memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args[3] = args[3];\n                gen_args += 4;\n            args += 4;\n        CASE_OP_32_64(movcond):\n            if (temps[args[1]].state == TCG_TEMP_CONST\n                && temps[args[2]].state == TCG_TEMP_CONST) {\n                tmp = do_constant_folding_cond(op, temps[args[1]].val,\n                                               temps[args[2]].val, args[5]);\n                if (temps_are_copies(args[0], args[4-tmp])) {\n                    gen_opc_buf[op_index] = INDEX_op_nop;\n                } else if (temps[args[4-tmp]].state == TCG_TEMP_CONST) {\n                    tcg_opt_gen_movi(gen_args, args[0], temps[args[4-tmp]].val);\n                } else {\n                    gen_opc_buf[op_index] = op_to_mov(op);\n                    tcg_opt_gen_mov(s, gen_args, args[0], args[4-tmp]);\n            } else {\n                reset_temp(args[0]);\n                gen_args[0] = args[0];\n                gen_args[1] = args[1];\n                gen_args[2] = args[2];\n                gen_args[3] = args[3];\n                gen_args[4] = args[4];\n                gen_args[5] = args[5];\n                gen_args += 6;\n            args += 6;\n        case INDEX_op_call:\n            nb_call_args = (args[0] >> 16) + (args[0] & 0xffff);\n            if (!(args[nb_call_args + 1] & (TCG_CALL_CONST | TCG_CALL_PURE))) {\n                for (i = 0; i < nb_globals; i++) {\n                    reset_temp(i);\n            for (i = 0; i < (args[0] >> 16); i++) {\n                reset_temp(args[i + 1]);\n            i = nb_call_args + 3;\n            while (i) {\n                *gen_args = *args;\n                args++;\n                gen_args++;\n                i--;\n            /* Default case: we do know nothing about operation so no\n               propagation is done.  We trash everything if the operation\n               is the end of a basic block, otherwise we only trash the\n               output args.  */\n            if (def->flags & TCG_OPF_BB_END) {\n                memset(temps, 0, nb_temps * sizeof(struct tcg_temp_info));\n            } else {\n                for (i = 0; i < def->nb_oargs; i++) {\n                    reset_temp(args[i]);\n            for (i = 0; i < def->nb_args; i++) {\n                gen_args[i] = args[i];\n            args += def->nb_args;\n            gen_args += def->nb_args;\n    return gen_args;", "idx": 15388}, {"project": "test", "commit_id": "test", "target": 1, "func": "void compute_images_mse_16bit(PSNRContext *s,\n\n                        const uint8_t *main_data[4], const int main_linesizes[4],\n\n                        const uint8_t *ref_data[4], const int ref_linesizes[4],\n\n                        int w, int h, double mse[4])\n\n{\n\n    int i, c, j;\n\n\n\n    for (c = 0; c < s->nb_components; c++) {\n\n        const int outw = s->planewidth[c];\n\n        const int outh = s->planeheight[c];\n\n        const uint16_t *main_line = (uint16_t *)main_data[c];\n\n        const uint16_t *ref_line = (uint16_t *)ref_data[c];\n\n        const int ref_linesize = ref_linesizes[c] / 2;\n\n        const int main_linesize = main_linesizes[c] / 2;\n\n        uint64_t m = 0;\n\n\n\n        for (i = 0; i < outh; i++) {\n\n            for (j = 0; j < outw; j++)\n\n                m += pow2(main_line[j] - ref_line[j]);\n\n            ref_line += ref_linesize;\n\n            main_line += main_linesize;\n\n        }\n\n        mse[c] = m / (double)(outw * outh);\n\n    }\n\n}\n", "idx": 15589}, {"project": "test", "commit_id": "test", "target": 1, "func": "putsum(uint8_t *data, uint32_t n, uint32_t sloc, uint32_t css, uint32_t cse)\n\n{\n\n    uint32_t sum;\n\n\n\n    if (cse && cse < n)\n\n        n = cse + 1;\n\n    if (sloc < n-1) {\n\n        sum = net_checksum_add(n-css, data+css);\n\n        stw_be_p(data + sloc, net_checksum_finish(sum));\n\n    }\n\n}\n", "idx": 15594}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int virtio_scsi_device_exit(DeviceState *qdev)\n\n{\n\n    VirtIOSCSI *s = VIRTIO_SCSI(qdev);\n\n    VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(qdev);\n\n\n\n    unregister_savevm(qdev, \"virtio-scsi\", s);\n\n    return virtio_scsi_common_exit(vs);\n\n}\n", "idx": 15846}, {"project": "test", "commit_id": "test", "target": 1, "func": "int hvf_vcpu_exec(CPUState *cpu)\n\n{\n\n    X86CPU *x86_cpu = X86_CPU(cpu);\n\n    CPUX86State *env = &x86_cpu->env;\n\n    int ret = 0;\n\n    uint64_t rip = 0;\n\n\n\n    cpu->halted = 0;\n\n\n\n    if (hvf_process_events(cpu)) {\n\n        return EXCP_HLT;\n\n    }\n\n\n\n    do {\n\n        if (cpu->vcpu_dirty) {\n\n            hvf_put_registers(cpu);\n\n            cpu->vcpu_dirty = false;\n\n        }\n\n\n\n        if (hvf_inject_interrupts(cpu)) {\n\n            return EXCP_INTERRUPT;\n\n        }\n\n        vmx_update_tpr(cpu);\n\n\n\n        qemu_mutex_unlock_iothread();\n\n        if (!cpu_is_bsp(X86_CPU(cpu)) && cpu->halted) {\n\n            qemu_mutex_lock_iothread();\n\n            return EXCP_HLT;\n\n        }\n\n\n\n        hv_return_t r  = hv_vcpu_run(cpu->hvf_fd);\n\n        assert_hvf_ok(r);\n\n\n\n        /* handle VMEXIT */\n\n        uint64_t exit_reason = rvmcs(cpu->hvf_fd, VMCS_EXIT_REASON);\n\n        uint64_t exit_qual = rvmcs(cpu->hvf_fd, VMCS_EXIT_QUALIFICATION);\n\n        uint32_t ins_len = (uint32_t)rvmcs(cpu->hvf_fd,\n\n                                           VMCS_EXIT_INSTRUCTION_LENGTH);\n\n\n\n        uint64_t idtvec_info = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);\n\n\n\n        hvf_store_events(cpu, ins_len, idtvec_info);\n\n        rip = rreg(cpu->hvf_fd, HV_X86_RIP);\n\n        RFLAGS(env) = rreg(cpu->hvf_fd, HV_X86_RFLAGS);\n\n        env->eflags = RFLAGS(env);\n\n\n\n        qemu_mutex_lock_iothread();\n\n\n\n        update_apic_tpr(cpu);\n\n        current_cpu = cpu;\n\n\n\n        ret = 0;\n\n        switch (exit_reason) {\n\n        case EXIT_REASON_HLT: {\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            if (!((cpu->interrupt_request & CPU_INTERRUPT_HARD) &&\n\n                (EFLAGS(env) & IF_MASK))\n\n                && !(cpu->interrupt_request & CPU_INTERRUPT_NMI) &&\n\n                !(idtvec_info & VMCS_IDT_VEC_VALID)) {\n\n                cpu->halted = 1;\n\n                ret = EXCP_HLT;\n\n            }\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n        case EXIT_REASON_MWAIT: {\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n            /* Need to check if MMIO or unmmaped fault */\n\n        case EXIT_REASON_EPT_FAULT:\n\n        {\n\n            hvf_slot *slot;\n\n            addr_t gpa = rvmcs(cpu->hvf_fd, VMCS_GUEST_PHYSICAL_ADDRESS);\n\n\n\n            if (((idtvec_info & VMCS_IDT_VEC_VALID) == 0) &&\n\n                ((exit_qual & EXIT_QUAL_NMIUDTI) != 0)) {\n\n                vmx_set_nmi_blocking(cpu);\n\n            }\n\n\n\n            slot = hvf_find_overlap_slot(gpa, gpa);\n\n            /* mmio */\n\n            if (ept_emulation_fault(slot, gpa, exit_qual)) {\n\n                struct x86_decode decode;\n\n\n\n                load_regs(cpu);\n\n                env->hvf_emul->fetch_rip = rip;\n\n\n\n                decode_instruction(env, &decode);\n\n                exec_instruction(env, &decode);\n\n                store_regs(cpu);\n\n                break;\n\n            }\n\n            break;\n\n        }\n\n        case EXIT_REASON_INOUT:\n\n        {\n\n            uint32_t in = (exit_qual & 8) != 0;\n\n            uint32_t size =  (exit_qual & 7) + 1;\n\n            uint32_t string =  (exit_qual & 16) != 0;\n\n            uint32_t port =  exit_qual >> 16;\n\n            /*uint32_t rep = (exit_qual & 0x20) != 0;*/\n\n\n\n#if 1\n\n            if (!string && in) {\n\n                uint64_t val = 0;\n\n                load_regs(cpu);\n\n                hvf_handle_io(env, port, &val, 0, size, 1);\n\n                if (size == 1) {\n\n                    AL(env) = val;\n\n                } else if (size == 2) {\n\n                    AX(env) = val;\n\n                } else if (size == 4) {\n\n                    RAX(env) = (uint32_t)val;\n\n                } else {\n\n                    VM_PANIC(\"size\");\n\n                }\n\n                RIP(env) += ins_len;\n\n                store_regs(cpu);\n\n                break;\n\n            } else if (!string && !in) {\n\n                RAX(env) = rreg(cpu->hvf_fd, HV_X86_RAX);\n\n                hvf_handle_io(env, port, &RAX(env), 1, size, 1);\n\n                macvm_set_rip(cpu, rip + ins_len);\n\n                break;\n\n            }\n\n#endif\n\n            struct x86_decode decode;\n\n\n\n            load_regs(cpu);\n\n            env->hvf_emul->fetch_rip = rip;\n\n\n\n            decode_instruction(env, &decode);\n\n            VM_PANIC_ON(ins_len != decode.len);\n\n            exec_instruction(env, &decode);\n\n            store_regs(cpu);\n\n\n\n            break;\n\n        }\n\n        case EXIT_REASON_CPUID: {\n\n            uint32_t rax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);\n\n            uint32_t rbx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RBX);\n\n            uint32_t rcx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);\n\n            uint32_t rdx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);\n\n\n\n            cpu_x86_cpuid(env, rax, rcx, &rax, &rbx, &rcx, &rdx);\n\n\n\n            wreg(cpu->hvf_fd, HV_X86_RAX, rax);\n\n            wreg(cpu->hvf_fd, HV_X86_RBX, rbx);\n\n            wreg(cpu->hvf_fd, HV_X86_RCX, rcx);\n\n            wreg(cpu->hvf_fd, HV_X86_RDX, rdx);\n\n\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        }\n\n        case EXIT_REASON_XSETBV: {\n\n            X86CPU *x86_cpu = X86_CPU(cpu);\n\n            CPUX86State *env = &x86_cpu->env;\n\n            uint32_t eax = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RAX);\n\n            uint32_t ecx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RCX);\n\n            uint32_t edx = (uint32_t)rreg(cpu->hvf_fd, HV_X86_RDX);\n\n\n\n            if (ecx) {\n\n                macvm_set_rip(cpu, rip + ins_len);\n\n                break;\n\n            }\n\n            env->xcr0 = ((uint64_t)edx << 32) | eax;\n\n            wreg(cpu->hvf_fd, HV_X86_XCR0, env->xcr0 | 1);\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        }\n\n        case EXIT_REASON_INTR_WINDOW:\n\n            vmx_clear_int_window_exiting(cpu);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_NMI_WINDOW:\n\n            vmx_clear_nmi_window_exiting(cpu);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_EXT_INTR:\n\n            /* force exit and allow io handling */\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        case EXIT_REASON_RDMSR:\n\n        case EXIT_REASON_WRMSR:\n\n        {\n\n            load_regs(cpu);\n\n            if (exit_reason == EXIT_REASON_RDMSR) {\n\n                simulate_rdmsr(cpu);\n\n            } else {\n\n                simulate_wrmsr(cpu);\n\n            }\n\n            RIP(env) += rvmcs(cpu->hvf_fd, VMCS_EXIT_INSTRUCTION_LENGTH);\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_CR_ACCESS: {\n\n            int cr;\n\n            int reg;\n\n\n\n            load_regs(cpu);\n\n            cr = exit_qual & 15;\n\n            reg = (exit_qual >> 8) & 15;\n\n\n\n            switch (cr) {\n\n            case 0x0: {\n\n                macvm_set_cr0(cpu->hvf_fd, RRX(env, reg));\n\n                break;\n\n            }\n\n            case 4: {\n\n                macvm_set_cr4(cpu->hvf_fd, RRX(env, reg));\n\n                break;\n\n            }\n\n            case 8: {\n\n                X86CPU *x86_cpu = X86_CPU(cpu);\n\n                if (exit_qual & 0x10) {\n\n                    RRX(env, reg) = cpu_get_apic_tpr(x86_cpu->apic_state);\n\n                } else {\n\n                    int tpr = RRX(env, reg);\n\n                    cpu_set_apic_tpr(x86_cpu->apic_state, tpr);\n\n                    ret = EXCP_INTERRUPT;\n\n                }\n\n                break;\n\n            }\n\n            default:\n\n                error_report(\"Unrecognized CR %d\\n\", cr);\n\n                abort();\n\n            }\n\n            RIP(env) += ins_len;\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_APIC_ACCESS: { /* TODO */\n\n            struct x86_decode decode;\n\n\n\n            load_regs(cpu);\n\n            env->hvf_emul->fetch_rip = rip;\n\n\n\n            decode_instruction(env, &decode);\n\n            exec_instruction(env, &decode);\n\n            store_regs(cpu);\n\n            break;\n\n        }\n\n        case EXIT_REASON_TPR: {\n\n            ret = 1;\n\n            break;\n\n        }\n\n        case EXIT_REASON_TASK_SWITCH: {\n\n            uint64_t vinfo = rvmcs(cpu->hvf_fd, VMCS_IDT_VECTORING_INFO);\n\n            x68_segment_selector sel = {.sel = exit_qual & 0xffff};\n\n            vmx_handle_task_switch(cpu, sel, (exit_qual >> 30) & 0x3,\n\n             vinfo & VMCS_INTR_VALID, vinfo & VECTORING_INFO_VECTOR_MASK, vinfo\n\n             & VMCS_INTR_T_MASK);\n\n            break;\n\n        }\n\n        case EXIT_REASON_TRIPLE_FAULT: {\n\n            qemu_system_reset_request(SHUTDOWN_CAUSE_GUEST_RESET);\n\n            ret = EXCP_INTERRUPT;\n\n            break;\n\n        }\n\n        case EXIT_REASON_RDPMC:\n\n            wreg(cpu->hvf_fd, HV_X86_RAX, 0);\n\n            wreg(cpu->hvf_fd, HV_X86_RDX, 0);\n\n            macvm_set_rip(cpu, rip + ins_len);\n\n            break;\n\n        case VMX_REASON_VMCALL:\n\n            /* TODO: inject #GP fault */\n\n            break;\n\n        default:\n\n            error_report(\"%llx: unhandled exit %llx\\n\", rip, exit_reason);\n\n        }\n\n    } while (ret == 0);\n\n\n\n    return ret;\n\n}\n", "idx": 15999}, {"project": "test", "commit_id": "test", "target": 1, "func": "int bdrv_pwrite(BlockDriverState *bs, int64_t offset,\n\n                const void *buf1, int count1)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n    if (!drv->bdrv_pwrite)\n\n        return bdrv_pwrite_em(bs, offset, buf1, count1);\n\n    if (bdrv_wr_badreq_bytes(bs, offset, count1))\n\n        return -EDOM;\n\n    return drv->bdrv_pwrite(bs, offset, buf1, count1);\n\n}\n", "idx": 16047}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int local_truncate(FsContext *ctx, V9fsPath *fs_path, off_t size)\n\n{\n\n    char *buffer;\n\n    int ret;\n\n    char *path = fs_path->data;\n\n\n\n    buffer = rpath(ctx, path);\n\n    ret = truncate(buffer, size);\n\n    g_free(buffer);\n\n    return ret;\n\n}\n", "idx": 16057}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void RENAME(yuy2toyv12)(const uint8_t *src, uint8_t *ydst, uint8_t *udst, uint8_t *vdst,\n\n\tunsigned int width, unsigned int height,\n\n\tint lumStride, int chromStride, int srcStride)\n\n{\n\n\tunsigned y;\n\n\tconst unsigned chromWidth= width>>1;\n\n\tfor(y=0; y<height; y+=2)\n\n\t{\n\n#ifdef HAVE_MMX\n\n\t\tasm volatile(\n\n\t\t\t\"xor %%\"REG_a\", %%\"REG_a\"\t\\n\\t\"\n\n\t\t\t\"pcmpeqw %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"psrlw $8, %%mm7\t\t\\n\\t\" // FF,00,FF,00...\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\tPREFETCH\" 64(%0, %%\"REG_a\", 4)\t\\n\\t\"\n\n\t\t\t\"movq (%0, %%\"REG_a\", 4), %%mm0\t\\n\\t\" // YUYV YUYV(0)\n\n\t\t\t\"movq 8(%0, %%\"REG_a\", 4), %%mm1\\n\\t\" // YUYV YUYV(4)\n\n\t\t\t\"movq %%mm0, %%mm2\t\t\\n\\t\" // YUYV YUYV(0)\n\n\t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // YUYV YUYV(4)\n\n\t\t\t\"psrlw $8, %%mm0\t\t\\n\\t\" // U0V0 U0V0(0)\n\n\t\t\t\"psrlw $8, %%mm1\t\t\\n\\t\" // U0V0 U0V0(4)\n\n\t\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" // Y0Y0 Y0Y0(0)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(4)\n\n\t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // UVUV UVUV(0)\n\n\t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // YYYY YYYY(0)\n\n\n\n\t\t\tMOVNTQ\" %%mm2, (%1, %%\"REG_a\", 2)\\n\\t\"\n\n\n\n\t\t\t\"movq 16(%0, %%\"REG_a\", 4), %%mm1\\n\\t\" // YUYV YUYV(8)\n\n\t\t\t\"movq 24(%0, %%\"REG_a\", 4), %%mm2\\n\\t\" // YUYV YUYV(12)\n\n\t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // YUYV YUYV(8)\n\n\t\t\t\"movq %%mm2, %%mm4\t\t\\n\\t\" // YUYV YUYV(12)\n\n\t\t\t\"psrlw $8, %%mm1\t\t\\n\\t\" // U0V0 U0V0(8)\n\n\t\t\t\"psrlw $8, %%mm2\t\t\\n\\t\" // U0V0 U0V0(12)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(8)\n\n\t\t\t\"pand %%mm7, %%mm4\t\t\\n\\t\" // Y0Y0 Y0Y0(12)\n\n\t\t\t\"packuswb %%mm2, %%mm1\t\t\\n\\t\" // UVUV UVUV(8)\n\n\t\t\t\"packuswb %%mm4, %%mm3\t\t\\n\\t\" // YYYY YYYY(8)\n\n\n\n\t\t\tMOVNTQ\" %%mm3, 8(%1, %%\"REG_a\", 2)\\n\\t\"\n\n\n\n\t\t\t\"movq %%mm0, %%mm2\t\t\\n\\t\" // UVUV UVUV(0)\n\n\t\t\t\"movq %%mm1, %%mm3\t\t\\n\\t\" // UVUV UVUV(8)\n\n\t\t\t\"psrlw $8, %%mm0\t\t\\n\\t\" // V0V0 V0V0(0)\n\n\t\t\t\"psrlw $8, %%mm1\t\t\\n\\t\" // V0V0 V0V0(8)\n\n\t\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" // U0U0 U0U0(0)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // U0U0 U0U0(8)\n\n\t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // VVVV VVVV(0)\n\n\t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // UUUU UUUU(0)\n\n\n\n\t\t\tMOVNTQ\" %%mm0, (%3, %%\"REG_a\")\t\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm2, (%2, %%\"REG_a\")\t\\n\\t\"\n\n\n\n\t\t\t\"add $8, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"cmp %4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\" jb 1b\t\t\t\t\\n\\t\"\n\n\t\t\t::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" ((long)chromWidth)\n\n\t\t\t: \"memory\", \"%\"REG_a\n\n\t\t);\n\n\n\n\t\tydst += lumStride;\n\n\t\tsrc  += srcStride;\n\n\n\n\t\tasm volatile(\n\n\t\t\t\"xor %%\"REG_a\", %%\"REG_a\"\t\\n\\t\"\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\tPREFETCH\" 64(%0, %%\"REG_a\", 4)\t\\n\\t\"\n\n\t\t\t\"movq (%0, %%\"REG_a\", 4), %%mm0\t\\n\\t\" // YUYV YUYV(0)\n\n\t\t\t\"movq 8(%0, %%\"REG_a\", 4), %%mm1\\n\\t\" // YUYV YUYV(4)\n\n\t\t\t\"movq 16(%0, %%\"REG_a\", 4), %%mm2\\n\\t\" // YUYV YUYV(8)\n\n\t\t\t\"movq 24(%0, %%\"REG_a\", 4), %%mm3\\n\\t\" // YUYV YUYV(12)\n\n\t\t\t\"pand %%mm7, %%mm0\t\t\\n\\t\" // Y0Y0 Y0Y0(0)\n\n\t\t\t\"pand %%mm7, %%mm1\t\t\\n\\t\" // Y0Y0 Y0Y0(4)\n\n\t\t\t\"pand %%mm7, %%mm2\t\t\\n\\t\" // Y0Y0 Y0Y0(8)\n\n\t\t\t\"pand %%mm7, %%mm3\t\t\\n\\t\" // Y0Y0 Y0Y0(12)\n\n\t\t\t\"packuswb %%mm1, %%mm0\t\t\\n\\t\" // YYYY YYYY(0)\n\n\t\t\t\"packuswb %%mm3, %%mm2\t\t\\n\\t\" // YYYY YYYY(8)\n\n\n\n\t\t\tMOVNTQ\" %%mm0, (%1, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm2, 8(%1, %%\"REG_a\", 2)\\n\\t\"\n\n\n\n\t\t\t\"add $8, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"cmp %4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\" jb 1b\t\t\t\t\\n\\t\"\n\n\n\n\t\t\t::\"r\"(src), \"r\"(ydst), \"r\"(udst), \"r\"(vdst), \"g\" ((long)chromWidth)\n\n\t\t\t: \"memory\", \"%\"REG_a\n\n\t\t);\n\n#else\n\n\t\tunsigned i;\n\n\t\tfor(i=0; i<chromWidth; i++)\n\n\t\t{\n\n\t\t\tydst[2*i+0] \t= src[4*i+0];\n\n\t\t\tudst[i] \t= src[4*i+1];\n\n\t\t\tydst[2*i+1] \t= src[4*i+2];\n\n\t\t\tvdst[i] \t= src[4*i+3];\n\n\t\t}\n\n\t\tydst += lumStride;\n\n\t\tsrc  += srcStride;\n\n\n\n\t\tfor(i=0; i<chromWidth; i++)\n\n\t\t{\n\n\t\t\tydst[2*i+0] \t= src[4*i+0];\n\n\t\t\tydst[2*i+1] \t= src[4*i+2];\n\n\t\t}\n\n#endif\n\n\t\tudst += chromStride;\n\n\t\tvdst += chromStride;\n\n\t\tydst += lumStride;\n\n\t\tsrc  += srcStride;\n\n\t}\n\n#ifdef HAVE_MMX\n\nasm volatile(   EMMS\" \\n\\t\"\n\n        \tSFENCE\" \\n\\t\"\n\n        \t:::\"memory\");\n\n#endif\n\n}\n", "idx": 16190}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int hevc_frame_start(HEVCContext *s)\n\n{\n\n    HEVCLocalContext *lc = &s->HEVClc;\n\n    int ret;\n\n\n\n    memset(s->horizontal_bs, 0, 2 * s->bs_width * (s->bs_height + 1));\n\n    memset(s->vertical_bs,   0, 2 * s->bs_width * (s->bs_height + 1));\n\n    memset(s->cbf_luma,      0, s->sps->min_tb_width * s->sps->min_tb_height);\n\n    memset(s->is_pcm,        0, s->sps->min_pu_width * s->sps->min_pu_height);\n\n\n\n    lc->start_of_tiles_x = 0;\n\n    s->is_decoded        = 0;\n\n\n\n\n    if (s->pps->tiles_enabled_flag)\n\n        lc->end_of_tiles_x = s->pps->column_width[0] << s->sps->log2_ctb_size;\n\n\n\n    ret = ff_hevc_set_new_ref(s, s->sps->sao_enabled ? &s->sao_frame : &s->frame,\n\n                              s->poc);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    ret = ff_hevc_frame_rps(s);\n\n    if (ret < 0) {\n\n        av_log(s->avctx, AV_LOG_ERROR, \"Error constructing the frame RPS.\\n\");\n\n        goto fail;\n\n    }\n\n\n\n    ret = set_side_data(s);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    av_frame_unref(s->output_frame);\n\n    ret = ff_hevc_output_frame(s, s->output_frame, 0);\n\n    if (ret < 0)\n\n        goto fail;\n\n\n\n    ff_thread_finish_setup(s->avctx);\n\n\n\n    return 0;\n\n\n\nfail:\n\n    if (s->ref)\n\n        ff_thread_report_progress(&s->ref->tf, INT_MAX, 0);\n\n    s->ref = NULL;\n\n    return ret;\n\n}", "idx": 16203}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void gen_mtdcrx(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    /* NIP cannot be restored if the memory exception comes from an helper */\n\n    gen_update_nip(ctx, ctx->nip - 4);\n\n    gen_helper_store_dcr(cpu_env, cpu_gpr[rA(ctx->opcode)],\n\n                         cpu_gpr[rS(ctx->opcode)]);\n\n    /* Note: Rc update flag set leads to undefined state of Rc0 */\n\n#endif\n\n}\n", "idx": 16207}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void get_sensor_evt_status(IPMIBmcSim *ibs,\n\n                                  uint8_t *cmd, unsigned int cmd_len,\n\n                                  uint8_t *rsp, unsigned int *rsp_len,\n\n                                  unsigned int max_rsp_len)\n\n{\n\n    IPMISensor *sens;\n\n\n\n    IPMI_CHECK_CMD_LEN(3);\n\n    if ((cmd[2] > MAX_SENSORS) ||\n\n        !IPMI_SENSOR_GET_PRESENT(ibs->sensors + cmd[2])) {\n\n        rsp[2] = IPMI_CC_REQ_ENTRY_NOT_PRESENT;\n\n        return;\n\n    }\n\n    sens = ibs->sensors + cmd[2];\n\n    IPMI_ADD_RSP_DATA(sens->reading);\n\n    IPMI_ADD_RSP_DATA(IPMI_SENSOR_GET_RET_STATUS(sens));\n\n    IPMI_ADD_RSP_DATA(sens->assert_states & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->assert_states >> 8) & 0xff);\n\n    IPMI_ADD_RSP_DATA(sens->deassert_states & 0xff);\n\n    IPMI_ADD_RSP_DATA((sens->deassert_states >> 8) & 0xff);\n\n}\n", "idx": 16216}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void vfio_unmap_bar(VFIODevice *vdev, int nr)\n\n{\n\n    VFIOBAR *bar = &vdev->bars[nr];\n\n\n\n    if (!bar->size) {\n\n        return;\n\n    }\n\n\n\n    vfio_bar_quirk_teardown(vdev, nr);\n\n\n\n    memory_region_del_subregion(&bar->mem, &bar->mmap_mem);\n\n    munmap(bar->mmap, memory_region_size(&bar->mmap_mem));\n\n\n\n\n    if (vdev->msix && vdev->msix->table_bar == nr) {\n\n        memory_region_del_subregion(&bar->mem, &vdev->msix->mmap_mem);\n\n        munmap(vdev->msix->mmap, memory_region_size(&vdev->msix->mmap_mem));\n\n\n    }\n\n\n\n    memory_region_destroy(&bar->mem);\n\n}", "idx": 16293}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int rtmp_packet_read_one_chunk(URLContext *h, RTMPPacket *p,\n                                      int chunk_size, RTMPPacket **prev_pkt_ptr,\n                                      int *nb_prev_pkt, uint8_t hdr)\n{\n    uint8_t buf[16];\n    int channel_id, timestamp, size;\n    uint32_t ts_field; // non-extended timestamp or delta field\n    uint32_t extra = 0;\n    enum RTMPPacketType type;\n    int written = 0;\n    int ret, toread;\n    RTMPPacket *prev_pkt;\n    written++;\n    channel_id = hdr & 0x3F;\n    if (channel_id < 2) { //special case for channel number >= 64\n        buf[1] = 0;\n        if (ffurl_read_complete(h, buf, channel_id + 1) != channel_id + 1)\n            return AVERROR(EIO);\n        written += channel_id + 1;\n        channel_id = AV_RL16(buf) + 64;\n    if ((ret = ff_rtmp_check_alloc_array(prev_pkt_ptr, nb_prev_pkt,\n                                         channel_id)) < 0)\n        return ret;\n    prev_pkt = *prev_pkt_ptr;\n    size  = prev_pkt[channel_id].size;\n    type  = prev_pkt[channel_id].type;\n    extra = prev_pkt[channel_id].extra;\n    hdr >>= 6; // header size indicator\n    if (hdr == RTMP_PS_ONEBYTE) {\n        ts_field = prev_pkt[channel_id].ts_field;\n    } else {\n        if (ffurl_read_complete(h, buf, 3) != 3)\n            return AVERROR(EIO);\n        written += 3;\n        ts_field = AV_RB24(buf);\n        if (hdr != RTMP_PS_FOURBYTES) {\n            if (ffurl_read_complete(h, buf, 3) != 3)\n                return AVERROR(EIO);\n            written += 3;\n            size = AV_RB24(buf);\n            if (ffurl_read_complete(h, buf, 1) != 1)\n                return AVERROR(EIO);\n            written++;\n            type = buf[0];\n            if (hdr == RTMP_PS_TWELVEBYTES) {\n                if (ffurl_read_complete(h, buf, 4) != 4)\n                    return AVERROR(EIO);\n                written += 4;\n                extra = AV_RL32(buf);\n    if (ts_field == 0xFFFFFF) {\n        if (ffurl_read_complete(h, buf, 4) != 4)\n            return AVERROR(EIO);\n        timestamp = AV_RB32(buf);\n    } else {\n        timestamp = ts_field;\n    if (hdr != RTMP_PS_TWELVEBYTES)\n        timestamp += prev_pkt[channel_id].timestamp;\n    if (!prev_pkt[channel_id].read) {\n        if ((ret = ff_rtmp_packet_create(p, channel_id, type, timestamp,\n                                         size)) < 0)\n            return ret;\n        p->read = written;\n        p->offset = 0;\n        prev_pkt[channel_id].ts_field   = ts_field;\n        prev_pkt[channel_id].timestamp  = timestamp;\n    } else {\n        // previous packet in this channel hasn't completed reading\n        RTMPPacket *prev = &prev_pkt[channel_id];\n        p->data          = prev->data;\n        p->size          = prev->size;\n        p->channel_id    = prev->channel_id;\n        p->type          = prev->type;\n        p->ts_field      = prev->ts_field;\n        p->extra         = prev->extra;\n        p->offset        = prev->offset;\n        p->read          = prev->read + written;\n        p->timestamp     = prev->timestamp;\n        prev->data       = NULL;\n    p->extra = extra;\n    // save history\n    prev_pkt[channel_id].channel_id = channel_id;\n    prev_pkt[channel_id].type       = type;\n    prev_pkt[channel_id].size       = size;\n    prev_pkt[channel_id].extra      = extra;\n    size = size - p->offset;\n    toread = FFMIN(size, chunk_size);\n    if (ffurl_read_complete(h, p->data + p->offset, toread) != toread) {\n        ff_rtmp_packet_destroy(p);\n        return AVERROR(EIO);\n    size      -= toread;\n    p->read   += toread;\n    p->offset += toread;\n    if (size > 0) {\n       RTMPPacket *prev = &prev_pkt[channel_id];\n       prev->data = p->data;\n       prev->read = p->read;\n       prev->offset = p->offset;\n       return AVERROR(EAGAIN);\n    prev_pkt[channel_id].read = 0; // read complete; reset if needed\n    return p->read;", "idx": 16385}, {"project": "test", "commit_id": "test", "target": 1, "func": "void set_system_memory_map(MemoryRegion *mr)\n\n{\n\n    memory_region_transaction_begin();\n\n    address_space_memory.root = mr;\n\n    memory_region_transaction_commit();\n\n}\n", "idx": 16449}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int decode_0(PAFVideoDecContext *c, uint8_t *pkt, uint8_t code)\n\n{\n\n    uint32_t opcode_size, offset;\n\n    uint8_t *dst, *dend, mask = 0, color = 0;\n\n    const uint8_t *src, *send, *opcodes;\n\n    int i, j, op = 0;\n\n\n\n    i = bytestream2_get_byte(&c->gb);\n\n    if (i) {\n\n        if (code & 0x10) {\n\n            int align;\n\n\n\n            align = bytestream2_tell(&c->gb) & 3;\n\n            if (align)\n\n                bytestream2_skip(&c->gb, 4 - align);\n\n        }\n\n        do {\n\n            int page, val, x, y;\n\n            val    = bytestream2_get_be16(&c->gb);\n\n            page   = val >> 14;\n\n            x      = (val & 0x7F) * 2;\n\n            y      = ((val >> 7) & 0x7F) * 2;\n\n            dst    = c->frame[page] + x + y * c->width;\n\n            dend   = c->frame[page] + c->frame_size;\n\n            offset = (x & 0x7F) * 2;\n\n            j      = bytestream2_get_le16(&c->gb) + offset;\n\n            do {\n\n                offset++;\n\n                if (dst + 3 * c->width + 4 > dend)\n\n                    return AVERROR_INVALIDDATA;\n\n                read4x4block(c, dst, c->width);\n\n                if ((offset & 0x3F) == 0)\n\n                    dst += c->width * 3;\n\n                dst += 4;\n\n            } while (offset < j);\n\n        } while (--i);\n\n    }\n\n\n\n    dst  = c->frame[c->current_frame];\n\n    dend = c->frame[c->current_frame] + c->frame_size;\n\n    do {\n\n        set_src_position(c, &src, &send);\n\n        if ((src + 3 * c->width + 4 > send) ||\n\n            (dst + 3 * c->width + 4 > dend))\n\n            return AVERROR_INVALIDDATA;\n\n        copy_block4(dst, src, c->width, c->width, 4);\n\n        i++;\n\n        if ((i & 0x3F) == 0)\n\n            dst += c->width * 3;\n\n        dst += 4;\n\n    } while (i < c->video_size / 16);\n\n\n\n    opcode_size = bytestream2_get_le16(&c->gb);\n\n    bytestream2_skip(&c->gb, 2);\n\n\n\n    if (bytestream2_get_bytes_left(&c->gb) < opcode_size)\n\n        return AVERROR_INVALIDDATA;\n\n\n\n    opcodes = pkt + bytestream2_tell(&c->gb);\n\n    bytestream2_skipu(&c->gb, opcode_size);\n\n\n\n    dst = c->frame[c->current_frame];\n\n\n\n    for (i = 0; i < c->height; i += 4, dst += c->width * 3)\n\n        for (j = 0; j < c->width; j += 4, dst += 4) {\n\n            int opcode, k = 0;\n\n            if (op > opcode_size)\n\n                return AVERROR_INVALIDDATA;\n\n            if (j & 4) {\n\n                opcode = opcodes[op] & 15;\n\n                op++;\n\n            } else {\n\n                opcode = opcodes[op] >> 4;\n\n            }\n\n\n\n            while (block_sequences[opcode][k]) {\n\n                offset = c->width * 2;\n\n                code   = block_sequences[opcode][k++];\n\n\n\n                switch (code) {\n\n                case 2:\n\n                    offset = 0;\n\n                case 3:\n\n                    color = bytestream2_get_byte(&c->gb);\n\n                case 4:\n\n                    mask = bytestream2_get_byte(&c->gb);\n\n                    copy_color_mask(dst + offset, c->width, mask, color);\n\n                    break;\n\n                case 5:\n\n                    offset = 0;\n\n                case 6:\n\n                    set_src_position(c, &src, &send);\n\n                case 7:\n\n                    if (src + offset + c->width + 4 > send)\n\n                        return AVERROR_INVALIDDATA;\n\n                    mask = bytestream2_get_byte(&c->gb);\n\n                    copy_src_mask(dst + offset, c->width, mask, src + offset);\n\n                    break;\n\n                }\n\n            }\n\n        }\n\n\n\n    return 0;\n\n}\n", "idx": 16614}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void cpu_ioreq_pio(ioreq_t *req)\n\n{\n\n    int i, sign;\n\n\n\n    sign = req->df ? -1 : 1;\n\n\n\n    if (req->dir == IOREQ_READ) {\n\n        if (!req->data_is_ptr) {\n\n            req->data = do_inp(req->addr, req->size);\n\n        } else {\n\n            uint32_t tmp;\n\n\n\n            for (i = 0; i < req->count; i++) {\n\n                tmp = do_inp(req->addr, req->size);\n\n                cpu_physical_memory_write(\n\n                        req->data + (sign * i * (int64_t)req->size),\n\n                        (uint8_t *) &tmp, req->size);\n\n            }\n\n        }\n\n    } else if (req->dir == IOREQ_WRITE) {\n\n        if (!req->data_is_ptr) {\n\n            do_outp(req->addr, req->size, req->data);\n\n        } else {\n\n            for (i = 0; i < req->count; i++) {\n\n                uint32_t tmp = 0;\n\n\n\n                cpu_physical_memory_read(\n\n                        req->data + (sign * i * (int64_t)req->size),\n\n                        (uint8_t*) &tmp, req->size);\n\n                do_outp(req->addr, req->size, tmp);\n\n            }\n\n        }\n\n    }\n\n}\n", "idx": 16666}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int parse_palette(AVCodecContext *avctx, GetByteContext *gbc,\n\n                         uint32_t *pal, int colors)\n\n{\n\n    int i;\n\n\n\n    for (i = 0; i <= colors; i++) {\n\n        uint8_t r, g, b;\n\n        unsigned int idx = bytestream2_get_be16(gbc); /* color index */\n\n        if (idx > 255) {\n\n            av_log(avctx, AV_LOG_WARNING,\n\n                   \"Palette index out of range: %u\\n\", idx);\n\n            bytestream2_skip(gbc, 6);\n\n            continue;\n\n        }\n\n        r = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        g = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        b = bytestream2_get_byte(gbc);\n\n        bytestream2_skip(gbc, 1);\n\n        pal[idx] = (r << 16) | (g << 8) | b;\n\n    }\n\n    return 0;\n\n}\n", "idx": 16755}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int compare_int64(const void *a, const void *b)\n\n{\n\n    int64_t va = *(int64_t *)a, vb = *(int64_t *)b;\n\n    return va < vb ? -1 : va > vb ? +1 : 0;\n\n}\n", "idx": 16767}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void openrisc_cpu_class_init(ObjectClass *oc, void *data)\n\n{\n\n    OpenRISCCPUClass *occ = OPENRISC_CPU_CLASS(oc);\n\n    CPUClass *cc = CPU_CLASS(occ);\n\n    DeviceClass *dc = DEVICE_CLASS(oc);\n\n\n\n    occ->parent_realize = dc->realize;\n\n    dc->realize = openrisc_cpu_realizefn;\n\n\n\n    occ->parent_reset = cc->reset;\n\n    cc->reset = openrisc_cpu_reset;\n\n\n\n    cc->class_by_name = openrisc_cpu_class_by_name;\n\n    cc->has_work = openrisc_cpu_has_work;\n\n    cc->do_interrupt = openrisc_cpu_do_interrupt;\n\n    cc->cpu_exec_interrupt = openrisc_cpu_exec_interrupt;\n\n    cc->dump_state = openrisc_cpu_dump_state;\n\n    cc->set_pc = openrisc_cpu_set_pc;\n\n    cc->gdb_read_register = openrisc_cpu_gdb_read_register;\n\n    cc->gdb_write_register = openrisc_cpu_gdb_write_register;\n\n#ifdef CONFIG_USER_ONLY\n\n    cc->handle_mmu_fault = openrisc_cpu_handle_mmu_fault;\n\n#else\n\n    cc->get_phys_page_debug = openrisc_cpu_get_phys_page_debug;\n\n    dc->vmsd = &vmstate_openrisc_cpu;\n\n#endif\n\n    cc->gdb_num_core_regs = 32 + 3;\n\n\n\n    /*\n\n     * Reason: openrisc_cpu_initfn() calls cpu_exec_init(), which saves\n\n     * the object in cpus -> dangling pointer after final\n\n     * object_unref().\n\n     */\n\n    dc->cannot_destroy_with_object_finalize_yet = true;\n\n}\n", "idx": 16924}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void tcp_accept_incoming_migration(void *opaque)\n\n{\n\n    struct sockaddr_in addr;\n\n    socklen_t addrlen = sizeof(addr);\n\n    int s = (intptr_t)opaque;\n\n    QEMUFile *f;\n\n    int c;\n\n\n\n    do {\n\n        c = qemu_accept(s, (struct sockaddr *)&addr, &addrlen);\n\n    } while (c == -1 && socket_error() == EINTR);\n\n    qemu_set_fd_handler2(s, NULL, NULL, NULL, NULL);\n\n    closesocket(s);\n\n\n\n    DPRINTF(\"accepted migration\\n\");\n\n\n\n    if (c == -1) {\n\n        fprintf(stderr, \"could not accept migration connection\\n\");\n\n        goto out;\n\n    }\n\n\n\n    f = qemu_fopen_socket(c, \"rb\");\n\n    if (f == NULL) {\n\n        fprintf(stderr, \"could not qemu_fopen socket\\n\");\n\n        goto out;\n\n    }\n\n\n\n    process_incoming_migration(f);\n\n    return;\n\n\n\nout:\n\n    closesocket(c);\n\n}\n", "idx": 16930}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void quorum_copy_qiov(QEMUIOVector *dest, QEMUIOVector *source)\n\n{\n\n    int i;\n\n    assert(dest->niov == source->niov);\n\n    assert(dest->size == source->size);\n\n    for (i = 0; i < source->niov; i++) {\n\n        assert(dest->iov[i].iov_len == source->iov[i].iov_len);\n\n        memcpy(dest->iov[i].iov_base,\n\n               source->iov[i].iov_base,\n\n               source->iov[i].iov_len);\n\n    }\n\n}\n", "idx": 16933}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void receive_from_chr_layer(SCLPConsole *scon, const uint8_t *buf,\n\n                                   int size)\n\n{\n\n    /* read data must fit into current buffer */\n\n    assert(size <= SIZE_BUFFER_VT220 - scon->iov_data_len);\n\n\n\n    /* put byte-stream from character layer into buffer */\n\n    memcpy(&scon->iov[scon->iov_bs], buf, size);\n\n    scon->iov_data_len += size;\n\n    scon->iov_sclp_rest += size;\n\n    scon->iov_bs += size;\n\n    scon->event.event_pending = true;\n\n}\n", "idx": 17172}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int read_header(AVFormatContext *s,\n\n                       AVFormatParameters *ap)\n\n{\n\n    JVDemuxContext *jv = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *vst, *ast;\n\n    int64_t audio_pts = 0;\n\n    int64_t offset;\n\n    int i;\n\n\n\n    avio_skip(pb, 80);\n\n\n\n    ast = av_new_stream(s, 0);\n\n    vst = av_new_stream(s, 1);\n\n    if (!ast || !vst)\n\n        return AVERROR(ENOMEM);\n\n\n\n    vst->codec->codec_type  = CODEC_TYPE_VIDEO;\n\n    vst->codec->codec_id    = CODEC_ID_JV;\n\n    vst->codec->codec_tag   = 0; /* no fourcc */\n\n    vst->codec->width       = avio_rl16(pb);\n\n    vst->codec->height      = avio_rl16(pb);\n\n    vst->nb_frames          =\n\n    ast->nb_index_entries   = avio_rl16(pb);\n\n    av_set_pts_info(vst, 64, avio_rl16(pb), 1000);\n\n\n\n    avio_skip(pb, 4);\n\n\n\n    ast->codec->codec_type  = CODEC_TYPE_AUDIO;\n\n    ast->codec->codec_id    = CODEC_ID_PCM_U8;\n\n    ast->codec->codec_tag   = 0; /* no fourcc */\n\n    ast->codec->sample_rate = avio_rl16(pb);\n\n    ast->codec->channels    = 1;\n\n    av_set_pts_info(ast, 64, 1, ast->codec->sample_rate);\n\n\n\n    avio_skip(pb, 10);\n\n\n\n    ast->index_entries = av_malloc(ast->nb_index_entries * sizeof(*ast->index_entries));\n\n    if (!ast->index_entries)\n\n        return AVERROR(ENOMEM);\n\n\n\n    jv->frames = av_malloc(ast->nb_index_entries * sizeof(JVFrame));\n\n    if (!jv->frames)\n\n        return AVERROR(ENOMEM);\n\n\n\n    offset = 0x68 + ast->nb_index_entries * 16;\n\n    for(i = 0; i < ast->nb_index_entries; i++) {\n\n        AVIndexEntry *e   = ast->index_entries + i;\n\n        JVFrame      *jvf = jv->frames + i;\n\n\n\n        /* total frame size including audio, video, palette data and padding */\n\n        e->size         = avio_rl32(pb);\n\n        e->timestamp    = i;\n\n        e->pos          = offset;\n\n        offset         += e->size;\n\n\n\n        jvf->audio_size = avio_rl32(pb);\n\n        jvf->video_size = avio_rl32(pb);\n\n        jvf->palette_size = avio_r8(pb) ? 768 : 0;\n\n\n\n        if (avio_r8(pb))\n\n             av_log(s, AV_LOG_WARNING, \"unsupported audio codec\\n\");\n\n        jvf->video_type = avio_r8(pb);\n\n        avio_skip(pb, 1);\n\n\n\n        e->timestamp = jvf->audio_size ? audio_pts : AV_NOPTS_VALUE;\n\n        audio_pts += jvf->audio_size;\n\n\n\n        e->flags = jvf->video_type != 1 ? AVINDEX_KEYFRAME : 0;\n\n    }\n\n\n\n    jv->state = JV_AUDIO;\n\n    return 0;\n\n}", "idx": 17280}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int write_l1_entry(BlockDriverState *bs, int l1_index)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    uint64_t buf[L1_ENTRIES_PER_SECTOR];\n\n    int l1_start_index;\n\n    int i, ret;\n\n\n\n    l1_start_index = l1_index & ~(L1_ENTRIES_PER_SECTOR - 1);\n\n    for (i = 0; i < L1_ENTRIES_PER_SECTOR; i++) {\n\n        buf[i] = cpu_to_be64(s->l1_table[l1_start_index + i]);\n\n    }\n\n\n\n    BLKDBG_EVENT(bs->file, BLKDBG_L1_UPDATE);\n\n    ret = bdrv_pwrite(bs->file, s->l1_table_offset + 8 * l1_start_index,\n\n        buf, sizeof(buf));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 17328}, {"project": "test", "commit_id": "test", "target": 1, "func": "int bdrv_read(BlockDriverState *bs, int64_t sector_num,\n\n              uint8_t *buf, int nb_sectors)\n\n{\n\n    BlockDriver *drv = bs->drv;\n\n\n\n    if (!drv)\n\n        return -ENOMEDIUM;\n\n\n\n\n\n    if (drv->bdrv_pread) {\n\n        int ret, len;\n\n        len = nb_sectors * 512;\n\n        ret = drv->bdrv_pread(bs, sector_num * 512, buf, len);\n\n        if (ret < 0)\n\n            return ret;\n\n        else if (ret != len)\n\n            return -EINVAL;\n\n        else {\n\n\t    bs->rd_bytes += (unsigned) len;\n\n\t    bs->rd_ops ++;\n\n            return 0;\n\n\t}\n\n    } else {\n\n        return drv->bdrv_read(bs, sector_num, buf, nb_sectors);\n\n    }\n\n}", "idx": 17337}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int make_cdt24_entry(int p1, int p2, int16_t *cdt)\n\n{\n\n    int r, b;\n\n\n\n    b = cdt[p2];\n\n    r = cdt[p1]<<16;\n\n    return (b+r) << 1;\n\n}\n", "idx": 17341}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int nsv_read_chunk(AVFormatContext *s, int fill_header)\n\n{\n\n    NSVContext *nsv = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st[2] = {NULL, NULL};\n\n    NSVStream *nst;\n\n    AVPacket *pkt;\n\n    int i, err = 0;\n\n    uint8_t auxcount; /* number of aux metadata, also 4 bits of vsize */\n\n    uint32_t vsize;\n\n    uint16_t asize;\n\n    uint16_t auxsize;\n\n\n\n    if (nsv->ahead[0].data || nsv->ahead[1].data)\n\n        return 0; //-1; /* hey! eat what you've in your plate first! */\n\n\n\nnull_chunk_retry:\n\n    if (pb->eof_reached)\n\n        return -1;\n\n\n\n    for (i = 0; i < NSV_MAX_RESYNC_TRIES && nsv->state < NSV_FOUND_NSVS && !err; i++)\n\n        err = nsv_resync(s);\n\n    if (err < 0)\n\n        return err;\n\n    if (nsv->state == NSV_FOUND_NSVS)\n\n        err = nsv_parse_NSVs_header(s);\n\n    if (err < 0)\n\n        return err;\n\n    if (nsv->state != NSV_HAS_READ_NSVS && nsv->state != NSV_FOUND_BEEF)\n\n        return -1;\n\n\n\n    auxcount = avio_r8(pb);\n\n    vsize = avio_rl16(pb);\n\n    asize = avio_rl16(pb);\n\n    vsize = (vsize << 4) | (auxcount >> 4);\n\n    auxcount &= 0x0f;\n\n    av_log(s, AV_LOG_TRACE, \"NSV CHUNK %\"PRIu8\" aux, %\"PRIu32\" bytes video, %\"PRIu16\" bytes audio\\n\",\n\n           auxcount, vsize, asize);\n\n    /* skip aux stuff */\n\n    for (i = 0; i < auxcount; i++) {\n\n        uint32_t av_unused auxtag;\n\n        auxsize = avio_rl16(pb);\n\n        auxtag = avio_rl32(pb);\n\n        avio_skip(pb, auxsize);\n\n        vsize -= auxsize + sizeof(uint16_t) + sizeof(uint32_t); /* that's becoming brain-dead */\n\n    }\n\n\n\n    if (pb->eof_reached)\n\n        return -1;\n\n    if (!vsize && !asize) {\n\n        nsv->state = NSV_UNSYNC;\n\n        goto null_chunk_retry;\n\n    }\n\n\n\n    /* map back streams to v,a */\n\n    if (s->nb_streams > 0)\n\n        st[s->streams[0]->id] = s->streams[0];\n\n    if (s->nb_streams > 1)\n\n        st[s->streams[1]->id] = s->streams[1];\n\n\n\n    if (vsize && st[NSV_ST_VIDEO]) {\n\n        nst = st[NSV_ST_VIDEO]->priv_data;\n\n        pkt = &nsv->ahead[NSV_ST_VIDEO];\n\n        av_get_packet(pb, pkt, vsize);\n\n        pkt->stream_index = st[NSV_ST_VIDEO]->index;//NSV_ST_VIDEO;\n\n        pkt->dts = nst->frame_offset;\n\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n\n        for (i = 0; i < FFMIN(8, vsize); i++)\n\n            av_log(s, AV_LOG_TRACE, \"NSV video: [%d] = %02\"PRIx8\"\\n\",\n\n                   i, pkt->data[i]);\n\n    }\n\n    if(st[NSV_ST_VIDEO])\n\n        ((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset++;\n\n\n\n    if (asize && st[NSV_ST_AUDIO]) {\n\n        nst = st[NSV_ST_AUDIO]->priv_data;\n\n        pkt = &nsv->ahead[NSV_ST_AUDIO];\n\n        /* read raw audio specific header on the first audio chunk... */\n\n        /* on ALL audio chunks ?? seems so! */\n\n        if (asize && st[NSV_ST_AUDIO]->codecpar->codec_tag == MKTAG('P', 'C', 'M', ' ')/* && fill_header*/) {\n\n            uint8_t bps;\n\n            uint8_t channels;\n\n            uint16_t samplerate;\n\n            bps = avio_r8(pb);\n\n            channels = avio_r8(pb);\n\n            samplerate = avio_rl16(pb);\n\n            if (!channels || !samplerate)\n\n                return AVERROR_INVALIDDATA;\n\n            asize-=4;\n\n            av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n\n                   bps, channels, samplerate);\n\n            if (fill_header) {\n\n                st[NSV_ST_AUDIO]->need_parsing = AVSTREAM_PARSE_NONE; /* we know everything */\n\n                if (bps != 16) {\n\n                    av_log(s, AV_LOG_TRACE, \"NSV AUDIO bit/sample != 16 (%\"PRIu8\")!!!\\n\", bps);\n\n                }\n\n                bps /= channels; // ???\n\n                if (bps == 8)\n\n                    st[NSV_ST_AUDIO]->codecpar->codec_id = AV_CODEC_ID_PCM_U8;\n\n                samplerate /= 4;/* UGH ??? XXX */\n\n                channels = 1;\n\n                st[NSV_ST_AUDIO]->codecpar->channels = channels;\n\n                st[NSV_ST_AUDIO]->codecpar->sample_rate = samplerate;\n\n                av_log(s, AV_LOG_TRACE, \"NSV RAWAUDIO: bps %\"PRIu8\", nchan %\"PRIu8\", srate %\"PRIu16\"\\n\",\n\n                       bps, channels, samplerate);\n\n            }\n\n        }\n\n        av_get_packet(pb, pkt, asize);\n\n        pkt->stream_index = st[NSV_ST_AUDIO]->index;//NSV_ST_AUDIO;\n\n        pkt->flags |= nsv->state == NSV_HAS_READ_NSVS ? AV_PKT_FLAG_KEY : 0; /* keyframe only likely on a sync frame */\n\n        if( nsv->state == NSV_HAS_READ_NSVS && st[NSV_ST_VIDEO] ) {\n\n            /* on a nsvs frame we have new information on a/v sync */\n\n            pkt->dts = (((NSVStream*)st[NSV_ST_VIDEO]->priv_data)->frame_offset-1);\n\n            pkt->dts *= (int64_t)1000        * nsv->framerate.den;\n\n            pkt->dts += (int64_t)nsv->avsync * nsv->framerate.num;\n\n            av_log(s, AV_LOG_TRACE, \"NSV AUDIO: sync:%\"PRId16\", dts:%\"PRId64,\n\n                   nsv->avsync, pkt->dts);\n\n        }\n\n        nst->frame_offset++;\n\n    }\n\n\n\n    nsv->state = NSV_UNSYNC;\n\n    return 0;\n\n}\n", "idx": 17381}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int block_save_complete(QEMUFile *f, void *opaque)\n\n{\n\n    int ret;\n\n\n\n    DPRINTF(\"Enter save live complete submitted %d transferred %d\\n\",\n\n            block_mig_state.submitted, block_mig_state.transferred);\n\n\n\n    ret = flush_blks(f);\n\n    if (ret) {\n\n        return ret;\n\n    }\n\n\n\n    blk_mig_reset_dirty_cursor();\n\n\n\n    /* we know for sure that save bulk is completed and\n\n       all async read completed */\n\n    blk_mig_lock();\n\n    assert(block_mig_state.submitted == 0);\n\n    blk_mig_unlock();\n\n\n\n    do {\n\n        ret = blk_mig_save_dirty_block(f, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    } while (ret == 0);\n\n\n\n    /* report completion */\n\n    qemu_put_be64(f, (100 << BDRV_SECTOR_BITS) | BLK_MIG_FLAG_PROGRESS);\n\n\n\n    DPRINTF(\"Block migration completed\\n\");\n\n\n\n    qemu_put_be64(f, BLK_MIG_FLAG_EOS);\n\n\n\n    blk_mig_cleanup();\n\n    return 0;\n\n}\n", "idx": 17411}, {"project": "test", "commit_id": "test", "target": 1, "func": "matroska_parse_block(MatroskaDemuxContext *matroska, uint8_t *data, int size,\n                     int64_t pos, uint64_t cluster_time, uint64_t duration,\n                     int is_keyframe, int is_bframe)\n{\n    int res = 0;\n    int track;\n    AVStream *st;\n    AVPacket *pkt;\n    uint8_t *origdata = data;\n    int16_t block_time;\n    uint32_t *lace_size = NULL;\n    int n, flags, laces = 0;\n    uint64_t num;\n    int stream_index;\n    /* first byte(s): tracknum */\n    if ((n = matroska_ebmlnum_uint(data, size, &num)) < 0) {\n        av_log(matroska->ctx, AV_LOG_ERROR, \"EBML block data error\\n\");\n        av_free(origdata);\n        return res;\n    }\n    data += n;\n    size -= n;\n    /* fetch track from num */\n    track = matroska_find_track_by_num(matroska, num);\n    if (size <= 3 || track < 0 || track >= matroska->num_tracks) {\n        av_log(matroska->ctx, AV_LOG_INFO,\n               \"Invalid stream %d or size %u\\n\", track, size);\n        av_free(origdata);\n        return res;\n    }\n    stream_index = matroska->tracks[track]->stream_index;\n    if (stream_index < 0 || stream_index >= matroska->ctx->nb_streams) {\n        av_free(origdata);\n        return res;\n    }\n    st = matroska->ctx->streams[stream_index];\n    if (st->discard >= AVDISCARD_ALL) {\n        av_free(origdata);\n        return res;\n    }\n    if (duration == AV_NOPTS_VALUE)\n        duration = matroska->tracks[track]->default_duration / matroska->time_scale;\n    /* block_time (relative to cluster time) */\n    block_time = AV_RB16(data);\n    data += 2;\n    flags = *data++;\n    size -= 3;\n    if (is_keyframe == -1)\n        is_keyframe = flags & 0x80 ? PKT_FLAG_KEY : 0;\n    if (matroska->skip_to_keyframe) {\n        if (!is_keyframe || st != matroska->skip_to_stream) {\n            av_free(origdata);\n            return res;\n        }\n        matroska->skip_to_keyframe = 0;\n    }\n    switch ((flags & 0x06) >> 1) {\n        case 0x0: /* no lacing */\n            laces = 1;\n            lace_size = av_mallocz(sizeof(int));\n            lace_size[0] = size;\n            break;\n        case 0x1: /* xiph lacing */\n        case 0x2: /* fixed-size lacing */\n        case 0x3: /* EBML lacing */\n            assert(size>0); // size <=3 is checked before size-=3 above\n            laces = (*data) + 1;\n            data += 1;\n            size -= 1;\n            lace_size = av_mallocz(laces * sizeof(int));\n            switch ((flags & 0x06) >> 1) {\n                case 0x1: /* xiph lacing */ {\n                    uint8_t temp;\n                    uint32_t total = 0;\n                    for (n = 0; res == 0 && n < laces - 1; n++) {\n                        while (1) {\n                            if (size == 0) {\n                                res = -1;\n                                break;\n                            }\n                            temp = *data;\n                            lace_size[n] += temp;\n                            data += 1;\n                            size -= 1;\n                            if (temp != 0xff)\n                                break;\n                        }\n                        total += lace_size[n];\n                    }\n                    lace_size[n] = size - total;\n                    break;\n                }\n                case 0x2: /* fixed-size lacing */\n                    for (n = 0; n < laces; n++)\n                        lace_size[n] = size / laces;\n                    break;\n                case 0x3: /* EBML lacing */ {\n                    uint32_t total;\n                    n = matroska_ebmlnum_uint(data, size, &num);\n                    if (n < 0) {\n                        av_log(matroska->ctx, AV_LOG_INFO,\n                               \"EBML block data error\\n\");\n                        break;\n                    }\n                    data += n;\n                    size -= n;\n                    total = lace_size[0] = num;\n                    for (n = 1; res == 0 && n < laces - 1; n++) {\n                        int64_t snum;\n                        int r;\n                        r = matroska_ebmlnum_sint (data, size, &snum);\n                        if (r < 0) {\n                            av_log(matroska->ctx, AV_LOG_INFO,\n                                   \"EBML block data error\\n\");\n                            break;\n                        }\n                        data += r;\n                        size -= r;\n                        lace_size[n] = lace_size[n - 1] + snum;\n                        total += lace_size[n];\n                    }\n                    lace_size[n] = size - total;\n                    break;\n                }\n            }\n            break;\n    }\n    if (res == 0) {\n        uint64_t timecode = AV_NOPTS_VALUE;\n        if (cluster_time != (uint64_t)-1\n            && (block_time >= 0 || cluster_time >= -block_time))\n            timecode = cluster_time + block_time;\n        for (n = 0; n < laces; n++) {\n            if (st->codec->codec_id == CODEC_ID_RA_288 ||\n                st->codec->codec_id == CODEC_ID_COOK ||\n                st->codec->codec_id == CODEC_ID_ATRAC3) {\n                MatroskaAudioTrack *audiotrack = (MatroskaAudioTrack *)matroska->tracks[track];\n                int a = st->codec->block_align;\n                int sps = audiotrack->sub_packet_size;\n                int cfs = audiotrack->coded_framesize;\n                int h = audiotrack->sub_packet_h;\n                int y = audiotrack->sub_packet_cnt;\n                int w = audiotrack->frame_size;\n                int x;\n                if (!audiotrack->pkt_cnt) {\n                    if (st->codec->codec_id == CODEC_ID_RA_288)\n                        for (x=0; x<h/2; x++)\n                            memcpy(audiotrack->buf+x*2*w+y*cfs,\n                                   data+x*cfs, cfs);\n                    else\n                        for (x=0; x<w/sps; x++)\n                            memcpy(audiotrack->buf+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), data+x*sps, sps);\n                    if (++audiotrack->sub_packet_cnt >= h) {\n                        audiotrack->sub_packet_cnt = 0;\n                        audiotrack->pkt_cnt = h*w / a;\n                    }\n                }\n                while (audiotrack->pkt_cnt) {\n                    pkt = av_mallocz(sizeof(AVPacket));\n                    av_new_packet(pkt, a);\n                    memcpy(pkt->data, audiotrack->buf\n                           + a * (h*w / a - audiotrack->pkt_cnt--), a);\n                    pkt->pos = pos;\n                    pkt->stream_index = stream_index;\n                    matroska_queue_packet(matroska, pkt);\n                }\n            } else {\n                int result, offset = 0, ilen, olen, pkt_size = lace_size[n];\n                uint8_t *pkt_data = data;\n                if (matroska->tracks[track]->encoding_scope & 1) {\n                    switch (matroska->tracks[track]->encoding_algo) {\n                    case MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP:\n                        offset = matroska->tracks[track]->encoding_settings_len;\n                        break;\n                    case MATROSKA_TRACK_ENCODING_COMP_LZO:\n                        pkt_data = NULL;\n                        do {\n                            ilen = lace_size[n];\n                            olen = pkt_size *= 3;\n                            pkt_data = av_realloc(pkt_data,\n                                                  pkt_size+LZO_OUTPUT_PADDING);\n                            result = lzo1x_decode(pkt_data, &olen, data, &ilen);\n                        } while (result==LZO_OUTPUT_FULL && pkt_size<10000000);\n                        if (result) {\n                            continue;\n                        }\n                        pkt_size -= olen;\n                        break;\n#ifdef CONFIG_ZLIB\n                    case MATROSKA_TRACK_ENCODING_COMP_ZLIB: {\n                        z_stream zstream = {0};\n                        pkt_data = NULL;\n                        if (inflateInit(&zstream) != Z_OK)\n                            continue;\n                        zstream.next_in = data;\n                        zstream.avail_in = lace_size[n];\n                        do {\n                            pkt_size *= 3;\n                            pkt_data = av_realloc(pkt_data, pkt_size);\n                            zstream.avail_out = pkt_size - zstream.total_out;\n                            zstream.next_out = pkt_data + zstream.total_out;\n                            result = inflate(&zstream, Z_NO_FLUSH);\n                        } while (result==Z_OK && pkt_size<10000000);\n                        pkt_size = zstream.total_out;\n                        inflateEnd(&zstream);\n                        if (result != Z_STREAM_END) {\n                            continue;\n                        }\n                        break;\n                    }\n#endif\n#ifdef CONFIG_BZLIB\n                    case MATROSKA_TRACK_ENCODING_COMP_BZLIB: {\n                        bz_stream bzstream = {0};\n                        pkt_data = NULL;\n                        if (BZ2_bzDecompressInit(&bzstream, 0, 0) != BZ_OK)\n                            continue;\n                        bzstream.next_in = data;\n                        bzstream.avail_in = lace_size[n];\n                        do {\n                            pkt_size *= 3;\n                            pkt_data = av_realloc(pkt_data, pkt_size);\n                            bzstream.avail_out = pkt_size - bzstream.total_out_lo32;\n                            bzstream.next_out = pkt_data + bzstream.total_out_lo32;\n                            result = BZ2_bzDecompress(&bzstream);\n                        } while (result==BZ_OK && pkt_size<10000000);\n                        pkt_size = bzstream.total_out_lo32;\n                        BZ2_bzDecompressEnd(&bzstream);\n                        if (result != BZ_STREAM_END) {\n                            continue;\n                        }\n                        break;\n                    }\n#endif\n                    }\n                }\n                pkt = av_mallocz(sizeof(AVPacket));\n                /* XXX: prevent data copy... */\n                if (av_new_packet(pkt, pkt_size+offset) < 0) {\n                    av_free(pkt);\n                    res = AVERROR(ENOMEM);\n                    n = laces-1;\n                    break;\n                }\n                if (offset)\n                    memcpy (pkt->data, matroska->tracks[track]->encoding_settings, offset);\n                memcpy (pkt->data+offset, pkt_data, pkt_size);\n                if (n == 0)\n                    pkt->flags = is_keyframe;\n                pkt->stream_index = stream_index;\n                pkt->pts = timecode;\n                pkt->pos = pos;\n                pkt->duration = duration;\n                matroska_queue_packet(matroska, pkt);\n            }\n            if (timecode != AV_NOPTS_VALUE)\n                timecode = duration ? timecode + duration : AV_NOPTS_VALUE;\n            data += lace_size[n];\n        }\n    }\n    av_free(lace_size);\n    av_free(origdata);\n    return res;\n}", "idx": 17412}, {"project": "test", "commit_id": "test", "target": 1, "func": "void qpci_memread(QPCIDevice *dev, void *data, void *buf, size_t len)\n\n{\n\n    uintptr_t addr = (uintptr_t)data;\n\n\n\n    g_assert(addr >= QPCI_PIO_LIMIT);\n\n    dev->bus->memread(dev->bus, addr, buf, len);\n\n}\n", "idx": 17449}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void quantize_and_encode_band_cost_ZERO_mips(struct AACEncContext *s,\n\n                                                         PutBitContext *pb, const float *in, float *out,\n\n                                                         const float *scaled, int size, int scale_idx,\n\n                                                         int cb, const float lambda, const float uplim,\n\n                                                         int *bits, const float ROUNDING) {\n\n    int i;\n\n    if (bits)\n\n        *bits = 0;\n\n    if (out) {\n\n        for (i = 0; i < size; i += 4) {\n\n           out[i  ] = 0.0f;\n\n           out[i+1] = 0.0f;\n\n           out[i+2] = 0.0f;\n\n           out[i+3] = 0.0f;\n\n        }\n\n    }\n\n}\n", "idx": 17513}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void coroutine_fn c1_fn(void *opaque)\n\n{\n\n    Coroutine *c2 = opaque;\n\n    qemu_coroutine_enter(c2, NULL);\n\n}\n", "idx": 17548}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int write_target_commit(BlockDriverState *bs, int64_t sector_num,\n\n\tconst uint8_t* buffer, int nb_sectors) {\n\n    BDRVVVFATState* s = bs->opaque;\n\n    return try_commit(s);\n\n}\n", "idx": 17553}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void mclms_predict(WmallDecodeCtx *s, int icoef, int *pred)\n\n{\n\n    int ich, i;\n\n    int order        = s->mclms_order;\n\n    int num_channels = s->num_channels;\n\n\n\n    for (ich = 0; ich < num_channels; ich++) {\n\n        pred[ich] = 0;\n\n        if (!s->is_channel_coded[ich])\n\n            continue;\n\n        for (i = 0; i < order * num_channels; i++)\n\n            pred[ich] += s->mclms_prevvalues[i + s->mclms_recent] *\n\n                         s->mclms_coeffs[i + order * num_channels * ich];\n\n        for (i = 0; i < ich; i++)\n\n            pred[ich] += s->channel_residues[i][icoef] *\n\n                         s->mclms_coeffs_cur[i + num_channels * ich];\n\n        pred[ich] += 1 << s->mclms_scaling - 1;\n\n        pred[ich] >>= s->mclms_scaling;\n\n        s->channel_residues[ich][icoef] += pred[ich];\n\n    }\n\n}\n", "idx": 17877}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int read_gab2_sub(AVFormatContext *s, AVStream *st, AVPacket *pkt)\n\n{\n\n    if (pkt->size >= 7 &&\n\n        pkt->size < INT_MAX - AVPROBE_PADDING_SIZE &&\n\n        !strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data + 5) == 2) {\n\n        uint8_t desc[256];\n\n        int score      = AVPROBE_SCORE_EXTENSION, ret;\n\n        AVIStream *ast = st->priv_data;\n\n        AVInputFormat *sub_demuxer;\n\n        AVRational time_base;\n\n        int size;\n\n        AVIOContext *pb = avio_alloc_context(pkt->data + 7,\n\n                                             pkt->size - 7,\n\n                                             0, NULL, NULL, NULL, NULL);\n\n        AVProbeData pd;\n\n        unsigned int desc_len = avio_rl32(pb);\n\n\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n\n            goto error;\n\n\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n\n        avio_skip(pb, desc_len - ret);\n\n        if (*desc)\n\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n\n\n        avio_rl16(pb);   /* flags? */\n\n        avio_rl32(pb);   /* data size */\n\n\n\n        size = pb->buf_end - pb->buf_ptr;\n\n        pd = (AVProbeData) { .buf      = av_mallocz(size + AVPROBE_PADDING_SIZE),\n\n                             .buf_size = size };\n\n        if (!pd.buf)\n\n            goto error;\n\n        memcpy(pd.buf, pb->buf_ptr, size);\n\n        sub_demuxer = av_probe_input_format2(&pd, 1, &score);\n\n        av_freep(&pd.buf);\n\n        if (!sub_demuxer)\n\n            goto error;\n\n\n\n        if (!(ast->sub_ctx = avformat_alloc_context()))\n\n            goto error;\n\n\n\n        ast->sub_ctx->pb = pb;\n\n\n\n        av_assert0(!ast->sub_ctx->codec_whitelist && !ast->sub_ctx->format_whitelist);\n\n        ast->sub_ctx-> codec_whitelist = av_strdup(s->codec_whitelist);\n\n        ast->sub_ctx->format_whitelist = av_strdup(s->format_whitelist);\n\n\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n\n            *st->codec = *ast->sub_ctx->streams[0]->codec;\n\n            ast->sub_ctx->streams[0]->codec->extradata = NULL;\n\n            time_base = ast->sub_ctx->streams[0]->time_base;\n\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n\n        }\n\n        ast->sub_buffer = pkt->data;\n\n        memset(pkt, 0, sizeof(*pkt));\n\n        return 1;\n\n\n\nerror:\n\n        av_freep(&pb);\n\n    }\n\n    return 0;\n\n}\n", "idx": 17908}, {"project": "test", "commit_id": "test", "target": 1, "func": "void qvirtio_pci_device_enable(QVirtioPCIDevice *d)\n\n{\n\n    qpci_device_enable(d->pdev);\n\n    d->addr = qpci_iomap(d->pdev, 0, NULL);\n\n    g_assert(d->addr != NULL);\n\n}\n", "idx": 17909}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int ass_decode_frame(AVCodecContext *avctx, void *data, int *got_sub_ptr,\n\n                            AVPacket *avpkt)\n\n{\n\n    const char *ptr = avpkt->data;\n\n    int len, size = avpkt->size;\n\n\n\n    while (size > 0) {\n\n        ASSDialog *dialog = ff_ass_split_dialog(avctx->priv_data, ptr, 0, NULL);\n\n        int duration = dialog->end - dialog->start;\n\n        len = ff_ass_add_rect(data, ptr, 0, duration, 1);\n\n        if (len < 0)\n\n            return len;\n\n        ptr  += len;\n\n        size -= len;\n\n    }\n\n\n\n    *got_sub_ptr = avpkt->size > 0;\n\n    return avpkt->size;\n\n}\n", "idx": 18175}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int find_dirty_height(VncState *vs, int y, int last_x, int x)\n\n{\n\n    int h;\n\n\n\n    for (h = 1; h < (vs->serverds.height - y); h++) {\n\n        int tmp_x;\n\n        if (!vnc_get_bit(vs->dirty_row[y + h], last_x))\n\n            break;\n\n        for (tmp_x = last_x; tmp_x < x; tmp_x++)\n\n            vnc_clear_bit(vs->dirty_row[y + h], tmp_x);\n\n    }\n\n\n\n    return h;\n\n}\n", "idx": 18194}, {"project": "test", "commit_id": "test", "target": 1, "func": "ff_rm_read_mdpr_codecdata (AVFormatContext *s, AVIOContext *pb,\n\n                           AVStream *st, RMStream *rst, int codec_data_size)\n\n{\n\n    unsigned int v;\n\n    int size;\n\n    int64_t codec_pos;\n\n    int ret;\n\n\n\n    avpriv_set_pts_info(st, 64, 1, 1000);\n\n    codec_pos = avio_tell(pb);\n\n    v = avio_rb32(pb);\n\n    if (v == MKTAG(0xfd, 'a', 'r', '.')) {\n\n        /* ra type header */\n\n        if (rm_read_audio_stream_info(s, pb, st, rst, 0))\n\n            return -1;\n\n    } else if (v == MKBETAG('L', 'S', 'D', ':')) {\n\n        avio_seek(pb, -4, SEEK_CUR);\n\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size)) < 0)\n\n            return ret;\n\n\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        st->codec->codec_tag  = AV_RL32(st->codec->extradata);\n\n        st->codec->codec_id   = ff_codec_get_id(ff_rm_codec_tags,\n\n                                                st->codec->codec_tag);\n\n    } else {\n\n        int fps;\n\n        if (avio_rl32(pb) != MKTAG('V', 'I', 'D', 'O')) {\n\n        fail1:\n\n            av_log(st->codec, AV_LOG_ERROR, \"Unsupported video codec\\n\");\n\n            goto skip;\n\n        }\n\n        st->codec->codec_tag = avio_rl32(pb);\n\n        st->codec->codec_id  = ff_codec_get_id(ff_rm_codec_tags,\n\n                                               st->codec->codec_tag);\n\n//        av_log(s, AV_LOG_DEBUG, \"%X %X\\n\", st->codec->codec_tag, MKTAG('R', 'V', '2', '0'));\n\n        if (st->codec->codec_id == CODEC_ID_NONE)\n\n            goto fail1;\n\n        st->codec->width  = avio_rb16(pb);\n\n        st->codec->height = avio_rb16(pb);\n\n        avio_skip(pb, 2); // looks like bits per sample\n\n        avio_skip(pb, 4); // always zero?\n\n        st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n        st->need_parsing = AVSTREAM_PARSE_TIMESTAMPS;\n\n        fps = avio_rb32(pb);\n\n\n\n        if ((ret = rm_read_extradata(pb, st->codec, codec_data_size - (avio_tell(pb) - codec_pos))) < 0)\n\n            return ret;\n\n\n\n        av_reduce(&st->r_frame_rate.den, &st->r_frame_rate.num,\n\n                  0x10000, fps, (1 << 30) - 1);\n\n        st->avg_frame_rate = st->r_frame_rate;\n\n    }\n\n\n\nskip:\n\n    /* skip codec info */\n\n    size = avio_tell(pb) - codec_pos;\n\n    avio_skip(pb, codec_data_size - size);\n\n\n\n    return 0;\n\n}\n", "idx": 18203}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void put_uint64(QEMUFile *f, void *pv, size_t size)\n\n{\n\n    uint64_t *v = pv;\n\n    qemu_put_be64s(f, v);\n\n}\n", "idx": 18211}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void qobject_input_type_bool(Visitor *v, const char *name, bool *obj,\n\n                                    Error **errp)\n\n{\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    QBool *qbool;\n\n\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    qbool = qobject_to_qbool(qobj);\n\n    if (!qbool) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"boolean\");\n\n        return;\n\n    }\n\n\n\n    *obj = qbool_get_bool(qbool);\n\n}\n", "idx": 18329}, {"project": "test", "commit_id": "test", "target": 1, "func": "int qemu_devtree_setprop_string(void *fdt, const char *node_path,\n\n                                const char *property, const char *string)\n\n{\n\n    int offset;\n\n\n\n    offset = fdt_path_offset(fdt, node_path);\n\n    if (offset < 0)\n\n        return offset;\n\n\n\n    return fdt_setprop_string(fdt, offset, property, string);\n\n}\n", "idx": 18412}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void rc4030_dma_as_update_one(rc4030State *s, int index, uint32_t frame)\n\n{\n\n    if (index < MAX_TL_ENTRIES) {\n\n        memory_region_set_enabled(&s->dma_mrs[index], false);\n\n    }\n\n\n\n    if (!frame) {\n\n        return;\n\n    }\n\n\n\n    if (index >= MAX_TL_ENTRIES) {\n\n        qemu_log_mask(LOG_UNIMP,\n\n                      \"rc4030: trying to use too high \"\n\n                      \"translation table entry %d (max allowed=%d)\",\n\n                      index, MAX_TL_ENTRIES);\n\n        return;\n\n    }\n\n    memory_region_set_alias_offset(&s->dma_mrs[index], frame);\n\n    memory_region_set_enabled(&s->dma_mrs[index], true);\n\n}\n", "idx": 18439}, {"project": "test", "commit_id": "test", "target": 1, "func": "static bool virtio_scsi_data_plane_handle_cmd(VirtIODevice *vdev,\n\n                                              VirtQueue *vq)\n\n{\n\n    VirtIOSCSI *s = (VirtIOSCSI *)vdev;\n\n\n\n    assert(s->ctx && s->dataplane_started);\n\n    return virtio_scsi_handle_cmd_vq(s, vq);\n\n}\n", "idx": 18447}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void bitmap_free(Qcow2Bitmap *bm)\n{\n    g_free(bm->name);\n    g_free(bm);", "idx": 18562}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void add_bytes_l2_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w)\n\n{\n\n    long i;\n\n    for (i = 0; i <= w - sizeof(long); i += sizeof(long)) {\n\n        long a = *(long *)(src1 + i);\n\n        long b = *(long *)(src2 + i);\n\n        *(long *)(dst + i) = ((a & pb_7f) + (b & pb_7f)) ^ ((a ^ b) & pb_80);\n\n    }\n\n    for (; i < w; i++)\n\n        dst[i] = src1[i] + src2[i];\n\n}\n", "idx": 18624}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int calculate_refcounts(BlockDriverState *bs, BdrvCheckResult *res,\n\n                               BdrvCheckMode fix, bool *rebuild,\n\n                               uint16_t **refcount_table, int64_t *nb_clusters)\n\n{\n\n    BDRVQcowState *s = bs->opaque;\n\n    int64_t i;\n\n    QCowSnapshot *sn;\n\n    int ret;\n\n\n\n    if (!*refcount_table) {\n\n        int64_t old_size = 0;\n\n        ret = realloc_refcount_array(s, refcount_table,\n\n                                     &old_size, *nb_clusters);\n\n        if (ret < 0) {\n\n            res->check_errors++;\n\n            return ret;\n\n        }\n\n    }\n\n\n\n    /* header */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        0, s->cluster_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* current L1 table */\n\n    ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                             s->l1_table_offset, s->l1_size, CHECK_FRAG_INFO);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* snapshots */\n\n    for (i = 0; i < s->nb_snapshots; i++) {\n\n        sn = s->snapshots + i;\n\n        ret = check_refcounts_l1(bs, res, refcount_table, nb_clusters,\n\n                                 sn->l1_table_offset, sn->l1_size, 0);\n\n        if (ret < 0) {\n\n            return ret;\n\n        }\n\n    }\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->snapshots_offset, s->snapshots_size);\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    /* refcount data */\n\n    ret = inc_refcounts(bs, res, refcount_table, nb_clusters,\n\n                        s->refcount_table_offset,\n\n                        s->refcount_table_size * sizeof(uint64_t));\n\n    if (ret < 0) {\n\n        return ret;\n\n    }\n\n\n\n    return check_refblocks(bs, res, fix, rebuild, refcount_table, nb_clusters);\n\n}\n", "idx": 18629}, {"project": "test", "commit_id": "test", "target": 1, "func": "static USBDevice *usb_msd_init(const char *filename)\n\n{\n\n    static int nr=0;\n\n    char id[8];\n\n    QemuOpts *opts;\n\n    DriveInfo *dinfo;\n\n    USBDevice *dev;\n\n    int fatal_error;\n\n    const char *p1;\n\n    char fmt[32];\n\n\n\n    /* parse -usbdevice disk: syntax into drive opts */\n\n    snprintf(id, sizeof(id), \"usb%d\", nr++);\n\n    opts = qemu_opts_create(&qemu_drive_opts, id, 0);\n\n\n\n    p1 = strchr(filename, ':');\n\n    if (p1++) {\n\n        const char *p2;\n\n\n\n        if (strstart(filename, \"format=\", &p2)) {\n\n            int len = MIN(p1 - p2, sizeof(fmt));\n\n            pstrcpy(fmt, len, p2);\n\n            qemu_opt_set(opts, \"format\", fmt);\n\n        } else if (*filename != ':') {\n\n            printf(\"unrecognized USB mass-storage option %s\\n\", filename);\n\n\n\n        filename = p1;\n\n\n    if (!*filename) {\n\n        printf(\"block device specification needed\\n\");\n\n\n\n    qemu_opt_set(opts, \"file\", filename);\n\n    qemu_opt_set(opts, \"if\", \"none\");\n\n\n\n    /* create host drive */\n\n    dinfo = drive_init(opts, NULL, &fatal_error);\n\n    if (!dinfo) {\n\n        qemu_opts_del(opts);\n\n\n\n\n\n    /* create guest device */\n\n    dev = usb_create(NULL /* FIXME */, \"usb-storage\");\n\n\n\n\n    qdev_prop_set_drive(&dev->qdev, \"drive\", dinfo);\n\n    if (qdev_init(&dev->qdev) < 0)\n\n\n\n\n    return dev;\n", "idx": 18820}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int mpc_read_packet(AVFormatContext *s, AVPacket *pkt)\n\n{\n\n    MPCContext *c = s->priv_data;\n\n    int ret, size, size2, curbits, cur = c->curframe;\n\n    int64_t tmp, pos;\n\n\n\n    if (c->curframe >= c->fcount)\n\n        return -1;\n\n\n\n    if(c->curframe != c->lastframe + 1){\n\n        url_fseek(s->pb, c->frames[c->curframe].pos, SEEK_SET);\n\n        c->curbits = c->frames[c->curframe].skip;\n\n    }\n\n    c->lastframe = c->curframe;\n\n    c->curframe++;\n\n    curbits = c->curbits;\n\n    pos = url_ftell(s->pb);\n\n    tmp = get_le32(s->pb);\n\n    if(curbits <= 12){\n\n        size2 = (tmp >> (12 - curbits)) & 0xFFFFF;\n\n    }else{\n\n        tmp = (tmp << 32) | get_le32(s->pb);\n\n        size2 = (tmp >> (44 - curbits)) & 0xFFFFF;\n\n    }\n\n    curbits += 20;\n\n    url_fseek(s->pb, pos, SEEK_SET);\n\n\n\n    size = ((size2 + curbits + 31) & ~31) >> 3;\n\n    if(cur == c->frames_noted){\n\n        c->frames[cur].pos = pos;\n\n        c->frames[cur].size = size;\n\n        c->frames[cur].skip = curbits - 20;\n\n        av_add_index_entry(s->streams[0], cur, cur, size, 0, AVINDEX_KEYFRAME);\n\n        c->frames_noted++;\n\n    }\n\n    c->curbits = (curbits + size2) & 0x1F;\n\n\n\n    if (av_new_packet(pkt, size) < 0)\n\n        return AVERROR(EIO);\n\n\n\n    pkt->data[0] = curbits;\n\n    pkt->data[1] = (c->curframe > c->fcount);\n\n\n\n\n\n    pkt->stream_index = 0;\n\n    pkt->pts = cur;\n\n    ret = get_buffer(s->pb, pkt->data + 4, size);\n\n    if(c->curbits)\n\n        url_fseek(s->pb, -4, SEEK_CUR);\n\n    if(ret < size){\n\n        av_free_packet(pkt);\n\n        return AVERROR(EIO);\n\n    }\n\n    pkt->size = ret + 4;\n\n\n\n    return 0;\n\n}", "idx": 18963}, {"project": "test", "commit_id": "test", "target": 1, "func": "void visit_type_bool(Visitor *v, bool *obj, const char *name, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        v->type_bool(v, obj, name, errp);\n\n    }\n\n}\n", "idx": 19005}, {"project": "test", "commit_id": "test", "target": 1, "func": "qemu_irq *pxa2xx_pic_init(target_phys_addr_t base, CPUState *env)\n\n{\n\n    struct pxa2xx_pic_state_s *s;\n\n    int iomemtype;\n\n    qemu_irq *qi;\n\n\n\n    s = (struct pxa2xx_pic_state_s *)\n\n            qemu_mallocz(sizeof(struct pxa2xx_pic_state_s));\n\n    if (!s)\n\n        return NULL;\n\n\n\n    s->cpu_env = env;\n\n    s->base = base;\n\n\n\n    s->int_pending[0] = 0;\n\n    s->int_pending[1] = 0;\n\n    s->int_enabled[0] = 0;\n\n    s->int_enabled[1] = 0;\n\n    s->is_fiq[0] = 0;\n\n    s->is_fiq[1] = 0;\n\n\n\n    qi = qemu_allocate_irqs(pxa2xx_pic_set_irq, s, PXA2XX_PIC_SRCS);\n\n\n\n    /* Enable IC memory-mapped registers access.  */\n\n    iomemtype = cpu_register_io_memory(0, pxa2xx_pic_readfn,\n\n                    pxa2xx_pic_writefn, s);\n\n    cpu_register_physical_memory(base, 0x000fffff, iomemtype);\n\n\n\n    /* Enable IC coprocessor access.  */\n\n    cpu_arm_set_cp_io(env, 6, pxa2xx_pic_cp_read, pxa2xx_pic_cp_write, s);\n\n\n\n    register_savevm(\"pxa2xx_pic\", 0, 0, pxa2xx_pic_save, pxa2xx_pic_load, s);\n\n\n\n    return qi;\n\n}\n", "idx": 19027}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline int gen_iwmmxt_shift(uint32_t insn, uint32_t mask, TCGv dest)\n\n{\n\n    int rd = (insn >> 0) & 0xf;\n\n    TCGv tmp;\n\n\n\n    if (insn & (1 << 8)) {\n\n        if (rd < ARM_IWMMXT_wCGR0 || rd > ARM_IWMMXT_wCGR3) {\n\n            return 1;\n\n        } else {\n\n            tmp = iwmmxt_load_creg(rd);\n\n        }\n\n    } else {\n\n        tmp = new_tmp();\n\n        iwmmxt_load_reg(cpu_V0, rd);\n\n        tcg_gen_trunc_i64_i32(tmp, cpu_V0);\n\n    }\n\n    tcg_gen_andi_i32(tmp, tmp, mask);\n\n    tcg_gen_mov_i32(dest, tmp);\n\n    dead_tmp(tmp);\n\n    return 0;\n\n}\n", "idx": 19403}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int get_htab_fd(sPAPRMachineState *spapr)\n\n{\n\n    if (spapr->htab_fd >= 0) {\n\n        return spapr->htab_fd;\n\n    }\n\n\n\n    spapr->htab_fd = kvmppc_get_htab_fd(false);\n\n    if (spapr->htab_fd < 0) {\n\n        error_report(\"Unable to open fd for reading hash table from KVM: %s\",\n\n                     strerror(errno));\n\n    }\n\n\n\n    return spapr->htab_fd;\n\n}\n", "idx": 19434}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void qobject_input_start_list(Visitor *v, const char *name,\n\n                                     GenericList **list, size_t size,\n\n                                     Error **errp)\n\n{\n\n    QObjectInputVisitor *qiv = to_qiv(v);\n\n    QObject *qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    const QListEntry *entry;\n\n\n\n    if (list) {\n\n        *list = NULL;\n\n    }\n\n    if (!qobj) {\n\n        return;\n\n    }\n\n    if (qobject_type(qobj) != QTYPE_QLIST) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE, name ? name : \"null\",\n\n                   \"list\");\n\n        return;\n\n    }\n\n\n\n    entry = qobject_input_push(qiv, qobj, list);\n\n    if (entry && list) {\n\n        *list = g_malloc0(size);\n\n    }\n\n}\n", "idx": 19441}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int parse_uint16(DeviceState *dev, Property *prop, const char *str)\n\n{\n\n    uint16_t *ptr = qdev_get_prop_ptr(dev, prop);\n\n    const char *fmt;\n\n\n\n    /* accept both hex and decimal */\n\n    fmt = strncasecmp(str, \"0x\",2) == 0 ? \"%\" PRIx16 : \"%\" PRIu16;\n\n    if (sscanf(str, fmt, ptr) != 1)\n\n        return -EINVAL;\n\n    return 0;\n\n}\n", "idx": 19554}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void scale_coefs (\n\n    int32_t *dst,\n\n    const int32_t *src,\n\n    int dynrng,\n\n    int len)\n\n{\n\n    int i, shift, round;\n\n    int16_t mul;\n\n    int temp, temp1, temp2, temp3, temp4, temp5, temp6, temp7;\n\n\n\n    mul = (dynrng & 0x1f) + 0x20;\n\n    shift = 4 - ((dynrng << 23) >> 28);\n\n    if (shift > 0 ) {\n\n      round = 1 << (shift-1);\n\n      for (i=0; i<len; i+=8) {\n\n\n\n          temp = src[i] * mul;\n\n          temp1 = src[i+1] * mul;\n\n          temp = temp + round;\n\n          temp2 = src[i+2] * mul;\n\n\n\n          temp1 = temp1 + round;\n\n          dst[i] = temp >> shift;\n\n          temp3 = src[i+3] * mul;\n\n          temp2 = temp2 + round;\n\n\n\n          dst[i+1] = temp1 >> shift;\n\n          temp4 = src[i + 4] * mul;\n\n          temp3 = temp3 + round;\n\n          dst[i+2] = temp2 >> shift;\n\n\n\n          temp5 = src[i+5] * mul;\n\n          temp4 = temp4 + round;\n\n          dst[i+3] = temp3 >> shift;\n\n          temp6 = src[i+6] * mul;\n\n\n\n          dst[i+4] = temp4 >> shift;\n\n          temp5 = temp5 + round;\n\n          temp7 = src[i+7] * mul;\n\n          temp6 = temp6 + round;\n\n\n\n          dst[i+5] = temp5 >> shift;\n\n          temp7 = temp7 + round;\n\n          dst[i+6] = temp6 >> shift;\n\n          dst[i+7] = temp7 >> shift;\n\n\n\n      }\n\n    } else {\n\n      shift = -shift;\n\n      for (i=0; i<len; i+=8) {\n\n\n\n          temp = src[i] * mul;\n\n          temp1 = src[i+1] * mul;\n\n          temp2 = src[i+2] * mul;\n\n\n\n          dst[i] = temp << shift;\n\n          temp3 = src[i+3] * mul;\n\n\n\n          dst[i+1] = temp1 << shift;\n\n          temp4 = src[i + 4] * mul;\n\n          dst[i+2] = temp2 << shift;\n\n\n\n          temp5 = src[i+5] * mul;\n\n          dst[i+3] = temp3 << shift;\n\n          temp6 = src[i+6] * mul;\n\n\n\n          dst[i+4] = temp4 << shift;\n\n          temp7 = src[i+7] * mul;\n\n\n\n          dst[i+5] = temp5 << shift;\n\n          dst[i+6] = temp6 << shift;\n\n          dst[i+7] = temp7 << shift;\n\n\n\n      }\n\n    }\n\n}\n", "idx": 19595}, {"project": "test", "commit_id": "test", "target": 1, "func": "void vnc_sasl_client_cleanup(VncState *vs)\n\n{\n\n    if (vs->sasl.conn) {\n\n        vs->sasl.runSSF = vs->sasl.waitWriteSSF = vs->sasl.wantSSF = 0;\n\n        vs->sasl.encodedLength = vs->sasl.encodedOffset = 0;\n\n        vs->sasl.encoded = NULL;\n\n        g_free(vs->sasl.username);\n\n        free(vs->sasl.mechlist);\n\n        vs->sasl.username = vs->sasl.mechlist = NULL;\n\n        sasl_dispose(&vs->sasl.conn);\n\n        vs->sasl.conn = NULL;\n\n    }\n\n}\n", "idx": 19633}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int integratorcm_init(SysBusDevice *dev)\n\n{\n\n    IntegratorCMState *s = INTEGRATOR_CM(dev);\n\n\n\n    s->cm_osc = 0x01000048;\n\n    /* ??? What should the high bits of this value be?  */\n\n    s->cm_auxosc = 0x0007feff;\n\n    s->cm_sdram = 0x00011122;\n\n    if (s->memsz >= 256) {\n\n        integrator_spd[31] = 64;\n\n        s->cm_sdram |= 0x10;\n\n    } else if (s->memsz >= 128) {\n\n        integrator_spd[31] = 32;\n\n        s->cm_sdram |= 0x0c;\n\n    } else if (s->memsz >= 64) {\n\n        integrator_spd[31] = 16;\n\n        s->cm_sdram |= 0x08;\n\n    } else if (s->memsz >= 32) {\n\n        integrator_spd[31] = 4;\n\n        s->cm_sdram |= 0x04;\n\n    } else {\n\n        integrator_spd[31] = 2;\n\n    }\n\n    memcpy(integrator_spd + 73, \"QEMU-MEMORY\", 11);\n\n    s->cm_init = 0x00000112;\n\n    s->cm_refcnt_offset = muldiv64(qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL), 24,\n\n                                   1000);\n\n    memory_region_init_ram(&s->flash, OBJECT(s), \"integrator.flash\", 0x100000,\n\n                           &error_abort);\n\n    vmstate_register_ram_global(&s->flash);\n\n\n\n    memory_region_init_io(&s->iomem, OBJECT(s), &integratorcm_ops, s,\n\n                          \"integratorcm\", 0x00800000);\n\n    sysbus_init_mmio(dev, &s->iomem);\n\n\n\n    integratorcm_do_remap(s);\n\n    /* ??? Save/restore.  */\n\n    return 0;\n\n}\n", "idx": 19643}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void unterminated_array_comma(void)\n\n{\n\n    QObject *obj = qobject_from_json(\"[32,\", NULL);\n\n    g_assert(obj == NULL);\n\n}\n", "idx": 19650}, {"project": "test", "commit_id": "test", "target": 1, "func": "void prepare_grab(void)\n\n{\n\n    fprintf(stderr, \"Must supply at least one input file\\n\");\n\n    exit(1);\n\n}\n", "idx": 19665}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void ehci_writeback_async_complete_packet(EHCIPacket *p)\n{\n    EHCIQueue *q = p->queue;\n    int state;\n    state = ehci_get_state(q->ehci, q->async);\n    ehci_state_executing(q);\n    ehci_state_writeback(q); /* Frees the packet! */\n    if (!(q->qh.token & QTD_TOKEN_HALT)) {\n        ehci_state_advqueue(q);\n    ehci_set_state(q->ehci, q->async, state);", "idx": 19685}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void wdt_diag288_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n    DIAG288Class *diag288 = DIAG288_CLASS(klass);\n\n\n\n    dc->realize = wdt_diag288_realize;\n\n    dc->unrealize = wdt_diag288_unrealize;\n\n    dc->reset = wdt_diag288_reset;\n\n\n    set_bit(DEVICE_CATEGORY_MISC, dc->categories);\n\n    dc->vmsd = &vmstate_diag288;\n\n    diag288->handle_timer = wdt_diag288_handle_timer;\n\n}", "idx": 19716}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void RENAME(planar2x)(const uint8_t *src, uint8_t *dst, long srcWidth, long srcHeight, long srcStride, long dstStride)\n\n{\n\n\tlong x,y;\n\n\n\n\tdst[0]= src[0];\n\n\n\n\t// first line\n\n\tfor(x=0; x<srcWidth-1; x++){\n\n\t\tdst[2*x+1]= (3*src[x] +   src[x+1])>>2;\n\n\t\tdst[2*x+2]= (  src[x] + 3*src[x+1])>>2;\n\n\t}\n\n\tdst[2*srcWidth-1]= src[srcWidth-1];\n\n\n\n        dst+= dstStride;\n\n\n\n\tfor(y=1; y<srcHeight; y++){\n\n#if defined (HAVE_MMX2) || defined (HAVE_3DNOW)\n\n\t\tconst long mmxSize= srcWidth&~15;\n\n\t\tasm volatile(\n\n\t\t\t\"mov %4, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\t\"movq (%0, %%\"REG_a\"), %%mm0\t\\n\\t\"\n\n\t\t\t\"movq (%1, %%\"REG_a\"), %%mm1\t\\n\\t\"\n\n\t\t\t\"movq 1(%0, %%\"REG_a\"), %%mm2\t\\n\\t\"\n\n\t\t\t\"movq 1(%1, %%\"REG_a\"), %%mm3\t\\n\\t\"\n\n\t\t\t\"movq -1(%0, %%\"REG_a\"), %%mm4\t\\n\\t\"\n\n\t\t\t\"movq -1(%1, %%\"REG_a\"), %%mm5\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm0, %%mm5\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm0, %%mm3\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm0, %%mm5\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm0, %%mm3\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm1, %%mm4\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm1, %%mm2\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm1, %%mm4\t\t\\n\\t\"\n\n\t\t\tPAVGB\" %%mm1, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"movq %%mm5, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"movq %%mm4, %%mm6\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm3, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"punpckhbw %%mm3, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm2, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"punpckhbw %%mm2, %%mm6\t\t\\n\\t\"\n\n#if 1\n\n\t\t\tMOVNTQ\" %%mm5, (%2, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm7, 8(%2, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm4, (%3, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\tMOVNTQ\" %%mm6, 8(%3, %%\"REG_a\", 2)\\n\\t\"\n\n#else\n\n\t\t\t\"movq %%mm5, (%2, %%\"REG_a\", 2)\t\\n\\t\"\n\n\t\t\t\"movq %%mm7, 8(%2, %%\"REG_a\", 2)\\n\\t\"\n\n\t\t\t\"movq %%mm4, (%3, %%\"REG_a\", 2)\t\\n\\t\"\n\n\t\t\t\"movq %%mm6, 8(%3, %%\"REG_a\", 2)\\n\\t\"\n\n#endif\n\n\t\t\t\"add $8, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\" js 1b\t\t\t\t\\n\\t\"\n\n\t\t\t:: \"r\" (src + mmxSize  ), \"r\" (src + srcStride + mmxSize  ),\n\n\t\t\t   \"r\" (dst + mmxSize*2), \"r\" (dst + dstStride + mmxSize*2),\n\n\t\t\t   \"g\" (-mmxSize)\n\n\t\t\t: \"%\"REG_a\n\n\n\n\t\t);\n\n#else\n\n\t\tconst long mmxSize=1;\n\n#endif\n\n\t\tdst[0        ]= (3*src[0] +   src[srcStride])>>2;\n\n\t\tdst[dstStride]= (  src[0] + 3*src[srcStride])>>2;\n\n\n\n\t\tfor(x=mmxSize-1; x<srcWidth-1; x++){\n\n\t\t\tdst[2*x          +1]= (3*src[x+0] +   src[x+srcStride+1])>>2;\n\n\t\t\tdst[2*x+dstStride+2]= (  src[x+0] + 3*src[x+srcStride+1])>>2;\n\n\t\t\tdst[2*x+dstStride+1]= (  src[x+1] + 3*src[x+srcStride  ])>>2;\n\n\t\t\tdst[2*x          +2]= (3*src[x+1] +   src[x+srcStride  ])>>2;\n\n\t\t}\n\n\t\tdst[srcWidth*2 -1            ]= (3*src[srcWidth-1] +   src[srcWidth-1 + srcStride])>>2;\n\n\t\tdst[srcWidth*2 -1 + dstStride]= (  src[srcWidth-1] + 3*src[srcWidth-1 + srcStride])>>2;\n\n\n\n\t\tdst+=dstStride*2;\n\n\t\tsrc+=srcStride;\n\n\t}\n\n\n\n\t// last line\n\n#if 1\n\n\tdst[0]= src[0];\n\n\n\n\tfor(x=0; x<srcWidth-1; x++){\n\n\t\tdst[2*x+1]= (3*src[x] +   src[x+1])>>2;\n\n\t\tdst[2*x+2]= (  src[x] + 3*src[x+1])>>2;\n\n\t}\n\n\tdst[2*srcWidth-1]= src[srcWidth-1];\n\n#else\n\n\tfor(x=0; x<srcWidth; x++){\n\n\t\tdst[2*x+0]=\n\n\t\tdst[2*x+1]= src[x];\n\n\t}\n\n#endif\n\n\n\n#ifdef HAVE_MMX\n\nasm volatile(   EMMS\" \\n\\t\"\n\n        \tSFENCE\" \\n\\t\"\n\n        \t:::\"memory\");\n\n#endif\n\n}\n", "idx": 19782}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void gen_mtmsr(DisasContext *ctx)\n\n{\n\n#if defined(CONFIG_USER_ONLY)\n\n    gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n#else\n\n    if (unlikely(ctx->pr)) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_PRIV_REG);\n\n        return;\n\n    }\n\n    if (ctx->opcode & 0x00010000) {\n\n        /* Special form that does not need any synchronisation */\n\n        TCGv t0 = tcg_temp_new();\n\n        tcg_gen_andi_tl(t0, cpu_gpr[rS(ctx->opcode)], (1 << MSR_RI) | (1 << MSR_EE));\n\n        tcg_gen_andi_tl(cpu_msr, cpu_msr, ~(target_ulong)((1 << MSR_RI) | (1 << MSR_EE)));\n\n        tcg_gen_or_tl(cpu_msr, cpu_msr, t0);\n\n        tcg_temp_free(t0);\n\n    } else {\n\n        TCGv msr = tcg_temp_new();\n\n\n\n        /* XXX: we need to update nip before the store\n\n         *      if we enter power saving mode, we will exit the loop\n\n         *      directly from ppc_store_msr\n\n         */\n\n        gen_update_nip(ctx, ctx->nip);\n\n#if defined(TARGET_PPC64)\n\n        tcg_gen_deposit_tl(msr, cpu_msr, cpu_gpr[rS(ctx->opcode)], 0, 32);\n\n#else\n\n        tcg_gen_mov_tl(msr, cpu_gpr[rS(ctx->opcode)]);\n\n#endif\n\n        gen_helper_store_msr(cpu_env, msr);\n\n        tcg_temp_free(msr);\n\n        /* Must stop the translation as machine state (may have) changed */\n\n        /* Note that mtmsr is not always defined as context-synchronizing */\n\n        gen_stop_exception(ctx);\n\n    }\n\n#endif\n\n}\n", "idx": 19808}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void flatview_ref(FlatView *view)\n\n{\n\n    atomic_inc(&view->ref);\n\n}\n", "idx": 19809}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int huff_build10(VLC *vlc, uint8_t *len)\n\n{\n\n    HuffEntry he[1024];\n\n    uint32_t codes[1024];\n\n    uint8_t bits[1024];\n\n    uint16_t syms[1024];\n\n    uint32_t code;\n\n    int i;\n\n\n\n    for (i = 0; i < 1024; i++) {\n\n        he[i].sym = 1023 - i;\n\n        he[i].len = len[i];\n\n\n\n    }\n\n    AV_QSORT(he, 1024, HuffEntry, huff_cmp_len10);\n\n\n\n    code = 1;\n\n    for (i = 1023; i >= 0; i--) {\n\n        codes[i] = code >> (32 - he[i].len);\n\n        bits[i]  = he[i].len;\n\n        syms[i]  = he[i].sym;\n\n        code += 0x80000000u >> (he[i].len - 1);\n\n    }\n\n\n\n    ff_free_vlc(vlc);\n\n    return ff_init_vlc_sparse(vlc, FFMIN(he[1023].len, 12), 1024,\n\n                              bits,  sizeof(*bits),  sizeof(*bits),\n\n                              codes, sizeof(*codes), sizeof(*codes),\n\n                              syms,  sizeof(*syms),  sizeof(*syms), 0);\n\n}", "idx": 19827}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void test_task_complete(void)\n\n{\n\n    QIOTask *task;\n\n    Object *obj = object_new(TYPE_DUMMY);\n\n    Object *src;\n\n    struct TestTaskData data = { NULL, NULL, false };\n\n\n\n    task = qio_task_new(obj, task_callback, &data, NULL);\n\n    src = qio_task_get_source(task);\n\n\n\n    qio_task_complete(task);\n\n\n\n    g_assert(obj == src);\n\n\n\n    object_unref(obj);\n\n    object_unref(src);\n\n\n\n    g_assert(data.source == obj);\n\n    g_assert(data.err == NULL);\n\n    g_assert(data.freed == false);\n\n}\n", "idx": 19834}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int wsvqa_read_header(AVFormatContext *s,\n\n                             AVFormatParameters *ap)\n\n{\n\n    WsVqaDemuxContext *wsvqa = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st;\n\n    unsigned char *header;\n\n    unsigned char scratch[VQA_PREAMBLE_SIZE];\n\n    unsigned int chunk_tag;\n\n    unsigned int chunk_size;\n\n\n\n    /* initialize the video decoder stream */\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n    av_set_pts_info(st, 33, 1, VQA_FRAMERATE);\n\n    wsvqa->video_stream_index = st->index;\n\n    st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n    st->codec->codec_id = CODEC_ID_WS_VQA;\n\n    st->codec->codec_tag = 0;  /* no fourcc */\n\n\n\n    /* skip to the start of the VQA header */\n\n    avio_seek(pb, 20, SEEK_SET);\n\n\n\n    /* the VQA header needs to go to the decoder */\n\n    st->codec->extradata_size = VQA_HEADER_SIZE;\n\n    st->codec->extradata = av_mallocz(VQA_HEADER_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    header = (unsigned char *)st->codec->extradata;\n\n    if (avio_read(pb, st->codec->extradata, VQA_HEADER_SIZE) !=\n\n        VQA_HEADER_SIZE) {\n\n        av_free(st->codec->extradata);\n\n        return AVERROR(EIO);\n\n    }\n\n    st->codec->width = AV_RL16(&header[6]);\n\n    st->codec->height = AV_RL16(&header[8]);\n\n\n\n    /* initialize the audio decoder stream for VQA v1 or nonzero samplerate */\n\n    if (AV_RL16(&header[24]) || (AV_RL16(&header[0]) == 1 && AV_RL16(&header[2]) == 1)) {\n\n        st = av_new_stream(s, 0);\n\n        if (!st)\n\n            return AVERROR(ENOMEM);\n\n        av_set_pts_info(st, 33, 1, VQA_FRAMERATE);\n\n        st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n        if (AV_RL16(&header[0]) == 1)\n\n            st->codec->codec_id = CODEC_ID_WESTWOOD_SND1;\n\n        else\n\n            st->codec->codec_id = CODEC_ID_ADPCM_IMA_WS;\n\n        st->codec->codec_tag = 0;  /* no tag */\n\n        st->codec->sample_rate = AV_RL16(&header[24]);\n\n        if (!st->codec->sample_rate)\n\n            st->codec->sample_rate = 22050;\n\n        st->codec->channels = header[26];\n\n        if (!st->codec->channels)\n\n            st->codec->channels = 1;\n\n        st->codec->bits_per_coded_sample = 16;\n\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate *\n\n            st->codec->bits_per_coded_sample / 4;\n\n        st->codec->block_align = st->codec->channels * st->codec->bits_per_coded_sample;\n\n\n\n        wsvqa->audio_stream_index = st->index;\n\n        wsvqa->audio_samplerate = st->codec->sample_rate;\n\n        wsvqa->audio_channels = st->codec->channels;\n\n        wsvqa->audio_frame_counter = 0;\n\n    }\n\n\n\n    /* there are 0 or more chunks before the FINF chunk; iterate until\n\n     * FINF has been skipped and the file will be ready to be demuxed */\n\n    do {\n\n        if (avio_read(pb, scratch, VQA_PREAMBLE_SIZE) != VQA_PREAMBLE_SIZE) {\n\n            av_free(st->codec->extradata);\n\n            return AVERROR(EIO);\n\n        }\n\n        chunk_tag = AV_RB32(&scratch[0]);\n\n        chunk_size = AV_RB32(&scratch[4]);\n\n\n\n        /* catch any unknown header tags, for curiousity */\n\n        switch (chunk_tag) {\n\n        case CINF_TAG:\n\n        case CINH_TAG:\n\n        case CIND_TAG:\n\n        case PINF_TAG:\n\n        case PINH_TAG:\n\n        case PIND_TAG:\n\n        case FINF_TAG:\n\n        case CMDS_TAG:\n\n            break;\n\n\n\n        default:\n\n            av_log (s, AV_LOG_ERROR, \" note: unknown chunk seen (%c%c%c%c)\\n\",\n\n                scratch[0], scratch[1],\n\n                scratch[2], scratch[3]);\n\n            break;\n\n        }\n\n\n\n        avio_skip(pb, chunk_size);\n\n    } while (chunk_tag != FINF_TAG);\n\n\n\n    return 0;\n\n}\n", "idx": 19892}, {"project": "test", "commit_id": "test", "target": 1, "func": "int ff_wma_init(AVCodecContext *avctx, int flags2)\n\n{\n\n    WMACodecContext *s = avctx->priv_data;\n\n    int i;\n\n    float bps1, high_freq;\n\n    volatile float bps;\n\n    int sample_rate1;\n\n    int coef_vlc_table;\n\n\n\n    if (   avctx->sample_rate <= 0 || avctx->sample_rate > 50000\n\n        || avctx->channels    <= 0 || avctx->channels    > 2\n\n        || avctx->bit_rate    <= 0)\n\n        return -1;\n\n\n\n    ff_fmt_convert_init(&s->fmt_conv, avctx);\n\n    avpriv_float_dsp_init(&s->fdsp, avctx->flags & CODEC_FLAG_BITEXACT);\n\n\n\n    if (avctx->codec->id == AV_CODEC_ID_WMAV1) {\n\n        s->version = 1;\n\n    } else {\n\n        s->version = 2;\n\n\n\n\n    /* compute MDCT block size */\n\n    s->frame_len_bits = ff_wma_get_frame_len_bits(avctx->sample_rate,\n\n                                                  s->version, 0);\n\n    s->next_block_len_bits = s->frame_len_bits;\n\n    s->prev_block_len_bits = s->frame_len_bits;\n\n    s->block_len_bits      = s->frame_len_bits;\n\n\n\n    s->frame_len = 1 << s->frame_len_bits;\n\n    if (s->use_variable_block_len) {\n\n        int nb_max, nb;\n\n        nb = ((flags2 >> 3) & 3) + 1;\n\n        if ((avctx->bit_rate / avctx->channels) >= 32000)\n\n            nb += 2;\n\n        nb_max = s->frame_len_bits - BLOCK_MIN_BITS;\n\n        if (nb > nb_max)\n\n            nb = nb_max;\n\n        s->nb_block_sizes = nb + 1;\n\n    } else {\n\n        s->nb_block_sizes = 1;\n\n\n\n\n    /* init rate dependent parameters */\n\n    s->use_noise_coding = 1;\n\n    high_freq = avctx->sample_rate * 0.5;\n\n\n\n    /* if version 2, then the rates are normalized */\n\n    sample_rate1 = avctx->sample_rate;\n\n    if (s->version == 2) {\n\n        if (sample_rate1 >= 44100) {\n\n            sample_rate1 = 44100;\n\n        } else if (sample_rate1 >= 22050) {\n\n            sample_rate1 = 22050;\n\n        } else if (sample_rate1 >= 16000) {\n\n            sample_rate1 = 16000;\n\n        } else if (sample_rate1 >= 11025) {\n\n            sample_rate1 = 11025;\n\n        } else if (sample_rate1 >= 8000) {\n\n            sample_rate1 = 8000;\n\n\n\n\n\n    bps = (float)avctx->bit_rate / (float)(avctx->channels * avctx->sample_rate);\n\n    s->byte_offset_bits = av_log2((int)(bps * s->frame_len / 8.0 + 0.5)) + 2;\n\n\n\n\n\n\n\n    /* compute high frequency value and choose if noise coding should\n\n       be activated */\n\n    bps1 = bps;\n\n    if (avctx->channels == 2)\n\n        bps1 = bps * 1.6;\n\n    if (sample_rate1 == 44100) {\n\n        if (bps1 >= 0.61) {\n\n            s->use_noise_coding = 0;\n\n        } else {\n\n            high_freq = high_freq * 0.4;\n\n\n    } else if (sample_rate1 == 22050) {\n\n        if (bps1 >= 1.16) {\n\n            s->use_noise_coding = 0;\n\n        } else if (bps1 >= 0.72) {\n\n            high_freq = high_freq * 0.7;\n\n        } else {\n\n            high_freq = high_freq * 0.6;\n\n\n    } else if (sample_rate1 == 16000) {\n\n        if (bps > 0.5) {\n\n            high_freq = high_freq * 0.5;\n\n        } else {\n\n            high_freq = high_freq * 0.3;\n\n\n    } else if (sample_rate1 == 11025) {\n\n        high_freq = high_freq * 0.7;\n\n    } else if (sample_rate1 == 8000) {\n\n        if (bps <= 0.625) {\n\n            high_freq = high_freq * 0.5;\n\n        } else if (bps > 0.75) {\n\n            s->use_noise_coding = 0;\n\n        } else {\n\n            high_freq = high_freq * 0.65;\n\n\n    } else {\n\n        if (bps >= 0.8) {\n\n            high_freq = high_freq * 0.75;\n\n        } else if (bps >= 0.6) {\n\n            high_freq = high_freq * 0.6;\n\n        } else {\n\n            high_freq = high_freq * 0.5;\n\n\n\n    av_dlog(s->avctx, \"flags2=0x%x\\n\", flags2);\n\n    av_dlog(s->avctx, \"version=%d channels=%d sample_rate=%d bitrate=%d block_align=%d\\n\",\n\n            s->version, avctx->channels, avctx->sample_rate, avctx->bit_rate,\n\n            avctx->block_align);\n\n    av_dlog(s->avctx, \"bps=%f bps1=%f high_freq=%f bitoffset=%d\\n\",\n\n            bps, bps1, high_freq, s->byte_offset_bits);\n\n    av_dlog(s->avctx, \"use_noise_coding=%d use_exp_vlc=%d nb_block_sizes=%d\\n\",\n\n            s->use_noise_coding, s->use_exp_vlc, s->nb_block_sizes);\n\n\n\n    /* compute the scale factor band sizes for each MDCT block size */\n\n    {\n\n        int a, b, pos, lpos, k, block_len, i, j, n;\n\n        const uint8_t *table;\n\n\n\n        if (s->version == 1) {\n\n            s->coefs_start = 3;\n\n        } else {\n\n            s->coefs_start = 0;\n\n\n        for (k = 0; k < s->nb_block_sizes; k++) {\n\n            block_len = s->frame_len >> k;\n\n\n\n            if (s->version == 1) {\n\n                lpos = 0;\n\n                for (i = 0; i < 25; i++) {\n\n                    a = ff_wma_critical_freqs[i];\n\n                    b = avctx->sample_rate;\n\n                    pos = ((block_len * 2 * a) + (b >> 1)) / b;\n\n                    if (pos > block_len)\n\n                        pos = block_len;\n\n                    s->exponent_bands[0][i] = pos - lpos;\n\n                    if (pos >= block_len) {\n\n                        i++;\n\n                        break;\n\n\n                    lpos = pos;\n\n\n                s->exponent_sizes[0] = i;\n\n            } else {\n\n                /* hardcoded tables */\n\n                table = NULL;\n\n                a = s->frame_len_bits - BLOCK_MIN_BITS - k;\n\n                if (a < 3) {\n\n                    if (avctx->sample_rate >= 44100) {\n\n                        table = exponent_band_44100[a];\n\n                    } else if (avctx->sample_rate >= 32000) {\n\n                        table = exponent_band_32000[a];\n\n                    } else if (avctx->sample_rate >= 22050) {\n\n                        table = exponent_band_22050[a];\n\n\n\n                if (table) {\n\n                    n = *table++;\n\n                    for (i = 0; i < n; i++)\n\n                        s->exponent_bands[k][i] = table[i];\n\n                    s->exponent_sizes[k] = n;\n\n                } else {\n\n                    j = 0;\n\n                    lpos = 0;\n\n                    for (i = 0; i < 25; i++) {\n\n                        a = ff_wma_critical_freqs[i];\n\n                        b = avctx->sample_rate;\n\n                        pos = ((block_len * 2 * a) + (b << 1)) / (4 * b);\n\n                        pos <<= 2;\n\n                        if (pos > block_len)\n\n                            pos = block_len;\n\n                        if (pos > lpos)\n\n                            s->exponent_bands[k][j++] = pos - lpos;\n\n                        if (pos >= block_len)\n\n                            break;\n\n                        lpos = pos;\n\n\n                    s->exponent_sizes[k] = j;\n\n\n\n\n\n            /* max number of coefs */\n\n            s->coefs_end[k] = (s->frame_len - ((s->frame_len * 9) / 100)) >> k;\n\n            /* high freq computation */\n\n            s->high_band_start[k] = (int)((block_len * 2 * high_freq) /\n\n                                          avctx->sample_rate + 0.5);\n\n            n = s->exponent_sizes[k];\n\n            j = 0;\n\n            pos = 0;\n\n            for (i = 0; i < n; i++) {\n\n                int start, end;\n\n                start = pos;\n\n                pos += s->exponent_bands[k][i];\n\n                end = pos;\n\n                if (start < s->high_band_start[k])\n\n                    start = s->high_band_start[k];\n\n                if (end > s->coefs_end[k])\n\n                    end = s->coefs_end[k];\n\n                if (end > start)\n\n                    s->exponent_high_bands[k][j++] = end - start;\n\n\n            s->exponent_high_sizes[k] = j;\n\n#if 0\n\n            tprintf(s->avctx, \"%5d: coefs_end=%d high_band_start=%d nb_high_bands=%d: \",\n\n                    s->frame_len >> k,\n\n                    s->coefs_end[k],\n\n                    s->high_band_start[k],\n\n                    s->exponent_high_sizes[k]);\n\n            for (j = 0; j < s->exponent_high_sizes[k]; j++)\n\n                tprintf(s->avctx, \" %d\", s->exponent_high_bands[k][j]);\n\n            tprintf(s->avctx, \"\\n\");\n\n#endif\n\n\n\n\n\n#ifdef TRACE\n\n    {\n\n        int i, j;\n\n        for (i = 0; i < s->nb_block_sizes; i++) {\n\n            tprintf(s->avctx, \"%5d: n=%2d:\",\n\n                    s->frame_len >> i,\n\n                    s->exponent_sizes[i]);\n\n            for (j = 0; j < s->exponent_sizes[i]; j++)\n\n                tprintf(s->avctx, \" %d\", s->exponent_bands[i][j]);\n\n            tprintf(s->avctx, \"\\n\");\n\n\n\n#endif\n\n\n\n    /* init MDCT windows : simple sinus window */\n\n    for (i = 0; i < s->nb_block_sizes; i++) {\n\n        ff_init_ff_sine_windows(s->frame_len_bits - i);\n\n        s->windows[i] = ff_sine_windows[s->frame_len_bits - i];\n\n\n\n\n    s->reset_block_lengths = 1;\n\n\n\n    if (s->use_noise_coding) {\n\n\n\n        /* init the noise generator */\n\n        if (s->use_exp_vlc) {\n\n            s->noise_mult = 0.02;\n\n        } else {\n\n            s->noise_mult = 0.04;\n\n\n\n\n#ifdef TRACE\n\n        for (i = 0; i < NOISE_TAB_SIZE; i++)\n\n            s->noise_table[i] = 1.0 * s->noise_mult;\n\n#else\n\n        {\n\n            unsigned int seed;\n\n            float norm;\n\n            seed = 1;\n\n            norm = (1.0 / (float)(1LL << 31)) * sqrt(3) * s->noise_mult;\n\n            for (i = 0; i < NOISE_TAB_SIZE; i++) {\n\n                seed = seed * 314159 + 1;\n\n                s->noise_table[i] = (float)((int)seed) * norm;\n\n\n\n#endif\n\n\n\n\n    /* choose the VLC tables for the coefficients */\n\n    coef_vlc_table = 2;\n\n    if (avctx->sample_rate >= 32000) {\n\n        if (bps1 < 0.72) {\n\n            coef_vlc_table = 0;\n\n        } else if (bps1 < 1.16) {\n\n            coef_vlc_table = 1;\n\n\n\n    s->coef_vlcs[0]= &coef_vlcs[coef_vlc_table * 2    ];\n\n    s->coef_vlcs[1]= &coef_vlcs[coef_vlc_table * 2 + 1];\n\n    init_coef_vlc(&s->coef_vlc[0], &s->run_table[0], &s->level_table[0], &s->int_table[0],\n\n                  s->coef_vlcs[0]);\n\n    init_coef_vlc(&s->coef_vlc[1], &s->run_table[1], &s->level_table[1], &s->int_table[1],\n\n                  s->coef_vlcs[1]);\n\n\n\n    return 0;\n", "idx": 19908}, {"project": "test", "commit_id": "test", "target": 1, "func": "void qemu_main_loop_start(void)\n\n{\n\n}\n", "idx": 19966}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void cpu_devinit(const char *cpu_model, unsigned int id,\n\n                        uint64_t prom_addr, qemu_irq **cpu_irqs)\n\n{\n\n    CPUState *cs;\n\n    SPARCCPU *cpu;\n\n    CPUSPARCState *env;\n\n\n\n    cpu = SPARC_CPU(cpu_generic_init(TYPE_SPARC_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"qemu: Unable to find Sparc CPU definition\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    cpu_sparc_set_id(env, id);\n\n    if (id == 0) {\n\n        qemu_register_reset(main_cpu_reset, cpu);\n\n    } else {\n\n        qemu_register_reset(secondary_cpu_reset, cpu);\n\n        cs = CPU(cpu);\n\n        cs->halted = 1;\n\n    }\n\n    *cpu_irqs = qemu_allocate_irqs(cpu_set_irq, cpu, MAX_PILS);\n\n    env->prom_addr = prom_addr;\n\n}\n", "idx": 19987}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int vp9_decode_frame(AVCodecContext *ctx, void *frame,\n\n                            int *got_frame, AVPacket *pkt)\n\n{\n\n    const uint8_t *data = pkt->data;\n\n    int size = pkt->size;\n\n    VP9Context *s = ctx->priv_data;\n\n    int res, tile_row, tile_col, i, ref, row, col;\n\n    int retain_segmap_ref = s->s.frames[REF_FRAME_SEGMAP].segmentation_map &&\n\n                            (!s->s.h.segmentation.enabled || !s->s.h.segmentation.update_map);\n\n    ptrdiff_t yoff, uvoff, ls_y, ls_uv;\n\n    AVFrame *f;\n\n    int bytesperpixel;\n\n\n\n    if ((res = decode_frame_header(ctx, data, size, &ref)) < 0) {\n\n        return res;\n\n    } else if (res == 0) {\n\n        if (!s->s.refs[ref].f->buf[0]) {\n\n            av_log(ctx, AV_LOG_ERROR, \"Requested reference %d not available\\n\", ref);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        if ((res = av_frame_ref(frame, s->s.refs[ref].f)) < 0)\n\n            return res;\n\n        ((AVFrame *)frame)->pts = pkt->pts;\n\n#if FF_API_PKT_PTS\n\nFF_DISABLE_DEPRECATION_WARNINGS\n\n        ((AVFrame *)frame)->pkt_pts = pkt->pts;\n\nFF_ENABLE_DEPRECATION_WARNINGS\n\n#endif\n\n        ((AVFrame *)frame)->pkt_dts = pkt->dts;\n\n        for (i = 0; i < 8; i++) {\n\n            if (s->next_refs[i].f->buf[0])\n\n                ff_thread_release_buffer(ctx, &s->next_refs[i]);\n\n            if (s->s.refs[i].f->buf[0] &&\n\n                (res = ff_thread_ref_frame(&s->next_refs[i], &s->s.refs[i])) < 0)\n\n                return res;\n\n        }\n\n        *got_frame = 1;\n\n        return pkt->size;\n\n    }\n\n    data += res;\n\n    size -= res;\n\n\n\n    if (!retain_segmap_ref || s->s.h.keyframe || s->s.h.intraonly) {\n\n        if (s->s.frames[REF_FRAME_SEGMAP].tf.f->buf[0])\n\n            vp9_unref_frame(ctx, &s->s.frames[REF_FRAME_SEGMAP]);\n\n        if (!s->s.h.keyframe && !s->s.h.intraonly && !s->s.h.errorres && s->s.frames[CUR_FRAME].tf.f->buf[0] &&\n\n            (res = vp9_ref_frame(ctx, &s->s.frames[REF_FRAME_SEGMAP], &s->s.frames[CUR_FRAME])) < 0)\n\n            return res;\n\n    }\n\n    if (s->s.frames[REF_FRAME_MVPAIR].tf.f->buf[0])\n\n        vp9_unref_frame(ctx, &s->s.frames[REF_FRAME_MVPAIR]);\n\n    if (!s->s.h.intraonly && !s->s.h.keyframe && !s->s.h.errorres && s->s.frames[CUR_FRAME].tf.f->buf[0] &&\n\n        (res = vp9_ref_frame(ctx, &s->s.frames[REF_FRAME_MVPAIR], &s->s.frames[CUR_FRAME])) < 0)\n\n        return res;\n\n    if (s->s.frames[CUR_FRAME].tf.f->buf[0])\n\n        vp9_unref_frame(ctx, &s->s.frames[CUR_FRAME]);\n\n    if ((res = vp9_alloc_frame(ctx, &s->s.frames[CUR_FRAME])) < 0)\n\n        return res;\n\n    f = s->s.frames[CUR_FRAME].tf.f;\n\n    f->key_frame = s->s.h.keyframe;\n\n    f->pict_type = (s->s.h.keyframe || s->s.h.intraonly) ? AV_PICTURE_TYPE_I : AV_PICTURE_TYPE_P;\n\n    ls_y = f->linesize[0];\n\n    ls_uv =f->linesize[1];\n\n\n\n    if (s->s.frames[REF_FRAME_SEGMAP].tf.f->buf[0] &&\n\n        (s->s.frames[REF_FRAME_MVPAIR].tf.f->width  != s->s.frames[CUR_FRAME].tf.f->width ||\n\n         s->s.frames[REF_FRAME_MVPAIR].tf.f->height != s->s.frames[CUR_FRAME].tf.f->height)) {\n\n        vp9_unref_frame(ctx, &s->s.frames[REF_FRAME_SEGMAP]);\n\n    }\n\n\n\n    // ref frame setup\n\n    for (i = 0; i < 8; i++) {\n\n        if (s->next_refs[i].f->buf[0])\n\n            ff_thread_release_buffer(ctx, &s->next_refs[i]);\n\n        if (s->s.h.refreshrefmask & (1 << i)) {\n\n            res = ff_thread_ref_frame(&s->next_refs[i], &s->s.frames[CUR_FRAME].tf);\n\n        } else if (s->s.refs[i].f->buf[0]) {\n\n            res = ff_thread_ref_frame(&s->next_refs[i], &s->s.refs[i]);\n\n        }\n\n        if (res < 0)\n\n            return res;\n\n    }\n\n\n\n    if (ctx->hwaccel) {\n\n        res = ctx->hwaccel->start_frame(ctx, NULL, 0);\n\n        if (res < 0)\n\n            return res;\n\n        res = ctx->hwaccel->decode_slice(ctx, pkt->data, pkt->size);\n\n        if (res < 0)\n\n            return res;\n\n        res = ctx->hwaccel->end_frame(ctx);\n\n        if (res < 0)\n\n            return res;\n\n        goto finish;\n\n    }\n\n\n\n    // main tile decode loop\n\n    bytesperpixel = s->bytesperpixel;\n\n    memset(s->above_partition_ctx, 0, s->cols);\n\n    memset(s->above_skip_ctx, 0, s->cols);\n\n    if (s->s.h.keyframe || s->s.h.intraonly) {\n\n        memset(s->above_mode_ctx, DC_PRED, s->cols * 2);\n\n    } else {\n\n        memset(s->above_mode_ctx, NEARESTMV, s->cols);\n\n    }\n\n    memset(s->above_y_nnz_ctx, 0, s->sb_cols * 16);\n\n    memset(s->above_uv_nnz_ctx[0], 0, s->sb_cols * 16 >> s->ss_h);\n\n    memset(s->above_uv_nnz_ctx[1], 0, s->sb_cols * 16 >> s->ss_h);\n\n    memset(s->above_segpred_ctx, 0, s->cols);\n\n    s->pass = s->s.frames[CUR_FRAME].uses_2pass =\n\n        ctx->active_thread_type == FF_THREAD_FRAME && s->s.h.refreshctx && !s->s.h.parallelmode;\n\n    if ((res = update_block_buffers(ctx)) < 0) {\n\n        av_log(ctx, AV_LOG_ERROR,\n\n               \"Failed to allocate block buffers\\n\");\n\n        return res;\n\n    }\n\n    if (s->s.h.refreshctx && s->s.h.parallelmode) {\n\n        int j, k, l, m;\n\n\n\n        for (i = 0; i < 4; i++) {\n\n            for (j = 0; j < 2; j++)\n\n                for (k = 0; k < 2; k++)\n\n                    for (l = 0; l < 6; l++)\n\n                        for (m = 0; m < 6; m++)\n\n                            memcpy(s->prob_ctx[s->s.h.framectxid].coef[i][j][k][l][m],\n\n                                   s->prob.coef[i][j][k][l][m], 3);\n\n            if (s->s.h.txfmmode == i)\n\n                break;\n\n        }\n\n        s->prob_ctx[s->s.h.framectxid].p = s->prob.p;\n\n        ff_thread_finish_setup(ctx);\n\n    } else if (!s->s.h.refreshctx) {\n\n        ff_thread_finish_setup(ctx);\n\n    }\n\n\n\n    do {\n\n        yoff = uvoff = 0;\n\n        s->b = s->b_base;\n\n        s->block = s->block_base;\n\n        s->uvblock[0] = s->uvblock_base[0];\n\n        s->uvblock[1] = s->uvblock_base[1];\n\n        s->eob = s->eob_base;\n\n        s->uveob[0] = s->uveob_base[0];\n\n        s->uveob[1] = s->uveob_base[1];\n\n\n\n        for (tile_row = 0; tile_row < s->s.h.tiling.tile_rows; tile_row++) {\n\n            set_tile_offset(&s->tile_row_start, &s->tile_row_end,\n\n                            tile_row, s->s.h.tiling.log2_tile_rows, s->sb_rows);\n\n            if (s->pass != 2) {\n\n                for (tile_col = 0; tile_col < s->s.h.tiling.tile_cols; tile_col++) {\n\n                    int64_t tile_size;\n\n\n\n                    if (tile_col == s->s.h.tiling.tile_cols - 1 &&\n\n                        tile_row == s->s.h.tiling.tile_rows - 1) {\n\n                        tile_size = size;\n\n                    } else {\n\n                        tile_size = AV_RB32(data);\n\n                        data += 4;\n\n                        size -= 4;\n\n                    }\n\n                    if (tile_size > size) {\n\n                        ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    ff_vp56_init_range_decoder(&s->c_b[tile_col], data, tile_size);\n\n                    if (vp56_rac_get_prob_branchy(&s->c_b[tile_col], 128)) { // marker bit\n\n                        ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);\n\n                        return AVERROR_INVALIDDATA;\n\n                    }\n\n                    data += tile_size;\n\n                    size -= tile_size;\n\n                }\n\n            }\n\n\n\n            for (row = s->tile_row_start; row < s->tile_row_end;\n\n                 row += 8, yoff += ls_y * 64, uvoff += ls_uv * 64 >> s->ss_v) {\n\n                struct VP9Filter *lflvl_ptr = s->lflvl;\n\n                ptrdiff_t yoff2 = yoff, uvoff2 = uvoff;\n\n\n\n                for (tile_col = 0; tile_col < s->s.h.tiling.tile_cols; tile_col++) {\n\n                    set_tile_offset(&s->tile_col_start, &s->tile_col_end,\n\n                                    tile_col, s->s.h.tiling.log2_tile_cols, s->sb_cols);\n\n\n\n                    if (s->pass != 2) {\n\n                        memset(s->left_partition_ctx, 0, 8);\n\n                        memset(s->left_skip_ctx, 0, 8);\n\n                        if (s->s.h.keyframe || s->s.h.intraonly) {\n\n                            memset(s->left_mode_ctx, DC_PRED, 16);\n\n                        } else {\n\n                            memset(s->left_mode_ctx, NEARESTMV, 8);\n\n                        }\n\n                        memset(s->left_y_nnz_ctx, 0, 16);\n\n                        memset(s->left_uv_nnz_ctx, 0, 32);\n\n                        memset(s->left_segpred_ctx, 0, 8);\n\n\n\n                        memcpy(&s->c, &s->c_b[tile_col], sizeof(s->c));\n\n                    }\n\n\n\n                    for (col = s->tile_col_start;\n\n                         col < s->tile_col_end;\n\n                         col += 8, yoff2 += 64 * bytesperpixel,\n\n                         uvoff2 += 64 * bytesperpixel >> s->ss_h, lflvl_ptr++) {\n\n                        // FIXME integrate with lf code (i.e. zero after each\n\n                        // use, similar to invtxfm coefficients, or similar)\n\n                        if (s->pass != 1) {\n\n                            memset(lflvl_ptr->mask, 0, sizeof(lflvl_ptr->mask));\n\n                        }\n\n\n\n                        if (s->pass == 2) {\n\n                            decode_sb_mem(ctx, row, col, lflvl_ptr,\n\n                                          yoff2, uvoff2, BL_64X64);\n\n                        } else {\n\n                            decode_sb(ctx, row, col, lflvl_ptr,\n\n                                      yoff2, uvoff2, BL_64X64);\n\n                        }\n\n                    }\n\n                    if (s->pass != 2) {\n\n                        memcpy(&s->c_b[tile_col], &s->c, sizeof(s->c));\n\n                    }\n\n                }\n\n\n\n                if (s->pass == 1) {\n\n                    continue;\n\n                }\n\n\n\n                // backup pre-loopfilter reconstruction data for intra\n\n                // prediction of next row of sb64s\n\n                if (row + 8 < s->rows) {\n\n                    memcpy(s->intra_pred_data[0],\n\n                           f->data[0] + yoff + 63 * ls_y,\n\n                           8 * s->cols * bytesperpixel);\n\n                    memcpy(s->intra_pred_data[1],\n\n                           f->data[1] + uvoff + ((64 >> s->ss_v) - 1) * ls_uv,\n\n                           8 * s->cols * bytesperpixel >> s->ss_h);\n\n                    memcpy(s->intra_pred_data[2],\n\n                           f->data[2] + uvoff + ((64 >> s->ss_v) - 1) * ls_uv,\n\n                           8 * s->cols * bytesperpixel >> s->ss_h);\n\n                }\n\n\n\n                // loopfilter one row\n\n                if (s->s.h.filter.level) {\n\n                    yoff2 = yoff;\n\n                    uvoff2 = uvoff;\n\n                    lflvl_ptr = s->lflvl;\n\n                    for (col = 0; col < s->cols;\n\n                         col += 8, yoff2 += 64 * bytesperpixel,\n\n                         uvoff2 += 64 * bytesperpixel >> s->ss_h, lflvl_ptr++) {\n\n                        loopfilter_sb(ctx, lflvl_ptr, row, col, yoff2, uvoff2);\n\n                    }\n\n                }\n\n\n\n                // FIXME maybe we can make this more finegrained by running the\n\n                // loopfilter per-block instead of after each sbrow\n\n                // In fact that would also make intra pred left preparation easier?\n\n                ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, row >> 3, 0);\n\n            }\n\n        }\n\n\n\n        if (s->pass < 2 && s->s.h.refreshctx && !s->s.h.parallelmode) {\n\n            adapt_probs(s);\n\n            ff_thread_finish_setup(ctx);\n\n        }\n\n    } while (s->pass++ == 1);\n\n    ff_thread_report_progress(&s->s.frames[CUR_FRAME].tf, INT_MAX, 0);\n\n\n\nfinish:\n\n    // ref frame setup\n\n    for (i = 0; i < 8; i++) {\n\n        if (s->s.refs[i].f->buf[0])\n\n            ff_thread_release_buffer(ctx, &s->s.refs[i]);\n\n        if (s->next_refs[i].f->buf[0] &&\n\n            (res = ff_thread_ref_frame(&s->s.refs[i], &s->next_refs[i])) < 0)\n\n            return res;\n\n    }\n\n\n\n    if (!s->s.h.invisible) {\n\n        if ((res = av_frame_ref(frame, s->s.frames[CUR_FRAME].tf.f)) < 0)\n\n            return res;\n\n        *got_frame = 1;\n\n    }\n\n\n\n    return pkt->size;\n\n}\n", "idx": 20035}, {"project": "test", "commit_id": "test", "target": 1, "func": "int h263_decode_picture_header(MpegEncContext *s)\n\n{\n\n    int format, width, height;\n\n\n\n    /* picture header */\n\n    if (get_bits(&s->gb, 22) != 0x20)\n\n        return -1;\n\n    skip_bits(&s->gb, 8); /* picture timestamp */\n\n\n\n    if (get_bits1(&s->gb) != 1)\n\n        return -1;\t/* marker */\n\n    if (get_bits1(&s->gb) != 0)\n\n        return -1;\t/* h263 id */\n\n    skip_bits1(&s->gb);\t/* split screen off */\n\n    skip_bits1(&s->gb);\t/* camera  off */\n\n    skip_bits1(&s->gb);\t/* freeze picture release off */\n\n\n\n    format = get_bits(&s->gb, 3);\n\n\n\n    if (format != 7) {\n\n        s->h263_plus = 0;\n\n        /* H.263v1 */\n\n        width = h263_format[format][0];\n\n        height = h263_format[format][1];\n\n        if (!width)\n\n            return -1;\n\n\n\n        s->pict_type = I_TYPE + get_bits1(&s->gb);\n\n\n\n        s->unrestricted_mv = get_bits1(&s->gb); \n\n        s->h263_long_vectors = s->unrestricted_mv;\n\n\n\n        if (get_bits1(&s->gb) != 0)\n\n            return -1;\t/* SAC: off */\n\n        if (get_bits1(&s->gb) != 0)\n\n            return -1;\t/* advanced prediction mode: off */\n\n        if (get_bits1(&s->gb) != 0)\n\n            return -1;\t/* not PB frame */\n\n\n\n        s->qscale = get_bits(&s->gb, 5);\n\n        skip_bits1(&s->gb);\t/* Continuous Presence Multipoint mode: off */\n\n    } else {\n\n        s->h263_plus = 1;\n\n        /* H.263v2 */\n\n        /* OPPTYPE */\n\n     \n\n        if (get_bits(&s->gb, 3) != 1) /* Update Full Extended PTYPE */\n\n            return -1;\n\n        format = get_bits(&s->gb, 3);\n\n                \n\n        skip_bits(&s->gb,1); /* Custom PCF */\n\n        umvplus_dec = get_bits(&s->gb, 1); /* Unrestricted Motion Vector */\n\n        skip_bits(&s->gb, 10);\n\n        skip_bits(&s->gb, 3); /* Reserved */\n\n        \n\n        /* MPPTYPE */\n\n        s->pict_type = get_bits(&s->gb, 3) + 1;\n\n        if (s->pict_type != I_TYPE &&\n\n            s->pict_type != P_TYPE)\n\n            return -1;\n\n        skip_bits(&s->gb, 7);\n\n        \n\n        /* Get the picture dimensions */\n\n        if (format == 6) {\n\n            /* Custom Picture Format (CPFMT) */\n\n            skip_bits(&s->gb, 4); /* aspect ratio */\n\n            width = (get_bits(&s->gb, 9) + 1) * 4;\n\n            skip_bits1(&s->gb);\n\n            height = get_bits(&s->gb, 9) * 4;\n\n#ifdef DEBUG \n\n            fprintf(stderr,\"\\nH.263+ Custom picture: %dx%d\\n\",width,height);\n\n#endif            \n\n        }\n\n        else {\n\n            width = h263_format[format][0];\n\n            height = h263_format[format][1];\n\n        }\n\n        \n\n        if ((width == 0) || (height == 0))\n\n            return -1;\n\n            \n\n        if (umvplus_dec) {\n\n            skip_bits1(&s->gb); /* Unlimited Unrestricted Motion Vectors Indicator (UUI) */\n\n        }\n\n            \n\n        s->qscale = get_bits(&s->gb, 5);\n\n    }\n\n    /* PEI */\n\n    while (get_bits1(&s->gb) != 0) {\n\n        skip_bits(&s->gb, 8);\n\n    }\n\n    s->f_code = 1;\n\n    s->width = width;\n\n    s->height = height;\n\n    return 0;\n\n}\n", "idx": 20109}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void continue_after_map_failure(void *opaque)\n\n{\n\n    DMAAIOCB *dbs = (DMAAIOCB *)opaque;\n\n\n\n    dbs->bh = qemu_bh_new(reschedule_dma, dbs);\n\n    qemu_bh_schedule(dbs->bh);\n\n}\n", "idx": 20131}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int seqvideo_decode_frame(AVCodecContext *avctx,\n\n                                 void *data, int *data_size,\n\n                                 AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n\n\n    SeqVideoContext *seq = avctx->priv_data;\n\n\n\n    seq->frame.reference = 1;\n\n    seq->frame.buffer_hints = FF_BUFFER_HINTS_VALID | FF_BUFFER_HINTS_PRESERVE | FF_BUFFER_HINTS_REUSABLE;\n\n    if (avctx->reget_buffer(avctx, &seq->frame)) {\n\n        av_log(seq->avctx, AV_LOG_ERROR, \"tiertexseqvideo: reget_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    seqvideo_decode(seq, buf, buf_size);\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame *)data = seq->frame;\n\n\n\n    return buf_size;\n\n}\n", "idx": 20422}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void _decode_opc(DisasContext * ctx)\n\n{\n\n    /* This code tries to make movcal emulation sufficiently\n\n       accurate for Linux purposes.  This instruction writes\n\n       memory, and prior to that, always allocates a cache line.\n\n       It is used in two contexts:\n\n       - in memcpy, where data is copied in blocks, the first write\n\n       of to a block uses movca.l for performance.\n\n       - in arch/sh/mm/cache-sh4.c, movcal.l + ocbi combination is used\n\n       to flush the cache. Here, the data written by movcal.l is never\n\n       written to memory, and the data written is just bogus.\n\n\n\n       To simulate this, we simulate movcal.l, we store the value to memory,\n\n       but we also remember the previous content. If we see ocbi, we check\n\n       if movcal.l for that address was done previously. If so, the write should\n\n       not have hit the memory, so we restore the previous content.\n\n       When we see an instruction that is neither movca.l\n\n       nor ocbi, the previous content is discarded.\n\n\n\n       To optimize, we only try to flush stores when we're at the start of\n\n       TB, or if we already saw movca.l in this TB and did not flush stores\n\n       yet.  */\n\n    if (ctx->has_movcal)\n\n\t{\n\n\t  int opcode = ctx->opcode & 0xf0ff;\n\n\t  if (opcode != 0x0093 /* ocbi */\n\n\t      && opcode != 0x00c3 /* movca.l */)\n\n\t      {\n\n\t\t  gen_helper_discard_movcal_backup ();\n\n\t\t  ctx->has_movcal = 0;\n\n\t      }\n\n\t}\n\n\n\n#if 0\n\n    fprintf(stderr, \"Translating opcode 0x%04x\\n\", ctx->opcode);\n\n#endif\n\n\n\n    switch (ctx->opcode) {\n\n    case 0x0019:\t\t/* div0u */\n\n\ttcg_gen_andi_i32(cpu_sr, cpu_sr, ~(SR_M | SR_Q | SR_T));\n\n\treturn;\n\n    case 0x000b:\t\t/* rts */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, cpu_pr);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0028:\t\t/* clrmac */\n\n\ttcg_gen_movi_i32(cpu_mach, 0);\n\n\ttcg_gen_movi_i32(cpu_macl, 0);\n\n\treturn;\n\n    case 0x0048:\t\t/* clrs */\n\n\ttcg_gen_andi_i32(cpu_sr, cpu_sr, ~SR_S);\n\n\treturn;\n\n    case 0x0008:\t\t/* clrt */\n\n\tgen_clr_t();\n\n\treturn;\n\n    case 0x0038:\t\t/* ldtlb */\n\n\tCHECK_PRIVILEGED\n\n\tgen_helper_ldtlb();\n\n\treturn;\n\n    case 0x002b:\t\t/* rte */\n\n\tCHECK_PRIVILEGED\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_sr, cpu_ssr);\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, cpu_spc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0058:\t\t/* sets */\n\n\ttcg_gen_ori_i32(cpu_sr, cpu_sr, SR_S);\n\n\treturn;\n\n    case 0x0018:\t\t/* sett */\n\n\tgen_set_t();\n\n\treturn;\n\n    case 0xfbfd:\t\t/* frchg */\n\n\ttcg_gen_xori_i32(cpu_fpscr, cpu_fpscr, FPSCR_FR);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0xf3fd:\t\t/* fschg */\n\n\ttcg_gen_xori_i32(cpu_fpscr, cpu_fpscr, FPSCR_SZ);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x0009:\t\t/* nop */\n\n\treturn;\n\n    case 0x001b:\t\t/* sleep */\n\n\tCHECK_PRIVILEGED\n\n\tgen_helper_sleep(tcg_const_i32(ctx->pc + 2));\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf000) {\n\n    case 0x1000:\t\t/* mov.l Rm,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B11_8), B3_0 * 4);\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x5000:\t\t/* mov.l @(disp,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 4);\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xe000:\t\t/* mov #imm,Rn */\n\n\ttcg_gen_movi_i32(REG(B11_8), B7_0s);\n\n\treturn;\n\n    case 0x9000:\t\t/* mov.w @(disp,PC),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_const_i32(ctx->pc + 4 + B7_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xd000:\t\t/* mov.l @(disp,PC),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_const_i32((ctx->pc + 4 + B7_0 * 4) & ~3);\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x7000:\t\t/* add #imm,Rn */\n\n\ttcg_gen_addi_i32(REG(B11_8), REG(B11_8), B7_0s);\n\n\treturn;\n\n    case 0xa000:\t\t/* bra disp */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tctx->delayed_pc = ctx->pc + 4 + B11_0s * 2;\n\n\ttcg_gen_movi_i32(cpu_delayed_pc, ctx->delayed_pc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\treturn;\n\n    case 0xb000:\t\t/* bsr disp */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\tctx->delayed_pc = ctx->pc + 4 + B11_0s * 2;\n\n\ttcg_gen_movi_i32(cpu_delayed_pc, ctx->delayed_pc);\n\n\tctx->flags |= DELAY_SLOT;\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf00f) {\n\n    case 0x6003:\t\t/* mov Rm,Rn */\n\n\ttcg_gen_mov_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x2000:\t\t/* mov.b Rm,@Rn */\n\n\ttcg_gen_qemu_st8(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x2001:\t\t/* mov.w Rm,@Rn */\n\n\ttcg_gen_qemu_st16(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x2002:\t\t/* mov.l Rm,@Rn */\n\n\ttcg_gen_qemu_st32(REG(B7_4), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x6000:\t\t/* mov.b @Rm,Rn */\n\n\ttcg_gen_qemu_ld8s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x6001:\t\t/* mov.w @Rm,Rn */\n\n\ttcg_gen_qemu_ld16s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x6002:\t\t/* mov.l @Rm,Rn */\n\n\ttcg_gen_qemu_ld32s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\treturn;\n\n    case 0x2004:\t\t/* mov.b Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 1);\n\n\t    tcg_gen_qemu_st8(REG(B7_4), addr, ctx->memidx);\t/* might cause re-execution */\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\t\t\t/* modify register status */\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x2005:\t\t/* mov.w Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 2);\n\n\t    tcg_gen_qemu_st16(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x2006:\t\t/* mov.l Rm,@-Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t}\n\n\treturn;\n\n    case 0x6004:\t\t/* mov.b @Rm+,Rn */\n\n\ttcg_gen_qemu_ld8s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 1);\n\n\treturn;\n\n    case 0x6005:\t\t/* mov.w @Rm+,Rn */\n\n\ttcg_gen_qemu_ld16s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 2);\n\n\treturn;\n\n    case 0x6006:\t\t/* mov.l @Rm+,Rn */\n\n\ttcg_gen_qemu_ld32s(REG(B11_8), REG(B7_4), ctx->memidx);\n\n\tif ( B11_8 != B7_4 )\n\n\t\ttcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\treturn;\n\n    case 0x0004:\t\t/* mov.b Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st8(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x0005:\t\t/* mov.w Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st16(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x0006:\t\t/* mov.l Rm,@(R0,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    tcg_gen_qemu_st32(REG(B7_4), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000c:\t\t/* mov.b @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld8s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000d:\t\t/* mov.w @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld16s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x000e:\t\t/* mov.l @(R0,Rm),Rn */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    tcg_gen_qemu_ld32s(REG(B11_8), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x6008:\t\t/* swap.b Rm,Rn */\n\n\t{\n\n\t    TCGv high, low;\n\n\t    high = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(high, REG(B7_4), 0xffff0000);\n\n\t    low = tcg_temp_new();\n\n\t    tcg_gen_ext16u_i32(low, REG(B7_4));\n\n\t    tcg_gen_bswap16_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x6009:\t\t/* swap.w Rm,Rn */\n\n\t{\n\n\t    TCGv high, low;\n\n\t    high = tcg_temp_new();\n\n\t    tcg_gen_shli_i32(high, REG(B7_4), 16);\n\n\t    low = tcg_temp_new();\n\n\t    tcg_gen_shri_i32(low, REG(B7_4), 16);\n\n\t    tcg_gen_ext16u_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x200d:\t\t/* xtrct Rm,Rn */\n\n\t{\n\n\t    TCGv high, low;\n\n\t    high = tcg_temp_new();\n\n\t    tcg_gen_shli_i32(high, REG(B7_4), 16);\n\n\t    low = tcg_temp_new();\n\n\t    tcg_gen_shri_i32(low, REG(B11_8), 16);\n\n\t    tcg_gen_ext16u_i32(low, low);\n\n\t    tcg_gen_or_i32(REG(B11_8), high, low);\n\n\t    tcg_temp_free(low);\n\n\t    tcg_temp_free(high);\n\n\t}\n\n\treturn;\n\n    case 0x300c:\t\t/* add Rm,Rn */\n\n\ttcg_gen_add_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x300e:\t\t/* addc Rm,Rn */\n\n\tgen_helper_addc(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300f:\t\t/* addv Rm,Rn */\n\n\tgen_helper_addv(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x2009:\t\t/* and Rm,Rn */\n\n\ttcg_gen_and_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x3000:\t\t/* cmp/eq Rm,Rn */\n\n\tgen_cmp(TCG_COND_EQ, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3003:\t\t/* cmp/ge Rm,Rn */\n\n\tgen_cmp(TCG_COND_GE, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3007:\t\t/* cmp/gt Rm,Rn */\n\n\tgen_cmp(TCG_COND_GT, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3006:\t\t/* cmp/hi Rm,Rn */\n\n\tgen_cmp(TCG_COND_GTU, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x3002:\t\t/* cmp/hs Rm,Rn */\n\n\tgen_cmp(TCG_COND_GEU, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x200c:\t\t/* cmp/str Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    TCGv cmp1 = tcg_temp_local_new();\n\n\t    TCGv cmp2 = tcg_temp_local_new();\n\n\t    tcg_gen_xor_i32(cmp1, REG(B7_4), REG(B11_8));\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0xff000000);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x00ff0000);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x0000ff00);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cmp2, cmp1, 0x000000ff);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cmp2, 0, label1);\n\n\t    tcg_gen_andi_i32(cpu_sr, cpu_sr, ~SR_T);\n\n\t    tcg_gen_br(label2);\n\n\t    gen_set_label(label1);\n\n\t    tcg_gen_ori_i32(cpu_sr, cpu_sr, SR_T);\n\n\t    gen_set_label(label2);\n\n\t    tcg_temp_free(cmp2);\n\n\t    tcg_temp_free(cmp1);\n\n\t}\n\n\treturn;\n\n    case 0x2007:\t\t/* div0s Rm,Rn */\n\n\t{\n\n\t    gen_copy_bit_i32(cpu_sr, 8, REG(B11_8), 31);\t/* SR_Q */\n\n\t    gen_copy_bit_i32(cpu_sr, 9, REG(B7_4), 31);\t\t/* SR_M */\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_xor_i32(val, REG(B7_4), REG(B11_8));\n\n\t    gen_copy_bit_i32(cpu_sr, 0, val, 31);\t\t/* SR_T */\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0x3004:\t\t/* div1 Rm,Rn */\n\n\tgen_helper_div1(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300d:\t\t/* dmuls.l Rm,Rn */\n\n\t{\n\n\t    TCGv_i64 tmp1 = tcg_temp_new_i64();\n\n\t    TCGv_i64 tmp2 = tcg_temp_new_i64();\n\n\n\n\t    tcg_gen_ext_i32_i64(tmp1, REG(B7_4));\n\n\t    tcg_gen_ext_i32_i64(tmp2, REG(B11_8));\n\n\t    tcg_gen_mul_i64(tmp1, tmp1, tmp2);\n\n\t    tcg_gen_trunc_i64_i32(cpu_macl, tmp1);\n\n\t    tcg_gen_shri_i64(tmp1, tmp1, 32);\n\n\t    tcg_gen_trunc_i64_i32(cpu_mach, tmp1);\n\n\n\n\t    tcg_temp_free_i64(tmp2);\n\n\t    tcg_temp_free_i64(tmp1);\n\n\t}\n\n\treturn;\n\n    case 0x3005:\t\t/* dmulu.l Rm,Rn */\n\n\t{\n\n\t    TCGv_i64 tmp1 = tcg_temp_new_i64();\n\n\t    TCGv_i64 tmp2 = tcg_temp_new_i64();\n\n\n\n\t    tcg_gen_extu_i32_i64(tmp1, REG(B7_4));\n\n\t    tcg_gen_extu_i32_i64(tmp2, REG(B11_8));\n\n\t    tcg_gen_mul_i64(tmp1, tmp1, tmp2);\n\n\t    tcg_gen_trunc_i64_i32(cpu_macl, tmp1);\n\n\t    tcg_gen_shri_i64(tmp1, tmp1, 32);\n\n\t    tcg_gen_trunc_i64_i32(cpu_mach, tmp1);\n\n\n\n\t    tcg_temp_free_i64(tmp2);\n\n\t    tcg_temp_free_i64(tmp1);\n\n\t}\n\n\treturn;\n\n    case 0x600e:\t\t/* exts.b Rm,Rn */\n\n\ttcg_gen_ext8s_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600f:\t\t/* exts.w Rm,Rn */\n\n\ttcg_gen_ext16s_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600c:\t\t/* extu.b Rm,Rn */\n\n\ttcg_gen_ext8u_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600d:\t\t/* extu.w Rm,Rn */\n\n\ttcg_gen_ext16u_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x000f:\t\t/* mac.l @Rm+,@Rn+ */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg0, REG(B7_4), ctx->memidx);\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg1, REG(B11_8), ctx->memidx);\n\n\t    gen_helper_macl(arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t}\n\n\treturn;\n\n    case 0x400f:\t\t/* mac.w @Rm+,@Rn+ */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg0, REG(B7_4), ctx->memidx);\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(arg1, REG(B11_8), ctx->memidx);\n\n\t    gen_helper_macw(arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 2);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 2);\n\n\t}\n\n\treturn;\n\n    case 0x0007:\t\t/* mul.l Rm,Rn */\n\n\ttcg_gen_mul_i32(cpu_macl, REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x200f:\t\t/* muls.w Rm,Rn */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_ext16s_i32(arg0, REG(B7_4));\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_ext16s_i32(arg1, REG(B11_8));\n\n\t    tcg_gen_mul_i32(cpu_macl, arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t}\n\n\treturn;\n\n    case 0x200e:\t\t/* mulu.w Rm,Rn */\n\n\t{\n\n\t    TCGv arg0, arg1;\n\n\t    arg0 = tcg_temp_new();\n\n\t    tcg_gen_ext16u_i32(arg0, REG(B7_4));\n\n\t    arg1 = tcg_temp_new();\n\n\t    tcg_gen_ext16u_i32(arg1, REG(B11_8));\n\n\t    tcg_gen_mul_i32(cpu_macl, arg0, arg1);\n\n\t    tcg_temp_free(arg1);\n\n\t    tcg_temp_free(arg0);\n\n\t}\n\n\treturn;\n\n    case 0x600b:\t\t/* neg Rm,Rn */\n\n\ttcg_gen_neg_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x600a:\t\t/* negc Rm,Rn */\n\n\tgen_helper_negc(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x6007:\t\t/* not Rm,Rn */\n\n\ttcg_gen_not_i32(REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x200b:\t\t/* or Rm,Rn */\n\n\ttcg_gen_or_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x400c:\t\t/* shad Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    int label3 = gen_new_label();\n\n\t    int label4 = gen_new_label();\n\n\t    TCGv shift;\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B7_4), 0, label1);\n\n\t    /* Rm positive, shift to the left */\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_shl_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label4);\n\n\t    /* Rm negative, shift to the right */\n\n\t    gen_set_label(label1);\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, shift, 0, label2);\n\n\t    tcg_gen_not_i32(shift, REG(B7_4));\n\n\t    tcg_gen_andi_i32(shift, shift, 0x1f);\n\n\t    tcg_gen_addi_i32(shift, shift, 1);\n\n\t    tcg_gen_sar_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label4);\n\n\t    /* Rm = -32 */\n\n\t    gen_set_label(label2);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B11_8), 0, label3);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0);\n\n\t    tcg_gen_br(label4);\n\n\t    gen_set_label(label3);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0xffffffff);\n\n\t    gen_set_label(label4);\n\n\t}\n\n\treturn;\n\n    case 0x400d:\t\t/* shld Rm,Rn */\n\n\t{\n\n\t    int label1 = gen_new_label();\n\n\t    int label2 = gen_new_label();\n\n\t    int label3 = gen_new_label();\n\n\t    TCGv shift;\n\n\t    tcg_gen_brcondi_i32(TCG_COND_LT, REG(B7_4), 0, label1);\n\n\t    /* Rm positive, shift to the left */\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_shl_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label3);\n\n\t    /* Rm negative, shift to the right */\n\n\t    gen_set_label(label1);\n\n            shift = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(shift, REG(B7_4), 0x1f);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, shift, 0, label2);\n\n\t    tcg_gen_not_i32(shift, REG(B7_4));\n\n\t    tcg_gen_andi_i32(shift, shift, 0x1f);\n\n\t    tcg_gen_addi_i32(shift, shift, 1);\n\n\t    tcg_gen_shr_i32(REG(B11_8), REG(B11_8), shift);\n\n\t    tcg_temp_free(shift);\n\n\t    tcg_gen_br(label3);\n\n\t    /* Rm = -32 */\n\n\t    gen_set_label(label2);\n\n\t    tcg_gen_movi_i32(REG(B11_8), 0);\n\n\t    gen_set_label(label3);\n\n\t}\n\n\treturn;\n\n    case 0x3008:\t\t/* sub Rm,Rn */\n\n\ttcg_gen_sub_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0x300a:\t\t/* subc Rm,Rn */\n\n\tgen_helper_subc(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x300b:\t\t/* subv Rm,Rn */\n\n\tgen_helper_subv(REG(B11_8), REG(B7_4), REG(B11_8));\n\n\treturn;\n\n    case 0x2008:\t\t/* tst Rm,Rn */\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_and_i32(val, REG(B7_4), REG(B11_8));\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0x200a:\t\t/* xor Rm,Rn */\n\n\ttcg_gen_xor_i32(REG(B11_8), REG(B11_8), REG(B7_4));\n\n\treturn;\n\n    case 0xf00c: /* fmov {F,D,X}Rm,{F,D,X}Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, XREG(B7_4));\n\n\t    gen_store_fpr64(fp, XREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t} else {\n\n\t    tcg_gen_mov_i32(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n\t}\n\n\treturn;\n\n    case 0xf00a: /* fmov {F,D,X}Rm,@Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr_hi = tcg_temp_new();\n\n\t    int fr = XREG(B7_4);\n\n\t    tcg_gen_addi_i32(addr_hi, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr  ], REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr+1], addr_hi,\t   ctx->memidx);\n\n\t    tcg_temp_free(addr_hi);\n\n\t} else {\n\n\t    tcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], REG(B11_8), ctx->memidx);\n\n\t}\n\n\treturn;\n\n    case 0xf008: /* fmov @Rm,{F,D,X}Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr_hi = tcg_temp_new();\n\n\t    int fr = XREG(B11_8);\n\n\t    tcg_gen_addi_i32(addr_hi, REG(B7_4), 4);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr  ], REG(B7_4), ctx->memidx);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr_hi,   ctx->memidx);\n\n\t    tcg_temp_free(addr_hi);\n\n\t} else {\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], REG(B7_4), ctx->memidx);\n\n\t}\n\n\treturn;\n\n    case 0xf009: /* fmov @Rm+,{F,D,X}Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr_hi = tcg_temp_new();\n\n\t    int fr = XREG(B11_8);\n\n\t    tcg_gen_addi_i32(addr_hi, REG(B7_4), 4);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr  ], REG(B7_4), ctx->memidx);\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr_hi,   ctx->memidx);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 8);\n\n\t    tcg_temp_free(addr_hi);\n\n\t} else {\n\n\t    tcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], REG(B7_4), ctx->memidx);\n\n\t    tcg_gen_addi_i32(REG(B7_4), REG(B7_4), 4);\n\n\t}\n\n\treturn;\n\n    case 0xf00b: /* fmov {F,D,X}Rm,@-Rn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_SZ) {\n\n\t    TCGv addr = tcg_temp_new_i32();\n\n\t    int fr = XREG(B7_4);\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr+1], addr, ctx->memidx);\n\n\t    tcg_gen_subi_i32(addr, addr, 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[fr  ], addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t} else {\n\n\t    TCGv addr;\n\n\t    addr = tcg_temp_new_i32();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf006: /* fmov @(R0,Rm),{F,D,X}Rm - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new_i32();\n\n\t    tcg_gen_add_i32(addr, REG(B7_4), REG(0));\n\n\t    if (ctx->fpscr & FPSCR_SZ) {\n\n\t\tint fr = XREG(B11_8);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr\t ], addr, ctx->memidx);\n\n\t\ttcg_gen_addi_i32(addr, addr, 4);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr, ctx->memidx);\n\n\t    } else {\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[FREG(B11_8)], addr, ctx->memidx);\n\n\t    }\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf007: /* fmov {F,D,X}Rn,@(R0,Rn) - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(B11_8), REG(0));\n\n\t    if (ctx->fpscr & FPSCR_SZ) {\n\n\t\tint fr = XREG(B7_4);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr\t ], addr, ctx->memidx);\n\n\t\ttcg_gen_addi_i32(addr, addr, 4);\n\n\t\ttcg_gen_qemu_ld32u(cpu_fregs[fr+1], addr, ctx->memidx);\n\n\t    } else {\n\n\t\ttcg_gen_qemu_st32(cpu_fregs[FREG(B7_4)], addr, ctx->memidx);\n\n\t    }\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf000: /* fadd Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf001: /* fsub Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf002: /* fmul Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf003: /* fdiv Rm,Rn - FPSCR: R[PR,Enable.O/U/I]/W[Cause,Flag] */\n\n    case 0xf004: /* fcmp/eq Rm,Rn - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n    case 0xf005: /* fcmp/gt Rm,Rn - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n\t{\n\n\t    CHECK_FPU_ENABLED\n\n\t    if (ctx->fpscr & FPSCR_PR) {\n\n                TCGv_i64 fp0, fp1;\n\n\n\n\t\tif (ctx->opcode & 0x0110)\n\n\t\t    break; /* illegal instruction */\n\n\t\tfp0 = tcg_temp_new_i64();\n\n\t\tfp1 = tcg_temp_new_i64();\n\n\t\tgen_load_fpr64(fp0, DREG(B11_8));\n\n\t\tgen_load_fpr64(fp1, DREG(B7_4));\n\n                switch (ctx->opcode & 0xf00f) {\n\n                case 0xf000:\t\t/* fadd Rm,Rn */\n\n                    gen_helper_fadd_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf001:\t\t/* fsub Rm,Rn */\n\n                    gen_helper_fsub_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf002:\t\t/* fmul Rm,Rn */\n\n                    gen_helper_fmul_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf003:\t\t/* fdiv Rm,Rn */\n\n                    gen_helper_fdiv_DT(fp0, fp0, fp1);\n\n                    break;\n\n                case 0xf004:\t\t/* fcmp/eq Rm,Rn */\n\n                    gen_helper_fcmp_eq_DT(fp0, fp1);\n\n                    return;\n\n                case 0xf005:\t\t/* fcmp/gt Rm,Rn */\n\n                    gen_helper_fcmp_gt_DT(fp0, fp1);\n\n                    return;\n\n                }\n\n\t\tgen_store_fpr64(fp0, DREG(B11_8));\n\n                tcg_temp_free_i64(fp0);\n\n                tcg_temp_free_i64(fp1);\n\n\t    } else {\n\n                switch (ctx->opcode & 0xf00f) {\n\n                case 0xf000:\t\t/* fadd Rm,Rn */\n\n                    gen_helper_fadd_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf001:\t\t/* fsub Rm,Rn */\n\n                    gen_helper_fsub_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf002:\t\t/* fmul Rm,Rn */\n\n                    gen_helper_fmul_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf003:\t\t/* fdiv Rm,Rn */\n\n                    gen_helper_fdiv_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    break;\n\n                case 0xf004:\t\t/* fcmp/eq Rm,Rn */\n\n                    gen_helper_fcmp_eq_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    return;\n\n                case 0xf005:\t\t/* fcmp/gt Rm,Rn */\n\n                    gen_helper_fcmp_gt_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B7_4)]);\n\n                    return;\n\n                }\n\n\t    }\n\n\t}\n\n\treturn;\n\n    case 0xf00e: /* fmac FR0,RM,Rn */\n\n        {\n\n            CHECK_FPU_ENABLED\n\n            if (ctx->fpscr & FPSCR_PR) {\n\n                break; /* illegal instruction */\n\n            } else {\n\n                gen_helper_fmac_FT(cpu_fregs[FREG(B11_8)],\n\n                                   cpu_fregs[FREG(0)], cpu_fregs[FREG(B7_4)], cpu_fregs[FREG(B11_8)]);\n\n                return;\n\n            }\n\n        }\n\n    }\n\n\n\n    switch (ctx->opcode & 0xff00) {\n\n    case 0xc900:\t\t/* and #imm,R0 */\n\n\ttcg_gen_andi_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xcd00:\t\t/* and.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_andi_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8b00:\t\t/* bf label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\t    gen_conditional_jump(ctx, ctx->pc + 2,\n\n\t\t\t\t ctx->pc + 4 + B7_0s * 2);\n\n\tctx->bstate = BS_BRANCH;\n\n\treturn;\n\n    case 0x8f00:\t\t/* bf/s label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tgen_branch_slot(ctx->delayed_pc = ctx->pc + 4 + B7_0s * 2, 0);\n\n\tctx->flags |= DELAY_SLOT_CONDITIONAL;\n\n\treturn;\n\n    case 0x8900:\t\t/* bt label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\t    gen_conditional_jump(ctx, ctx->pc + 4 + B7_0s * 2,\n\n\t\t\t\t ctx->pc + 2);\n\n\tctx->bstate = BS_BRANCH;\n\n\treturn;\n\n    case 0x8d00:\t\t/* bt/s label */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\tgen_branch_slot(ctx->delayed_pc = ctx->pc + 4 + B7_0s * 2, 1);\n\n\tctx->flags |= DELAY_SLOT_CONDITIONAL;\n\n\treturn;\n\n    case 0x8800:\t\t/* cmp/eq #imm,R0 */\n\n\tgen_cmp_imm(TCG_COND_EQ, REG(0), B7_0s);\n\n\treturn;\n\n    case 0xc400:\t\t/* mov.b @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0);\n\n\t    tcg_gen_qemu_ld8s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc500:\t\t/* mov.w @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc600:\t\t/* mov.l @(disp,GBR),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 4);\n\n\t    tcg_gen_qemu_ld32s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc000:\t\t/* mov.b R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0);\n\n\t    tcg_gen_qemu_st8(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc100:\t\t/* mov.w R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 2);\n\n\t    tcg_gen_qemu_st16(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc200:\t\t/* mov.l R0,@(disp,GBR) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, cpu_gbr, B7_0 * 4);\n\n\t    tcg_gen_qemu_st32(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8000:\t\t/* mov.b R0,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0);\n\n\t    tcg_gen_qemu_st8(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8100:\t\t/* mov.w R0,@(disp,Rn) */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 2);\n\n\t    tcg_gen_qemu_st16(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8400:\t\t/* mov.b @(disp,Rn),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0);\n\n\t    tcg_gen_qemu_ld8s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0x8500:\t\t/* mov.w @(disp,Rn),R0 */\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_addi_i32(addr, REG(B7_4), B3_0 * 2);\n\n\t    tcg_gen_qemu_ld16s(REG(0), addr, ctx->memidx);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc700:\t\t/* mova @(disp,PC),R0 */\n\n\ttcg_gen_movi_i32(REG(0), ((ctx->pc & 0xfffffffc) + 4 + B7_0 * 4) & ~3);\n\n\treturn;\n\n    case 0xcb00:\t\t/* or #imm,R0 */\n\n\ttcg_gen_ori_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xcf00:\t\t/* or.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_ori_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xc300:\t\t/* trapa #imm */\n\n\t{\n\n\t    TCGv imm;\n\n\t    CHECK_NOT_DELAY_SLOT\n\n\t    tcg_gen_movi_i32(cpu_pc, ctx->pc);\n\n\t    imm = tcg_const_i32(B7_0);\n\n\t    gen_helper_trapa(imm);\n\n\t    tcg_temp_free(imm);\n\n\t    ctx->bstate = BS_BRANCH;\n\n\t}\n\n\treturn;\n\n    case 0xc800:\t\t/* tst #imm,R0 */\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(val, REG(0), B7_0);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0xcc00:\t\t/* tst.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_add_i32(val, REG(0), cpu_gbr);\n\n\t    tcg_gen_qemu_ld8u(val, val, ctx->memidx);\n\n\t    tcg_gen_andi_i32(val, val, B7_0);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0xca00:\t\t/* xor #imm,R0 */\n\n\ttcg_gen_xori_i32(REG(0), REG(0), B7_0);\n\n\treturn;\n\n    case 0xce00:\t\t/* xor.b #imm,@(R0,GBR) */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_add_i32(addr, REG(0), cpu_gbr);\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    tcg_gen_xori_i32(val, val, B7_0);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf08f) {\n\n    case 0x408e:\t\t/* ldc Rm,Rn_BANK */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_mov_i32(ALTREG(B6_4), REG(B11_8));\n\n\treturn;\n\n    case 0x4087:\t\t/* ldc.l @Rm+,Rn_BANK */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_qemu_ld32s(ALTREG(B6_4), REG(B11_8), ctx->memidx);\n\n\ttcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\treturn;\n\n    case 0x0082:\t\t/* stc Rm_BANK,Rn */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_mov_i32(REG(B11_8), ALTREG(B6_4));\n\n\treturn;\n\n    case 0x4083:\t\t/* stc.l Rm_BANK,@-Rn */\n\n\tCHECK_PRIVILEGED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(ALTREG(B6_4), addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    }\n\n\n\n    switch (ctx->opcode & 0xf0ff) {\n\n    case 0x0023:\t\t/* braf Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_addi_i32(cpu_delayed_pc, REG(B11_8), ctx->pc + 4);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x0003:\t\t/* bsrf Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\ttcg_gen_add_i32(cpu_delayed_pc, REG(B11_8), cpu_pr);\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x4015:\t\t/* cmp/pl Rn */\n\n\tgen_cmp_imm(TCG_COND_GT, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x4011:\t\t/* cmp/pz Rn */\n\n\tgen_cmp_imm(TCG_COND_GE, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x4010:\t\t/* dt Rn */\n\n\ttcg_gen_subi_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_cmp_imm(TCG_COND_EQ, REG(B11_8), 0);\n\n\treturn;\n\n    case 0x402b:\t\t/* jmp @Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, REG(B11_8));\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x400b:\t\t/* jsr @Rn */\n\n\tCHECK_NOT_DELAY_SLOT\n\n\ttcg_gen_movi_i32(cpu_pr, ctx->pc + 4);\n\n\ttcg_gen_mov_i32(cpu_delayed_pc, REG(B11_8));\n\n\tctx->flags |= DELAY_SLOT;\n\n\tctx->delayed_pc = (uint32_t) - 1;\n\n\treturn;\n\n    case 0x400e:\t\t/* ldc Rm,SR */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_andi_i32(cpu_sr, REG(B11_8), 0x700083f3);\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x4007:\t\t/* ldc.l @Rm+,SR */\n\n\tCHECK_PRIVILEGED\n\n\t{\n\n\t    TCGv val = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(val, REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_andi_i32(cpu_sr, val, 0x700083f3);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t    ctx->bstate = BS_STOP;\n\n\t}\n\n\treturn;\n\n    case 0x0002:\t\t/* stc SR,Rn */\n\n\tCHECK_PRIVILEGED\n\n\ttcg_gen_mov_i32(REG(B11_8), cpu_sr);\n\n\treturn;\n\n    case 0x4003:\t\t/* stc SR,@-Rn */\n\n\tCHECK_PRIVILEGED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(cpu_sr, addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n#define LD(reg,ldnum,ldpnum,prechk)\t\t\\\n\n  case ldnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    tcg_gen_mov_i32 (cpu_##reg, REG(B11_8));\t\t\t\\\n\n    return;\t\t\t\t\t\t\t\\\n\n  case ldpnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    tcg_gen_qemu_ld32s (cpu_##reg, REG(B11_8), ctx->memidx);\t\\\n\n    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\t\t\\\n\n    return;\n\n#define ST(reg,stnum,stpnum,prechk)\t\t\\\n\n  case stnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    tcg_gen_mov_i32 (REG(B11_8), cpu_##reg);\t\t\t\\\n\n    return;\t\t\t\t\t\t\t\\\n\n  case stpnum:\t\t\t\t\t\t\t\\\n\n    prechk    \t\t\t\t\t\t\t\\\n\n    {\t\t\t\t\t\t\t\t\\\n\n\tTCGv addr = tcg_temp_new();\t\t\t\t\\\n\n\ttcg_gen_subi_i32(addr, REG(B11_8), 4);\t\t\t\\\n\n\ttcg_gen_qemu_st32 (cpu_##reg, addr, ctx->memidx);\t\\\n\n\ttcg_gen_mov_i32(REG(B11_8), addr);\t\t\t\\\n\n\ttcg_temp_free(addr);\t\t\t\t\t\\\n\n    }\t\t\t\t\t\t\t\t\\\n\n    return;\n\n#define LDST(reg,ldnum,ldpnum,stnum,stpnum,prechk)\t\t\\\n\n\tLD(reg,ldnum,ldpnum,prechk)\t\t\t\t\\\n\n\tST(reg,stnum,stpnum,prechk)\n\n\tLDST(gbr,  0x401e, 0x4017, 0x0012, 0x4013, {})\n\n\tLDST(vbr,  0x402e, 0x4027, 0x0022, 0x4023, CHECK_PRIVILEGED)\n\n\tLDST(ssr,  0x403e, 0x4037, 0x0032, 0x4033, CHECK_PRIVILEGED)\n\n\tLDST(spc,  0x404e, 0x4047, 0x0042, 0x4043, CHECK_PRIVILEGED)\n\n\tST(sgr,  0x003a, 0x4032, CHECK_PRIVILEGED)\n\n\tLD(sgr,  0x403a, 0x4036, CHECK_PRIVILEGED if (!(ctx->features & SH_FEATURE_SH4A)) break;)\n\n\tLDST(dbr,  0x40fa, 0x40f6, 0x00fa, 0x40f2, CHECK_PRIVILEGED)\n\n\tLDST(mach, 0x400a, 0x4006, 0x000a, 0x4002, {})\n\n\tLDST(macl, 0x401a, 0x4016, 0x001a, 0x4012, {})\n\n\tLDST(pr,   0x402a, 0x4026, 0x002a, 0x4022, {})\n\n\tLDST(fpul, 0x405a, 0x4056, 0x005a, 0x4052, {CHECK_FPU_ENABLED})\n\n    case 0x406a:\t\t/* lds Rm,FPSCR */\n\n\tCHECK_FPU_ENABLED\n\n\tgen_helper_ld_fpscr(REG(B11_8));\n\n\tctx->bstate = BS_STOP;\n\n\treturn;\n\n    case 0x4066:\t\t/* lds.l @Rm+,FPSCR */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(addr, REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\t    gen_helper_ld_fpscr(addr);\n\n\t    tcg_temp_free(addr);\n\n\t    ctx->bstate = BS_STOP;\n\n\t}\n\n\treturn;\n\n    case 0x006a:\t\t/* sts FPSCR,Rn */\n\n\tCHECK_FPU_ENABLED\n\n\ttcg_gen_andi_i32(REG(B11_8), cpu_fpscr, 0x003fffff);\n\n\treturn;\n\n    case 0x4062:\t\t/* sts FPSCR,@-Rn */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    val = tcg_temp_new();\n\n\t    tcg_gen_andi_i32(val, cpu_fpscr, 0x003fffff);\n\n\t    addr = tcg_temp_new();\n\n\t    tcg_gen_subi_i32(addr, REG(B11_8), 4);\n\n\t    tcg_gen_qemu_st32(val, addr, ctx->memidx);\n\n\t    tcg_gen_mov_i32(REG(B11_8), addr);\n\n\t    tcg_temp_free(addr);\n\n\t    tcg_temp_free(val);\n\n\t}\n\n\treturn;\n\n    case 0x00c3:\t\t/* movca.l R0,@Rm */\n\n        {\n\n            TCGv val = tcg_temp_new();\n\n            tcg_gen_qemu_ld32u(val, REG(B11_8), ctx->memidx);\n\n            gen_helper_movcal (REG(B11_8), val);            \n\n            tcg_gen_qemu_st32(REG(0), REG(B11_8), ctx->memidx);\n\n        }\n\n        ctx->has_movcal = 1;\n\n\treturn;\n\n    case 0x40a9:\n\n\t/* MOVUA.L @Rm,R0 (Rm) -> R0\n\n\t   Load non-boundary-aligned data */\n\n\ttcg_gen_qemu_ld32u(REG(0), REG(B11_8), ctx->memidx);\n\n\treturn;\n\n    case 0x40e9:\n\n\t/* MOVUA.L @Rm+,R0   (Rm) -> R0, Rm + 4 -> Rm\n\n\t   Load non-boundary-aligned data */\n\n\ttcg_gen_qemu_ld32u(REG(0), REG(B11_8), ctx->memidx);\n\n\ttcg_gen_addi_i32(REG(B11_8), REG(B11_8), 4);\n\n\treturn;\n\n    case 0x0029:\t\t/* movt Rn */\n\n\ttcg_gen_andi_i32(REG(B11_8), cpu_sr, SR_T);\n\n\treturn;\n\n    case 0x0073:\n\n        /* MOVCO.L\n\n\t       LDST -> T\n\n               If (T == 1) R0 -> (Rn)\n\n               0 -> LDST\n\n        */\n\n        if (ctx->features & SH_FEATURE_SH4A) {\n\n\t    int label = gen_new_label();\n\n\t    gen_clr_t();\n\n\t    tcg_gen_or_i32(cpu_sr, cpu_sr, cpu_ldst);\n\n\t    tcg_gen_brcondi_i32(TCG_COND_EQ, cpu_ldst, 0, label);\n\n\t    tcg_gen_qemu_st32(REG(0), REG(B11_8), ctx->memidx);\n\n\t    gen_set_label(label);\n\n\t    tcg_gen_movi_i32(cpu_ldst, 0);\n\n\t    return;\n\n\t} else\n\n\t    break;\n\n    case 0x0063:\n\n        /* MOVLI.L @Rm,R0\n\n               1 -> LDST\n\n               (Rm) -> R0\n\n               When interrupt/exception\n\n               occurred 0 -> LDST\n\n        */\n\n\tif (ctx->features & SH_FEATURE_SH4A) {\n\n\t    tcg_gen_movi_i32(cpu_ldst, 0);\n\n\t    tcg_gen_qemu_ld32s(REG(0), REG(B11_8), ctx->memidx);\n\n\t    tcg_gen_movi_i32(cpu_ldst, 1);\n\n\t    return;\n\n\t} else\n\n\t    break;\n\n    case 0x0093:\t\t/* ocbi @Rn */\n\n\t{\n\n\t    gen_helper_ocbi (REG(B11_8));\n\n\t}\n\n\treturn;\n\n    case 0x00a3:\t\t/* ocbp @Rn */\n\n\t{\n\n\t    TCGv dummy = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(dummy, REG(B11_8), ctx->memidx);\n\n\t    tcg_temp_free(dummy);\n\n\t}\n\n\treturn;\n\n    case 0x00b3:\t\t/* ocbwb @Rn */\n\n\t{\n\n\t    TCGv dummy = tcg_temp_new();\n\n\t    tcg_gen_qemu_ld32s(dummy, REG(B11_8), ctx->memidx);\n\n\t    tcg_temp_free(dummy);\n\n\t}\n\n\treturn;\n\n    case 0x0083:\t\t/* pref @Rn */\n\n\treturn;\n\n    case 0x00d3:\t\t/* prefi @Rn */\n\n\tif (ctx->features & SH_FEATURE_SH4A)\n\n\t    return;\n\n\telse\n\n\t    break;\n\n    case 0x00e3:\t\t/* icbi @Rn */\n\n\tif (ctx->features & SH_FEATURE_SH4A)\n\n\t    return;\n\n\telse\n\n\t    break;\n\n    case 0x00ab:\t\t/* synco */\n\n\tif (ctx->features & SH_FEATURE_SH4A)\n\n\t    return;\n\n\telse\n\n\t    break;\n\n    case 0x4024:\t\t/* rotcl Rn */\n\n\t{\n\n\t    TCGv tmp = tcg_temp_new();\n\n\t    tcg_gen_mov_i32(tmp, cpu_sr);\n\n\t    gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\t    tcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\t    gen_copy_bit_i32(REG(B11_8), 0, tmp, 0);\n\n\t    tcg_temp_free(tmp);\n\n\t}\n\n\treturn;\n\n    case 0x4025:\t\t/* rotcr Rn */\n\n\t{\n\n\t    TCGv tmp = tcg_temp_new();\n\n\t    tcg_gen_mov_i32(tmp, cpu_sr);\n\n\t    gen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\t    tcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\t    gen_copy_bit_i32(REG(B11_8), 31, tmp, 0);\n\n\t    tcg_temp_free(tmp);\n\n\t}\n\n\treturn;\n\n    case 0x4004:\t\t/* rotl Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_copy_bit_i32(REG(B11_8), 0, cpu_sr, 0);\n\n\treturn;\n\n    case 0x4005:\t\t/* rotr Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\tgen_copy_bit_i32(REG(B11_8), 31, cpu_sr, 0);\n\n\treturn;\n\n    case 0x4000:\t\t/* shll Rn */\n\n    case 0x4020:\t\t/* shal Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 31);\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4021:\t\t/* shar Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_sari_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4001:\t\t/* shlr Rn */\n\n\tgen_copy_bit_i32(cpu_sr, 0, REG(B11_8), 0);\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 1);\n\n\treturn;\n\n    case 0x4008:\t\t/* shll2 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 2);\n\n\treturn;\n\n    case 0x4018:\t\t/* shll8 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 8);\n\n\treturn;\n\n    case 0x4028:\t\t/* shll16 Rn */\n\n\ttcg_gen_shli_i32(REG(B11_8), REG(B11_8), 16);\n\n\treturn;\n\n    case 0x4009:\t\t/* shlr2 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 2);\n\n\treturn;\n\n    case 0x4019:\t\t/* shlr8 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 8);\n\n\treturn;\n\n    case 0x4029:\t\t/* shlr16 Rn */\n\n\ttcg_gen_shri_i32(REG(B11_8), REG(B11_8), 16);\n\n\treturn;\n\n    case 0x401b:\t\t/* tas.b @Rn */\n\n\t{\n\n\t    TCGv addr, val;\n\n\t    addr = tcg_temp_local_new();\n\n\t    tcg_gen_mov_i32(addr, REG(B11_8));\n\n\t    val = tcg_temp_local_new();\n\n\t    tcg_gen_qemu_ld8u(val, addr, ctx->memidx);\n\n\t    gen_cmp_imm(TCG_COND_EQ, val, 0);\n\n\t    tcg_gen_ori_i32(val, val, 0x80);\n\n\t    tcg_gen_qemu_st8(val, addr, ctx->memidx);\n\n\t    tcg_temp_free(val);\n\n\t    tcg_temp_free(addr);\n\n\t}\n\n\treturn;\n\n    case 0xf00d: /* fsts FPUL,FRn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\ttcg_gen_mov_i32(cpu_fregs[FREG(B11_8)], cpu_fpul);\n\n\treturn;\n\n    case 0xf01d: /* flds FRm,FPUL - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\ttcg_gen_mov_i32(cpu_fpul, cpu_fregs[FREG(B11_8)]);\n\n\treturn;\n\n    case 0xf02d: /* float FPUL,FRn/DRn - FPSCR: R[PR,Enable.I]/W[Cause,Flag] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    TCGv_i64 fp;\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    fp = tcg_temp_new_i64();\n\n\t    gen_helper_float_DT(fp, cpu_fpul);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\telse {\n\n\t    gen_helper_float_FT(cpu_fregs[FREG(B11_8)], cpu_fpul);\n\n\t}\n\n\treturn;\n\n    case 0xf03d: /* ftrc FRm/DRm,FPUL - FPSCR: R[PR,Enable.V]/W[Cause,Flag] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    TCGv_i64 fp;\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_ftrc_DT(cpu_fpul, fp);\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\telse {\n\n\t    gen_helper_ftrc_FT(cpu_fpul, cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf04d: /* fneg FRn/DRn - FPSCR: Nothing */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    gen_helper_fneg_T(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf05d: /* fabs FRn/DRn */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_fabs_DT(fp, fp);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t} else {\n\n\t    gen_helper_fabs_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf06d: /* fsqrt FRn */\n\n\tCHECK_FPU_ENABLED\n\n\tif (ctx->fpscr & FPSCR_PR) {\n\n\t    if (ctx->opcode & 0x0100)\n\n\t\tbreak; /* illegal instruction */\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_fsqrt_DT(fp, fp);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t} else {\n\n\t    gen_helper_fsqrt_FT(cpu_fregs[FREG(B11_8)], cpu_fregs[FREG(B11_8)]);\n\n\t}\n\n\treturn;\n\n    case 0xf07d: /* fsrra FRn */\n\n\tCHECK_FPU_ENABLED\n\n\tbreak;\n\n    case 0xf08d: /* fldi0 FRn - FPSCR: R[PR] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (!(ctx->fpscr & FPSCR_PR)) {\n\n\t    tcg_gen_movi_i32(cpu_fregs[FREG(B11_8)], 0);\n\n\t}\n\n\treturn;\n\n    case 0xf09d: /* fldi1 FRn - FPSCR: R[PR] */\n\n\tCHECK_FPU_ENABLED\n\n\tif (!(ctx->fpscr & FPSCR_PR)) {\n\n\t    tcg_gen_movi_i32(cpu_fregs[FREG(B11_8)], 0x3f800000);\n\n\t}\n\n\treturn;\n\n    case 0xf0ad: /* fcnvsd FPUL,DRn */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_helper_fcnvsd_FT_DT(fp, cpu_fpul);\n\n\t    gen_store_fpr64(fp, DREG(B11_8));\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\treturn;\n\n    case 0xf0bd: /* fcnvds DRn,FPUL */\n\n\tCHECK_FPU_ENABLED\n\n\t{\n\n\t    TCGv_i64 fp = tcg_temp_new_i64();\n\n\t    gen_load_fpr64(fp, DREG(B11_8));\n\n\t    gen_helper_fcnvds_DT_FT(cpu_fpul, fp);\n\n\t    tcg_temp_free_i64(fp);\n\n\t}\n\n\treturn;\n\n    }\n\n#if 0\n\n    fprintf(stderr, \"unknown instruction 0x%04x at pc 0x%08x\\n\",\n\n\t    ctx->opcode, ctx->pc);\n\n    fflush(stderr);\n\n#endif\n\n    gen_helper_raise_illegal_instruction();\n\n    ctx->bstate = BS_EXCP;\n\n}\n", "idx": 20467}, {"project": "test", "commit_id": "test", "target": 1, "func": "void wm8750_set_bclk_in(void *opaque, int hz)\n\n{\n\n    struct wm8750_s *s = (struct wm8750_s *) opaque;\n\n\n\n    s->ext_adc_hz = hz;\n\n    s->ext_dac_hz = hz;\n\n    wm8750_clk_update(s, 1);\n\n}\n", "idx": 20471}, {"project": "test", "commit_id": "test", "target": 1, "func": "IEEE_ARITH2(sqrtt)\n\nIEEE_ARITH2(cvtst)\n\nIEEE_ARITH2(cvtts)\n\n\n\nstatic void gen_cvttq(DisasContext *ctx, int rb, int rc, int fn11)\n\n{\n\n    TCGv vb, vc;\n\n\n\n    /* No need to set flushzero, since we have an integer output.  */\n\n    vb = gen_ieee_input(ctx, rb, fn11, 0);\n\n    vc = dest_fpr(ctx, rc);\n\n\n\n    /* Almost all integer conversions use cropped rounding, and most\n\n       also do not have integer overflow enabled.  Special case that.  */\n\n    switch (fn11) {\n\n    case QUAL_RM_C:\n\n        gen_helper_cvttq_c(vc, cpu_env, vb);\n\n        break;\n\n    case QUAL_V | QUAL_RM_C:\n\n    case QUAL_S | QUAL_V | QUAL_RM_C:\n\n    case QUAL_S | QUAL_V | QUAL_I | QUAL_RM_C:\n\n        gen_helper_cvttq_svic(vc, cpu_env, vb);\n\n        break;\n\n    default:\n\n        gen_qual_roundmode(ctx, fn11);\n\n        gen_helper_cvttq(vc, cpu_env, vb);\n\n        break;\n\n    }\n\n\n\n    gen_fp_exc_raise(rc, fn11);\n\n}\n", "idx": 20631}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int virtio_serial_device_exit(DeviceState *dev)\n\n{\n\n    VirtIOSerial *vser = VIRTIO_SERIAL(dev);\n\n    VirtIODevice *vdev = VIRTIO_DEVICE(dev);\n\n\n\n    unregister_savevm(dev, \"virtio-console\", vser);\n\n\n\n    g_free(vser->ivqs);\n\n    g_free(vser->ovqs);\n\n    g_free(vser->ports_map);\n\n    if (vser->post_load) {\n\n        g_free(vser->post_load->connected);\n\n        timer_del(vser->post_load->timer);\n\n        timer_free(vser->post_load->timer);\n\n        g_free(vser->post_load);\n\n    }\n\n    virtio_cleanup(vdev);\n\n    return 0;\n\n}\n", "idx": 20643}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void virtio_queue_notify_vq(VirtQueue *vq)\n{\n    if (vq->vring.desc && vq->handle_output) {\n        VirtIODevice *vdev = vq->vdev;\n        trace_virtio_queue_notify(vdev, vq - vdev->vq, vq);\n        vq->handle_output(vdev, vq);", "idx": 20647}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void hScale_altivec_real(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc, int16_t *filter, int16_t *filterPos, int filterSize) {\n\n  register int i;\n\n  int __attribute__ ((aligned (16))) tempo[4];\n\n\n\n  if (filterSize % 4) {\n\n    for(i=0; i<dstW; i++) {\n\n      register int j;\n\n      register int srcPos = filterPos[i];\n\n      register int val = 0;\n\n      for(j=0; j<filterSize; j++) {\n\n\tval += ((int)src[srcPos + j])*filter[filterSize*i + j];\n\n      }\n\n      dst[i] = av_clip(val>>7, 0, (1<<15)-1);\n\n    }\n\n  }\n\n  else\n\n  switch (filterSize) {\n\n  case 4:\n\n    {\n\n      for(i=0; i<dstW; i++) {\n\n\tregister int srcPos = filterPos[i];\n\n\n\n\tvector unsigned char src_v0 = vec_ld(srcPos, src);\n\n\tvector unsigned char src_v1, src_vF;\n\n\tvector signed short src_v, filter_v;\n\n\tvector signed int val_vEven, val_s;\n\n\tif ((((int)src + srcPos)% 16) > 12) {\n\n\t  src_v1 = vec_ld(srcPos + 16, src);\n\n\t}\n\n\tsrc_vF = vec_perm(src_v0, src_v1, vec_lvsl(srcPos, src));\n\n\n\n\tsrc_v = // vec_unpackh sign-extends...\n\n\t  (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n\t// now put our elements in the even slots\n\n\tsrc_v = vec_mergeh(src_v, (vector signed short)vzero);\n\n\n\n\tfilter_v = vec_ld(i << 3, filter);\n\n        // the 3 above is 2 (filterSize == 4) + 1 (sizeof(short) == 2)\n\n\n\n        // the neat trick : we only care for half the elements,\n\n        // high or low depending on (i<<3)%16 (it's 0 or 8 here),\n\n        // and we're going to use vec_mule, so we chose\n\n        // carefully how to \"unpack\" the elements into the even slots\n\n\tif ((i << 3) % 16)\n\n\t  filter_v = vec_mergel(filter_v,(vector signed short)vzero);\n\n\telse\n\n\t  filter_v = vec_mergeh(filter_v,(vector signed short)vzero);\n\n\n\n\tval_vEven = vec_mule(src_v, filter_v);\n\n\tval_s = vec_sums(val_vEven, vzero);\n\n\tvec_st(val_s, 0, tempo);\n\n\tdst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);\n\n      }\n\n    }\n\n    break;\n\n\n\n  case 8:\n\n    {\n\n      for(i=0; i<dstW; i++) {\n\n\tregister int srcPos = filterPos[i];\n\n\n\n\tvector unsigned char src_v0 = vec_ld(srcPos, src);\n\n\tvector unsigned char src_v1, src_vF;\n\n\tvector signed short src_v, filter_v;\n\n\tvector signed int val_v, val_s;\n\n\tif ((((int)src + srcPos)% 16) > 8) {\n\n\t  src_v1 = vec_ld(srcPos + 16, src);\n\n\t}\n\n\tsrc_vF = vec_perm(src_v0, src_v1, vec_lvsl(srcPos, src));\n\n\n\n\tsrc_v = // vec_unpackh sign-extends...\n\n\t  (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n\tfilter_v = vec_ld(i << 4, filter);\n\n        // the 4 above is 3 (filterSize == 8) + 1 (sizeof(short) == 2)\n\n\n\n\tval_v = vec_msums(src_v, filter_v, (vector signed int)vzero);\n\n\tval_s = vec_sums(val_v, vzero);\n\n\tvec_st(val_s, 0, tempo);\n\n\tdst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);\n\n      }\n\n    }\n\n    break;\n\n\n\n  case 16:\n\n    {\n\n      for(i=0; i<dstW; i++) {\n\n\tregister int srcPos = filterPos[i];\n\n\n\n\tvector unsigned char src_v0 = vec_ld(srcPos, src);\n\n\tvector unsigned char src_v1 = vec_ld(srcPos + 16, src);\n\n\tvector unsigned char src_vF = vec_perm(src_v0, src_v1, vec_lvsl(srcPos, src));\n\n\n\n\tvector signed short src_vA = // vec_unpackh sign-extends...\n\n\t  (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n\tvector signed short src_vB = // vec_unpackh sign-extends...\n\n\t  (vector signed short)(vec_mergel((vector unsigned char)vzero, src_vF));\n\n\n\n\tvector signed short filter_v0 = vec_ld(i << 5, filter);\n\n       \tvector signed short filter_v1 = vec_ld((i << 5) + 16, filter);\n\n        // the 5 above are 4 (filterSize == 16) + 1 (sizeof(short) == 2)\n\n\n\n\tvector signed int val_acc = vec_msums(src_vA, filter_v0, (vector signed int)vzero);\n\n\tvector signed int val_v = vec_msums(src_vB, filter_v1, val_acc);\n\n\n\n\tvector signed int val_s = vec_sums(val_v, vzero);\n\n\n\n\tvec_st(val_s, 0, tempo);\n\n\tdst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);\n\n      }\n\n    }\n\n    break;\n\n\n\n  default:\n\n    {\n\n      for(i=0; i<dstW; i++) {\n\n\tregister int j;\n\n\tregister int srcPos = filterPos[i];\n\n\n\n        vector signed int val_s, val_v = (vector signed int)vzero;\n\n\tvector signed short filter_v0R = vec_ld(i * 2 * filterSize, filter);\n\n        vector unsigned char permF = vec_lvsl((i * 2 * filterSize), filter);\n\n\n\n        vector unsigned char src_v0 = vec_ld(srcPos, src);\n\n        vector unsigned char permS = vec_lvsl(srcPos, src);\n\n\n\n        for (j = 0 ; j < filterSize - 15; j += 16) {\n\n          vector unsigned char src_v1 = vec_ld(srcPos + j + 16, src);\n\n          vector unsigned char src_vF = vec_perm(src_v0, src_v1, permS);\n\n\n\n          vector signed short src_vA = // vec_unpackh sign-extends...\n\n            (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n          vector signed short src_vB = // vec_unpackh sign-extends...\n\n            (vector signed short)(vec_mergel((vector unsigned char)vzero, src_vF));\n\n\n\n          vector signed short filter_v1R = vec_ld((i * 2 * filterSize) + (j * 2) + 16, filter);\n\n          vector signed short filter_v2R = vec_ld((i * 2 * filterSize) + (j * 2) + 32, filter);\n\n          vector signed short filter_v0 = vec_perm(filter_v0R, filter_v1R, permF);\n\n          vector signed short filter_v1 = vec_perm(filter_v1R, filter_v2R, permF);\n\n\n\n          vector signed int val_acc = vec_msums(src_vA, filter_v0, val_v);\n\n          val_v = vec_msums(src_vB, filter_v1, val_acc);\n\n\n\n          filter_v0R = filter_v2R;\n\n          src_v0 = src_v1;\n\n        }\n\n\n\n        if (j < (filterSize-7)) {\n\n          // loading src_v0 is useless, it's already done above\n\n          //vector unsigned char src_v0 = vec_ld(srcPos + j, src);\n\n          vector unsigned char src_v1, src_vF;\n\n          vector signed short src_v, filter_v1R, filter_v;\n\n          if ((((int)src + srcPos)% 16) > 8) {\n\n            src_v1 = vec_ld(srcPos + j + 16, src);\n\n          }\n\n          src_vF = vec_perm(src_v0, src_v1, permS);\n\n\n\n          src_v = // vec_unpackh sign-extends...\n\n            (vector signed short)(vec_mergeh((vector unsigned char)vzero, src_vF));\n\n          // loading filter_v0R is useless, it's already done above\n\n          //vector signed short filter_v0R = vec_ld((i * 2 * filterSize) + j, filter);\n\n          filter_v1R = vec_ld((i * 2 * filterSize) + (j * 2) + 16, filter);\n\n          filter_v = vec_perm(filter_v0R, filter_v1R, permF);\n\n\n\n          val_v = vec_msums(src_v, filter_v, val_v);\n\n        }\n\n\n\n        val_s = vec_sums(val_v, vzero);\n\n\n\n        vec_st(val_s, 0, tempo);\n\n        dst[i] = av_clip(tempo[3]>>7, 0, (1<<15)-1);\n\n      }\n\n\n\n    }\n\n  }\n\n}\n", "idx": 20698}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void property_get_enum(Object *obj, Visitor *v, void *opaque,\n\n                              const char *name, Error **errp)\n\n{\n\n    EnumProperty *prop = opaque;\n\n    int value;\n\n\n\n    value = prop->get(obj, errp);\n\n    visit_type_enum(v, &value, prop->strings, NULL, name, errp);\n\n}\n", "idx": 20722}, {"project": "test", "commit_id": "test", "target": 1, "func": "CharDriverState *qemu_chr_alloc(void)\n\n{\n\n    CharDriverState *chr = g_malloc0(sizeof(CharDriverState));\n\n\n    return chr;\n\n}", "idx": 20761}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void ecc_init(target_phys_addr_t base, qemu_irq irq, uint32_t version)\n\n{\n\n    DeviceState *dev;\n\n    SysBusDevice *s;\n\n\n\n    dev = qdev_create(NULL, \"eccmemctl\");\n\n    qdev_prop_set_uint32(dev, \"version\", version);\n\n    qdev_init(dev);\n\n    s = sysbus_from_qdev(dev);\n\n    sysbus_connect_irq(s, 0, irq);\n\n    sysbus_mmio_map(s, 0, base);\n\n    if (version == 0) { // SS-600MP only\n\n        sysbus_mmio_map(s, 1, base + 0x1000);\n\n    }\n\n}\n", "idx": 20766}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void test_tco1_status_bits(void)\n\n{\n\n    TestData d;\n\n    uint16_t ticks = 8;\n\n    uint16_t val;\n\n    int ret;\n\n\n\n    d.args = NULL;\n\n    d.noreboot = true;\n\n    test_init(&d);\n\n\n\n    stop_tco(&d);\n\n    clear_tco_status(&d);\n\n    reset_on_second_timeout(false);\n\n    set_tco_timeout(&d, ticks);\n\n    load_tco(&d);\n\n    start_tco(&d);\n\n    clock_step(ticks * TCO_TICK_NSEC);\n\n\n\n    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_IN, 0);\n\n    qpci_io_writeb(d.dev, d.tco_io_base + TCO_DAT_OUT, 0);\n\n    val = qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS);\n\n    ret = val & (TCO_TIMEOUT | SW_TCO_SMI | TCO_INT_STS) ? 1 : 0;\n\n    g_assert(ret == 1);\n\n    qpci_io_writew(d.dev, d.tco_io_base + TCO1_STS, val);\n\n    g_assert_cmpint(qpci_io_readw(d.dev, d.tco_io_base + TCO1_STS), ==, 0);\n\n    qtest_end();\n\n}\n", "idx": 20835}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int iff_read_header(AVFormatContext *s)\n\n{\n\n    IffDemuxContext *iff = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st;\n\n    uint8_t *buf;\n\n    uint32_t chunk_id, data_size;\n\n    uint32_t screenmode = 0, num, den;\n\n    unsigned transparency = 0;\n\n    unsigned masking = 0; // no mask\n\n    uint8_t fmt[16];\n\n    int fmt_size;\n\n\n\n    st = avformat_new_stream(s, NULL);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    st->codec->channels = 1;\n\n    st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n\n    avio_skip(pb, 8);\n\n    // codec_tag used by ByteRun1 decoder to distinguish progressive (PBM) and interlaced (ILBM) content\n\n    st->codec->codec_tag = avio_rl32(pb);\n\n    iff->bitmap_compression = -1;\n\n    iff->svx8_compression = -1;\n\n    iff->maud_bits = -1;\n\n    iff->maud_compression = -1;\n\n\n\n    while(!url_feof(pb)) {\n\n        uint64_t orig_pos;\n\n        int res;\n\n        const char *metadata_tag = NULL;\n\n        chunk_id = avio_rl32(pb);\n\n        data_size = avio_rb32(pb);\n\n        orig_pos = avio_tell(pb);\n\n\n\n        switch(chunk_id) {\n\n        case ID_VHDR:\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n\n\n            if (data_size < 14)\n\n                return AVERROR_INVALIDDATA;\n\n            avio_skip(pb, 12);\n\n            st->codec->sample_rate = avio_rb16(pb);\n\n            if (data_size >= 16) {\n\n                avio_skip(pb, 1);\n\n                iff->svx8_compression = avio_r8(pb);\n\n            }\n\n            break;\n\n\n\n        case ID_MHDR:\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n\n\n            if (data_size < 32)\n\n                return AVERROR_INVALIDDATA;\n\n            avio_skip(pb, 4);\n\n            iff->maud_bits = avio_rb16(pb);\n\n            avio_skip(pb, 2);\n\n            num = avio_rb32(pb);\n\n            den = avio_rb16(pb);\n\n            if (!den)\n\n                return AVERROR_INVALIDDATA;\n\n            avio_skip(pb, 2);\n\n            st->codec->sample_rate = num / den;\n\n            st->codec->channels = avio_rb16(pb);\n\n            iff->maud_compression = avio_rb16(pb);\n\n            if (st->codec->channels == 1)\n\n                st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n\n            else if (st->codec->channels == 2)\n\n                st->codec->channel_layout = AV_CH_LAYOUT_STEREO;\n\n            break;\n\n\n\n        case ID_ABIT:\n\n        case ID_BODY:\n\n        case ID_DBOD:\n\n        case ID_MDAT:\n\n            iff->body_pos = avio_tell(pb);\n\n            iff->body_end = iff->body_pos + data_size;\n\n            iff->body_size = data_size;\n\n            break;\n\n\n\n        case ID_CHAN:\n\n            if (data_size < 4)\n\n                return AVERROR_INVALIDDATA;\n\n            if (avio_rb32(pb) < 6) {\n\n                st->codec->channels       = 1;\n\n                st->codec->channel_layout = AV_CH_LAYOUT_MONO;\n\n            } else {\n\n                st->codec->channels       = 2;\n\n                st->codec->channel_layout = AV_CH_LAYOUT_STEREO;\n\n            }\n\n            break;\n\n\n\n        case ID_CAMG:\n\n            if (data_size < 4)\n\n                return AVERROR_INVALIDDATA;\n\n            screenmode                = avio_rb32(pb);\n\n            break;\n\n\n\n        case ID_CMAP:\n\n            if (data_size > INT_MAX - IFF_EXTRA_VIDEO_SIZE - FF_INPUT_BUFFER_PADDING_SIZE)\n\n                return AVERROR_INVALIDDATA;\n\n            st->codec->extradata_size = data_size + IFF_EXTRA_VIDEO_SIZE;\n\n            st->codec->extradata      = av_malloc(data_size + IFF_EXTRA_VIDEO_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if (!st->codec->extradata)\n\n                return AVERROR(ENOMEM);\n\n            if (avio_read(pb, st->codec->extradata + IFF_EXTRA_VIDEO_SIZE, data_size) < 0)\n\n                return AVERROR(EIO);\n\n            break;\n\n\n\n        case ID_BMHD:\n\n            st->codec->codec_type            = AVMEDIA_TYPE_VIDEO;\n\n            if (data_size <= 8)\n\n                return AVERROR_INVALIDDATA;\n\n            st->codec->width                 = avio_rb16(pb);\n\n            st->codec->height                = avio_rb16(pb);\n\n            avio_skip(pb, 4); // x, y offset\n\n            st->codec->bits_per_coded_sample = avio_r8(pb);\n\n            if (data_size >= 10)\n\n                masking                      = avio_r8(pb);\n\n            if (data_size >= 11)\n\n                iff->bitmap_compression      = avio_r8(pb);\n\n            if (data_size >= 14) {\n\n                avio_skip(pb, 1); // padding\n\n                transparency                 = avio_rb16(pb);\n\n            }\n\n            if (data_size >= 16) {\n\n                st->sample_aspect_ratio.num  = avio_r8(pb);\n\n                st->sample_aspect_ratio.den  = avio_r8(pb);\n\n            }\n\n            break;\n\n\n\n        case ID_DPEL:\n\n            if (data_size < 4 || (data_size & 3))\n\n                return AVERROR_INVALIDDATA;\n\n            if ((fmt_size = avio_read(pb, fmt, sizeof(fmt))) < 0)\n\n                return fmt_size;\n\n            if (fmt_size == sizeof(deep_rgb24) && !memcmp(fmt, deep_rgb24, sizeof(deep_rgb24)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_RGB24;\n\n            else if (fmt_size == sizeof(deep_rgba) && !memcmp(fmt, deep_rgba, sizeof(deep_rgba)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_RGBA;\n\n            else if (fmt_size == sizeof(deep_bgra) && !memcmp(fmt, deep_bgra, sizeof(deep_bgra)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_BGRA;\n\n            else if (fmt_size == sizeof(deep_argb) && !memcmp(fmt, deep_argb, sizeof(deep_argb)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_ARGB;\n\n            else if (fmt_size == sizeof(deep_abgr) && !memcmp(fmt, deep_abgr, sizeof(deep_abgr)))\n\n                st->codec->pix_fmt = AV_PIX_FMT_ABGR;\n\n            else {\n\n                av_log_ask_for_sample(s, \"unsupported color format\\n\");\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n            break;\n\n\n\n        case ID_DGBL:\n\n            st->codec->codec_type            = AVMEDIA_TYPE_VIDEO;\n\n            if (data_size < 8)\n\n                return AVERROR_INVALIDDATA;\n\n            st->codec->width                 = avio_rb16(pb);\n\n            st->codec->height                = avio_rb16(pb);\n\n            iff->bitmap_compression          = avio_rb16(pb);\n\n            st->sample_aspect_ratio.num      = avio_r8(pb);\n\n            st->sample_aspect_ratio.den      = avio_r8(pb);\n\n            st->codec->bits_per_coded_sample = 24;\n\n            break;\n\n\n\n        case ID_DLOC:\n\n            if (data_size < 4)\n\n                return AVERROR_INVALIDDATA;\n\n            st->codec->width  = avio_rb16(pb);\n\n            st->codec->height = avio_rb16(pb);\n\n            break;\n\n\n\n        case ID_TVDC:\n\n            if (data_size < sizeof(iff->tvdc))\n\n                return AVERROR_INVALIDDATA;\n\n            res = avio_read(pb, iff->tvdc, sizeof(iff->tvdc));\n\n            if (res < 0)\n\n                return res;\n\n            break;\n\n\n\n        case ID_ANNO:\n\n        case ID_TEXT:      metadata_tag = \"comment\";   break;\n\n        case ID_AUTH:      metadata_tag = \"artist\";    break;\n\n        case ID_COPYRIGHT: metadata_tag = \"copyright\"; break;\n\n        case ID_NAME:      metadata_tag = \"title\";     break;\n\n        }\n\n\n\n        if (metadata_tag) {\n\n            if ((res = get_metadata(s, metadata_tag, data_size)) < 0) {\n\n                av_log(s, AV_LOG_ERROR, \"cannot allocate metadata tag %s!\\n\", metadata_tag);\n\n                return res;\n\n            }\n\n        }\n\n        avio_skip(pb, data_size - (avio_tell(pb) - orig_pos) + (data_size & 1));\n\n    }\n\n\n\n    avio_seek(pb, iff->body_pos, SEEK_SET);\n\n\n\n    switch(st->codec->codec_type) {\n\n    case AVMEDIA_TYPE_AUDIO:\n\n        avpriv_set_pts_info(st, 32, 1, st->codec->sample_rate);\n\n\n\n        if (st->codec->codec_tag == ID_16SV)\n\n            st->codec->codec_id = AV_CODEC_ID_PCM_S16BE_PLANAR;\n\n        else if (st->codec->codec_tag == ID_MAUD) {\n\n            if (iff->maud_bits == 8 && !iff->maud_compression) {\n\n                st->codec->codec_id = AV_CODEC_ID_PCM_U8;\n\n            } else if (iff->maud_bits == 16 && !iff->maud_compression) {\n\n                st->codec->codec_id = AV_CODEC_ID_PCM_S16BE;\n\n            } else if (iff->maud_bits ==  8 && iff->maud_compression == 2) {\n\n                st->codec->codec_id = AV_CODEC_ID_PCM_ALAW;\n\n            } else if (iff->maud_bits ==  8 && iff->maud_compression == 3) {\n\n                st->codec->codec_id = AV_CODEC_ID_PCM_MULAW;\n\n            } else {\n\n                av_log_ask_for_sample(s, \"unsupported compression %d and bit depth %d\\n\", iff->maud_compression, iff->maud_bits);\n\n                return AVERROR_PATCHWELCOME;\n\n            }\n\n\n\n            st->codec->bits_per_coded_sample =\n\n                av_get_bits_per_sample(st->codec->codec_id);\n\n\n\n            st->codec->block_align =\n\n                st->codec->bits_per_coded_sample * st->codec->channels / 8;\n\n        } else {\n\n        switch (iff->svx8_compression) {\n\n        case COMP_NONE:\n\n            st->codec->codec_id = AV_CODEC_ID_PCM_S8_PLANAR;\n\n            break;\n\n        case COMP_FIB:\n\n            st->codec->codec_id = AV_CODEC_ID_8SVX_FIB;\n\n            break;\n\n        case COMP_EXP:\n\n            st->codec->codec_id = AV_CODEC_ID_8SVX_EXP;\n\n            break;\n\n        default:\n\n            av_log(s, AV_LOG_ERROR,\n\n                   \"Unknown SVX8 compression method '%d'\\n\", iff->svx8_compression);\n\n            return -1;\n\n        }\n\n        }\n\n\n\n        st->codec->bits_per_coded_sample = av_get_bits_per_sample(st->codec->codec_id);\n\n        st->codec->bit_rate = st->codec->channels * st->codec->sample_rate * st->codec->bits_per_coded_sample;\n\n        st->codec->block_align = st->codec->channels * st->codec->bits_per_coded_sample;\n\n        break;\n\n\n\n    case AVMEDIA_TYPE_VIDEO:\n\n        iff->bpp          = st->codec->bits_per_coded_sample;\n\n        if ((screenmode & 0x800 /* Hold And Modify */) && iff->bpp <= 8) {\n\n            iff->ham      = iff->bpp > 6 ? 6 : 4;\n\n            st->codec->bits_per_coded_sample = 24;\n\n        }\n\n        iff->flags        = (screenmode & 0x80 /* Extra HalfBrite */) && iff->bpp <= 8;\n\n        iff->masking      = masking;\n\n        iff->transparency = transparency;\n\n\n\n        if (!st->codec->extradata) {\n\n            st->codec->extradata_size = IFF_EXTRA_VIDEO_SIZE;\n\n            st->codec->extradata      = av_malloc(IFF_EXTRA_VIDEO_SIZE + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if (!st->codec->extradata)\n\n                return AVERROR(ENOMEM);\n\n        }\n\n\n        buf = st->codec->extradata;\n\n        bytestream_put_be16(&buf, IFF_EXTRA_VIDEO_SIZE);\n\n        bytestream_put_byte(&buf, iff->bitmap_compression);\n\n        bytestream_put_byte(&buf, iff->bpp);\n\n        bytestream_put_byte(&buf, iff->ham);\n\n        bytestream_put_byte(&buf, iff->flags);\n\n        bytestream_put_be16(&buf, iff->transparency);\n\n        bytestream_put_byte(&buf, iff->masking);\n\n        bytestream_put_buffer(&buf, iff->tvdc, sizeof(iff->tvdc));\n\n        st->codec->codec_id = AV_CODEC_ID_IFF_ILBM;\n\n        break;\n\n    default:\n\n        return -1;\n\n    }\n\n\n\n    return 0;\n\n}", "idx": 20917}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void save_bits(WMAProDecodeCtx *s, GetBitContext* gb, int len,\n                      int append)\n{\n    int buflen;\n    /** when the frame data does not need to be concatenated, the input buffer\n        is resetted and additional bits from the previous frame are copyed\n        and skipped later so that a fast byte copy is possible */\n    if (!append) {\n        s->frame_offset = get_bits_count(gb) & 7;\n        s->num_saved_bits = s->frame_offset;\n        init_put_bits(&s->pb, s->frame_data, MAX_FRAMESIZE);\n    buflen = (s->num_saved_bits + len + 8) >> 3;\n    if (len <= 0 || buflen > MAX_FRAMESIZE) {\n        avpriv_request_sample(s->avctx, \"Too small input buffer\");\n    s->num_saved_bits += len;\n    if (!append) {\n        avpriv_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3),\n                     s->num_saved_bits);\n    } else {\n        int align = 8 - (get_bits_count(gb) & 7);\n        align = FFMIN(align, len);\n        put_bits(&s->pb, align, get_bits(gb, align));\n        len -= align;\n        avpriv_copy_bits(&s->pb, gb->buffer + (get_bits_count(gb) >> 3), len);\n    skip_bits_long(gb, len);\n    {\n        PutBitContext tmp = s->pb;\n        flush_put_bits(&tmp);\n    init_get_bits(&s->gb, s->frame_data, s->num_saved_bits);\n    skip_bits(&s->gb, s->frame_offset);", "idx": 21007}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int read_interval_packets(WriterContext *w, AVFormatContext *fmt_ctx,\n\n                                 const ReadInterval *interval, int64_t *cur_ts)\n\n{\n\n    AVPacket pkt, pkt1;\n\n    AVFrame *frame = NULL;\n\n    int ret = 0, i = 0, frame_count = 0;\n\n    int64_t start = -INT64_MAX, end = interval->end;\n\n    int has_start = 0, has_end = interval->has_end && !interval->end_is_offset;\n\n\n\n    av_init_packet(&pkt);\n\n\n\n    av_log(NULL, AV_LOG_VERBOSE, \"Processing read interval \");\n\n    log_read_interval(interval, NULL, AV_LOG_VERBOSE);\n\n\n\n    if (interval->has_start) {\n\n        int64_t target;\n\n        if (interval->start_is_offset) {\n\n            if (*cur_ts == AV_NOPTS_VALUE) {\n\n                av_log(NULL, AV_LOG_ERROR,\n\n                       \"Could not seek to relative position since current \"\n\n                       \"timestamp is not defined\\n\");\n\n                ret = AVERROR(EINVAL);\n\n\n\n            target = *cur_ts + interval->start;\n\n        } else {\n\n            target = interval->start;\n\n\n\n\n        av_log(NULL, AV_LOG_VERBOSE, \"Seeking to read interval start point %s\\n\",\n\n               av_ts2timestr(target, &AV_TIME_BASE_Q));\n\n        if ((ret = avformat_seek_file(fmt_ctx, -1, -INT64_MAX, target, INT64_MAX, 0)) < 0) {\n\n            av_log(NULL, AV_LOG_ERROR, \"Could not seek to position %\"PRId64\": %s\\n\",\n\n                   interval->start, av_err2str(ret));\n\n\n\n\n\n\n    frame = av_frame_alloc();\n\n\n\n\n\n    while (!av_read_frame(fmt_ctx, &pkt)) {\n\n        if (selected_streams[pkt.stream_index]) {\n\n            AVRational tb = fmt_ctx->streams[pkt.stream_index]->time_base;\n\n\n\n            if (pkt.pts != AV_NOPTS_VALUE)\n\n                *cur_ts = av_rescale_q(pkt.pts, tb, AV_TIME_BASE_Q);\n\n\n\n            if (!has_start && *cur_ts != AV_NOPTS_VALUE) {\n\n                start = *cur_ts;\n\n                has_start = 1;\n\n\n\n\n            if (has_start && !has_end && interval->end_is_offset) {\n\n                end = start + interval->end;\n\n                has_end = 1;\n\n\n\n\n            if (interval->end_is_offset && interval->duration_frames) {\n\n                if (frame_count >= interval->end)\n\n                    break;\n\n            } else if (has_end && *cur_ts != AV_NOPTS_VALUE && *cur_ts >= end) {\n\n                break;\n\n\n\n\n            frame_count++;\n\n            if (do_read_packets) {\n\n                if (do_show_packets)\n\n                    show_packet(w, fmt_ctx, &pkt, i++);\n\n                nb_streams_packets[pkt.stream_index]++;\n\n\n            if (do_read_frames) {\n\n                pkt1 = pkt;\n\n                while (pkt1.size && process_frame(w, fmt_ctx, frame, &pkt1) > 0);\n\n\n\n        av_free_packet(&pkt);\n\n\n    av_init_packet(&pkt);\n\n    pkt.data = NULL;\n\n    pkt.size = 0;\n\n    //Flush remaining frames that are cached in the decoder\n\n    for (i = 0; i < fmt_ctx->nb_streams; i++) {\n\n        pkt.stream_index = i;\n\n        if (do_read_frames)\n\n            while (process_frame(w, fmt_ctx, frame, &pkt) > 0);\n\n\n\n\nend:\n\n    av_frame_free(&frame);\n\n    if (ret < 0) {\n\n        av_log(NULL, AV_LOG_ERROR, \"Could not read packets in interval \");\n\n        log_read_interval(interval, NULL, AV_LOG_ERROR);\n\n\n    return ret;\n", "idx": 21012}, {"project": "test", "commit_id": "test", "target": 1, "func": "void palette8tobgr16(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette)\n\n{\n\n\tlong i;\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t\t((uint16_t *)dst)[i] = bswap_16(((uint16_t *)palette)[ src[i] ]);\n\n}\n", "idx": 21118}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int read_gab2_sub(AVStream *st, AVPacket *pkt) {\n\n    if (!strcmp(pkt->data, \"GAB2\") && AV_RL16(pkt->data+5) == 2) {\n\n        uint8_t desc[256];\n\n        int score = AVPROBE_SCORE_MAX / 2, ret;\n\n        AVIStream *ast = st->priv_data;\n\n        AVInputFormat *sub_demuxer;\n\n        AVRational time_base;\n\n        AVIOContext *pb = avio_alloc_context( pkt->data + 7,\n\n                                              pkt->size - 7,\n\n                                              0, NULL, NULL, NULL, NULL);\n\n        AVProbeData pd;\n\n        unsigned int desc_len = avio_rl32(pb);\n\n\n\n        if (desc_len > pb->buf_end - pb->buf_ptr)\n\n            goto error;\n\n\n\n        ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc));\n\n        avio_skip(pb, desc_len - ret);\n\n        if (*desc)\n\n            av_dict_set(&st->metadata, \"title\", desc, 0);\n\n\n\n        avio_rl16(pb);   /* flags? */\n\n        avio_rl32(pb);   /* data size */\n\n\n\n        pd = (AVProbeData) { .buf = pb->buf_ptr, .buf_size = pb->buf_end - pb->buf_ptr };\n\n        if (!(sub_demuxer = av_probe_input_format2(&pd, 1, &score)))\n\n            goto error;\n\n\n\n        if (!(ast->sub_ctx = avformat_alloc_context()))\n\n            goto error;\n\n\n\n        ast->sub_ctx->pb      = pb;\n\n        if (!avformat_open_input(&ast->sub_ctx, \"\", sub_demuxer, NULL)) {\n\n            ff_read_packet(ast->sub_ctx, &ast->sub_pkt);\n\n            *st->codec = *ast->sub_ctx->streams[0]->codec;\n\n            ast->sub_ctx->streams[0]->codec->extradata = NULL;\n\n            time_base = ast->sub_ctx->streams[0]->time_base;\n\n            avpriv_set_pts_info(st, 64, time_base.num, time_base.den);\n\n        }\n\n        ast->sub_buffer = pkt->data;\n\n        memset(pkt, 0, sizeof(*pkt));\n\n        return 1;\n\nerror:\n\n        av_freep(&pb);\n\n    }\n\n    return 0;\n\n}\n", "idx": 21155}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int decode_copy(uint8_t *frame, int width, int height,\n\n                       const uint8_t *src, const uint8_t *src_end)\n\n{\n\n    const int size = width * height;\n\n\n\n    if (src_end - src < size)\n\n        return -1;\n\n    bytestream_get_buffer(&src, frame, size);\n\n    return 0;\n\n}\n", "idx": 21284}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void mpegvideo_extract_headers(AVCodecParserContext *s,\n\n                                      AVCodecContext *avctx,\n\n                                      const uint8_t *buf, int buf_size)\n\n{\n\n    ParseContext1 *pc = s->priv_data;\n\n    const uint8_t *buf_end;\n\n\n    uint32_t start_code;\n\n    int frame_rate_index, ext_type, bytes_left;\n\n    int frame_rate_ext_n, frame_rate_ext_d;\n\n    int picture_structure, top_field_first, repeat_first_field, progressive_frame;\n\n    int horiz_size_ext, vert_size_ext, bit_rate_ext;\n\n//FIXME replace the crap with get_bits()\n\n    s->repeat_pict = 0;\n\n    buf_end = buf + buf_size;\n\n    while (buf < buf_end) {\n\n        start_code= -1;\n\n        buf= ff_find_start_code(buf, buf_end, &start_code);\n\n        bytes_left = buf_end - buf;\n\n        switch(start_code) {\n\n        case PICTURE_START_CODE:\n\n            ff_fetch_timestamp(s, buf-buf_start-4, 1);\n\n\n\n            if (bytes_left >= 2) {\n\n                s->pict_type = (buf[1] >> 3) & 7;\n\n            }\n\n            break;\n\n        case SEQ_START_CODE:\n\n            if (bytes_left >= 7) {\n\n                pc->width  = (buf[0] << 4) | (buf[1] >> 4);\n\n                pc->height = ((buf[1] & 0x0f) << 8) | buf[2];\n\n                avcodec_set_dimensions(avctx, pc->width, pc->height);\n\n                frame_rate_index = buf[3] & 0xf;\n\n                pc->frame_rate.den = avctx->time_base.den = ff_frame_rate_tab[frame_rate_index].num;\n\n                pc->frame_rate.num = avctx->time_base.num = ff_frame_rate_tab[frame_rate_index].den;\n\n                avctx->bit_rate = ((buf[4]<<10) | (buf[5]<<2) | (buf[6]>>6))*400;\n\n                avctx->codec_id = CODEC_ID_MPEG1VIDEO;\n\n                avctx->sub_id = 1;\n\n            }\n\n            break;\n\n        case EXT_START_CODE:\n\n            if (bytes_left >= 1) {\n\n                ext_type = (buf[0] >> 4);\n\n                switch(ext_type) {\n\n                case 0x1: /* sequence extension */\n\n                    if (bytes_left >= 6) {\n\n                        horiz_size_ext = ((buf[1] & 1) << 1) | (buf[2] >> 7);\n\n                        vert_size_ext = (buf[2] >> 5) & 3;\n\n                        bit_rate_ext = ((buf[2] & 0x1F)<<7) | (buf[3]>>1);\n\n                        frame_rate_ext_n = (buf[5] >> 5) & 3;\n\n                        frame_rate_ext_d = (buf[5] & 0x1f);\n\n                        pc->progressive_sequence = buf[1] & (1 << 3);\n\n                        avctx->has_b_frames= !(buf[5] >> 7);\n\n\n\n                        pc->width  |=(horiz_size_ext << 12);\n\n                        pc->height |=( vert_size_ext << 12);\n\n                        avctx->bit_rate += (bit_rate_ext << 18) * 400;\n\n                        avcodec_set_dimensions(avctx, pc->width, pc->height);\n\n                        avctx->time_base.den = pc->frame_rate.den * (frame_rate_ext_n + 1);\n\n                        avctx->time_base.num = pc->frame_rate.num * (frame_rate_ext_d + 1);\n\n                        avctx->codec_id = CODEC_ID_MPEG2VIDEO;\n\n                        avctx->sub_id = 2; /* forces MPEG2 */\n\n                    }\n\n                    break;\n\n                case 0x8: /* picture coding extension */\n\n                    if (bytes_left >= 5) {\n\n                        picture_structure = buf[2]&3;\n\n                        top_field_first = buf[3] & (1 << 7);\n\n                        repeat_first_field = buf[3] & (1 << 1);\n\n                        progressive_frame = buf[4] & (1 << 7);\n\n\n\n                        /* check if we must repeat the frame */\n\n                        if (repeat_first_field) {\n\n                            if (pc->progressive_sequence) {\n\n                                if (top_field_first)\n\n                                    s->repeat_pict = 4;\n\n                                else\n\n                                    s->repeat_pict = 2;\n\n                            } else if (progressive_frame) {\n\n                                s->repeat_pict = 1;\n\n                            }\n\n                        }\n\n                    }\n\n                    break;\n\n                }\n\n            }\n\n            break;\n\n        case -1:\n\n            goto the_end;\n\n        default:\n\n            /* we stop parsing when we encounter a slice. It ensures\n\n               that this function takes a negligible amount of time */\n\n            if (start_code >= SLICE_MIN_START_CODE &&\n\n                start_code <= SLICE_MAX_START_CODE)\n\n                goto the_end;\n\n            break;\n\n        }\n\n    }\n\n the_end: ;\n\n}", "idx": 21374}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void mov_update_dts_shift(MOVStreamContext *sc, int duration)\n\n{\n\n    if (duration < 0) {\n\n\n\n\n\n        sc->dts_shift = FFMAX(sc->dts_shift, -duration);\n\n", "idx": 21385}, {"project": "test", "commit_id": "test", "target": 1, "func": "void qemu_spice_display_init(DisplayState *ds)\n\n{\n\n    assert(sdpy.ds == NULL);\n\n    qemu_spice_display_init_common(&sdpy, ds);\n\n    register_displaychangelistener(ds, &display_listener);\n\n\n\n    sdpy.qxl.base.sif = &dpy_interface.base;\n\n    qemu_spice_add_interface(&sdpy.qxl.base);\n\n    assert(sdpy.worker);\n\n\n\n    qemu_spice_create_host_memslot(&sdpy);\n\n    qemu_spice_create_host_primary(&sdpy);\n\n}\n", "idx": 21392}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void gen_dst(DisasContext *ctx)\n\n{\n\n    if (rA(ctx->opcode) == 0) {\n\n        gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX);\n\n    } else {\n\n        /* interpreted as no-op */\n\n    }\n\n}\n", "idx": 21466}, {"project": "test", "commit_id": "test", "target": 1, "func": "void OPPROTO op_POWER_doz (void)\n\n{\n\n    if (Ts1 > Ts0)\n\n        T0 = T1 - T0;\n\n    else\n\n        T0 = 0;\n\n    RETURN();\n\n}\n", "idx": 21569}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void fill_table(uint8_t* table[256 + 2*YUVRGB_TABLE_HEADROOM], const int elemsize,\n\n                       const int inc, void *y_tab)\n\n{\n\n    int i;\n\n    uint8_t *y_table = y_tab;\n\n\n\n    y_table -= elemsize * (inc >> 9);\n\n\n\n    for (i = 0; i < 256 + 2*YUVRGB_TABLE_HEADROOM; i++) {\n\n        int64_t cb = av_clip(i-YUVRGB_TABLE_HEADROOM, 0, 255)*inc;\n\n        table[i] = y_table + elemsize * (cb >> 16);\n\n    }\n\n}\n", "idx": 21583}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int xpm_decode_frame(AVCodecContext *avctx, void *data,\n\n                            int *got_frame, AVPacket *avpkt)\n\n{\n\n    XPMDecContext *x = avctx->priv_data;\n\n    AVFrame *p=data;\n\n    const uint8_t *end, *ptr = avpkt->data;\n\n    int ncolors, cpp, ret, i, j;\n\n    int64_t size;\n\n    uint32_t *dst;\n\n\n\n    avctx->pix_fmt = AV_PIX_FMT_BGRA;\n\n\n\n    end = avpkt->data + avpkt->size;\n\n    while (memcmp(ptr, \"/* XPM */\\n\", 10) && ptr < end - 10)\n\n        ptr++;\n\n\n\n    if (ptr >= end) {\n\n        av_log(avctx, AV_LOG_ERROR, \"missing signature\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    ptr += mod_strcspn(ptr, \"\\\"\");\n\n    if (sscanf(ptr, \"\\\"%u %u %u %u\\\",\",\n\n               &avctx->width, &avctx->height, &ncolors, &cpp) != 4) {\n\n        av_log(avctx, AV_LOG_ERROR, \"missing image parameters\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    if ((ret = ff_set_dimensions(avctx, avctx->width, avctx->height)) < 0)\n\n        return ret;\n\n\n\n    if ((ret = ff_get_buffer(avctx, p, 0)) < 0)\n\n        return ret;\n\n\n\n    if (cpp <= 0 || cpp >= 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"unsupported/invalid number of chars per pixel: %d\\n\", cpp);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    size = 1;\n\n    for (i = 0; i < cpp; i++)\n\n        size *= 94;\n\n\n\n    if (ncolors <= 0 || ncolors > size) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid number of colors: %d\\n\", ncolors);\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    size *= 4;\n\n\n\n    av_fast_padded_malloc(&x->pixels, &x->pixels_size, size);\n\n    if (!x->pixels)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ptr += mod_strcspn(ptr, \",\") + 1;\n\n    for (i = 0; i < ncolors; i++) {\n\n        const uint8_t *index;\n\n        int len;\n\n\n\n        ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n\n        if (ptr + cpp > end)\n\n            return AVERROR_INVALIDDATA;\n\n        index = ptr;\n\n        ptr += cpp;\n\n\n\n        ptr = strstr(ptr, \"c \");\n\n        if (ptr) {\n\n            ptr += 2;\n\n        } else {\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n\n\n        len = strcspn(ptr, \"\\\" \");\n\n\n\n        if ((ret = ascii2index(index, cpp)) < 0)\n\n            return ret;\n\n\n\n        x->pixels[ret] = color_string_to_rgba(ptr, len);\n\n        ptr += mod_strcspn(ptr, \",\") + 1;\n\n    }\n\n\n\n    for (i = 0; i < avctx->height; i++) {\n\n        dst = (uint32_t *)(p->data[0] + i * p->linesize[0]);\n\n        ptr += mod_strcspn(ptr, \"\\\"\") + 1;\n\n\n\n        for (j = 0; j < avctx->width; j++) {\n\n            if (ptr + cpp > end)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            if ((ret = ascii2index(ptr, cpp)) < 0)\n\n                return ret;\n\n\n\n            *dst++ = x->pixels[ret];\n\n            ptr += cpp;\n\n        }\n\n        ptr += mod_strcspn(ptr, \",\") + 1;\n\n    }\n\n\n\n    p->key_frame = 1;\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    *got_frame = 1;\n\n\n\n    return avpkt->size;\n\n}\n", "idx": 21762}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int get_bits(Jpeg2000DecoderContext *s, int n)\n\n{\n\n    int res = 0;\n\n    if (s->buf_end - s->buf < ((n - s->bit_index) >> 8))\n\n        return AVERROR_INVALIDDATA;\n\n    while (--n >= 0) {\n\n        res <<= 1;\n\n        if (s->bit_index == 0) {\n\n            s->bit_index = 7 + (*s->buf != 0xff);\n\n            s->buf++;\n\n        }\n\n        s->bit_index--;\n\n        res |= (*s->buf >> s->bit_index) & 1;\n\n    }\n\n    return res;\n\n}\n", "idx": 21822}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void master_abort_mem_write(void *opaque, hwaddr addr, uint64_t val,\n\n                                   unsigned size)\n\n{\n\n}\n", "idx": 21889}, {"project": "test", "commit_id": "test", "target": 1, "func": "void ff_init_cabac_decoder(CABACContext *c, const uint8_t *buf, int buf_size){\n\n    c->bytestream_start=\n\n    c->bytestream= buf;\n\n    c->bytestream_end= buf + buf_size;\n\n\n\n#if CABAC_BITS == 16\n\n    c->low =  (*c->bytestream++)<<18;\n\n    c->low+=  (*c->bytestream++)<<10;\n\n#else\n\n    c->low =  (*c->bytestream++)<<10;\n\n#endif\n\n    c->low+= ((*c->bytestream++)<<2) + 2;\n\n    c->range= 0x1FE;\n\n}\n", "idx": 21919}, {"project": "test", "commit_id": "test", "target": 1, "func": "PPC_OP(divw)\n\n{\n\n    if ((Ts0 == INT32_MIN && Ts1 == -1) || Ts1 == 0) {\n\n        T0 = (int32_t)((-1) * (T0 >> 31));\n\n    } else {\n\n        T0 = (Ts0 / Ts1);\n\n    }\n\n    RETURN();\n\n}\n", "idx": 21957}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void netfilter_finalize(Object *obj)\n\n{\n\n    NetFilterState *nf = NETFILTER(obj);\n\n    NetFilterClass *nfc = NETFILTER_GET_CLASS(obj);\n\n\n\n    if (nfc->cleanup) {\n\n        nfc->cleanup(nf);\n\n    }\n\n\n\n    if (nf->netdev && !QTAILQ_EMPTY(&nf->netdev->filters)) {\n\n        QTAILQ_REMOVE(&nf->netdev->filters, nf, next);\n\n    }\n\n\n}", "idx": 21962}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void amdvi_realize(DeviceState *dev, Error **err)\n\n{\n\n    int ret = 0;\n\n    AMDVIState *s = AMD_IOMMU_DEVICE(dev);\n\n    X86IOMMUState *x86_iommu = X86_IOMMU_DEVICE(dev);\n\n    PCIBus *bus = PC_MACHINE(qdev_get_machine())->bus;\n\n    s->iotlb = g_hash_table_new_full(amdvi_uint64_hash,\n\n                                     amdvi_uint64_equal, g_free, g_free);\n\n\n\n    /* This device should take care of IOMMU PCI properties */\n\n    x86_iommu->type = TYPE_AMD;\n\n    qdev_set_parent_bus(DEVICE(&s->pci), &bus->qbus);\n\n    object_property_set_bool(OBJECT(&s->pci), true, \"realized\", err);\n\n    s->capab_offset = pci_add_capability(&s->pci.dev, AMDVI_CAPAB_ID_SEC, 0,\n\n                                         AMDVI_CAPAB_SIZE);\n\n    assert(s->capab_offset > 0);\n\n    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_MSI, 0, AMDVI_CAPAB_REG_SIZE);\n\n    assert(ret > 0);\n\n    ret = pci_add_capability(&s->pci.dev, PCI_CAP_ID_HT, 0, AMDVI_CAPAB_REG_SIZE);\n\n    assert(ret > 0);\n\n\n\n    /* set up MMIO */\n\n    memory_region_init_io(&s->mmio, OBJECT(s), &mmio_mem_ops, s, \"amdvi-mmio\",\n\n                          AMDVI_MMIO_SIZE);\n\n\n\n    sysbus_init_mmio(SYS_BUS_DEVICE(s), &s->mmio);\n\n    sysbus_mmio_map(SYS_BUS_DEVICE(s), 0, AMDVI_BASE_ADDR);\n\n    pci_setup_iommu(bus, amdvi_host_dma_iommu, s);\n\n    s->devid = object_property_get_int(OBJECT(&s->pci), \"addr\", err);\n\n    msi_init(&s->pci.dev, 0, 1, true, false, err);\n\n    amdvi_init(s);\n\n}\n", "idx": 21969}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int mov_read_default(MOVContext *c, AVIOContext *pb, MOVAtom atom)\n\n{\n\n    int64_t total_size = 0;\n\n    MOVAtom a;\n\n    int i;\n\n\n\n    if (atom.size < 0)\n\n        atom.size = INT64_MAX;\n\n    while (total_size + 8 <= atom.size && !avio_feof(pb)) {\n\n        int (*parse)(MOVContext*, AVIOContext*, MOVAtom) = NULL;\n\n        a.size = atom.size;\n\n        a.type=0;\n\n        if (atom.size >= 8) {\n\n            a.size = avio_rb32(pb);\n\n            a.type = avio_rl32(pb);\n\n            if (a.type == MKTAG('f','r','e','e') &&\n\n                a.size >= 8 &&\n\n                c->moov_retry) {\n\n                uint8_t buf[8];\n\n                uint32_t *type = (uint32_t *)buf + 1;\n\n                avio_read(pb, buf, 8);\n\n                avio_seek(pb, -8, SEEK_CUR);\n\n                if (*type == MKTAG('m','v','h','d') ||\n\n                    *type == MKTAG('c','m','o','v')) {\n\n                    av_log(c->fc, AV_LOG_ERROR, \"Detected moov in a free atom.\\n\");\n\n                    a.type = MKTAG('m','o','o','v');\n\n                }\n\n            }\n\n            if (atom.type != MKTAG('r','o','o','t') &&\n\n                atom.type != MKTAG('m','o','o','v'))\n\n            {\n\n                if (a.type == MKTAG('t','r','a','k') || a.type == MKTAG('m','d','a','t'))\n\n                {\n\n                    av_log(c->fc, AV_LOG_ERROR, \"Broken file, trak/mdat not at top-level\\n\");\n\n                    avio_skip(pb, -8);\n\n                    return 0;\n\n                }\n\n            }\n\n            total_size += 8;\n\n            if (a.size == 1) { /* 64 bit extended size */\n\n                a.size = avio_rb64(pb) - 8;\n\n                total_size += 8;\n\n            }\n\n        }\n\n        av_dlog(c->fc, \"type: %08x '%.4s' parent:'%.4s' sz: %\"PRId64\" %\"PRId64\" %\"PRId64\"\\n\",\n\n                a.type, (char*)&a.type, (char*)&atom.type, a.size, total_size, atom.size);\n\n        if (a.size == 0) {\n\n            a.size = atom.size - total_size + 8;\n\n        }\n\n        a.size -= 8;\n\n        if (a.size < 0)\n\n            break;\n\n        a.size = FFMIN(a.size, atom.size - total_size);\n\n\n\n        for (i = 0; mov_default_parse_table[i].type; i++)\n\n            if (mov_default_parse_table[i].type == a.type) {\n\n                parse = mov_default_parse_table[i].parse;\n\n                break;\n\n            }\n\n\n\n        // container is user data\n\n        if (!parse && (atom.type == MKTAG('u','d','t','a') ||\n\n                       atom.type == MKTAG('i','l','s','t')))\n\n            parse = mov_read_udta_string;\n\n\n\n        if (!parse) { /* skip leaf atoms data */\n\n            avio_skip(pb, a.size);\n\n        } else {\n\n            int64_t start_pos = avio_tell(pb);\n\n            int64_t left;\n\n            int err = parse(c, pb, a);\n\n            if (err < 0)\n\n                return err;\n\n            if (c->found_moov && c->found_mdat &&\n\n                ((!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX) ||\n\n                 start_pos + a.size == avio_size(pb))) {\n\n                if (!pb->seekable || c->fc->flags & AVFMT_FLAG_IGNIDX)\n\n                    c->next_root_atom = start_pos + a.size;\n\n                return 0;\n\n            }\n\n            left = a.size - avio_tell(pb) + start_pos;\n\n            if (left > 0) /* skip garbage at atom end */\n\n                avio_skip(pb, left);\n\n            else if (left < 0) {\n\n                av_log(c->fc, AV_LOG_WARNING,\n\n                       \"overread end of atom '%.4s' by %\"PRId64\" bytes\\n\",\n\n                       (char*)&a.type, -left);\n\n                avio_seek(pb, left, SEEK_CUR);\n\n            }\n\n        }\n\n\n\n        total_size += a.size;\n\n    }\n\n\n\n    if (total_size < atom.size && atom.size < 0x7ffff)\n\n        avio_skip(pb, atom.size - total_size);\n\n\n\n    return 0;\n\n}\n", "idx": 22013}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void dwt_encode97_int(DWTContext *s, int *t)\n\n{\n\n    int lev,\n\n        w = s->linelen[s->ndeclevels-1][0];\n\n    int *line = s->i_linebuf;\n\n    line += 5;\n\n\n\n    for (lev = s->ndeclevels-1; lev >= 0; lev--){\n\n        int lh = s->linelen[lev][0],\n\n            lv = s->linelen[lev][1],\n\n            mh = s->mod[lev][0],\n\n            mv = s->mod[lev][1],\n\n            lp;\n\n        int *l;\n\n\n\n        // VER_SD\n\n        l = line + mv;\n\n        for (lp = 0; lp < lh; lp++) {\n\n            int i, j = 0;\n\n\n\n            for (i = 0; i < lv; i++)\n\n                l[i] = t[w*i + lp];\n\n\n\n            sd_1d97_int(line, mv, mv + lv);\n\n\n\n            // copy back and deinterleave\n\n            for (i =   mv; i < lv; i+=2, j++)\n\n                t[w*j + lp] = ((l[i] * I_LFTG_X) + (1 << 16)) >> 17;\n\n            for (i = 1-mv; i < lv; i+=2, j++)\n\n                t[w*j + lp] = ((l[i] * I_LFTG_K) + (1 << 16)) >> 17;\n\n        }\n\n\n\n        // HOR_SD\n\n        l = line + mh;\n\n        for (lp = 0; lp < lv; lp++){\n\n            int i, j = 0;\n\n\n\n            for (i = 0; i < lh; i++)\n\n                l[i] = t[w*lp + i];\n\n\n\n            sd_1d97_int(line, mh, mh + lh);\n\n\n\n            // copy back and deinterleave\n\n            for (i =   mh; i < lh; i+=2, j++)\n\n                t[w*lp + j] = ((l[i] * I_LFTG_X) + (1 << 16)) >> 17;\n\n            for (i = 1-mh; i < lh; i+=2, j++)\n\n                t[w*lp + j] = ((l[i] * I_LFTG_K) + (1 << 16)) >> 17;\n\n        }\n\n\n\n    }\n\n}\n", "idx": 22034}, {"project": "test", "commit_id": "test", "target": 1, "func": "void error_propagate(Error **dst_errp, Error *local_err)\n\n{\n\n    if (local_err && dst_errp == &error_abort) {\n\n        error_report_err(local_err);\n\n        abort();\n\n    } else if (dst_errp && !*dst_errp) {\n\n        *dst_errp = local_err;\n\n    } else if (local_err) {\n\n        error_free(local_err);\n\n    }\n\n}\n", "idx": 22047}, {"project": "test", "commit_id": "test", "target": 1, "func": "gen_msub32_q(TCGv ret, TCGv arg1, TCGv arg2, TCGv arg3, uint32_t n,\n\n             uint32_t up_shift, CPUTriCoreState *env)\n\n{\n\n    TCGv temp = tcg_temp_new();\n\n    TCGv temp2 = tcg_temp_new();\n\n    TCGv temp3 = tcg_temp_new();\n\n    TCGv_i64 t1 = tcg_temp_new_i64();\n\n    TCGv_i64 t2 = tcg_temp_new_i64();\n\n    TCGv_i64 t3 = tcg_temp_new_i64();\n\n    TCGv_i64 t4 = tcg_temp_new_i64();\n\n\n\n    tcg_gen_ext_i32_i64(t2, arg2);\n\n    tcg_gen_ext_i32_i64(t3, arg3);\n\n\n\n    tcg_gen_mul_i64(t2, t2, t3);\n\n\n\n    tcg_gen_ext_i32_i64(t1, arg1);\n\n    /* if we shift part of the fraction out, we need to round up */\n\n    tcg_gen_andi_i64(t4, t2, (1ll << (up_shift - n)) - 1);\n\n    tcg_gen_setcondi_i64(TCG_COND_NE, t4, t4, 0);\n\n    tcg_gen_sari_i64(t2, t2, up_shift - n);\n\n    tcg_gen_add_i64(t2, t2, t4);\n\n\n\n    tcg_gen_sub_i64(t3, t1, t2);\n\n    tcg_gen_trunc_i64_i32(temp3, t3);\n\n    /* calc v bit */\n\n    tcg_gen_setcondi_i64(TCG_COND_GT, t1, t3, 0x7fffffffLL);\n\n    tcg_gen_setcondi_i64(TCG_COND_LT, t2, t3, -0x80000000LL);\n\n    tcg_gen_or_i64(t1, t1, t2);\n\n    tcg_gen_trunc_i64_i32(cpu_PSW_V, t1);\n\n    tcg_gen_shli_tl(cpu_PSW_V, cpu_PSW_V, 31);\n\n    /* We produce an overflow on the host if the mul before was\n\n       (0x80000000 * 0x80000000) << 1). If this is the\n\n       case, we negate the ovf. */\n\n    if (n == 1) {\n\n        tcg_gen_setcondi_tl(TCG_COND_EQ, temp, arg2, 0x80000000);\n\n        tcg_gen_setcond_tl(TCG_COND_EQ, temp2, arg2, arg3);\n\n        tcg_gen_and_tl(temp, temp, temp2);\n\n        tcg_gen_shli_tl(temp, temp, 31);\n\n        /* negate v bit, if special condition */\n\n        tcg_gen_xor_tl(cpu_PSW_V, cpu_PSW_V, temp);\n\n    }\n\n    /* Calc SV bit */\n\n    tcg_gen_or_tl(cpu_PSW_SV, cpu_PSW_SV, cpu_PSW_V);\n\n    /* Calc AV/SAV bits */\n\n    tcg_gen_add_tl(cpu_PSW_AV, temp3, temp3);\n\n    tcg_gen_xor_tl(cpu_PSW_AV, temp3, cpu_PSW_AV);\n\n    /* calc SAV */\n\n    tcg_gen_or_tl(cpu_PSW_SAV, cpu_PSW_SAV, cpu_PSW_AV);\n\n    /* write back result */\n\n    tcg_gen_mov_tl(ret, temp3);\n\n\n\n    tcg_temp_free(temp);\n\n    tcg_temp_free(temp2);\n\n    tcg_temp_free(temp3);\n\n    tcg_temp_free_i64(t1);\n\n    tcg_temp_free_i64(t2);\n\n    tcg_temp_free_i64(t3);\n\n    tcg_temp_free_i64(t4);\n\n}\n", "idx": 22058}, {"project": "test", "commit_id": "test", "target": 1, "func": "PPC_OP(extsh)\n\n{\n\n    T0 = (int32_t)((int16_t)(Ts0));\n\n    RETURN();\n\n}\n", "idx": 22250}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline int cow_set_bit(BlockDriverState *bs, int64_t bitnum)\n\n{\n\n    uint64_t offset = sizeof(struct cow_header_v2) + bitnum / 8;\n\n    uint8_t bitmap;\n\n\n\n    if (bdrv_pread(bs->file, offset, &bitmap, sizeof(bitmap)) !=\n\n\t    sizeof(bitmap)) {\n\n       return -errno;\n\n    }\n\n\n\n    bitmap |= (1 << (bitnum % 8));\n\n\n\n    if (bdrv_pwrite(bs->file, offset, &bitmap, sizeof(bitmap)) !=\n\n\t    sizeof(bitmap)) {\n\n       return -errno;\n\n    }\n\n    return 0;\n\n}\n", "idx": 22365}, {"project": "test", "commit_id": "test", "target": 1, "func": "PPC_OP(cmpl)\n\n{\n\n    if (T0 < T1) {\n\n        T0 = 0x08;\n\n    } else if (T0 > T1) {\n\n        T0 = 0x04;\n\n    } else {\n\n        T0 = 0x02;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 22369}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int roq_read_packet(AVFormatContext *s,\n\n                           AVPacket *pkt)\n\n{\n\n    RoqDemuxContext *roq = s->priv_data;\n\n    AVIOContext *pb = s->pb;\n\n    int ret = 0;\n\n    unsigned int chunk_size;\n\n    unsigned int chunk_type;\n\n    unsigned int codebook_size;\n\n    unsigned char preamble[RoQ_CHUNK_PREAMBLE_SIZE];\n\n    int packet_read = 0;\n\n    int64_t codebook_offset;\n\n\n\n    while (!packet_read) {\n\n\n\n        if (avio_feof(s->pb))\n\n            return AVERROR(EIO);\n\n\n\n        /* get the next chunk preamble */\n\n        if ((ret = avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE)) !=\n\n            RoQ_CHUNK_PREAMBLE_SIZE)\n\n            return AVERROR(EIO);\n\n\n\n        chunk_type = AV_RL16(&preamble[0]);\n\n        chunk_size = AV_RL32(&preamble[2]);\n\n        if(chunk_size > INT_MAX)\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        chunk_size = ffio_limit(pb, chunk_size);\n\n\n\n        switch (chunk_type) {\n\n\n\n        case RoQ_INFO:\n\n            if (roq->video_stream_index == -1) {\n\n                AVStream *st = avformat_new_stream(s, NULL);\n\n                if (!st)\n\n                    return AVERROR(ENOMEM);\n\n                avpriv_set_pts_info(st, 63, 1, roq->frame_rate);\n\n                roq->video_stream_index = st->index;\n\n                st->codecpar->codec_type   = AVMEDIA_TYPE_VIDEO;\n\n                st->codecpar->codec_id     = AV_CODEC_ID_ROQ;\n\n                st->codecpar->codec_tag    = 0;  /* no fourcc */\n\n\n\n                if (avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE) != RoQ_CHUNK_PREAMBLE_SIZE)\n\n                    return AVERROR(EIO);\n\n                st->codecpar->width  = roq->width  = AV_RL16(preamble);\n\n                st->codecpar->height = roq->height = AV_RL16(preamble + 2);\n\n                break;\n\n            }\n\n            /* don't care about this chunk anymore */\n\n            avio_skip(pb, RoQ_CHUNK_PREAMBLE_SIZE);\n\n            break;\n\n\n\n        case RoQ_QUAD_CODEBOOK:\n\n            if (roq->video_stream_index < 0)\n\n                return AVERROR_INVALIDDATA;\n\n            /* packet needs to contain both this codebook and next VQ chunk */\n\n            codebook_offset = avio_tell(pb) - RoQ_CHUNK_PREAMBLE_SIZE;\n\n            codebook_size = chunk_size;\n\n            avio_skip(pb, codebook_size);\n\n            if (avio_read(pb, preamble, RoQ_CHUNK_PREAMBLE_SIZE) !=\n\n                RoQ_CHUNK_PREAMBLE_SIZE)\n\n                return AVERROR(EIO);\n\n            chunk_size = AV_RL32(&preamble[2]) + RoQ_CHUNK_PREAMBLE_SIZE * 2 +\n\n                codebook_size;\n\n\n\n            if (chunk_size > INT_MAX)\n\n                return AVERROR_INVALIDDATA;\n\n\n\n            /* rewind */\n\n            avio_seek(pb, codebook_offset, SEEK_SET);\n\n\n\n            /* load up the packet */\n\n            ret= av_get_packet(pb, pkt, chunk_size);\n\n            if (ret != chunk_size)\n\n                return AVERROR(EIO);\n\n            pkt->stream_index = roq->video_stream_index;\n\n            pkt->pts = roq->video_pts++;\n\n\n\n            packet_read = 1;\n\n            break;\n\n\n\n        case RoQ_SOUND_MONO:\n\n        case RoQ_SOUND_STEREO:\n\n            if (roq->audio_stream_index == -1) {\n\n                AVStream *st = avformat_new_stream(s, NULL);\n\n                if (!st)\n\n                    return AVERROR(ENOMEM);\n\n                avpriv_set_pts_info(st, 32, 1, RoQ_AUDIO_SAMPLE_RATE);\n\n                roq->audio_stream_index = st->index;\n\n                st->codecpar->codec_type = AVMEDIA_TYPE_AUDIO;\n\n                st->codecpar->codec_id = AV_CODEC_ID_ROQ_DPCM;\n\n                st->codecpar->codec_tag = 0;  /* no tag */\n\n                if (chunk_type == RoQ_SOUND_STEREO) {\n\n                    st->codecpar->channels       = 2;\n\n                    st->codecpar->channel_layout = AV_CH_LAYOUT_STEREO;\n\n                } else {\n\n                    st->codecpar->channels       = 1;\n\n                    st->codecpar->channel_layout = AV_CH_LAYOUT_MONO;\n\n                }\n\n                roq->audio_channels    = st->codecpar->channels;\n\n                st->codecpar->sample_rate = RoQ_AUDIO_SAMPLE_RATE;\n\n                st->codecpar->bits_per_coded_sample = 16;\n\n                st->codecpar->bit_rate = st->codecpar->channels * st->codecpar->sample_rate *\n\n                    st->codecpar->bits_per_coded_sample;\n\n                st->codecpar->block_align = st->codecpar->channels * st->codecpar->bits_per_coded_sample;\n\n            }\n\n        case RoQ_QUAD_VQ:\n\n            if (chunk_type == RoQ_QUAD_VQ) {\n\n                if (roq->video_stream_index < 0)\n\n                    return AVERROR_INVALIDDATA;\n\n            }\n\n\n\n            /* load up the packet */\n\n            if (av_new_packet(pkt, chunk_size + RoQ_CHUNK_PREAMBLE_SIZE))\n\n                return AVERROR(EIO);\n\n            /* copy over preamble */\n\n            memcpy(pkt->data, preamble, RoQ_CHUNK_PREAMBLE_SIZE);\n\n\n\n            if (chunk_type == RoQ_QUAD_VQ) {\n\n                pkt->stream_index = roq->video_stream_index;\n\n                pkt->pts = roq->video_pts++;\n\n            } else {\n\n                pkt->stream_index = roq->audio_stream_index;\n\n                pkt->pts = roq->audio_frame_count;\n\n                roq->audio_frame_count += (chunk_size / roq->audio_channels);\n\n            }\n\n\n\n            pkt->pos= avio_tell(pb);\n\n            ret = avio_read(pb, pkt->data + RoQ_CHUNK_PREAMBLE_SIZE,\n\n                chunk_size);\n\n            if (ret != chunk_size)\n\n                ret = AVERROR(EIO);\n\n\n\n            packet_read = 1;\n\n            break;\n\n\n\n        default:\n\n            av_log(s, AV_LOG_ERROR, \"  unknown RoQ chunk (%04X)\\n\", chunk_type);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    return ret;\n\n}\n", "idx": 22426}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void RENAME(hScale)(int16_t *dst, int dstW, uint8_t *src, int srcW, int xInc,\n\n\t\t\t\t  int16_t *filter, int16_t *filterPos, int filterSize)\n\n{\n\n#ifdef HAVE_MMX\n\n\tassert(filterSize % 4 == 0 && filterSize>0);\n\n\tif(filterSize==4) // allways true for upscaling, sometimes for down too\n\n\t{\n\n\t\tlong counter= -2*dstW;\n\n\t\tfilter-= counter*2;\n\n\t\tfilterPos-= counter/2;\n\n\t\tdst-= counter/2;\n\n\t\tasm volatile(\n\n\t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"movq \"MANGLE(w02)\", %%mm6\t\\n\\t\"\n\n\t\t\t\"push %%\"REG_BP\"\t\t\\n\\t\" // we use 7 regs here ...\n\n\t\t\t\"mov %%\"REG_a\", %%\"REG_BP\"\t\\n\\t\"\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\t\"movzwl (%2, %%\"REG_BP\"), %%eax\t\\n\\t\"\n\n\t\t\t\"movzwl 2(%2, %%\"REG_BP\"), %%ebx\\n\\t\"\n\n\t\t\t\"movq (%1, %%\"REG_BP\", 4), %%mm1\\n\\t\"\n\n\t\t\t\"movq 8(%1, %%\"REG_BP\", 4), %%mm3\\n\\t\"\n\n\t\t\t\"movd (%3, %%\"REG_a\"), %%mm0\t\\n\\t\"\n\n\t\t\t\"movd (%3, %%\"REG_b\"), %%mm2\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm2, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm3, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm6, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm0, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"movd %%mm0, (%4, %%\"REG_BP\")\t\\n\\t\"\n\n\t\t\t\"add $4, %%\"REG_BP\"\t\t\\n\\t\"\n\n\t\t\t\" jnc 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t\"pop %%\"REG_BP\"\t\t\t\\n\\t\"\n\n\t\t\t: \"+a\" (counter)\n\n\t\t\t: \"c\" (filter), \"d\" (filterPos), \"S\" (src), \"D\" (dst)\n\n\t\t\t: \"%\"REG_b\n\n\t\t);\n\n\t}\n\n\telse if(filterSize==8)\n\n\t{\n\n\t\tlong counter= -2*dstW;\n\n\t\tfilter-= counter*4;\n\n\t\tfilterPos-= counter/2;\n\n\t\tdst-= counter/2;\n\n\t\tasm volatile(\n\n\t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"movq \"MANGLE(w02)\", %%mm6\t\\n\\t\"\n\n\t\t\t\"push %%\"REG_BP\"\t\t\\n\\t\" // we use 7 regs here ...\n\n\t\t\t\"mov %%\"REG_a\", %%\"REG_BP\"\t\\n\\t\"\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\t\"movzwl (%2, %%\"REG_BP\"), %%eax\t\\n\\t\"\n\n\t\t\t\"movzwl 2(%2, %%\"REG_BP\"), %%ebx\\n\\t\"\n\n\t\t\t\"movq (%1, %%\"REG_BP\", 8), %%mm1\\n\\t\"\n\n\t\t\t\"movq 16(%1, %%\"REG_BP\", 8), %%mm3\\n\\t\"\n\n\t\t\t\"movd (%3, %%\"REG_a\"), %%mm0\t\\n\\t\"\n\n\t\t\t\"movd (%3, %%\"REG_b\"), %%mm2\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm2, %%mm3\t\t\\n\\t\"\n\n\n\n\t\t\t\"movq 8(%1, %%\"REG_BP\", 8), %%mm1\\n\\t\"\n\n\t\t\t\"movq 24(%1, %%\"REG_BP\", 8), %%mm5\\n\\t\"\n\n\t\t\t\"movd 4(%3, %%\"REG_a\"), %%mm4\t\\n\\t\"\n\n\t\t\t\"movd 4(%3, %%\"REG_b\"), %%mm2\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm1, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm2, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"paddd %%mm4, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"paddd %%mm5, %%mm3\t\t\\n\\t\"\n\n\t\t\t\t\t\t\n\n\t\t\t\"psrad $8, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm3, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm6, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm0, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"movd %%mm0, (%4, %%\"REG_BP\")\t\\n\\t\"\n\n\t\t\t\"add $4, %%\"REG_BP\"\t\t\\n\\t\"\n\n\t\t\t\" jnc 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t\"pop %%\"REG_BP\"\t\t\t\\n\\t\"\n\n\t\t\t: \"+a\" (counter)\n\n\t\t\t: \"c\" (filter), \"d\" (filterPos), \"S\" (src), \"D\" (dst)\n\n\t\t\t: \"%\"REG_b\n\n\t\t);\n\n\t}\n\n\telse\n\n\t{\n\n\t\tuint8_t *offset = src+filterSize;\n\n\t\tlong counter= -2*dstW;\n\n//\t\tfilter-= counter*filterSize/2;\n\n\t\tfilterPos-= counter/2;\n\n\t\tdst-= counter/2;\n\n\t\tasm volatile(\n\n\t\t\t\"pxor %%mm7, %%mm7\t\t\\n\\t\"\n\n\t\t\t\"movq \"MANGLE(w02)\", %%mm6\t\\n\\t\"\n\n\t\t\t\".balign 16\t\t\t\\n\\t\"\n\n\t\t\t\"1:\t\t\t\t\\n\\t\"\n\n\t\t\t\"mov %2, %%\"REG_c\"\t\t\\n\\t\"\n\n\t\t\t\"movzwl (%%\"REG_c\", %0), %%eax\t\\n\\t\"\n\n\t\t\t\"movzwl 2(%%\"REG_c\", %0), %%ebx\t\\n\\t\"\n\n\t\t\t\"mov %5, %%\"REG_c\"\t\t\\n\\t\"\n\n\t\t\t\"pxor %%mm4, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"pxor %%mm5, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"2:\t\t\t\t\\n\\t\"\n\n\t\t\t\"movq (%1), %%mm1\t\t\\n\\t\"\n\n\t\t\t\"movq (%1, %6), %%mm3\t\t\\n\\t\"\n\n\t\t\t\"movd (%%\"REG_c\", %%\"REG_a\"), %%mm0\\n\\t\"\n\n\t\t\t\"movd (%%\"REG_c\", %%\"REG_b\"), %%mm2\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"punpcklbw %%mm7, %%mm2\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm1, %%mm0\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm2, %%mm3\t\t\\n\\t\"\n\n\t\t\t\"paddd %%mm3, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"paddd %%mm0, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"add $8, %1\t\t\t\\n\\t\"\n\n\t\t\t\"add $4, %%\"REG_c\"\t\t\\n\\t\"\n\n\t\t\t\"cmp %4, %%\"REG_c\"\t\t\\n\\t\"\n\n\t\t\t\" jb 2b\t\t\t\t\\n\\t\"\n\n\t\t\t\"add %6, %1\t\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"psrad $8, %%mm5\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm5, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"pmaddwd %%mm6, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"packssdw %%mm4, %%mm4\t\t\\n\\t\"\n\n\t\t\t\"mov %3, %%\"REG_a\"\t\t\\n\\t\"\n\n\t\t\t\"movd %%mm4, (%%\"REG_a\", %0)\t\\n\\t\"\n\n\t\t\t\"add $4, %0\t\t\t\\n\\t\"\n\n\t\t\t\" jnc 1b\t\t\t\\n\\t\"\n\n\n\n\t\t\t: \"+r\" (counter), \"+r\" (filter)\n\n\t\t\t: \"m\" (filterPos), \"m\" (dst), \"m\"(offset),\n\n\t\t\t  \"m\" (src), \"r\" ((long)filterSize*2)\n\n\t\t\t: \"%\"REG_b, \"%\"REG_a, \"%\"REG_c\n\n\t\t);\n\n\t}\n\n#else\n\n#ifdef HAVE_ALTIVEC\n\n\thScale_altivec_real(dst, dstW, src, srcW, xInc, filter, filterPos, filterSize);\n\n#else\n\n\tint i;\n\n\tfor(i=0; i<dstW; i++)\n\n\t{\n\n\t\tint j;\n\n\t\tint srcPos= filterPos[i];\n\n\t\tint val=0;\n\n//\t\tprintf(\"filterPos: %d\\n\", filterPos[i]);\n\n\t\tfor(j=0; j<filterSize; j++)\n\n\t\t{\n\n//\t\t\tprintf(\"filter: %d, src: %d\\n\", filter[i], src[srcPos + j]);\n\n\t\t\tval += ((int)src[srcPos + j])*filter[filterSize*i + j];\n\n\t\t}\n\n//\t\tfilter += hFilterSize;\n\n\t\tdst[i] = MIN(MAX(0, val>>7), (1<<15)-1); // the cubic equation does overflow ...\n\n//\t\tdst[i] = val>>7;\n\n\t}\n\n#endif\n\n#endif\n\n}\n", "idx": 22429}, {"project": "test", "commit_id": "test", "target": 1, "func": "void qemu_mutex_lock_iothread(void)\n\n{\n\n    if (!tcg_enabled()) {\n\n        qemu_mutex_lock(&qemu_global_mutex);\n\n    } else {\n\n        iothread_requesting_mutex = true;\n\n        if (qemu_mutex_trylock(&qemu_global_mutex)) {\n\n            qemu_cpu_kick_thread(first_cpu);\n\n            qemu_mutex_lock(&qemu_global_mutex);\n\n        }\n\n        iothread_requesting_mutex = false;\n\n        qemu_cond_broadcast(&qemu_io_proceeded_cond);\n\n    }\n\n}\n", "idx": 22534}, {"project": "test", "commit_id": "test", "target": 1, "func": "void stream_start(BlockDriverState *bs, BlockDriverState *base,\n\n                  const char *base_id, int64_t speed,\n\n                  BlockDriverCompletionFunc *cb,\n\n                  void *opaque, Error **errp)\n\n{\n\n    StreamBlockJob *s;\n\n    Coroutine *co;\n\n\n\n    s = block_job_create(&stream_job_type, bs, speed, cb, opaque, errp);\n\n    if (!s) {\n\n        return;\n\n    }\n\n\n\n    s->base = base;\n\n    if (base_id) {\n\n        pstrcpy(s->backing_file_id, sizeof(s->backing_file_id), base_id);\n\n    }\n\n\n\n    co = qemu_coroutine_create(stream_run);\n\n    trace_stream_start(bs, base, s, co, opaque);\n\n    qemu_coroutine_enter(co, s);\n\n}\n", "idx": 22652}, {"project": "test", "commit_id": "test", "target": 1, "func": "PPC_OP(srawi)\n\n{\n\n    T1 = T0;\n\n    T0 = (Ts0 >> PARAM(1));\n\n    if (Ts1 < 0 && (Ts1 & PARAM(2)) != 0) {\n\n        xer_ca = 1;\n\n    } else {\n\n        xer_ca = 0;\n\n    }\n\n    RETURN();\n\n}\n", "idx": 22683}, {"project": "test", "commit_id": "test", "target": 1, "func": "static av_cold int dnxhd_decode_close(AVCodecContext *avctx)\n\n{\n\n    DNXHDContext *ctx = avctx->priv_data;\n\n\n\n    ff_free_vlc(&ctx->ac_vlc);\n\n    ff_free_vlc(&ctx->dc_vlc);\n\n    ff_free_vlc(&ctx->run_vlc);\n\n\n\n    av_freep(&ctx->mb_scan_index);\n\n    av_freep(&ctx->rows);\n\n\n\n    return 0;\n\n}\n", "idx": 22718}, {"project": "test", "commit_id": "test", "target": 1, "func": "static const char *keyval_parse_one(QDict *qdict, const char *params,\n\n                                    const char *implied_key,\n\n                                    Error **errp)\n\n{\n\n    const char *key, *key_end, *s;\n\n    size_t len;\n\n    char key_in_cur[128];\n\n    QDict *cur;\n\n    int ret;\n\n    QObject *next;\n\n    QString *val;\n\n\n\n    key = params;\n\n    len = strcspn(params, \"=,\");\n\n    if (implied_key && len && key[len] != '=') {\n\n        /* Desugar implied key */\n\n        key = implied_key;\n\n        len = strlen(implied_key);\n\n    }\n\n    key_end = key + len;\n\n\n\n    /*\n\n     * Loop over key fragments: @s points to current fragment, it\n\n     * applies to @cur.  @key_in_cur[] holds the previous fragment.\n\n     */\n\n    cur = qdict;\n\n    s = key;\n\n    for (;;) {\n\n        ret = parse_qapi_name(s, false);\n\n        len = ret < 0 ? 0 : ret;\n\n        assert(s + len <= key_end);\n\n        if (!len || (s + len < key_end && s[len] != '.')) {\n\n            assert(key != implied_key);\n\n            error_setg(errp, \"Invalid parameter '%.*s'\",\n\n                       (int)(key_end - key), key);\n\n            return NULL;\n\n        }\n\n        if (len >= sizeof(key_in_cur)) {\n\n            assert(key != implied_key);\n\n            error_setg(errp, \"Parameter%s '%.*s' is too long\",\n\n                       s != key || s + len != key_end ? \" fragment\" : \"\",\n\n                       (int)len, s);\n\n            return NULL;\n\n        }\n\n\n\n        if (s != key) {\n\n            next = keyval_parse_put(cur, key_in_cur, NULL,\n\n                                    key, s - 1, errp);\n\n            if (!next) {\n\n                return NULL;\n\n            }\n\n            cur = qobject_to_qdict(next);\n\n            assert(cur);\n\n        }\n\n\n\n        memcpy(key_in_cur, s, len);\n\n        key_in_cur[len] = 0;\n\n        s += len;\n\n\n\n        if (*s != '.') {\n\n            break;\n\n        }\n\n        s++;\n\n    }\n\n\n\n    if (key == implied_key) {\n\n        assert(!*s);\n\n        s = params;\n\n    } else {\n\n        if (*s != '=') {\n\n            error_setg(errp, \"Expected '=' after parameter '%.*s'\",\n\n                       (int)(s - key), key);\n\n            return NULL;\n\n        }\n\n        s++;\n\n    }\n\n\n\n    val = qstring_new();\n\n    for (;;) {\n\n        if (!*s) {\n\n            break;\n\n        } else if (*s == ',') {\n\n            s++;\n\n            if (*s != ',') {\n\n                break;\n\n            }\n\n        }\n\n        qstring_append_chr(val, *s++);\n\n    }\n\n\n\n    if (!keyval_parse_put(cur, key_in_cur, val, key, key_end, errp)) {\n\n        return NULL;\n\n    }\n\n    return s;\n\n}\n", "idx": 22815}, {"project": "test", "commit_id": "test", "target": 1, "func": "static AVRational update_sar(int old_w, int old_h, AVRational sar, int new_w, int new_h)\n\n{\n\n    // attempt to keep aspect during typical resolution switches\n\n    if (!sar.num)\n\n        sar = (AVRational){1, 1};\n\n\n\n    sar = av_mul_q(sar, (AVRational){new_h * old_w, new_w * old_h});\n\n    return sar;\n\n}\n", "idx": 22833}, {"project": "test", "commit_id": "test", "target": 1, "func": "static uint32_t qpci_pc_config_readl(QPCIBus *bus, int devfn, uint8_t offset)\n\n{\n\n    outl(0xcf8, (1 << 31) | (devfn << 8) | offset);\n\n    return inl(0xcfc);\n\n}\n", "idx": 22834}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int load_normal_reset(S390CPU *cpu)\n\n{\n\n    S390CPUClass *scc = S390_CPU_GET_CLASS(cpu);\n\n\n\n    pause_all_vcpus();\n\n    cpu_synchronize_all_states();\n\n    cpu_reset_all();\n\n\n    io_subsystem_reset();\n\n    scc->initial_cpu_reset(CPU(cpu));\n\n    scc->load_normal(CPU(cpu));\n\n    cpu_synchronize_all_post_reset();\n\n    resume_all_vcpus();\n\n    return 0;\n\n}", "idx": 22875}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void get_xbzrle_cache_stats(MigrationInfo *info)\n\n{\n\n    if (migrate_use_xbzrle()) {\n\n        info->has_xbzrle_cache = true;\n\n        info->xbzrle_cache = g_malloc0(sizeof(*info->xbzrle_cache));\n\n        info->xbzrle_cache->cache_size = migrate_xbzrle_cache_size();\n\n        info->xbzrle_cache->bytes = xbzrle_mig_bytes_transferred();\n\n        info->xbzrle_cache->pages = xbzrle_mig_pages_transferred();\n\n        info->xbzrle_cache->cache_miss = xbzrle_mig_pages_cache_miss();\n\n        info->xbzrle_cache->cache_miss_rate = xbzrle_mig_cache_miss_rate();\n\n        info->xbzrle_cache->overflow = xbzrle_mig_pages_overflow();\n\n    }\n\n}\n", "idx": 22906}, {"project": "test", "commit_id": "test", "target": 1, "func": "static PowerPCCPU *ppc440_init_xilinx(ram_addr_t *ram_size,\n\n                                      int do_init,\n\n                                      const char *cpu_model,\n\n                                      uint32_t sysclk)\n\n{\n\n    PowerPCCPU *cpu;\n\n    CPUPPCState *env;\n\n    qemu_irq *irqs;\n\n\n\n    cpu = POWERPC_CPU(cpu_generic_init(TYPE_POWERPC_CPU, cpu_model));\n\n    if (cpu == NULL) {\n\n        fprintf(stderr, \"Unable to initialize CPU!\\n\");\n\n        exit(1);\n\n    }\n\n    env = &cpu->env;\n\n\n\n    ppc_booke_timers_init(cpu, sysclk, 0/* no flags */);\n\n\n\n    ppc_dcr_init(env, NULL, NULL);\n\n\n\n    /* interrupt controller */\n\n    irqs = g_malloc0(sizeof(qemu_irq) * PPCUIC_OUTPUT_NB);\n\n    irqs[PPCUIC_OUTPUT_INT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_INT];\n\n    irqs[PPCUIC_OUTPUT_CINT] = ((qemu_irq *)env->irq_inputs)[PPC40x_INPUT_CINT];\n\n    ppcuic_init(env, irqs, 0x0C0, 0, 1);\n\n    return cpu;\n\n}\n", "idx": 22931}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void lumRangeToJpeg16_c(int16_t *_dst, int width)\n\n{\n\n    int i;\n\n    int32_t *dst = (int32_t *) _dst;\n\n    for (i = 0; i < width; i++)\n\n        dst[i] = (FFMIN(dst[i],30189<<4)*19077 - (39057361<<4))>>14;\n\n}\n", "idx": 22955}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void find_motion(DeshakeContext *deshake, uint8_t *src1, uint8_t *src2,\n\n                        int width, int height, int stride, Transform *t)\n\n{\n\n    int x, y;\n\n    IntMotionVector mv = {0, 0};\n\n    int counts[128][128];\n\n    int count_max_value = 0;\n\n    int contrast;\n\n\n\n    int pos;\n\n    double *angles = av_malloc(sizeof(*angles) * width * height / (16 * deshake->blocksize));\n\n    int center_x = 0, center_y = 0;\n\n    double p_x, p_y;\n\n\n\n    // Reset counts to zero\n\n    for (x = 0; x < deshake->rx * 2 + 1; x++) {\n\n        for (y = 0; y < deshake->ry * 2 + 1; y++) {\n\n            counts[x][y] = 0;\n\n        }\n\n    }\n\n\n\n    pos = 0;\n\n    // Find motion for every block and store the motion vector in the counts\n\n    for (y = deshake->ry; y < height - deshake->ry - (deshake->blocksize * 2); y += deshake->blocksize * 2) {\n\n        // We use a width of 16 here to match the libavcodec sad functions\n\n        for (x = deshake->rx; x < width - deshake->rx - 16; x += 16) {\n\n            // If the contrast is too low, just skip this block as it probably\n\n            // won't be very useful to us.\n\n            contrast = block_contrast(src2, x, y, stride, deshake->blocksize);\n\n            if (contrast > deshake->contrast) {\n\n                //av_log(NULL, AV_LOG_ERROR, \"%d\\n\", contrast);\n\n                find_block_motion(deshake, src1, src2, x, y, stride, &mv);\n\n                if (mv.x != -1 && mv.y != -1) {\n\n                    counts[mv.x + deshake->rx][mv.y + deshake->ry] += 1;\n\n                    if (x > deshake->rx && y > deshake->ry)\n\n                        angles[pos++] = block_angle(x, y, 0, 0, &mv);\n\n\n\n                    center_x += mv.x;\n\n                    center_y += mv.y;\n\n                }\n\n            }\n\n        }\n\n    }\n\n\n\n    pos = FFMAX(1, pos);\n\n\n\n    center_x /= pos;\n\n    center_y /= pos;\n\n\n\n    t->angle = clean_mean(angles, pos);\n\n    if (t->angle < 0.001)\n\n        t->angle = 0;\n\n\n\n    // Find the most common motion vector in the frame and use it as the gmv\n\n    for (y = deshake->ry * 2; y >= 0; y--) {\n\n        for (x = 0; x < deshake->rx * 2 + 1; x++) {\n\n            //av_log(NULL, AV_LOG_ERROR, \"%5d \", counts[x][y]);\n\n            if (counts[x][y] > count_max_value) {\n\n                t->vector.x = x - deshake->rx;\n\n                t->vector.y = y - deshake->ry;\n\n                count_max_value = counts[x][y];\n\n            }\n\n        }\n\n        //av_log(NULL, AV_LOG_ERROR, \"\\n\");\n\n    }\n\n\n\n    p_x = (center_x - width / 2);\n\n    p_y = (center_y - height / 2);\n\n    t->vector.x += (cos(t->angle)-1)*p_x  - sin(t->angle)*p_y;\n\n    t->vector.y += sin(t->angle)*p_x  + (cos(t->angle)-1)*p_y;\n\n\n\n    // Clamp max shift & rotation?\n\n    t->vector.x = av_clipf(t->vector.x, -deshake->rx * 2, deshake->rx * 2);\n\n    t->vector.y = av_clipf(t->vector.y, -deshake->ry * 2, deshake->ry * 2);\n\n    t->angle = av_clipf(t->angle, -0.1, 0.1);\n\n\n\n    //av_log(NULL, AV_LOG_ERROR, \"%d x %d\\n\", avg->x, avg->y);\n\n    av_free(angles);\n\n}\n", "idx": 22959}, {"project": "test", "commit_id": "test", "target": 1, "func": "static TCGv gen_ea(CPUM68KState *env, DisasContext *s, uint16_t insn,\n\n                   int opsize, TCGv val, TCGv *addrp, ea_what what)\n\n{\n\n    TCGv reg;\n\n    TCGv result;\n\n    uint32_t offset;\n\n\n\n    switch ((insn >> 3) & 7) {\n\n    case 0: /* Data register direct.  */\n\n        reg = DREG(insn, 0);\n\n        if (what == EA_STORE) {\n\n            gen_partset_reg(opsize, reg, val);\n\n            return store_dummy;\n\n        } else {\n\n            return gen_extend(reg, opsize, what == EA_LOADS);\n\n        }\n\n    case 1: /* Address register direct.  */\n\n        reg = AREG(insn, 0);\n\n        if (what == EA_STORE) {\n\n            tcg_gen_mov_i32(reg, val);\n\n            return store_dummy;\n\n        } else {\n\n            return gen_extend(reg, opsize, what == EA_LOADS);\n\n        }\n\n    case 2: /* Indirect register */\n\n        reg = AREG(insn, 0);\n\n        return gen_ldst(s, opsize, reg, val, what);\n\n    case 3: /* Indirect postincrement.  */\n\n        reg = AREG(insn, 0);\n\n        result = gen_ldst(s, opsize, reg, val, what);\n\n        /* ??? This is not exception safe.  The instruction may still\n\n           fault after this point.  */\n\n        if (what == EA_STORE || !addrp)\n\n            tcg_gen_addi_i32(reg, reg, opsize_bytes(opsize));\n\n        return result;\n\n    case 4: /* Indirect predecrememnt.  */\n\n        {\n\n            TCGv tmp;\n\n            if (addrp && what == EA_STORE) {\n\n                tmp = *addrp;\n\n            } else {\n\n                tmp = gen_lea(env, s, insn, opsize);\n\n                if (IS_NULL_QREG(tmp))\n\n                    return tmp;\n\n                if (addrp)\n\n                    *addrp = tmp;\n\n            }\n\n            result = gen_ldst(s, opsize, tmp, val, what);\n\n            /* ??? This is not exception safe.  The instruction may still\n\n               fault after this point.  */\n\n            if (what == EA_STORE || !addrp) {\n\n                reg = AREG(insn, 0);\n\n                tcg_gen_mov_i32(reg, tmp);\n\n            }\n\n        }\n\n        return result;\n\n    case 5: /* Indirect displacement.  */\n\n    case 6: /* Indirect index + displacement.  */\n\n        return gen_ea_once(env, s, insn, opsize, val, addrp, what);\n\n    case 7: /* Other */\n\n        switch (insn & 7) {\n\n        case 0: /* Absolute short.  */\n\n        case 1: /* Absolute long.  */\n\n        case 2: /* pc displacement  */\n\n        case 3: /* pc index+displacement.  */\n\n            return gen_ea_once(env, s, insn, opsize, val, addrp, what);\n\n        case 4: /* Immediate.  */\n\n            /* Sign extend values for consistency.  */\n\n            switch (opsize) {\n\n            case OS_BYTE:\n\n                if (what == EA_LOADS) {\n\n                    offset = cpu_ldsb_code(env, s->pc + 1);\n\n                } else {\n\n                    offset = cpu_ldub_code(env, s->pc + 1);\n\n                }\n\n                s->pc += 2;\n\n                break;\n\n            case OS_WORD:\n\n                if (what == EA_LOADS) {\n\n                    offset = cpu_ldsw_code(env, s->pc);\n\n                } else {\n\n                    offset = cpu_lduw_code(env, s->pc);\n\n                }\n\n                s->pc += 2;\n\n                break;\n\n            case OS_LONG:\n\n                offset = read_im32(env, s);\n\n                break;\n\n            default:\n\n                qemu_assert(0, \"Bad immediate operand\");\n\n            }\n\n            return tcg_const_i32(offset);\n\n        default:\n\n            return NULL_QREG;\n\n        }\n\n    }\n\n    /* Should never happen.  */\n\n    return NULL_QREG;\n\n}\n", "idx": 22969}, {"project": "test", "commit_id": "test", "target": 1, "func": "int ff_h263_decode_mb(MpegEncContext *s,\n                      int16_t block[6][64])\n{\n    int cbpc, cbpy, i, cbp, pred_x, pred_y, mx, my, dquant;\n    int16_t *mot_val;\n    const int xy= s->mb_x + s->mb_y * s->mb_stride;\n    int cbpb = 0, pb_mv_count = 0;\n    av_assert2(!s->h263_pred);\n    if (s->pict_type == AV_PICTURE_TYPE_P) {\n        do{\n            if (get_bits1(&s->gb)) {\n                /* skip mb */\n                s->mb_intra = 0;\n                for(i=0;i<6;i++)\n                    s->block_last_index[i] = -1;\n                s->mv_dir = MV_DIR_FORWARD;\n                s->mv_type = MV_TYPE_16X16;\n                s->current_picture.mb_type[xy] = MB_TYPE_SKIP | MB_TYPE_16x16 | MB_TYPE_L0;\n                s->mv[0][0][0] = 0;\n                s->mv[0][0][1] = 0;\n                s->mb_skipped = !(s->obmc | s->loop_filter);\n                goto end;\n            cbpc = get_vlc2(&s->gb, ff_h263_inter_MCBPC_vlc.table, INTER_MCBPC_VLC_BITS, 2);\n            if (cbpc < 0){\n                av_log(s->avctx, AV_LOG_ERROR, \"cbpc damaged at %d %d\\n\", s->mb_x, s->mb_y);\n        }while(cbpc == 20);\n        s->bdsp.clear_blocks(s->block[0]);\n        dquant = cbpc & 8;\n        s->mb_intra = ((cbpc & 4) != 0);\n        if (s->mb_intra) goto intra;\n        if(s->pb_frame && get_bits1(&s->gb))\n            pb_mv_count = h263_get_modb(&s->gb, s->pb_frame, &cbpb);\n        cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n        if(s->alt_inter_vlc==0 || (cbpc & 3)!=3)\n            cbpy ^= 0xF;\n        cbp = (cbpc & 3) | (cbpy << 2);\n        if (dquant) {\n            h263_decode_dquant(s);\n        s->mv_dir = MV_DIR_FORWARD;\n        if ((cbpc & 16) == 0) {\n            s->current_picture.mb_type[xy] = MB_TYPE_16x16 | MB_TYPE_L0;\n            /* 16x16 motion prediction */\n            s->mv_type = MV_TYPE_16X16;\n            ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);\n            if (s->umvplus)\n               mx = h263p_decode_umotion(s, pred_x);\n            else\n               mx = ff_h263_decode_motion(s, pred_x, 1);\n            if (mx >= 0xffff)\n            if (s->umvplus)\n               my = h263p_decode_umotion(s, pred_y);\n            else\n               my = ff_h263_decode_motion(s, pred_y, 1);\n            if (my >= 0xffff)\n            s->mv[0][0][0] = mx;\n            s->mv[0][0][1] = my;\n            if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)\n               skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */\n        } else {\n            s->current_picture.mb_type[xy] = MB_TYPE_8x8 | MB_TYPE_L0;\n            s->mv_type = MV_TYPE_8X8;\n            for(i=0;i<4;i++) {\n                mot_val = ff_h263_pred_motion(s, i, 0, &pred_x, &pred_y);\n                if (s->umvplus)\n                    mx = h263p_decode_umotion(s, pred_x);\n                else\n                    mx = ff_h263_decode_motion(s, pred_x, 1);\n                if (mx >= 0xffff)\n                if (s->umvplus)\n                    my = h263p_decode_umotion(s, pred_y);\n                else\n                    my = ff_h263_decode_motion(s, pred_y, 1);\n                if (my >= 0xffff)\n                s->mv[0][i][0] = mx;\n                s->mv[0][i][1] = my;\n                if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)\n                  skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */\n                mot_val[0] = mx;\n                mot_val[1] = my;\n    } else if(s->pict_type==AV_PICTURE_TYPE_B) {\n        int mb_type;\n        const int stride= s->b8_stride;\n        int16_t *mot_val0 = s->current_picture.motion_val[0][2 * (s->mb_x + s->mb_y * stride)];\n        int16_t *mot_val1 = s->current_picture.motion_val[1][2 * (s->mb_x + s->mb_y * stride)];\n//        const int mv_xy= s->mb_x + 1 + s->mb_y * s->mb_stride;\n        //FIXME ugly\n        mot_val0[0       ]= mot_val0[2       ]= mot_val0[0+2*stride]= mot_val0[2+2*stride]=\n        mot_val0[1       ]= mot_val0[3       ]= mot_val0[1+2*stride]= mot_val0[3+2*stride]=\n        mot_val1[0       ]= mot_val1[2       ]= mot_val1[0+2*stride]= mot_val1[2+2*stride]=\n        mot_val1[1       ]= mot_val1[3       ]= mot_val1[1+2*stride]= mot_val1[3+2*stride]= 0;\n        do{\n            mb_type= get_vlc2(&s->gb, h263_mbtype_b_vlc.table, H263_MBTYPE_B_VLC_BITS, 2);\n            if (mb_type < 0){\n                av_log(s->avctx, AV_LOG_ERROR, \"b mb_type damaged at %d %d\\n\", s->mb_x, s->mb_y);\n            mb_type= h263_mb_type_b_map[ mb_type ];\n        }while(!mb_type);\n        s->mb_intra = IS_INTRA(mb_type);\n        if(HAS_CBP(mb_type)){\n            s->bdsp.clear_blocks(s->block[0]);\n            cbpc = get_vlc2(&s->gb, cbpc_b_vlc.table, CBPC_B_VLC_BITS, 1);\n            if(s->mb_intra){\n                dquant = IS_QUANT(mb_type);\n                goto intra;\n            cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n            if (cbpy < 0){\n                av_log(s->avctx, AV_LOG_ERROR, \"b cbpy damaged at %d %d\\n\", s->mb_x, s->mb_y);\n            if(s->alt_inter_vlc==0 || (cbpc & 3)!=3)\n                cbpy ^= 0xF;\n            cbp = (cbpc & 3) | (cbpy << 2);\n        }else\n            cbp=0;\n        av_assert2(!s->mb_intra);\n        if(IS_QUANT(mb_type)){\n            h263_decode_dquant(s);\n        if(IS_DIRECT(mb_type)){\n            s->mv_dir = MV_DIR_FORWARD | MV_DIR_BACKWARD | MV_DIRECT;\n            mb_type |= set_direct_mv(s);\n        }else{\n            s->mv_dir = 0;\n            s->mv_type= MV_TYPE_16X16;\n//FIXME UMV\n            if(USES_LIST(mb_type, 0)){\n                int16_t *mot_val= ff_h263_pred_motion(s, 0, 0, &pred_x, &pred_y);\n                s->mv_dir = MV_DIR_FORWARD;\n                if (s->umvplus)\n                    mx = h263p_decode_umotion(s, pred_x);\n                else\n                    mx = ff_h263_decode_motion(s, pred_x, 1);\n                if (mx >= 0xffff)\n                if (s->umvplus)\n                    my = h263p_decode_umotion(s, pred_y);\n                else\n                    my = ff_h263_decode_motion(s, pred_y, 1);\n                if (my >= 0xffff)\n                if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)\n                    skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */\n                s->mv[0][0][0] = mx;\n                s->mv[0][0][1] = my;\n                mot_val[0       ]= mot_val[2       ]= mot_val[0+2*stride]= mot_val[2+2*stride]= mx;\n                mot_val[1       ]= mot_val[3       ]= mot_val[1+2*stride]= mot_val[3+2*stride]= my;\n            if(USES_LIST(mb_type, 1)){\n                int16_t *mot_val= ff_h263_pred_motion(s, 0, 1, &pred_x, &pred_y);\n                s->mv_dir |= MV_DIR_BACKWARD;\n                if (s->umvplus)\n                    mx = h263p_decode_umotion(s, pred_x);\n                else\n                    mx = ff_h263_decode_motion(s, pred_x, 1);\n                if (mx >= 0xffff)\n                if (s->umvplus)\n                    my = h263p_decode_umotion(s, pred_y);\n                else\n                    my = ff_h263_decode_motion(s, pred_y, 1);\n                if (my >= 0xffff)\n                if (s->umvplus && (mx - pred_x) == 1 && (my - pred_y) == 1)\n                    skip_bits1(&s->gb); /* Bit stuffing to prevent PSC */\n                s->mv[1][0][0] = mx;\n                s->mv[1][0][1] = my;\n                mot_val[0       ]= mot_val[2       ]= mot_val[0+2*stride]= mot_val[2+2*stride]= mx;\n                mot_val[1       ]= mot_val[3       ]= mot_val[1+2*stride]= mot_val[3+2*stride]= my;\n        s->current_picture.mb_type[xy] = mb_type;\n    } else { /* I-Frame */\n        do{\n            cbpc = get_vlc2(&s->gb, ff_h263_intra_MCBPC_vlc.table, INTRA_MCBPC_VLC_BITS, 2);\n            if (cbpc < 0){\n                av_log(s->avctx, AV_LOG_ERROR, \"I cbpc damaged at %d %d\\n\", s->mb_x, s->mb_y);\n        }while(cbpc == 8);\n        s->bdsp.clear_blocks(s->block[0]);\n        dquant = cbpc & 4;\n        s->mb_intra = 1;\nintra:\n        s->current_picture.mb_type[xy] = MB_TYPE_INTRA;\n        if (s->h263_aic) {\n            s->ac_pred = get_bits1(&s->gb);\n            if(s->ac_pred){\n                s->current_picture.mb_type[xy] = MB_TYPE_INTRA | MB_TYPE_ACPRED;\n                s->h263_aic_dir = get_bits1(&s->gb);\n        }else\n            s->ac_pred = 0;\n        if(s->pb_frame && get_bits1(&s->gb))\n            pb_mv_count = h263_get_modb(&s->gb, s->pb_frame, &cbpb);\n        cbpy = get_vlc2(&s->gb, ff_h263_cbpy_vlc.table, CBPY_VLC_BITS, 1);\n        if(cbpy<0){\n            av_log(s->avctx, AV_LOG_ERROR, \"I cbpy damaged at %d %d\\n\", s->mb_x, s->mb_y);\n        cbp = (cbpc & 3) | (cbpy << 2);\n        if (dquant) {\n            h263_decode_dquant(s);\n        pb_mv_count += !!s->pb_frame;\n    while(pb_mv_count--){\n        ff_h263_decode_motion(s, 0, 1);\n        ff_h263_decode_motion(s, 0, 1);\n    /* decode each block */\n    for (i = 0; i < 6; i++) {\n        if (h263_decode_block(s, block[i], i, cbp&32) < 0)\n            return -1;\n        cbp+=cbp;\n    if(s->pb_frame && h263_skip_b_part(s, cbpb) < 0)\n        return -1;\n    if(s->obmc && !s->mb_intra){\n        if(s->pict_type == AV_PICTURE_TYPE_P && s->mb_x+1<s->mb_width && s->mb_num_left != 1)\n            preview_obmc(s);\nend:\n        /* per-MB end of slice check */\n    {\n        int v= show_bits(&s->gb, 16);\n        if (get_bits_left(&s->gb) < 16) {\n            v >>= 16 - get_bits_left(&s->gb);\n        if(v==0)\n            return SLICE_END;\n    return SLICE_OK;", "idx": 23256}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void arm_mptimer_class_init(ObjectClass *klass, void *data)\n\n{\n\n    DeviceClass *dc = DEVICE_CLASS(klass);\n\n\n\n    dc->realize = arm_mptimer_realize;\n\n    dc->vmsd = &vmstate_arm_mptimer;\n\n    dc->reset = arm_mptimer_reset;\n\n    dc->no_user = 1;\n\n    dc->props = arm_mptimer_properties;\n\n}\n", "idx": 23277}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int decode_trns_chunk(AVCodecContext *avctx, PNGDecContext *s,\n\n                             uint32_t length)\n\n{\n\n    int v, i;\n\n\n\n    if (s->color_type == PNG_COLOR_TYPE_PALETTE) {\n\n        if (length > 256 || !(s->state & PNG_PLTE))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        for (i = 0; i < length; i++) {\n\n            v = bytestream2_get_byte(&s->gb);\n\n            s->palette[i] = (s->palette[i] & 0x00ffffff) | (v << 24);\n\n        }\n\n    } else if (s->color_type == PNG_COLOR_TYPE_GRAY || s->color_type == PNG_COLOR_TYPE_RGB) {\n\n        if ((s->color_type == PNG_COLOR_TYPE_GRAY && length != 2) ||\n\n            (s->color_type == PNG_COLOR_TYPE_RGB && length != 6))\n\n            return AVERROR_INVALIDDATA;\n\n\n\n        for (i = 0; i < length / 2; i++) {\n\n            /* only use the least significant bits */\n\n            v = av_mod_uintp2(bytestream2_get_be16(&s->gb), s->bit_depth);\n\n\n\n            if (s->bit_depth > 8)\n\n                AV_WB16(&s->transparent_color_be[2 * i], v);\n\n            else\n\n                s->transparent_color_be[i] = v;\n\n        }\n\n    } else {\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    bytestream2_skip(&s->gb, 4); /* crc */\n\n    s->has_trns = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 23309}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc,\n\n                                       int S)\n\n{\n\n    unsigned bit;\n\n\n\n    if (s->extra_bits) {\n\n        S <<= s->extra_bits;\n\n\n\n        if (s->got_extra_bits &&\n\n            get_bits_left(&s->gb_extra_bits) >= s->extra_bits) {\n\n            S   |= get_bits_long(&s->gb_extra_bits, s->extra_bits);\n\n            *crc = *crc * 9 + (S & 0xffff) * 3 + ((unsigned)S >> 16);\n\n        }\n\n    }\n\n\n\n    bit = (S & s->and) | s->or;\n\n    bit = ((S + bit) << s->shift) - bit;\n\n\n\n    if (s->hybrid)\n\n        bit = av_clip(bit, s->hybrid_minclip, s->hybrid_maxclip);\n\n\n\n    return bit << s->post_shift;\n\n}\n", "idx": 23323}, {"project": "test", "commit_id": "test", "target": 1, "func": "target_ulong helper_ldl(CPUMIPSState *env, target_ulong arg1,\n\n                        target_ulong arg2, int mem_idx)\n\n{\n\n    uint64_t tmp;\n\n\n\n    tmp = do_lbu(env, arg2, mem_idx);\n\n    arg1 = (arg1 & 0x00FFFFFFFFFFFFFFULL) | (tmp << 56);\n\n\n\n    if (GET_LMASK64(arg2) <= 6) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 1), mem_idx);\n\n        arg1 = (arg1 & 0xFF00FFFFFFFFFFFFULL) | (tmp << 48);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 5) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 2), mem_idx);\n\n        arg1 = (arg1 & 0xFFFF00FFFFFFFFFFULL) | (tmp << 40);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 4) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 3), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFF00FFFFFFFFULL) | (tmp << 32);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 3) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 4), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFF00FFFFFFULL) | (tmp << 24);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 2) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 5), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFF00FFFFULL) | (tmp << 16);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) <= 1) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 6), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFFFF00FFULL) | (tmp << 8);\n\n    }\n\n\n\n    if (GET_LMASK64(arg2) == 0) {\n\n        tmp = do_lbu(env, GET_OFFSET(arg2, 7), mem_idx);\n\n        arg1 = (arg1 & 0xFFFFFFFFFFFFFF00ULL) | tmp;\n\n    }\n\n\n\n    return arg1;\n\n}\n", "idx": 23339}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int coroutine_fn bdrv_aligned_pwritev(BdrvChild *child,\n    BdrvTrackedRequest *req, int64_t offset, unsigned int bytes,\n    int64_t align, QEMUIOVector *qiov, int flags)\n{\n    BlockDriverState *bs = child->bs;\n    BlockDriver *drv = bs->drv;\n    bool waited;\n    int ret;\n    int64_t end_sector = DIV_ROUND_UP(offset + bytes, BDRV_SECTOR_SIZE);\n    uint64_t bytes_remaining = bytes;\n    int max_transfer;\n    if (bdrv_has_readonly_bitmaps(bs)) {\n        return -EPERM;\n    assert(is_power_of_2(align));\n    assert((offset & (align - 1)) == 0);\n    assert((bytes & (align - 1)) == 0);\n    assert(!qiov || bytes == qiov->size);\n    assert((bs->open_flags & BDRV_O_NO_IO) == 0);\n    assert(!(flags & ~BDRV_REQ_MASK));\n    max_transfer = QEMU_ALIGN_DOWN(MIN_NON_ZERO(bs->bl.max_transfer, INT_MAX),\n                                   align);\n    waited = wait_serialising_requests(req);\n    assert(!waited || !req->serialising);\n    assert(req->overlap_offset <= offset);\n    assert(offset + bytes <= req->overlap_offset + req->overlap_bytes);\n    assert(child->perm & BLK_PERM_WRITE);\n    assert(end_sector <= bs->total_sectors || child->perm & BLK_PERM_RESIZE);\n    ret = notifier_with_return_list_notify(&bs->before_write_notifiers, req);\n    if (!ret && bs->detect_zeroes != BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF &&\n        !(flags & BDRV_REQ_ZERO_WRITE) && drv->bdrv_co_pwrite_zeroes &&\n        qemu_iovec_is_zero(qiov)) {\n        flags |= BDRV_REQ_ZERO_WRITE;\n        if (bs->detect_zeroes == BLOCKDEV_DETECT_ZEROES_OPTIONS_UNMAP) {\n            flags |= BDRV_REQ_MAY_UNMAP;\n    if (ret < 0) {\n        /* Do nothing, write notifier decided to fail this request */\n    } else if (flags & BDRV_REQ_ZERO_WRITE) {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV_ZERO);\n        ret = bdrv_co_do_pwrite_zeroes(bs, offset, bytes, flags);\n    } else if (flags & BDRV_REQ_WRITE_COMPRESSED) {\n        ret = bdrv_driver_pwritev_compressed(bs, offset, bytes, qiov);\n    } else if (bytes <= max_transfer) {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV);\n        ret = bdrv_driver_pwritev(bs, offset, bytes, qiov, flags);\n    } else {\n        bdrv_debug_event(bs, BLKDBG_PWRITEV);\n        while (bytes_remaining) {\n            int num = MIN(bytes_remaining, max_transfer);\n            QEMUIOVector local_qiov;\n            int local_flags = flags;\n            assert(num);\n            if (num < bytes_remaining && (flags & BDRV_REQ_FUA) &&\n                !(bs->supported_write_flags & BDRV_REQ_FUA)) {\n                /* If FUA is going to be emulated by flush, we only\n                 * need to flush on the last iteration */\n                local_flags &= ~BDRV_REQ_FUA;\n            qemu_iovec_init(&local_qiov, qiov->niov);\n            qemu_iovec_concat(&local_qiov, qiov, bytes - bytes_remaining, num);\n            ret = bdrv_driver_pwritev(bs, offset + bytes - bytes_remaining,\n                                      num, &local_qiov, local_flags);\n            qemu_iovec_destroy(&local_qiov);\n            if (ret < 0) {\n                break;\n            bytes_remaining -= num;\n    bdrv_debug_event(bs, BLKDBG_PWRITEV_DONE);\n    atomic_inc(&bs->write_gen);\n    bdrv_set_dirty(bs, offset, bytes);\n    stat64_max(&bs->wr_highest_offset, offset + bytes);\n    if (ret >= 0) {\n        bs->total_sectors = MAX(bs->total_sectors, end_sector);\n        ret = 0;\n    return ret;", "idx": 23386}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void rv40_h_weak_loop_filter(uint8_t *src, const int stride,\n\n                                    const int filter_p1, const int filter_q1,\n\n                                    const int alpha, const int beta,\n\n                                    const int lim_p0q0, const int lim_q1,\n\n                                    const int lim_p1)\n\n{\n\n    rv40_weak_loop_filter(src, stride, 1, filter_p1, filter_q1,\n\n                          alpha, beta, lim_p0q0, lim_q1, lim_p1);\n\n}\n", "idx": 23627}, {"project": "test", "commit_id": "test", "target": 1, "func": "int av_image_check_sar(unsigned int w, unsigned int h, AVRational sar)\n\n{\n\n    int64_t scaled_dim;\n\n\n\n    if (!sar.den)\n\n        return AVERROR(EINVAL);\n\n\n\n    if (!sar.num || sar.num == sar.den)\n\n        return 0;\n\n\n\n    if (sar.num < sar.den)\n\n        scaled_dim = av_rescale_rnd(w, sar.num, sar.den, AV_ROUND_ZERO);\n\n    else\n\n        scaled_dim = av_rescale_rnd(h, sar.den, sar.num, AV_ROUND_ZERO);\n\n\n\n    if (scaled_dim > 0)\n\n        return 0;\n\n\n\n    return AVERROR(EINVAL);\n\n}\n", "idx": 23762}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void decode_gray_bitstream(HYuvContext *s, int count)\n\n{\n\n    int i;\n\n    OPEN_READER(re, &s->gb);\n\n    count /= 2;\n\n\n\n    if (count >= (get_bits_left(&s->gb)) / (32 * 2)) {\n\n        for (i = 0; i < count && get_bits_left(&s->gb) > 0; i++) {\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    } else {\n\n        for (i = 0; i < count; i++) {\n\n            READ_2PIX(s->temp[0][2 * i], s->temp[0][2 * i + 1], 0);\n\n        }\n\n    }\n\n    CLOSE_READER(re, &s->gb);\n\n}\n", "idx": 23769}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int pcx_decode_frame(AVCodecContext *avctx, void *data, int *data_size,\n\n                            AVPacket *avpkt) {\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    PCXContext * const s = avctx->priv_data;\n\n    AVFrame *picture = data;\n\n    AVFrame * const p = &s->picture;\n\n    int compressed, xmin, ymin, xmax, ymax;\n\n    unsigned int w, h, bits_per_pixel, bytes_per_line, nplanes, stride, y, x,\n\n                 bytes_per_scanline;\n\n    uint8_t *ptr;\n\n    uint8_t const *bufstart = buf;\n\n    uint8_t *scanline;\n\n    int ret = -1;\n\n\n\n    if (buf[0] != 0x0a || buf[1] > 5) {\n\n        av_log(avctx, AV_LOG_ERROR, \"this is not PCX encoded data\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    compressed = buf[2];\n\n    xmin = AV_RL16(buf+ 4);\n\n    ymin = AV_RL16(buf+ 6);\n\n    xmax = AV_RL16(buf+ 8);\n\n    ymax = AV_RL16(buf+10);\n\n\n\n    if (xmax < xmin || ymax < ymin) {\n\n        av_log(avctx, AV_LOG_ERROR, \"invalid image dimensions\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    w = xmax - xmin + 1;\n\n    h = ymax - ymin + 1;\n\n\n\n    bits_per_pixel     = buf[3];\n\n    bytes_per_line     = AV_RL16(buf+66);\n\n    nplanes            = buf[65];\n\n    bytes_per_scanline = nplanes * bytes_per_line;\n\n\n\n    if (bytes_per_scanline < w * bits_per_pixel * nplanes / 8) {\n\n        av_log(avctx, AV_LOG_ERROR, \"PCX data is corrupted\\n\");\n\n        return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    switch ((nplanes<<8) + bits_per_pixel) {\n\n        case 0x0308:\n\n            avctx->pix_fmt = AV_PIX_FMT_RGB24;\n\n            break;\n\n        case 0x0108:\n\n        case 0x0104:\n\n        case 0x0102:\n\n        case 0x0101:\n\n        case 0x0401:\n\n        case 0x0301:\n\n        case 0x0201:\n\n            avctx->pix_fmt = AV_PIX_FMT_PAL8;\n\n            break;\n\n        default:\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid PCX file\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n    }\n\n\n\n    buf += 128;\n\n\n\n    if (p->data[0])\n\n        avctx->release_buffer(avctx, p);\n\n\n\n    if (av_image_check_size(w, h, 0, avctx))\n\n        return AVERROR_INVALIDDATA;\n\n    if (w != avctx->width || h != avctx->height)\n\n        avcodec_set_dimensions(avctx, w, h);\n\n    if ((ret = avctx->get_buffer(avctx, p)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return ret;\n\n    }\n\n\n\n    p->pict_type = AV_PICTURE_TYPE_I;\n\n\n\n    ptr    = p->data[0];\n\n    stride = p->linesize[0];\n\n\n\n    scanline = av_malloc(bytes_per_scanline);\n\n    if (!scanline)\n\n        return AVERROR(ENOMEM);\n\n\n\n    if (nplanes == 3 && bits_per_pixel == 8) {\n\n        for (y=0; y<h; y++) {\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x=0; x<w; x++) {\n\n                ptr[3*x  ] = scanline[x                    ];\n\n                ptr[3*x+1] = scanline[x+ bytes_per_line    ];\n\n                ptr[3*x+2] = scanline[x+(bytes_per_line<<1)];\n\n            }\n\n\n\n            ptr += stride;\n\n        }\n\n\n\n    } else if (nplanes == 1 && bits_per_pixel == 8) {\n\n        const uint8_t *palstart = bufstart + buf_size - 769;\n\n\n\n        for (y=0; y<h; y++, ptr+=stride) {\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n            memcpy(ptr, scanline, w);\n\n        }\n\n\n\n        if (buf != palstart) {\n\n            av_log(avctx, AV_LOG_WARNING, \"image data possibly corrupted\\n\");\n\n            buf = palstart;\n\n        }\n\n        if (*buf++ != 12) {\n\n            av_log(avctx, AV_LOG_ERROR, \"expected palette after image data\\n\");\n\n            ret = AVERROR_INVALIDDATA;\n\n            goto end;\n\n        }\n\n\n\n    } else if (nplanes == 1) {   /* all packed formats, max. 16 colors */\n\n        GetBitContext s;\n\n\n\n        for (y=0; y<h; y++) {\n\n            init_get_bits(&s, scanline, bytes_per_scanline<<3);\n\n\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x=0; x<w; x++)\n\n                ptr[x] = get_bits(&s, bits_per_pixel);\n\n            ptr += stride;\n\n        }\n\n\n\n    } else {    /* planar, 4, 8 or 16 colors */\n\n        int i;\n\n\n\n        for (y=0; y<h; y++) {\n\n            buf = pcx_rle_decode(buf, scanline, bytes_per_scanline, compressed);\n\n\n\n            for (x=0; x<w; x++) {\n\n                int m = 0x80 >> (x&7), v = 0;\n\n                for (i=nplanes - 1; i>=0; i--) {\n\n                    v <<= 1;\n\n                    v  += !!(scanline[i*bytes_per_line + (x>>3)] & m);\n\n                }\n\n                ptr[x] = v;\n\n            }\n\n            ptr += stride;\n\n        }\n\n    }\n\n\n\n    if (nplanes == 1 && bits_per_pixel == 8) {\n\n        pcx_palette(&buf, (uint32_t *) p->data[1], 256);\n\n    } else if (bits_per_pixel * nplanes == 1) {\n\n        AV_WN32A(p->data[1]  , 0xFF000000);\n\n        AV_WN32A(p->data[1]+4, 0xFFFFFFFF);\n\n    } else if (bits_per_pixel < 8) {\n\n        const uint8_t *palette = bufstart+16;\n\n        pcx_palette(&palette, (uint32_t *) p->data[1], 16);\n\n    }\n\n\n\n    *picture = s->picture;\n\n    *data_size = sizeof(AVFrame);\n\n\n\n    ret = buf - bufstart;\n\nend:\n\n    av_free(scanline);\n\n    return ret;\n\n}\n", "idx": 23786}, {"project": "test", "commit_id": "test", "target": 1, "func": "unsigned long find_next_zero_bit(const unsigned long *addr, unsigned long size,\n\n\t\t\t\t unsigned long offset)\n\n{\n\n    const unsigned long *p = addr + BITOP_WORD(offset);\n\n    unsigned long result = offset & ~(BITS_PER_LONG-1);\n\n    unsigned long tmp;\n\n\n\n    if (offset >= size) {\n\n        return size;\n\n    }\n\n    size -= result;\n\n    offset %= BITS_PER_LONG;\n\n    if (offset) {\n\n        tmp = *(p++);\n\n        tmp |= ~0UL >> (BITS_PER_LONG - offset);\n\n        if (size < BITS_PER_LONG) {\n\n            goto found_first;\n\n        }\n\n        if (~tmp) {\n\n            goto found_middle;\n\n        }\n\n        size -= BITS_PER_LONG;\n\n        result += BITS_PER_LONG;\n\n    }\n\n    while (size & ~(BITS_PER_LONG-1)) {\n\n        if (~(tmp = *(p++))) {\n\n            goto found_middle;\n\n        }\n\n        result += BITS_PER_LONG;\n\n        size -= BITS_PER_LONG;\n\n    }\n\n    if (!size) {\n\n        return result;\n\n    }\n\n    tmp = *p;\n\n\n\nfound_first:\n\n    tmp |= ~0UL << size;\n\n    if (tmp == ~0UL) {\t/* Are any bits zero? */\n\n        return result + size;\t/* Nope. */\n\n    }\n\nfound_middle:\n\n    return result + ffz(tmp);\n\n}\n", "idx": 23888}, {"project": "test", "commit_id": "test", "target": 1, "func": "void visit_end_implicit_struct(Visitor *v, Error **errp)\n\n{\n\n    assert(!error_is_set(errp));\n\n    if (v->end_implicit_struct) {\n\n        v->end_implicit_struct(v, errp);\n\n    }\n\n}\n", "idx": 23895}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int nbd_reject_length(NBDClient *client, bool fatal, Error **errp)\n\n{\n\n    int ret;\n\n\n\n    assert(client->optlen);\n\n    if (nbd_drop(client->ioc, client->optlen, errp) < 0) {\n\n        return -EIO;\n\n    }\n\n    ret = nbd_negotiate_send_rep_err(client, NBD_REP_ERR_INVALID, errp,\n\n                                     \"option '%s' should have zero length\",\n\n                                     nbd_opt_lookup(client->opt));\n\n    if (fatal && !ret) {\n\n        error_setg(errp, \"option '%s' should have zero length\",\n\n                   nbd_opt_lookup(client->opt));\n\n        return -EINVAL;\n\n    }\n\n    return ret;\n\n}\n", "idx": 23899}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int kvmppc_read_host_property(const char *node_path, const char *prop,\n\n                                     void *val, size_t len)\n\n{\n\n    char *path;\n\n    FILE *f;\n\n    int ret;\n\n    int pathlen;\n\n\n\n    pathlen = snprintf(NULL, 0, \"%s/%s/%s\", PROC_DEVTREE_PATH, node_path, prop)\n\n              + 1;\n\n    path = qemu_malloc(pathlen);\n\n    if (path == NULL) {\n\n        ret = -ENOMEM;\n\n        goto out;\n\n    }\n\n\n\n    snprintf(path, pathlen, \"%s/%s/%s\", PROC_DEVTREE_PATH, node_path, prop);\n\n\n\n    f = fopen(path, \"rb\");\n\n    if (f == NULL) {\n\n        ret = errno;\n\n        goto free;\n\n    }\n\n\n\n    len = fread(val, len, 1, f);\n\n    if (len != 1) {\n\n        ret = ferror(f);\n\n        goto close;\n\n    }\n\n\n\nclose:\n\n    fclose(f);\n\nfree:\n\n    free(path);\n\nout:\n\n    return ret;\n\n}\n", "idx": 23912}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void gen_op_arith_compute_ov(DisasContext *ctx, TCGv arg0,\n\n                                           TCGv arg1, TCGv arg2, int sub)\n\n{\n\n    TCGv t0 = tcg_temp_new();\n\n\n\n    tcg_gen_xor_tl(cpu_ov, arg0, arg1);\n\n    tcg_gen_xor_tl(t0, arg1, arg2);\n\n    if (sub) {\n\n        tcg_gen_and_tl(cpu_ov, cpu_ov, t0);\n\n    } else {\n\n        tcg_gen_andc_tl(cpu_ov, cpu_ov, t0);\n\n    }\n\n    tcg_temp_free(t0);\n\n    if (NARROW_MODE(ctx)) {\n\n        tcg_gen_ext32s_tl(cpu_ov, cpu_ov);\n\n    }\n\n    tcg_gen_shri_tl(cpu_ov, cpu_ov, TARGET_LONG_BITS - 1);\n\n    tcg_gen_or_tl(cpu_so, cpu_so, cpu_ov);\n\n}\n", "idx": 24009}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int read_kuki_chunk(AVFormatContext *s, int64_t size)\n\n{\n\n    AVIOContext *pb = s->pb;\n\n    AVStream *st      = s->streams[0];\n\n\n\n    if (size < 0 || size > INT_MAX - FF_INPUT_BUFFER_PADDING_SIZE)\n\n        return -1;\n\n\n\n    if (st->codec->codec_id == AV_CODEC_ID_AAC) {\n\n        /* The magic cookie format for AAC is an mp4 esds atom.\n\n           The lavc AAC decoder requires the data from the codec specific\n\n           description as extradata input. */\n\n        int strt, skip;\n\n        MOVAtom atom;\n\n\n\n        strt = avio_tell(pb);\n\n        ff_mov_read_esds(s, pb, atom);\n\n        skip = size - (avio_tell(pb) - strt);\n\n        if (skip < 0 || !st->codec->extradata ||\n\n            st->codec->codec_id != AV_CODEC_ID_AAC) {\n\n            av_log(s, AV_LOG_ERROR, \"invalid AAC magic cookie\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        avio_skip(pb, skip);\n\n    } else if (st->codec->codec_id == AV_CODEC_ID_ALAC) {\n\n#define ALAC_PREAMBLE 12\n\n#define ALAC_HEADER   36\n\n#define ALAC_NEW_KUKI 24\n\n        uint8_t preamble[12];\n\n        if (size < ALAC_NEW_KUKI) {\n\n            av_log(s, AV_LOG_ERROR, \"invalid ALAC magic cookie\\n\");\n\n            avio_skip(pb, size);\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n        avio_read(pb, preamble, ALAC_PREAMBLE);\n\n\n\n        st->codec->extradata = av_mallocz(ALAC_HEADER + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!st->codec->extradata)\n\n            return AVERROR(ENOMEM);\n\n\n\n        /* For the old style cookie, we skip 12 bytes, then read 36 bytes.\n\n         * The new style cookie only contains the last 24 bytes of what was\n\n         * 36 bytes in the old style cookie, so we fabricate the first 12 bytes\n\n         * in that case to maintain compatibility. */\n\n        if (!memcmp(&preamble[4], \"frmaalac\", 8)) {\n\n            if (size < ALAC_PREAMBLE + ALAC_HEADER) {\n\n                av_log(s, AV_LOG_ERROR, \"invalid ALAC magic cookie\\n\");\n\n                av_freep(&st->codec->extradata);\n\n                return AVERROR_INVALIDDATA;\n\n            }\n\n            avio_read(pb, st->codec->extradata, ALAC_HEADER);\n\n            avio_skip(pb, size - ALAC_PREAMBLE - ALAC_HEADER);\n\n        } else {\n\n            AV_WB32(st->codec->extradata, 36);\n\n            memcpy(&st->codec->extradata[4], \"alac\", 4);\n\n            AV_WB32(&st->codec->extradata[8], 0);\n\n            memcpy(&st->codec->extradata[12], preamble, 12);\n\n            avio_read(pb, &st->codec->extradata[24], ALAC_NEW_KUKI - 12);\n\n            avio_skip(pb, size - ALAC_NEW_KUKI);\n\n        }\n\n        st->codec->extradata_size = ALAC_HEADER;\n\n    } else {\n\n        st->codec->extradata = av_mallocz(size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n        if (!st->codec->extradata)\n\n            return AVERROR(ENOMEM);\n\n        avio_read(pb, st->codec->extradata, size);\n\n        st->codec->extradata_size = size;\n\n    }\n\n\n\n    return 0;\n\n}\n", "idx": 24230}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void *qemu_fopen_rdma(RDMAContext *rdma, const char *mode)\n\n{\n\n    QEMUFileRDMA *r = g_malloc0(sizeof(QEMUFileRDMA));\n\n\n\n    if (qemu_file_mode_is_not_valid(mode)) {\n\n        return NULL;\n\n    }\n\n\n\n    r->rdma = rdma;\n\n\n\n    if (mode[0] == 'w') {\n\n        r->file = qemu_fopen_ops(r, &rdma_write_ops);\n\n    } else {\n\n        r->file = qemu_fopen_ops(r, &rdma_read_ops);\n\n    }\n\n\n\n    return r->file;\n\n}\n", "idx": 24231}, {"project": "test", "commit_id": "test", "target": 1, "func": "void bdrv_drain(BlockDriverState *bs)\n\n{\n\n    bool busy = true;\n\n\n\n    bdrv_drain_recurse(bs);\n\n\n\n\n\n    while (busy) {\n\n        /* Keep iterating */\n\n         bdrv_flush_io_queue(bs);\n\n         busy = bdrv_requests_pending(bs);\n\n         busy |= aio_poll(bdrv_get_aio_context(bs), busy);\n\n", "idx": 24292}, {"project": "test", "commit_id": "test", "target": 1, "func": "static const char *qobject_input_get_keyval(QObjectInputVisitor *qiv,\n\n                                            const char *name,\n\n                                            Error **errp)\n\n{\n\n    QObject *qobj;\n\n    QString *qstr;\n\n\n\n    qobj = qobject_input_get_object(qiv, name, true, errp);\n\n    if (!qobj) {\n\n        return NULL;\n\n    }\n\n\n\n    qstr = qobject_to_qstring(qobj);\n\n    if (!qstr) {\n\n        error_setg(errp, QERR_INVALID_PARAMETER_TYPE,\n\n                   full_name(qiv, name), \"string\");\n\n        return NULL;\n\n    }\n\n\n\n    return qstring_get_str(qstr);\n\n}\n", "idx": 24328}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void qio_channel_socket_finalize(Object *obj)\n{\n    QIOChannelSocket *ioc = QIO_CHANNEL_SOCKET(obj);\n    if (ioc->fd != -1) {\n#ifdef WIN32\n        WSAEventSelect(ioc->fd, NULL, 0);\n#endif\n        closesocket(ioc->fd);\n        ioc->fd = -1;", "idx": 24331}, {"project": "test", "commit_id": "test", "target": 1, "func": "bool ftrace_init(void)\n\n{\n\n    char mount_point[PATH_MAX];\n\n    char path[PATH_MAX];\n\n    int debugfs_found;\n\n    int trace_fd = -1;\n\n\n\n    debugfs_found = find_mount(mount_point, \"debugfs\");\n\n    if (debugfs_found) {\n\n        snprintf(path, PATH_MAX, \"%s/tracing/tracing_on\", mount_point);\n\n        trace_fd = open(path, O_WRONLY);\n\n        if (trace_fd < 0) {\n\n            if (errno == EACCES) {\n\n                trace_marker_fd = open(\"/dev/null\", O_WRONLY);\n\n                if (trace_marker_fd != -1) {\n\n                    return true;\n\n                }\n\n            }\n\n            perror(\"Could not open ftrace 'tracing_on' file\");\n\n            return false;\n\n        } else {\n\n            if (write(trace_fd, \"1\", 1) < 0) {\n\n                perror(\"Could not write to 'tracing_on' file\");\n\n                close(trace_fd);\n\n                return false;\n\n            }\n\n            close(trace_fd);\n\n        }\n\n        snprintf(path, PATH_MAX, \"%s/tracing/trace_marker\", mount_point);\n\n        trace_marker_fd = open(path, O_WRONLY);\n\n        if (trace_marker_fd < 0) {\n\n            perror(\"Could not open ftrace 'trace_marker' file\");\n\n            return false;\n\n        }\n\n    } else {\n\n        fprintf(stderr, \"debugfs is not mounted\\n\");\n\n        return false;\n\n    }\n\n\n\n    return true;\n\n}\n", "idx": 24351}, {"project": "test", "commit_id": "test", "target": 1, "func": "void visit_type_int(Visitor *v, int64_t *obj, const char *name, Error **errp)\n\n{\n\n    if (!error_is_set(errp)) {\n\n        v->type_int(v, obj, name, errp);\n\n    }\n\n}\n", "idx": 24364}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void diff_bytes_c(uint8_t *dst, uint8_t *src1, uint8_t *src2, int w){\n\n    long i;\n\n#if !HAVE_FAST_UNALIGNED\n\n    if((long)src2 & (sizeof(long)-1)){\n\n        for(i=0; i+7<w; i+=8){\n\n            dst[i+0] = src1[i+0]-src2[i+0];\n\n            dst[i+1] = src1[i+1]-src2[i+1];\n\n            dst[i+2] = src1[i+2]-src2[i+2];\n\n            dst[i+3] = src1[i+3]-src2[i+3];\n\n            dst[i+4] = src1[i+4]-src2[i+4];\n\n            dst[i+5] = src1[i+5]-src2[i+5];\n\n            dst[i+6] = src1[i+6]-src2[i+6];\n\n            dst[i+7] = src1[i+7]-src2[i+7];\n\n        }\n\n    }else\n\n#endif\n\n    for(i=0; i<=w-sizeof(long); i+=sizeof(long)){\n\n        long a = *(long*)(src1+i);\n\n        long b = *(long*)(src2+i);\n\n        *(long*)(dst+i) = ((a|pb_80) - (b&pb_7f)) ^ ((a^b^pb_80)&pb_80);\n\n    }\n\n    for(; i<w; i++)\n\n        dst[i+0] = src1[i+0]-src2[i+0];\n\n}\n", "idx": 24472}, {"project": "test", "commit_id": "test", "target": 1, "func": "int ff_filter_frame(AVFilterLink *link, AVFrame *frame)\n\n{\n\n    int (*filter_frame)(AVFilterLink *, AVFrame *);\n\n    AVFilterPad *dst = link->dstpad;\n\n    AVFrame *out;\n\n\n\n    FF_DPRINTF_START(NULL, filter_frame);\n\n    ff_dlog_link(NULL, link, 1);\n\n\n\n    if (!(filter_frame = dst->filter_frame))\n\n        filter_frame = default_filter_frame;\n\n\n\n    /* copy the frame if needed */\n\n    if (dst->needs_writable && !av_frame_is_writable(frame)) {\n\n        av_log(link->dst, AV_LOG_DEBUG, \"Copying data in avfilter.\\n\");\n\n\n\n        switch (link->type) {\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            out = ff_get_video_buffer(link, link->w, link->h);\n\n            break;\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            out = ff_get_audio_buffer(link, frame->nb_samples);\n\n            break;\n\n        default: return AVERROR(EINVAL);\n\n        }\n\n        if (!out) {\n\n            av_frame_free(&frame);\n\n            return AVERROR(ENOMEM);\n\n        }\n\n        av_frame_copy_props(out, frame);\n\n\n\n        switch (link->type) {\n\n        case AVMEDIA_TYPE_VIDEO:\n\n            av_image_copy(out->data, out->linesize, frame->data, frame->linesize,\n\n                          frame->format, frame->width, frame->height);\n\n            break;\n\n        case AVMEDIA_TYPE_AUDIO:\n\n            av_samples_copy(out->extended_data, frame->extended_data,\n\n                            0, 0, frame->nb_samples,\n\n                            av_get_channel_layout_nb_channels(frame->channel_layout),\n\n                            frame->format);\n\n            break;\n\n        default: return AVERROR(EINVAL);\n\n        }\n\n\n\n        av_frame_free(&frame);\n\n    } else\n\n        out = frame;\n\n\n\n    return filter_frame(link, out);\n\n}\n", "idx": 24484}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void property_set_enum(Object *obj, Visitor *v, void *opaque,\n\n                              const char *name, Error **errp)\n\n{\n\n    EnumProperty *prop = opaque;\n\n    int value;\n\n\n\n    visit_type_enum(v, &value, prop->strings, NULL, name, errp);\n\n    prop->set(obj, value, errp);\n\n}\n", "idx": 24486}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int do_sigframe_return_v2(CPUState *env, target_ulong frame_addr,\n                                 struct target_ucontext_v2 *uc)\n{\n    sigset_t host_set;\n    abi_ulong *regspace;\n    target_to_host_sigset(&host_set, &uc->tuc_sigmask);\n    sigprocmask(SIG_SETMASK, &host_set, NULL);\n    if (restore_sigcontext(env, &uc->tuc_mcontext))\n    if (do_sigaltstack(frame_addr + offsetof(struct target_ucontext_v2, tuc_stack), 0, get_sp_from_cpustate(env)) == -EFAULT)\n#if 0\n    /* Send SIGTRAP if we're single-stepping */\n    if (ptrace_cancel_bpt(current))\n            send_sig(SIGTRAP, current, 1);\n#endif\n    return 0;", "idx": 24578}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void FUNCC(pred8x8_left_dc)(uint8_t *_src, int stride){\n\n    int i;\n\n    int dc0, dc2;\n\n    pixel4 dc0splat, dc2splat;\n\n    pixel *src = (pixel*)_src;\n\n    stride /= sizeof(pixel);\n\n\n\n    dc0=dc2=0;\n\n    for(i=0;i<4; i++){\n\n        dc0+= src[-1+i*stride];\n\n        dc2+= src[-1+(i+4)*stride];\n\n    }\n\n    dc0splat = PIXEL_SPLAT_X4((dc0 + 2)>>2);\n\n    dc2splat = PIXEL_SPLAT_X4((dc2 + 2)>>2);\n\n\n\n    for(i=0; i<4; i++){\n\n        ((pixel4*)(src+i*stride))[0]=\n\n        ((pixel4*)(src+i*stride))[1]= dc0splat;\n\n    }\n\n    for(i=4; i<8; i++){\n\n        ((pixel4*)(src+i*stride))[0]=\n\n        ((pixel4*)(src+i*stride))[1]= dc2splat;\n\n    }\n\n}\n", "idx": 24621}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void alloc_and_copy(uint8_t **poutbuf,          int *poutbuf_size,\n\n                           const uint8_t *sps_pps, uint32_t sps_pps_size,\n\n                           const uint8_t *in,      uint32_t in_size) {\n\n    uint32_t offset = *poutbuf_size;\n\n    uint8_t nal_header_size = offset ? 3 : 4;\n\n\n\n    *poutbuf_size += sps_pps_size+in_size+nal_header_size;\n\n    *poutbuf = av_realloc(*poutbuf, *poutbuf_size);\n\n    if (sps_pps)\n\n        memcpy(*poutbuf+offset, sps_pps, sps_pps_size);\n\n    memcpy(*poutbuf+sps_pps_size+nal_header_size+offset, in, in_size);\n\n    if (!offset)\n\n        AV_WB32(*poutbuf+sps_pps_size, 1);\n\n    else {\n\n        (*poutbuf+offset)[0] = (*poutbuf+offset)[1] = 0;\n\n        (*poutbuf+offset)[2] = 1;\n\n    }\n\n}\n", "idx": 24625}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void ff_wmv2_idct_put_c(uint8_t *dest, int line_size, DCTELEM *block)\n\n{\n\n    ff_wmv2_idct_c(block);\n\n    put_pixels_clamped_c(block, dest, line_size);\n\n}\n", "idx": 24668}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void write_target_close(BlockDriverState *bs) {\n\n    BDRVVVFATState* s = *((BDRVVVFATState**) bs->opaque);\n\n    bdrv_delete(s->qcow);\n\n    free(s->qcow_filename);\n\n}\n", "idx": 24730}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int aiff_read_packet(AVFormatContext *s,\n                            AVPacket *pkt)\n{\n    AVStream *st = s->streams[0];\n    AIFFInputContext *aiff = s->priv_data;\n    int64_t max_size;\n    int res, size;\n    /* calculate size of remaining data */\n    max_size = aiff->data_end - avio_tell(s->pb);\n    if (max_size <= 0)\n        return AVERROR_EOF;\n    /* Now for that packet */\n    switch (st->codecpar->codec_id) {\n    case AV_CODEC_ID_ADPCM_IMA_QT:\n    case AV_CODEC_ID_GSM:\n    case AV_CODEC_ID_QDM2:\n    case AV_CODEC_ID_QCELP:\n        size = st->codecpar->block_align;\n        break;\n    default:\n        size = st->codecpar->block_align ? (MAX_SIZE / st->codecpar->block_align) * st->codecpar->block_align : MAX_SIZE;\n    size = FFMIN(max_size, size);\n    res = av_get_packet(s->pb, pkt, size);\n    if (res < 0)\n        return res;\n    if (size >= st->codecpar->block_align)\n        pkt->flags &= ~AV_PKT_FLAG_CORRUPT;\n    /* Only one stream in an AIFF file */\n    pkt->stream_index = 0;\n    pkt->duration     = (res / st->codecpar->block_align) * aiff->block_duration;\n    return 0;", "idx": 24732}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int ram_block_enable_notify(const char *block_name, void *host_addr,\n\n                                   ram_addr_t offset, ram_addr_t length,\n\n                                   void *opaque)\n\n{\n\n    MigrationIncomingState *mis = opaque;\n\n    struct uffdio_register reg_struct;\n\n\n\n    reg_struct.range.start = (uintptr_t)host_addr;\n\n    reg_struct.range.len = length;\n\n    reg_struct.mode = UFFDIO_REGISTER_MODE_MISSING;\n\n\n\n    /* Now tell our userfault_fd that it's responsible for this area */\n\n    if (ioctl(mis->userfault_fd, UFFDIO_REGISTER, &reg_struct)) {\n\n        error_report(\"%s userfault register: %s\", __func__, strerror(errno));\n\n\n\n\n\n\n\n\n\n    return 0;\n", "idx": 24771}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void co_write_request(void *opaque)\n\n{\n\n    BDRVSheepdogState *s = opaque;\n\n\n\n    qemu_coroutine_enter(s->co_send, NULL);\n\n}\n", "idx": 24895}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int decode_frame_ilbm(AVCodecContext *avctx,\n\n                            void *data, int *data_size,\n\n                            AVPacket *avpkt)\n\n{\n\n    IffContext *s = avctx->priv_data;\n\n    const uint8_t *buf = avpkt->size >= 2 ? avpkt->data + AV_RB16(avpkt->data) : NULL;\n\n    const int buf_size = avpkt->size >= 2 ? avpkt->size - AV_RB16(avpkt->data) : 0;\n\n    const uint8_t *buf_end = buf+buf_size;\n\n    int y, plane, res;\n\n\n\n    if ((res = extract_header(avctx, avpkt)) < 0)\n\n        return res;\n\n\n\n    if (s->init) {\n\n        if ((res = avctx->reget_buffer(avctx, &s->frame)) < 0) {\n\n            av_log(avctx, AV_LOG_ERROR, \"reget_buffer() failed\\n\");\n\n            return res;\n\n        }\n\n    } else if ((res = avctx->get_buffer(avctx, &s->frame)) < 0) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return res;\n\n    } else if (avctx->bits_per_coded_sample <= 8 && avctx->pix_fmt != PIX_FMT_GRAY8) {\n\n        if ((res = ff_cmap_read_palette(avctx, (uint32_t*)s->frame.data[1])) < 0)\n\n            return res;\n\n    }\n\n    s->init = 1;\n\n\n\n    if (avctx->codec_tag == MKTAG('A','C','B','M')) {\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);\n\n            for (plane = 0; plane < s->bpp; plane++) {\n\n                for(y = 0; y < avctx->height && buf < buf_end; y++ ) {\n\n                    uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                    decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n            }\n\n        } else if (s->ham) { // HAM to PIX_FMT_BGR32\n\n            memset(s->frame.data[0], 0, avctx->height * s->frame.linesize[0]);\n\n            for(y = 0; y < avctx->height; y++) {\n\n                uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n\n                memset(s->ham_buf, 0, s->planesize * 8);\n\n                for (plane = 0; plane < s->bpp; plane++) {\n\n                    const uint8_t * start = buf + (plane * avctx->height + y) * s->planesize;\n\n                    if (start >= buf_end)\n\n                        break;\n\n                    decodeplane8(s->ham_buf, start, FFMIN(s->planesize, buf_end - start), plane);\n\n                }\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        }\n\n    } else if (avctx->codec_tag == MKTAG('D','E','E','P')) {\n\n        int raw_width = avctx->width * (av_get_bits_per_pixel(&av_pix_fmt_descriptors[avctx->pix_fmt]) >> 3);\n\n        int x;\n\n        for(y = 0; y < avctx->height && buf < buf_end; y++ ) {\n\n            uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n\n            memcpy(row, buf, FFMIN(raw_width, buf_end - buf));\n\n            buf += raw_width;\n\n            if (avctx->pix_fmt == PIX_FMT_BGR32) {\n\n                for(x = 0; x < avctx->width; x++)\n\n                    row[4 * x + 3] = row[4 * x + 3] & 0xF0 | (row[4 * x + 3] >> 4);\n\n            }\n\n        }\n\n    } else if (avctx->codec_tag == MKTAG('I','L','B','M')) { // interleaved\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            for(y = 0; y < avctx->height; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memset(row, 0, avctx->width);\n\n                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {\n\n                    decodeplane8(row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n            }\n\n        } else if (s->ham) { // HAM to PIX_FMT_BGR32\n\n            for (y = 0; y < avctx->height; y++) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memset(s->ham_buf, 0, s->planesize * 8);\n\n                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {\n\n                    decodeplane8(s->ham_buf, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        } else { // PIX_FMT_BGR32\n\n            for(y = 0; y < avctx->height; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][y*s->frame.linesize[0]];\n\n                memset(row, 0, avctx->width << 2);\n\n                for (plane = 0; plane < s->bpp && buf < buf_end; plane++) {\n\n                    decodeplane32((uint32_t *) row, buf, FFMIN(s->planesize, buf_end - buf), plane);\n\n                    buf += s->planesize;\n\n                }\n\n            }\n\n        }\n\n    } else if (avctx->codec_tag == MKTAG('P','B','M',' ')) { // IFF-PBM\n\n        if (avctx->pix_fmt == PIX_FMT_PAL8 || avctx->pix_fmt == PIX_FMT_GRAY8) {\n\n            for(y = 0; y < avctx->height; y++ ) {\n\n                uint8_t *row = &s->frame.data[0][y * s->frame.linesize[0]];\n\n                memcpy(row, buf, FFMIN(avctx->width, buf_end - buf));\n\n                buf += avctx->width + (avctx->width % 2); // padding if odd\n\n            }\n\n        } else if (s->ham) { // IFF-PBM: HAM to PIX_FMT_BGR32\n\n            for (y = 0; y < avctx->height; y++) {\n\n                uint8_t *row = &s->frame.data[0][ y*s->frame.linesize[0] ];\n\n                memcpy(s->ham_buf, buf, FFMIN(avctx->width, buf_end - buf));\n\n                buf += avctx->width + (avctx->width & 1); // padding if odd\n\n                decode_ham_plane32((uint32_t *) row, s->ham_buf, s->ham_palbuf, s->planesize);\n\n            }\n\n        } else {\n\n            av_log_ask_for_sample(avctx, \"unsupported bpp\\n\");\n\n            return AVERROR_INVALIDDATA;\n\n        }\n\n    }\n\n\n\n    *data_size = sizeof(AVFrame);\n\n    *(AVFrame*)data = s->frame;\n\n    return buf_size;\n\n}\n", "idx": 24896}, {"project": "test", "commit_id": "test", "target": 1, "func": "void helper_idivl_EAX_T0(void)\n\n{\n\n    int den, q, r;\n\n    int64_t num;\n\n    \n\n    num = ((uint32_t)EAX) | ((uint64_t)((uint32_t)EDX) << 32);\n\n    den = T0;\n\n    if (den == 0) {\n\n        raise_exception(EXCP00_DIVZ);\n\n    }\n\n#ifdef BUGGY_GCC_DIV64\n\n    r = idiv32(&q, num, den);\n\n#else\n\n    q = (num / den);\n\n    r = (num % den);\n\n#endif\n\n    EAX = (uint32_t)q;\n\n    EDX = (uint32_t)r;\n\n}\n", "idx": 25075}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void idct_col(int16_t *blk, const uint8_t *quant)\n\n{\n\n    int t0, t1, t2, t3, t4, t5, t6, t7, t8, t9, tA, tB, tC, tD, tE, tF;\n\n    int t10, t11, t12, t13;\n\n    int s0, s1, s2, s3, s4, s5, s6, s7;\n\n\n\n    s0 = (int) blk[0 * 8] * quant[0 * 8];\n\n    s1 = (int) blk[1 * 8] * quant[1 * 8];\n\n    s2 = (int) blk[2 * 8] * quant[2 * 8];\n\n    s3 = (int) blk[3 * 8] * quant[3 * 8];\n\n    s4 = (int) blk[4 * 8] * quant[4 * 8];\n\n    s5 = (int) blk[5 * 8] * quant[5 * 8];\n\n    s6 = (int) blk[6 * 8] * quant[6 * 8];\n\n    s7 = (int) blk[7 * 8] * quant[7 * 8];\n\n\n\n    t0  =  (s3 * 19266 + s5 * 12873) >> 15;\n\n    t1  =  (s5 * 19266 - s3 * 12873) >> 15;\n\n    t2  = ((s7 * 4520  + s1 * 22725) >> 15) - t0;\n\n    t3  = ((s1 * 4520  - s7 * 22725) >> 15) - t1;\n\n    t4  = t0 * 2 + t2;\n\n    t5  = t1 * 2 + t3;\n\n    t6  = t2 - t3;\n\n    t7  = t3 * 2 + t6;\n\n    t8  = (t6 * 11585) >> 14;\n\n    t9  = (t7 * 11585) >> 14;\n\n    tA  = (s2 * 8867 - s6 * 21407) >> 14;\n\n    tB  = (s6 * 8867 + s2 * 21407) >> 14;\n\n    tC  = (s0 >> 1) - (s4 >> 1);\n\n    tD  = (s4 >> 1) * 2 + tC;\n\n    tE  = tC - (tA >> 1);\n\n    tF  = tD - (tB >> 1);\n\n    t10 = tF - t5;\n\n    t11 = tE - t8;\n\n    t12 = tE + (tA >> 1) * 2 - t9;\n\n    t13 = tF + (tB >> 1) * 2 - t4;\n\n\n\n    blk[0 * 8] = t13 + t4 * 2;\n\n    blk[1 * 8] = t12 + t9 * 2;\n\n    blk[2 * 8] = t11 + t8 * 2;\n\n    blk[3 * 8] = t10 + t5 * 2;\n\n    blk[4 * 8] = t10;\n\n    blk[5 * 8] = t11;\n\n    blk[6 * 8] = t12;\n\n    blk[7 * 8] = t13;\n\n}\n", "idx": 25081}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void FUNC(put_hevc_epel_bi_w_h)(uint8_t *_dst, ptrdiff_t _dststride, uint8_t *_src, ptrdiff_t _srcstride,\n\n                                       int16_t *src2,\n\n                                       int height, int denom, int wx0, int wx1,\n\n                                       int ox0, int ox1, intptr_t mx, intptr_t my, int width)\n\n{\n\n    int x, y;\n\n    pixel *src = (pixel *)_src;\n\n    ptrdiff_t srcstride  = _srcstride / sizeof(pixel);\n\n    pixel *dst          = (pixel *)_dst;\n\n    ptrdiff_t dststride = _dststride / sizeof(pixel);\n\n    const int8_t *filter = ff_hevc_epel_filters[mx - 1];\n\n    int shift = 14 + 1 - BIT_DEPTH;\n\n    int log2Wd = denom + shift - 1;\n\n\n\n    ox0     = ox0 * (1 << (BIT_DEPTH - 8));\n\n    ox1     = ox1 * (1 << (BIT_DEPTH - 8));\n\n    for (y = 0; y < height; y++) {\n\n        for (x = 0; x < width; x++)\n\n            dst[x] = av_clip_pixel(((EPEL_FILTER(src, 1) >> (BIT_DEPTH - 8)) * wx1 + src2[x] * wx0 +\n\n                                    ((ox0 + ox1 + 1) << log2Wd)) >> (log2Wd + 1));\n\n        src  += srcstride;\n\n        dst  += dststride;\n\n        src2 += MAX_PB_SIZE;\n\n    }\n\n}\n", "idx": 25181}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void mm_stop_timer(struct qemu_alarm_timer *t)\n\n{\n\n    timeKillEvent(mm_timer);\n\n    timeEndPeriod(mm_period);\n\n}\n", "idx": 25185}, {"project": "test", "commit_id": "test", "target": 1, "func": "void add_command(const cmdinfo_t *ci)\n\n{\n\n    cmdtab = realloc((void *)cmdtab, ++ncmds * sizeof(*cmdtab));\n\n    cmdtab[ncmds - 1] = *ci;\n\n    qsort(cmdtab, ncmds, sizeof(*cmdtab), compare);\n\n}\n", "idx": 25252}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int virtio_net_handle_mac(VirtIONet *n, uint8_t cmd,\n\n                                 struct iovec *iov, unsigned int iov_cnt)\n\n{\n\n    struct virtio_net_ctrl_mac mac_data;\n\n    size_t s;\n\n    NetClientState *nc = qemu_get_queue(n->nic);\n\n\n\n    if (cmd == VIRTIO_NET_CTRL_MAC_ADDR_SET) {\n\n        if (iov_size(iov, iov_cnt) != sizeof(n->mac)) {\n\n            return VIRTIO_NET_ERR;\n\n        }\n\n        s = iov_to_buf(iov, iov_cnt, 0, &n->mac, sizeof(n->mac));\n\n        assert(s == sizeof(n->mac));\n\n        qemu_format_nic_info_str(qemu_get_queue(n->nic), n->mac);\n\n        rxfilter_notify(nc);\n\n\n\n        return VIRTIO_NET_OK;\n\n    }\n\n\n\n    if (cmd != VIRTIO_NET_CTRL_MAC_TABLE_SET) {\n\n        return VIRTIO_NET_ERR;\n\n    }\n\n\n\n    int in_use = 0;\n\n    int first_multi = 0;\n\n    uint8_t uni_overflow = 0;\n\n    uint8_t multi_overflow = 0;\n\n    uint8_t *macs = g_malloc0(MAC_TABLE_ENTRIES * ETH_ALEN);\n\n\n\n    s = iov_to_buf(iov, iov_cnt, 0, &mac_data.entries,\n\n                   sizeof(mac_data.entries));\n\n    mac_data.entries = ldl_p(&mac_data.entries);\n\n    if (s != sizeof(mac_data.entries)) {\n\n        goto error;\n\n    }\n\n    iov_discard_front(&iov, &iov_cnt, s);\n\n\n\n    if (mac_data.entries * ETH_ALEN > iov_size(iov, iov_cnt)) {\n\n        goto error;\n\n    }\n\n\n\n    if (mac_data.entries <= MAC_TABLE_ENTRIES) {\n\n        s = iov_to_buf(iov, iov_cnt, 0, macs,\n\n                       mac_data.entries * ETH_ALEN);\n\n        if (s != mac_data.entries * ETH_ALEN) {\n\n            goto error;\n\n        }\n\n        in_use += mac_data.entries;\n\n    } else {\n\n        uni_overflow = 1;\n\n    }\n\n\n\n    iov_discard_front(&iov, &iov_cnt, mac_data.entries * ETH_ALEN);\n\n\n\n    first_multi = in_use;\n\n\n\n    s = iov_to_buf(iov, iov_cnt, 0, &mac_data.entries,\n\n                   sizeof(mac_data.entries));\n\n    mac_data.entries = ldl_p(&mac_data.entries);\n\n    if (s != sizeof(mac_data.entries)) {\n\n        goto error;\n\n    }\n\n\n\n    iov_discard_front(&iov, &iov_cnt, s);\n\n\n\n    if (mac_data.entries * ETH_ALEN != iov_size(iov, iov_cnt)) {\n\n        goto error;\n\n    }\n\n\n\n    if (in_use + mac_data.entries <= MAC_TABLE_ENTRIES) {\n\n        s = iov_to_buf(iov, iov_cnt, 0, &macs[in_use * ETH_ALEN],\n\n                       mac_data.entries * ETH_ALEN);\n\n        if (s != mac_data.entries * ETH_ALEN) {\n\n            goto error;\n\n        }\n\n        in_use += mac_data.entries;\n\n    } else {\n\n        multi_overflow = 1;\n\n    }\n\n\n\n    n->mac_table.in_use = in_use;\n\n    n->mac_table.first_multi = first_multi;\n\n    n->mac_table.uni_overflow = uni_overflow;\n\n    n->mac_table.multi_overflow = multi_overflow;\n\n    memcpy(n->mac_table.macs, macs, MAC_TABLE_ENTRIES * ETH_ALEN);\n\n    g_free(macs);\n\n    rxfilter_notify(nc);\n\n\n\n    return VIRTIO_NET_OK;\n\n\n\nerror:\n\n    g_free(macs);\n\n    return VIRTIO_NET_ERR;\n\n}\n", "idx": 25382}, {"project": "test", "commit_id": "test", "target": 1, "func": "static av_cold int ffmmal_init_decoder(AVCodecContext *avctx)\n{\n    MMALDecodeContext *ctx = avctx->priv_data;\n    MMAL_STATUS_T status;\n    MMAL_ES_FORMAT_T *format_in;\n    MMAL_COMPONENT_T *decoder;\n    char tmp[32];\n    int ret = 0;\n    bcm_host_init();\n    if (mmal_vc_init()) {\n        av_log(avctx, AV_LOG_ERROR, \"Cannot initialize MMAL VC driver!\\n\");\n        return AVERROR(ENOSYS);\n    if ((ret = ff_get_format(avctx, avctx->codec->pix_fmts)) < 0)\n        return ret;\n    avctx->pix_fmt = ret;\n    if ((status = mmal_component_create(MMAL_COMPONENT_DEFAULT_VIDEO_DECODER, &ctx->decoder)))\n        goto fail;\n    decoder = ctx->decoder;\n    format_in = decoder->input[0]->format;\n    format_in->type = MMAL_ES_TYPE_VIDEO;\n    switch (avctx->codec_id) {\n        case AV_CODEC_ID_MPEG2VIDEO:\n            format_in->encoding = MMAL_ENCODING_MP2V;\n            break;\n        case AV_CODEC_ID_MPEG4:\n            format_in->encoding = MMAL_ENCODING_MP4V;\n            break;\n        case AV_CODEC_ID_VC1:\n            format_in->encoding = MMAL_ENCODING_WVC1;\n            break;\n        case AV_CODEC_ID_H264:\n        default:\n            format_in->encoding = MMAL_ENCODING_H264;\n            break;\n    format_in->es->video.width = FFALIGN(avctx->width, 32);\n    format_in->es->video.height = FFALIGN(avctx->height, 16);\n    format_in->es->video.crop.width = avctx->width;\n    format_in->es->video.crop.height = avctx->height;\n    format_in->es->video.frame_rate.num = 24000;\n    format_in->es->video.frame_rate.den = 1001;\n    format_in->es->video.par.num = avctx->sample_aspect_ratio.num;\n    format_in->es->video.par.den = avctx->sample_aspect_ratio.den;\n    format_in->flags = MMAL_ES_FORMAT_FLAG_FRAMED;\n    av_get_codec_tag_string(tmp, sizeof(tmp), format_in->encoding);\n    av_log(avctx, AV_LOG_DEBUG, \"Using MMAL %s encoding.\\n\", tmp);\n    if ((status = mmal_port_format_commit(decoder->input[0])))\n        goto fail;\n    decoder->input[0]->buffer_num =\n        FFMAX(decoder->input[0]->buffer_num_min, 20);\n    decoder->input[0]->buffer_size =\n        FFMAX(decoder->input[0]->buffer_size_min, 512 * 1024);\n    ctx->pool_in = mmal_pool_create(decoder->input[0]->buffer_num, 0);\n    if (!ctx->pool_in) {\n        ret = AVERROR(ENOMEM);\n        goto fail;\n    if ((ret = ffmal_update_format(avctx)) < 0)\n        goto fail;\n    ctx->queue_decoded_frames = mmal_queue_create();\n    if (!ctx->queue_decoded_frames)\n        goto fail;\n    decoder->input[0]->userdata = (void*)avctx;\n    decoder->output[0]->userdata = (void*)avctx;\n    decoder->control->userdata = (void*)avctx;\n    if ((status = mmal_port_enable(decoder->control, control_port_cb)))\n        goto fail;\n    if ((status = mmal_port_enable(decoder->input[0], input_callback)))\n        goto fail;\n    if ((status = mmal_port_enable(decoder->output[0], output_callback)))\n        goto fail;\n    if ((status = mmal_component_enable(decoder)))\n        goto fail;\n    return 0;\nfail:\n    ffmmal_close_decoder(avctx);\n    return ret < 0 ? ret : AVERROR_UNKNOWN;", "idx": 25401}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int ogg_get_length(AVFormatContext *s)\n\n{\n\n    struct ogg *ogg = s->priv_data;\n\n    int i;\n\n    int64_t size, end;\n\n    int streams_left=0;\n\n\n\n    if(!s->pb->seekable)\n\n        return 0;\n\n\n\n// already set\n\n    if (s->duration != AV_NOPTS_VALUE)\n\n        return 0;\n\n\n\n    size = avio_size(s->pb);\n\n    if(size < 0)\n\n        return 0;\n\n    end = size > MAX_PAGE_SIZE? size - MAX_PAGE_SIZE: 0;\n\n\n\n    ogg_save (s);\n\n    avio_seek (s->pb, end, SEEK_SET);\n\n\n\n    while (!ogg_read_page (s, &i)){\n\n        if (ogg->streams[i].granule != -1 && ogg->streams[i].granule != 0 &&\n\n            ogg->streams[i].codec) {\n\n            s->streams[i]->duration =\n\n                ogg_gptopts (s, i, ogg->streams[i].granule, NULL);\n\n            if (s->streams[i]->start_time != AV_NOPTS_VALUE){\n\n                s->streams[i]->duration -= s->streams[i]->start_time;\n\n                streams_left-= (ogg->streams[i].got_start==-1);\n\n                ogg->streams[i].got_start= 1;\n\n            }else if(!ogg->streams[i].got_start){\n\n                ogg->streams[i].got_start= -1;\n\n                streams_left++;\n\n            }\n\n        }\n\n    }\n\n\n\n    ogg_restore (s, 0);\n\n\n\n    ogg_save (s);\n\n    avio_seek (s->pb, s->data_offset, SEEK_SET);\n\n    ogg_reset(s);\n\n\n    while (!ogg_packet(s, &i, NULL, NULL, NULL)) {\n\n\n        int64_t pts = ogg_calc_pts(s, i, NULL);\n\n        if (pts != AV_NOPTS_VALUE && s->streams[i]->start_time == AV_NOPTS_VALUE && !ogg->streams[i].got_start){\n\n            s->streams[i]->duration -= pts;\n\n            ogg->streams[i].got_start= 1;\n\n            streams_left--;\n\n        }else if(s->streams[i]->start_time != AV_NOPTS_VALUE && !ogg->streams[i].got_start){\n\n            ogg->streams[i].got_start= 1;\n\n            streams_left--;\n\n        }\n\n        }\n\n            if(streams_left<=0)\n\n                break;\n\n    }\n\n    ogg_restore (s, 0);\n\n\n\n    return 0;\n\n}", "idx": 25404}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int mimic_decode_frame(AVCodecContext *avctx, void *data,\n\n                              int *data_size, AVPacket *avpkt)\n\n{\n\n    const uint8_t *buf = avpkt->data;\n\n    int buf_size = avpkt->size;\n\n    MimicContext *ctx = avctx->priv_data;\n\n    GetByteContext gb;\n\n    int is_pframe;\n\n    int width, height;\n\n    int quality, num_coeffs;\n\n    int swap_buf_size = buf_size - MIMIC_HEADER_SIZE;\n\n\n\n    if (buf_size <= MIMIC_HEADER_SIZE) {\n\n        av_log(avctx, AV_LOG_ERROR, \"insufficient data\\n\");\n\n        return -1;\n\n    }\n\n\n\n    bytestream2_init(&gb, buf, MIMIC_HEADER_SIZE);\n\n    bytestream2_skip(&gb, 2); /* some constant (always 256) */\n\n    quality    = bytestream2_get_le16u(&gb);\n\n    width      = bytestream2_get_le16u(&gb);\n\n    height     = bytestream2_get_le16u(&gb);\n\n    bytestream2_skip(&gb, 4); /* some constant */\n\n    is_pframe  = bytestream2_get_le32u(&gb);\n\n    num_coeffs = bytestream2_get_byteu(&gb);\n\n    bytestream2_skip(&gb, 3); /* some constant */\n\n\n\n    if(!ctx->avctx) {\n\n        int i;\n\n\n\n        if(!(width == 160 && height == 120) &&\n\n           !(width == 320 && height == 240)) {\n\n            av_log(avctx, AV_LOG_ERROR, \"invalid width/height!\\n\");\n\n            return -1;\n\n        }\n\n\n\n        ctx->avctx     = avctx;\n\n        avctx->width   = width;\n\n        avctx->height  = height;\n\n        avctx->pix_fmt = PIX_FMT_YUV420P;\n\n        for(i = 0; i < 3; i++) {\n\n            ctx->num_vblocks[i] = -((-height) >> (3 + !!i));\n\n            ctx->num_hblocks[i] =     width   >> (3 + !!i) ;\n\n        }\n\n    } else if(width != ctx->avctx->width || height != ctx->avctx->height) {\n\n        av_log(avctx, AV_LOG_ERROR, \"resolution changing is not supported\\n\");\n\n        return -1;\n\n    }\n\n\n\n    if(is_pframe && !ctx->buf_ptrs[ctx->prev_index].data[0]) {\n\n        av_log(avctx, AV_LOG_ERROR, \"decoding must start with keyframe\\n\");\n\n        return -1;\n\n    }\n\n\n\n    ctx->buf_ptrs[ctx->cur_index].reference = 1;\n\n    ctx->buf_ptrs[ctx->cur_index].pict_type = is_pframe ? AV_PICTURE_TYPE_P:AV_PICTURE_TYPE_I;\n\n    if(ff_thread_get_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index])) {\n\n        av_log(avctx, AV_LOG_ERROR, \"get_buffer() failed\\n\");\n\n        return -1;\n\n    }\n\n\n\n    ctx->next_prev_index = ctx->cur_index;\n\n    ctx->next_cur_index  = (ctx->cur_index - 1) & 15;\n\n\n\n    prepare_avpic(ctx, &ctx->flipped_ptrs[ctx->cur_index],\n\n                  (AVPicture*) &ctx->buf_ptrs[ctx->cur_index]);\n\n\n\n    ff_thread_finish_setup(avctx);\n\n\n\n    av_fast_malloc(&ctx->swap_buf, &ctx->swap_buf_size,\n\n                                 swap_buf_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n    if(!ctx->swap_buf)\n\n        return AVERROR(ENOMEM);\n\n\n\n    ctx->dsp.bswap_buf(ctx->swap_buf,\n\n                        (const uint32_t*) (buf + MIMIC_HEADER_SIZE),\n\n                        swap_buf_size>>2);\n\n    init_get_bits(&ctx->gb, ctx->swap_buf, swap_buf_size << 3);\n\n\n\n    if(!decode(ctx, quality, num_coeffs, !is_pframe)) {\n\n        if (avctx->active_thread_type&FF_THREAD_FRAME)\n\n            ff_thread_report_progress(&ctx->buf_ptrs[ctx->cur_index], INT_MAX, 0);\n\n        else {\n\n            ff_thread_release_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index]);\n\n            return -1;\n\n        }\n\n    }\n\n\n\n    *(AVFrame*)data = ctx->buf_ptrs[ctx->cur_index];\n\n    *data_size = sizeof(AVFrame);\n\n\n\n    ctx->prev_index = ctx->next_prev_index;\n\n    ctx->cur_index  = ctx->next_cur_index;\n\n\n\n    /* Only release frames that aren't used for backreferences anymore */\n\n    if(ctx->buf_ptrs[ctx->cur_index].data[0])\n\n        ff_thread_release_buffer(avctx, &ctx->buf_ptrs[ctx->cur_index]);\n\n\n\n    return buf_size;\n\n}\n", "idx": 25413}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int gdb_set_avr_reg(CPUState *env, uint8_t *mem_buf, int n)\n\n{\n\n    if (n < 32) {\n\n#ifdef WORDS_BIGENDIAN\n\n        env->avr[n].u64[0] = ldq_p(mem_buf);\n\n        env->avr[n].u64[1] = ldq_p(mem_buf+8);\n\n#else\n\n        env->avr[n].u64[1] = ldq_p(mem_buf);\n\n        env->avr[n].u64[0] = ldq_p(mem_buf+8);\n\n#endif\n\n        return 16;\n\n    }\n\n    if (n == 33) {\n\n        env->vscr = ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    if (n == 34) {\n\n        env->spr[SPR_VRSAVE] = (target_ulong)ldl_p(mem_buf);\n\n        return 4;\n\n    }\n\n    return 0;\n\n}\n", "idx": 25459}, {"project": "test", "commit_id": "test", "target": 1, "func": "int64_t qemu_ftell(QEMUFile *f)\n\n{\n\n    qemu_fflush(f);\n\n    return f->pos;\n\n}\n", "idx": 25492}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int add_hfyu_left_prediction_int16_c(uint16_t *dst, const uint16_t *src, unsigned mask, int w, int acc){\n\n    int i;\n\n\n\n    for(i=0; i<w-1; i++){\n\n        acc+= src[i];\n\n        dst[i]= acc & mask;\n\n        i++;\n\n        acc+= src[i];\n\n        dst[i]= acc & mask;\n\n    }\n\n\n\n    for(; i<w; i++){\n\n        acc+= src[i];\n\n        dst[i]= acc & mask;\n\n    }\n\n\n\n    return acc;\n\n}\n", "idx": 25530}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void render_line(int x0, uint8_t y0, int x1, int y1, float *buf)\n\n{\n\n    int dy  = y1 - y0;\n\n    int adx = x1 - x0;\n\n    int ady = FFABS(dy);\n\n    int sy  = dy < 0 ? -1 : 1;\n\n    buf[x0] = ff_vorbis_floor1_inverse_db_table[y0];\n\n    if (ady*2 <= adx) { // optimized common case\n\n        render_line_unrolled(x0, y0, x1, sy, ady, adx, buf);\n\n    } else {\n\n        int base  = dy / adx;\n\n        int x     = x0;\n\n        uint8_t y = y0;\n\n        int err   = -adx;\n\n        ady -= FFABS(base) * adx;\n\n        while (++x < x1) {\n\n            y += base;\n\n            err += ady;\n\n            if (err >= 0) {\n\n                err -= adx;\n\n                y   += sy;\n\n            }\n\n            buf[x] = ff_vorbis_floor1_inverse_db_table[y];\n\n        }\n\n    }\n\n}\n", "idx": 25729}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int read_old_huffman_tables(HYuvContext *s){\n\n#if 1\n\n    GetBitContext gb;\n\n    int i;\n\n\n\n    init_get_bits(&gb, classic_shift_luma, sizeof(classic_shift_luma)*8);\n\n    if(read_len_table(s->len[0], &gb)<0)\n\n        return -1;\n\n    init_get_bits(&gb, classic_shift_chroma, sizeof(classic_shift_chroma)*8);\n\n    if(read_len_table(s->len[1], &gb)<0)\n\n        return -1;\n\n\n\n    for(i=0; i<256; i++) s->bits[0][i] = classic_add_luma  [i];\n\n    for(i=0; i<256; i++) s->bits[1][i] = classic_add_chroma[i];\n\n\n\n    if(s->bitstream_bpp >= 24){\n\n        memcpy(s->bits[1], s->bits[0], 256*sizeof(uint32_t));\n\n        memcpy(s->len[1] , s->len [0], 256*sizeof(uint8_t));\n\n    }\n\n    memcpy(s->bits[2], s->bits[1], 256*sizeof(uint32_t));\n\n    memcpy(s->len[2] , s->len [1], 256*sizeof(uint8_t));\n\n\n\n    for(i=0; i<3; i++){\n\n        ff_free_vlc(&s->vlc[i]);\n\n        init_vlc(&s->vlc[i], VLC_BITS, 256, s->len[i], 1, 1, s->bits[i], 4, 4, 0);\n\n    }\n\n\n\n    generate_joint_tables(s);\n\n\n\n    return 0;\n\n#else\n\n    av_log(s->avctx, AV_LOG_DEBUG, \"v1 huffyuv is not supported \\n\");\n\n    return -1;\n\n#endif\n\n}\n", "idx": 25748}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int pixlet_decode_frame(AVCodecContext *avctx, void *data,\n                               int *got_frame, AVPacket *avpkt)\n{\n    PixletContext *ctx = avctx->priv_data;\n    int i, w, h, width, height, ret, version;\n    AVFrame *p = data;\n    ThreadFrame frame = { .f = data };\n    uint32_t pktsize;\n    bytestream2_init(&ctx->gb, avpkt->data, avpkt->size);\n    pktsize = bytestream2_get_be32(&ctx->gb);\n    if (pktsize <= 44 || pktsize - 4 > bytestream2_get_bytes_left(&ctx->gb)) {\n        av_log(avctx, AV_LOG_ERROR, \"Invalid packet size %\"PRIu32\"\\n\", pktsize);\n    }\n    version = bytestream2_get_le32(&ctx->gb);\n    if (version != 1)\n        avpriv_request_sample(avctx, \"Version %d\", version);\n    bytestream2_skip(&ctx->gb, 4);\n    if (bytestream2_get_be32(&ctx->gb) != 1)\n    bytestream2_skip(&ctx->gb, 4);\n    width  = bytestream2_get_be32(&ctx->gb);\n    height = bytestream2_get_be32(&ctx->gb);\n    w = FFALIGN(width,  1 << (NB_LEVELS + 1));\n    h = FFALIGN(height, 1 << (NB_LEVELS + 1));\n    ctx->levels = bytestream2_get_be32(&ctx->gb);\n    if (ctx->levels != NB_LEVELS)\n    ctx->depth = bytestream2_get_be32(&ctx->gb);\n    if (ctx->depth < 8 || ctx->depth > 15) {\n        avpriv_request_sample(avctx, \"Depth %d\", ctx->depth);\n    }\n    ret = ff_set_dimensions(avctx, w, h);\n    if (ret < 0)\n        return ret;\n    avctx->width  = width;\n    avctx->height = height;\n    if (ctx->w != w || ctx->h != h) {\n        free_buffers(avctx);\n        ctx->w = w;\n        ctx->h = h;\n        ret = init_decoder(avctx);\n        if (ret < 0) {\n            free_buffers(avctx);\n            ctx->w = 0;\n            ctx->h = 0;\n            return ret;\n        }\n    }\n    bytestream2_skip(&ctx->gb, 8);\n    p->pict_type = AV_PICTURE_TYPE_I;\n    p->key_frame = 1;\n    p->color_range = AVCOL_RANGE_JPEG;\n    ret = ff_thread_get_buffer(avctx, &frame, 0);\n    if (ret < 0)\n        return ret;\n    for (i = 0; i < 3; i++) {\n        ret = decode_plane(avctx, i, avpkt, frame.f);\n        if (ret < 0)\n            return ret;\n        if (avctx->flags & AV_CODEC_FLAG_GRAY)\n            break;\n    }\n    postprocess_luma(frame.f, ctx->w, ctx->h, ctx->depth);\n    postprocess_chroma(frame.f, ctx->w >> 1, ctx->h >> 1, ctx->depth);\n    *got_frame = 1;\n    return pktsize;\n}", "idx": 25828}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int matroska_read_header(AVFormatContext *s)\n\n{\n\n    MatroskaDemuxContext *matroska = s->priv_data;\n\n    EbmlList *attachements_list = &matroska->attachments;\n\n    MatroskaAttachement *attachements;\n\n    EbmlList *chapters_list = &matroska->chapters;\n\n    MatroskaChapter *chapters;\n\n    MatroskaTrack *tracks;\n\n    uint64_t max_start = 0;\n\n    int64_t pos;\n\n    Ebml ebml = { 0 };\n\n    AVStream *st;\n\n    int i, j, k, res;\n\n\n\n    matroska->ctx = s;\n\n\n\n    /* First read the EBML header. */\n\n    if (ebml_parse(matroska, ebml_syntax, &ebml)\n\n        || ebml.version > EBML_VERSION       || ebml.max_size > sizeof(uint64_t)\n\n        || ebml.id_length > sizeof(uint32_t) || ebml.doctype_version > 3) {\n\n        av_log(matroska->ctx, AV_LOG_ERROR,\n\n               \"EBML header using unsupported features\\n\"\n\n               \"(EBML version %\"PRIu64\", doctype %s, doc version %\"PRIu64\")\\n\",\n\n               ebml.version, ebml.doctype, ebml.doctype_version);\n\n        ebml_free(ebml_syntax, &ebml);\n\n        return AVERROR_PATCHWELCOME;\n\n    } else if (ebml.doctype_version == 3) {\n\n        av_log(matroska->ctx, AV_LOG_WARNING,\n\n               \"EBML header using unsupported features\\n\"\n\n               \"(EBML version %\"PRIu64\", doctype %s, doc version %\"PRIu64\")\\n\",\n\n               ebml.version, ebml.doctype, ebml.doctype_version);\n\n    }\n\n    for (i = 0; i < FF_ARRAY_ELEMS(matroska_doctypes); i++)\n\n        if (!strcmp(ebml.doctype, matroska_doctypes[i]))\n\n            break;\n\n    if (i >= FF_ARRAY_ELEMS(matroska_doctypes)) {\n\n        av_log(s, AV_LOG_WARNING, \"Unknown EBML doctype '%s'\\n\", ebml.doctype);\n\n    }\n\n    ebml_free(ebml_syntax, &ebml);\n\n\n\n    /* The next thing is a segment. */\n\n    pos = avio_tell(matroska->ctx->pb);\n\n    res = ebml_parse(matroska, matroska_segments, matroska);\n\n    // try resyncing until we find a EBML_STOP type element.\n\n    while (res != 1) {\n\n        res = matroska_resync(matroska, pos);\n\n        if (res < 0)\n\n            return res;\n\n        pos = avio_tell(matroska->ctx->pb);\n\n        res = ebml_parse(matroska, matroska_segment, matroska);\n\n    }\n\n    matroska_execute_seekhead(matroska);\n\n\n\n    if (!matroska->time_scale)\n\n        matroska->time_scale = 1000000;\n\n    if (matroska->duration)\n\n        matroska->ctx->duration = matroska->duration * matroska->time_scale\n\n                                  * 1000 / AV_TIME_BASE;\n\n    av_dict_set(&s->metadata, \"title\", matroska->title, 0);\n\n\n\n    if (matroska->date_utc.size == 8)\n\n        matroska_metadata_creation_time(&s->metadata, AV_RB64(matroska->date_utc.data));\n\n\n\n    tracks = matroska->tracks.elem;\n\n    for (i=0; i < matroska->tracks.nb_elem; i++) {\n\n        MatroskaTrack *track = &tracks[i];\n\n        enum CodecID codec_id = CODEC_ID_NONE;\n\n        EbmlList *encodings_list = &track->encodings;\n\n        MatroskaTrackEncoding *encodings = encodings_list->elem;\n\n        uint8_t *extradata = NULL;\n\n        int extradata_size = 0;\n\n        int extradata_offset = 0;\n\n        uint32_t fourcc = 0;\n\n        AVIOContext b;\n\n\n\n        /* Apply some sanity checks. */\n\n        if (track->type != MATROSKA_TRACK_TYPE_VIDEO &&\n\n            track->type != MATROSKA_TRACK_TYPE_AUDIO &&\n\n            track->type != MATROSKA_TRACK_TYPE_SUBTITLE) {\n\n            av_log(matroska->ctx, AV_LOG_INFO,\n\n                   \"Unknown or unsupported track type %\"PRIu64\"\\n\",\n\n                   track->type);\n\n            continue;\n\n        }\n\n        if (track->codec_id == NULL)\n\n            continue;\n\n\n\n        if (track->type == MATROSKA_TRACK_TYPE_VIDEO) {\n\n            if (!track->default_duration)\n\n                track->default_duration = 1000000000/track->video.frame_rate;\n\n            if (!track->video.display_width)\n\n                track->video.display_width = track->video.pixel_width;\n\n            if (!track->video.display_height)\n\n                track->video.display_height = track->video.pixel_height;\n\n            if (track->video.color_space.size == 4)\n\n                fourcc = AV_RL32(track->video.color_space.data);\n\n        } else if (track->type == MATROSKA_TRACK_TYPE_AUDIO) {\n\n            if (!track->audio.out_samplerate)\n\n                track->audio.out_samplerate = track->audio.samplerate;\n\n        }\n\n        if (encodings_list->nb_elem > 1) {\n\n            av_log(matroska->ctx, AV_LOG_ERROR,\n\n                   \"Multiple combined encodings not supported\");\n\n        } else if (encodings_list->nb_elem == 1) {\n\n            if (encodings[0].type ||\n\n                (encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_HEADERSTRIP &&\n\n#if CONFIG_ZLIB\n\n                 encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_ZLIB &&\n\n#endif\n\n#if CONFIG_BZLIB\n\n                 encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_BZLIB &&\n\n#endif\n\n                 encodings[0].compression.algo != MATROSKA_TRACK_ENCODING_COMP_LZO)) {\n\n                encodings[0].scope = 0;\n\n                av_log(matroska->ctx, AV_LOG_ERROR,\n\n                       \"Unsupported encoding type\");\n\n            } else if (track->codec_priv.size && encodings[0].scope&2) {\n\n                uint8_t *codec_priv = track->codec_priv.data;\n\n                int offset = matroska_decode_buffer(&track->codec_priv.data,\n\n                                                    &track->codec_priv.size,\n\n                                                    track);\n\n                if (offset < 0) {\n\n                    track->codec_priv.data = NULL;\n\n                    track->codec_priv.size = 0;\n\n                    av_log(matroska->ctx, AV_LOG_ERROR,\n\n                           \"Failed to decode codec private data\\n\");\n\n                } else if (offset > 0) {\n\n                    track->codec_priv.data = av_malloc(track->codec_priv.size + offset);\n\n                    memcpy(track->codec_priv.data,\n\n                           encodings[0].compression.settings.data, offset);\n\n                    memcpy(track->codec_priv.data+offset, codec_priv,\n\n                           track->codec_priv.size);\n\n                    track->codec_priv.size += offset;\n\n                }\n\n                if (codec_priv != track->codec_priv.data)\n\n                    av_free(codec_priv);\n\n            }\n\n        }\n\n\n\n        for(j=0; ff_mkv_codec_tags[j].id != CODEC_ID_NONE; j++){\n\n            if(!strncmp(ff_mkv_codec_tags[j].str, track->codec_id,\n\n                        strlen(ff_mkv_codec_tags[j].str))){\n\n                codec_id= ff_mkv_codec_tags[j].id;\n\n                break;\n\n            }\n\n        }\n\n\n\n        st = track->stream = avformat_new_stream(s, NULL);\n\n        if (st == NULL)\n\n            return AVERROR(ENOMEM);\n\n\n\n        if (!strcmp(track->codec_id, \"V_MS/VFW/FOURCC\")\n\n            && track->codec_priv.size >= 40\n\n            && track->codec_priv.data != NULL) {\n\n            track->ms_compat = 1;\n\n            fourcc = AV_RL32(track->codec_priv.data + 16);\n\n            codec_id = ff_codec_get_id(ff_codec_bmp_tags, fourcc);\n\n            extradata_offset = 40;\n\n        } else if (!strcmp(track->codec_id, \"A_MS/ACM\")\n\n                   && track->codec_priv.size >= 14\n\n                   && track->codec_priv.data != NULL) {\n\n            int ret;\n\n            ffio_init_context(&b, track->codec_priv.data, track->codec_priv.size,\n\n                          AVIO_FLAG_READ, NULL, NULL, NULL, NULL);\n\n            ret = ff_get_wav_header(&b, st->codec, track->codec_priv.size);\n\n            if (ret < 0)\n\n                return ret;\n\n            codec_id = st->codec->codec_id;\n\n            extradata_offset = FFMIN(track->codec_priv.size, 18);\n\n        } else if (!strcmp(track->codec_id, \"V_QUICKTIME\")\n\n                   && (track->codec_priv.size >= 86)\n\n                   && (track->codec_priv.data != NULL)) {\n\n            fourcc = AV_RL32(track->codec_priv.data);\n\n            codec_id = ff_codec_get_id(ff_codec_movvideo_tags, fourcc);\n\n        } else if (codec_id == CODEC_ID_PCM_S16BE) {\n\n            switch (track->audio.bitdepth) {\n\n            case  8:  codec_id = CODEC_ID_PCM_U8;     break;\n\n            case 24:  codec_id = CODEC_ID_PCM_S24BE;  break;\n\n            case 32:  codec_id = CODEC_ID_PCM_S32BE;  break;\n\n            }\n\n        } else if (codec_id == CODEC_ID_PCM_S16LE) {\n\n            switch (track->audio.bitdepth) {\n\n            case  8:  codec_id = CODEC_ID_PCM_U8;     break;\n\n            case 24:  codec_id = CODEC_ID_PCM_S24LE;  break;\n\n            case 32:  codec_id = CODEC_ID_PCM_S32LE;  break;\n\n            }\n\n        } else if (codec_id==CODEC_ID_PCM_F32LE && track->audio.bitdepth==64) {\n\n            codec_id = CODEC_ID_PCM_F64LE;\n\n        } else if (codec_id == CODEC_ID_AAC && !track->codec_priv.size) {\n\n            int profile = matroska_aac_profile(track->codec_id);\n\n            int sri = matroska_aac_sri(track->audio.samplerate);\n\n            extradata = av_mallocz(5 + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if (extradata == NULL)\n\n                return AVERROR(ENOMEM);\n\n            extradata[0] = (profile << 3) | ((sri&0x0E) >> 1);\n\n            extradata[1] = ((sri&0x01) << 7) | (track->audio.channels<<3);\n\n            if (strstr(track->codec_id, \"SBR\")) {\n\n                sri = matroska_aac_sri(track->audio.out_samplerate);\n\n                extradata[2] = 0x56;\n\n                extradata[3] = 0xE5;\n\n                extradata[4] = 0x80 | (sri<<3);\n\n                extradata_size = 5;\n\n            } else\n\n                extradata_size = 2;\n\n        } else if (codec_id == CODEC_ID_TTA) {\n\n            extradata_size = 30;\n\n            extradata = av_mallocz(extradata_size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if (extradata == NULL)\n\n                return AVERROR(ENOMEM);\n\n            ffio_init_context(&b, extradata, extradata_size, 1,\n\n                          NULL, NULL, NULL, NULL);\n\n            avio_write(&b, \"TTA1\", 4);\n\n            avio_wl16(&b, 1);\n\n            avio_wl16(&b, track->audio.channels);\n\n            avio_wl16(&b, track->audio.bitdepth);\n\n            avio_wl32(&b, track->audio.out_samplerate);\n\n            avio_wl32(&b, matroska->ctx->duration * track->audio.out_samplerate);\n\n        } else if (codec_id == CODEC_ID_RV10 || codec_id == CODEC_ID_RV20 ||\n\n                   codec_id == CODEC_ID_RV30 || codec_id == CODEC_ID_RV40) {\n\n            extradata_offset = 26;\n\n        } else if (codec_id == CODEC_ID_RA_144) {\n\n            track->audio.out_samplerate = 8000;\n\n            track->audio.channels = 1;\n\n        } else if (codec_id == CODEC_ID_RA_288 || codec_id == CODEC_ID_COOK ||\n\n                   codec_id == CODEC_ID_ATRAC3 || codec_id == CODEC_ID_SIPR) {\n\n            int flavor;\n\n            ffio_init_context(&b, track->codec_priv.data,track->codec_priv.size,\n\n                          0, NULL, NULL, NULL, NULL);\n\n            avio_skip(&b, 22);\n\n            flavor                       = avio_rb16(&b);\n\n            track->audio.coded_framesize = avio_rb32(&b);\n\n            avio_skip(&b, 12);\n\n            track->audio.sub_packet_h    = avio_rb16(&b);\n\n            track->audio.frame_size      = avio_rb16(&b);\n\n            track->audio.sub_packet_size = avio_rb16(&b);\n\n            track->audio.buf = av_malloc(track->audio.frame_size * track->audio.sub_packet_h);\n\n            if (codec_id == CODEC_ID_RA_288) {\n\n                st->codec->block_align = track->audio.coded_framesize;\n\n                track->codec_priv.size = 0;\n\n            } else {\n\n                if (codec_id == CODEC_ID_SIPR && flavor < 4) {\n\n                    const int sipr_bit_rate[4] = { 6504, 8496, 5000, 16000 };\n\n                    track->audio.sub_packet_size = ff_sipr_subpk_size[flavor];\n\n                    st->codec->bit_rate = sipr_bit_rate[flavor];\n\n                }\n\n                st->codec->block_align = track->audio.sub_packet_size;\n\n                extradata_offset = 78;\n\n            }\n\n        }\n\n        track->codec_priv.size -= extradata_offset;\n\n\n\n        if (codec_id == CODEC_ID_NONE)\n\n            av_log(matroska->ctx, AV_LOG_INFO,\n\n                   \"Unknown/unsupported CodecID %s.\\n\", track->codec_id);\n\n\n\n        if (track->time_scale < 0.01)\n\n            track->time_scale = 1.0;\n\n        avpriv_set_pts_info(st, 64, matroska->time_scale*track->time_scale, 1000*1000*1000); /* 64 bit pts in ns */\n\n\n\n        st->codec->codec_id = codec_id;\n\n        st->start_time = 0;\n\n        if (strcmp(track->language, \"und\"))\n\n            av_dict_set(&st->metadata, \"language\", track->language, 0);\n\n        av_dict_set(&st->metadata, \"title\", track->name, 0);\n\n\n\n        if (track->flag_default)\n\n            st->disposition |= AV_DISPOSITION_DEFAULT;\n\n        if (track->flag_forced)\n\n            st->disposition |= AV_DISPOSITION_FORCED;\n\n\n\n        if (!st->codec->extradata) {\n\n            if(extradata){\n\n                st->codec->extradata = extradata;\n\n                st->codec->extradata_size = extradata_size;\n\n            } else if(track->codec_priv.data && track->codec_priv.size > 0){\n\n                st->codec->extradata = av_mallocz(track->codec_priv.size +\n\n                                                  FF_INPUT_BUFFER_PADDING_SIZE);\n\n                if(st->codec->extradata == NULL)\n\n                    return AVERROR(ENOMEM);\n\n                st->codec->extradata_size = track->codec_priv.size;\n\n                memcpy(st->codec->extradata,\n\n                       track->codec_priv.data + extradata_offset,\n\n                       track->codec_priv.size);\n\n            }\n\n        }\n\n\n\n        if (track->type == MATROSKA_TRACK_TYPE_VIDEO) {\n\n            MatroskaTrackPlane *planes = track->operation.combine_planes.elem;\n\n\n\n            st->codec->codec_type = AVMEDIA_TYPE_VIDEO;\n\n            st->codec->codec_tag  = fourcc;\n\n            st->codec->width  = track->video.pixel_width;\n\n            st->codec->height = track->video.pixel_height;\n\n            av_reduce(&st->sample_aspect_ratio.num,\n\n                      &st->sample_aspect_ratio.den,\n\n                      st->codec->height * track->video.display_width,\n\n                      st->codec-> width * track->video.display_height,\n\n                      255);\n\n            st->need_parsing = AVSTREAM_PARSE_HEADERS;\n\n            if (track->default_duration)\n\n                st->avg_frame_rate = av_d2q(1000000000.0/track->default_duration, INT_MAX);\n\n\n\n            /* export stereo mode flag as metadata tag */\n\n            if (track->video.stereo_mode && track->video.stereo_mode < MATROSKA_VIDEO_STEREO_MODE_COUNT)\n\n                av_dict_set(&st->metadata, \"stereo_mode\", matroska_video_stereo_mode[track->video.stereo_mode], 0);\n\n\n\n            /* if we have virtual track, mark the real tracks */\n\n            for (j=0; j < track->operation.combine_planes.nb_elem; j++) {\n\n                char buf[32];\n\n                if (planes[j].type >= MATROSKA_VIDEO_STEREO_PLANE_COUNT)\n\n                    continue;\n\n                snprintf(buf, sizeof(buf), \"%s_%d\",\n\n                         matroska_video_stereo_plane[planes[j].type], i);\n\n                for (k=0; k < matroska->tracks.nb_elem; k++)\n\n                    if (planes[j].uid == tracks[k].uid) {\n\n                        av_dict_set(&s->streams[k]->metadata,\n\n                                    \"stereo_mode\", buf, 0);\n\n                        break;\n\n                    }\n\n            }\n\n        } else if (track->type == MATROSKA_TRACK_TYPE_AUDIO) {\n\n            st->codec->codec_type = AVMEDIA_TYPE_AUDIO;\n\n            st->codec->sample_rate = track->audio.out_samplerate;\n\n            st->codec->channels = track->audio.channels;\n\n            if (st->codec->codec_id != CODEC_ID_AAC)\n\n            st->need_parsing = AVSTREAM_PARSE_HEADERS;\n\n        } else if (track->type == MATROSKA_TRACK_TYPE_SUBTITLE) {\n\n            st->codec->codec_type = AVMEDIA_TYPE_SUBTITLE;\n\n        }\n\n    }\n\n\n\n    attachements = attachements_list->elem;\n\n    for (j=0; j<attachements_list->nb_elem; j++) {\n\n        if (!(attachements[j].filename && attachements[j].mime &&\n\n              attachements[j].bin.data && attachements[j].bin.size > 0)) {\n\n            av_log(matroska->ctx, AV_LOG_ERROR, \"incomplete attachment\\n\");\n\n        } else {\n\n            AVStream *st = avformat_new_stream(s, NULL);\n\n            if (st == NULL)\n\n                break;\n\n            av_dict_set(&st->metadata, \"filename\",attachements[j].filename, 0);\n\n            av_dict_set(&st->metadata, \"mimetype\", attachements[j].mime, 0);\n\n            st->codec->codec_id = CODEC_ID_NONE;\n\n            st->codec->codec_type = AVMEDIA_TYPE_ATTACHMENT;\n\n            st->codec->extradata  = av_malloc(attachements[j].bin.size + FF_INPUT_BUFFER_PADDING_SIZE);\n\n            if(st->codec->extradata == NULL)\n\n                break;\n\n            st->codec->extradata_size = attachements[j].bin.size;\n\n            memcpy(st->codec->extradata, attachements[j].bin.data, attachements[j].bin.size);\n\n\n\n            for (i=0; ff_mkv_mime_tags[i].id != CODEC_ID_NONE; i++) {\n\n                if (!strncmp(ff_mkv_mime_tags[i].str, attachements[j].mime,\n\n                             strlen(ff_mkv_mime_tags[i].str))) {\n\n                    st->codec->codec_id = ff_mkv_mime_tags[i].id;\n\n                    break;\n\n                }\n\n            }\n\n            attachements[j].stream = st;\n\n        }\n\n    }\n\n\n\n    chapters = chapters_list->elem;\n\n    for (i=0; i<chapters_list->nb_elem; i++)\n\n        if (chapters[i].start != AV_NOPTS_VALUE && chapters[i].uid\n\n            && (max_start==0 || chapters[i].start > max_start)) {\n\n            chapters[i].chapter =\n\n            avpriv_new_chapter(s, chapters[i].uid, (AVRational){1, 1000000000},\n\n                           chapters[i].start, chapters[i].end,\n\n                           chapters[i].title);\n\n            av_dict_set(&chapters[i].chapter->metadata,\n\n                             \"title\", chapters[i].title, 0);\n\n            max_start = chapters[i].start;\n\n        }\n\n\n\n    matroska_add_index_entries(matroska);\n\n\n\n    matroska_convert_tags(s);\n\n\n\n    return 0;\n\n}\n", "idx": 25854}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int filter_frame(AVFilterLink *inlink, AVFrame *picref)\n\n{\n\n    AVFilterContext *ctx = inlink->dst;\n\n    SignatureContext *sic = ctx->priv;\n\n    StreamContext *sc = &(sic->streamcontexts[FF_INLINK_IDX(inlink)]);\n\n    FineSignature* fs;\n\n\n\n    static const uint8_t pot3[5] = { 3*3*3*3, 3*3*3, 3*3, 3, 1 };\n\n    /* indexes of words : 210,217,219,274,334  44,175,233,270,273  57,70,103,237,269  100,285,295,337,354  101,102,111,275,296\n\n    s2usw = sorted to unsorted wordvec: 44 is at index 5, 57 at index 10...\n\n    */\n\n    static const unsigned int wordvec[25] = {44,57,70,100,101,102,103,111,175,210,217,219,233,237,269,270,273,274,275,285,295,296,334,337,354};\n\n    static const uint8_t      s2usw[25]   = { 5,10,11, 15, 20, 21, 12, 22,  6,  0,  1,  2,  7, 13, 14,  8,  9,  3, 23, 16, 17, 24,  4, 18, 19};\n\n\n\n    uint8_t wordt2b[5] = { 0, 0, 0, 0, 0 }; /* word ternary to binary */\n\n    uint64_t intpic[32][32];\n\n    uint64_t rowcount;\n\n    uint8_t *p = picref->data[0];\n\n    int inti, intj;\n\n    int *intjlut;\n\n\n\n    uint64_t conflist[DIFFELEM_SIZE];\n\n    int f = 0, g = 0, w = 0;\n\n    int32_t dh1 = 1, dh2 = 1, dw1 = 1, dw2 = 1, a, b;\n\n    int64_t denom;\n\n    int i, j, k, ternary;\n\n    uint64_t blocksum;\n\n    int blocksize;\n\n    int64_t th; /* threshold */\n\n    int64_t sum;\n\n\n\n    int64_t precfactor = (sc->divide) ? 65536 : BLOCK_LCM;\n\n\n\n    /* initialize fs */\n\n    if (sc->curfinesig) {\n\n        fs = av_mallocz(sizeof(FineSignature));\n\n        if (!fs)\n\n            return AVERROR(ENOMEM);\n\n        sc->curfinesig->next = fs;\n\n        fs->prev = sc->curfinesig;\n\n        sc->curfinesig = fs;\n\n    } else {\n\n        fs = sc->curfinesig = sc->finesiglist;\n\n        sc->curcoarsesig1->first = fs;\n\n    }\n\n\n\n    fs->pts = picref->pts;\n\n    fs->index = sc->lastindex++;\n\n\n\n    memset(intpic, 0, sizeof(uint64_t)*32*32);\n\n    intjlut = av_malloc_array(inlink->w, sizeof(int));\n\n    if (!intjlut)\n\n        return AVERROR(ENOMEM);\n\n    for (i = 0; i < inlink->w; i++) {\n\n        intjlut[i] = (i*32)/inlink->w;\n\n    }\n\n\n\n    for (i = 0; i < inlink->h; i++) {\n\n        inti = (i*32)/inlink->h;\n\n        for (j = 0; j < inlink->w; j++) {\n\n            intj = intjlut[j];\n\n            intpic[inti][intj] += p[j];\n\n        }\n\n        p += picref->linesize[0];\n\n    }\n\n    av_freep(&intjlut);\n\n\n\n    /* The following calculates a summed area table (intpic) and brings the numbers\n\n     * in intpic to the same denominator.\n\n     * So you only have to handle the numinator in the following sections.\n\n     */\n\n    dh1 = inlink->h / 32;\n\n    if (inlink->h % 32)\n\n        dh2 = dh1 + 1;\n\n    dw1 = inlink->w / 32;\n\n    if (inlink->w % 32)\n\n        dw2 = dw1 + 1;\n\n    denom = (sc->divide) ? dh1 * dh2 * dw1 * dw2 : 1;\n\n\n\n    for (i = 0; i < 32; i++) {\n\n        rowcount = 0;\n\n        a = 1;\n\n        if (dh2 > 1) {\n\n            a = ((inlink->h*(i+1))%32 == 0) ? (inlink->h*(i+1))/32 - 1 : (inlink->h*(i+1))/32;\n\n            a -= ((inlink->h*i)%32 == 0) ? (inlink->h*i)/32 - 1 : (inlink->h*i)/32;\n\n            a = (a == dh1)? dh2 : dh1;\n\n        }\n\n        for (j = 0; j < 32; j++) {\n\n            b = 1;\n\n            if (dw2 > 1) {\n\n                b = ((inlink->w*(j+1))%32 == 0) ? (inlink->w*(j+1))/32 - 1 : (inlink->w*(j+1))/32;\n\n                b -= ((inlink->w*j)%32 == 0) ? (inlink->w*j)/32 - 1 : (inlink->w*j)/32;\n\n                b = (b == dw1)? dw2 : dw1;\n\n            }\n\n            rowcount += intpic[i][j] * a * b * precfactor / denom;\n\n            if (i > 0) {\n\n                intpic[i][j] = intpic[i-1][j] + rowcount;\n\n            } else {\n\n                intpic[i][j] = rowcount;\n\n            }\n\n        }\n\n    }\n\n\n\n    denom = (sc->divide) ? 1 : dh1 * dh2 * dw1 * dw2;\n\n\n\n    for (i = 0; i < ELEMENT_COUNT; i++) {\n\n        const ElemCat* elemcat = elements[i];\n\n        int64_t* elemsignature;\n\n        uint64_t* sortsignature;\n\n\n\n        elemsignature = av_malloc_array(elemcat->elem_count, sizeof(int64_t));\n\n        if (!elemsignature)\n\n            return AVERROR(ENOMEM);\n\n        sortsignature = av_malloc_array(elemcat->elem_count, sizeof(int64_t));\n\n        if (!sortsignature)\n\n            return AVERROR(ENOMEM);\n\n\n\n        for (j = 0; j < elemcat->elem_count; j++) {\n\n            blocksum = 0;\n\n            blocksize = 0;\n\n            for (k = 0; k < elemcat->left_count; k++) {\n\n                blocksum += get_block_sum(sc, intpic, &elemcat->blocks[j*elemcat->block_count+k]);\n\n                blocksize += get_block_size(&elemcat->blocks[j*elemcat->block_count+k]);\n\n            }\n\n            sum = blocksum / blocksize;\n\n            if (elemcat->av_elem) {\n\n                sum -= 128 * precfactor * denom;\n\n            } else {\n\n                blocksum = 0;\n\n                blocksize = 0;\n\n                for (; k < elemcat->block_count; k++) {\n\n                    blocksum += get_block_sum(sc, intpic, &elemcat->blocks[j*elemcat->block_count+k]);\n\n                    blocksize += get_block_size(&elemcat->blocks[j*elemcat->block_count+k]);\n\n                }\n\n                sum -= blocksum / blocksize;\n\n                conflist[g++] = FFABS(sum * 8 / (precfactor * denom));\n\n            }\n\n\n\n            elemsignature[j] = sum;\n\n            sortsignature[j] = FFABS(sum);\n\n        }\n\n\n\n        /* get threshold */\n\n        qsort(sortsignature, elemcat->elem_count, sizeof(uint64_t), (void*) cmp);\n\n        th = sortsignature[(int) (elemcat->elem_count*0.333)];\n\n\n\n        /* ternarize */\n\n        for (j = 0; j < elemcat->elem_count; j++) {\n\n            if (elemsignature[j] < -th) {\n\n                ternary = 0;\n\n            } else if (elemsignature[j] <= th) {\n\n                ternary = 1;\n\n            } else {\n\n                ternary = 2;\n\n            }\n\n            fs->framesig[f/5] += ternary * pot3[f%5];\n\n\n\n            if (f == wordvec[w]) {\n\n                fs->words[s2usw[w]/5] += ternary * pot3[wordt2b[s2usw[w]/5]++];\n\n                if (w < 24)\n\n                    w++;\n\n            }\n\n            f++;\n\n        }\n\n        av_freep(&elemsignature);\n\n        av_freep(&sortsignature);\n\n    }\n\n\n\n    /* confidence */\n\n    qsort(conflist, DIFFELEM_SIZE, sizeof(uint64_t), (void*) cmp);\n\n    fs->confidence = FFMIN(conflist[DIFFELEM_SIZE/2], 255);\n\n\n\n    /* coarsesignature */\n\n    if (sc->coarsecount == 0) {\n\n        if (sc->curcoarsesig2) {\n\n            sc->curcoarsesig1 = av_mallocz(sizeof(CoarseSignature));\n\n            if (!sc->curcoarsesig1)\n\n                return AVERROR(ENOMEM);\n\n            sc->curcoarsesig1->first = fs;\n\n            sc->curcoarsesig2->next = sc->curcoarsesig1;\n\n            sc->coarseend = sc->curcoarsesig1;\n\n        }\n\n    }\n\n    if (sc->coarsecount == 45) {\n\n        sc->midcoarse = 1;\n\n        sc->curcoarsesig2 = av_mallocz(sizeof(CoarseSignature));\n\n        if (!sc->curcoarsesig2)\n\n            return AVERROR(ENOMEM);\n\n        sc->curcoarsesig2->first = fs;\n\n        sc->curcoarsesig1->next = sc->curcoarsesig2;\n\n        sc->coarseend = sc->curcoarsesig2;\n\n    }\n\n    for (i = 0; i < 5; i++) {\n\n        set_bit(sc->curcoarsesig1->data[i], fs->words[i]);\n\n    }\n\n    /* assuming the actual frame is the last */\n\n    sc->curcoarsesig1->last = fs;\n\n    if (sc->midcoarse) {\n\n        for (i = 0; i < 5; i++) {\n\n            set_bit(sc->curcoarsesig2->data[i], fs->words[i]);\n\n        }\n\n        sc->curcoarsesig2->last = fs;\n\n    }\n\n\n\n    sc->coarsecount = (sc->coarsecount+1)%90;\n\n\n\n    /* debug printing finesignature */\n\n    if (av_log_get_level() == AV_LOG_DEBUG) {\n\n        av_log(ctx, AV_LOG_DEBUG, \"input %d, confidence: %d\\n\", FF_INLINK_IDX(inlink), fs->confidence);\n\n\n\n        av_log(ctx, AV_LOG_DEBUG, \"words:\");\n\n        for (i = 0; i < 5; i++) {\n\n            av_log(ctx, AV_LOG_DEBUG, \" %d:\", fs->words[i] );\n\n            av_log(ctx, AV_LOG_DEBUG, \" %d\", fs->words[i] / pot3[0] );\n\n            for (j = 1; j < 5; j++)\n\n                av_log(ctx, AV_LOG_DEBUG, \",%d\", fs->words[i] % pot3[j-1] / pot3[j] );\n\n            av_log(ctx, AV_LOG_DEBUG, \";\");\n\n        }\n\n        av_log(ctx, AV_LOG_DEBUG, \"\\n\");\n\n\n\n        av_log(ctx, AV_LOG_DEBUG, \"framesignature:\");\n\n        for (i = 0; i < SIGELEM_SIZE/5; i++) {\n\n            av_log(ctx, AV_LOG_DEBUG, \" %d\", fs->framesig[i] / pot3[0] );\n\n            for (j = 1; j < 5; j++)\n\n                av_log(ctx, AV_LOG_DEBUG, \",%d\", fs->framesig[i] % pot3[j-1] / pot3[j] );\n\n        }\n\n        av_log(ctx, AV_LOG_DEBUG, \"\\n\");\n\n    }\n\n\n\n    if (FF_INLINK_IDX(inlink) == 0)\n\n        return ff_filter_frame(inlink->dst->outputs[0], picref);\n\n    return 1;\n\n}\n", "idx": 25859}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void test_dma_fragmented(void)\n\n{\n\n    AHCIQState *ahci;\n\n    AHCICommand *cmd;\n\n    uint8_t px;\n\n    size_t bufsize = 4096;\n\n    unsigned char *tx = g_malloc(bufsize);\n\n    unsigned char *rx = g_malloc0(bufsize);\n\n    uint64_t ptr;\n\n\n\n    ahci = ahci_boot_and_enable(NULL);\n\n    px = ahci_port_select(ahci);\n\n    ahci_port_clear(ahci, px);\n\n\n\n    /* create pattern */\n\n    generate_pattern(tx, bufsize, AHCI_SECTOR_SIZE);\n\n\n\n    /* Create a DMA buffer in guest memory, and write our pattern to it. */\n\n    ptr = guest_alloc(ahci->parent->alloc, bufsize);\n\n    g_assert(ptr);\n\n    bufwrite(ptr, tx, bufsize);\n\n\n\n    cmd = ahci_command_create(CMD_WRITE_DMA);\n\n    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);\n\n    ahci_command_commit(ahci, cmd, px);\n\n    ahci_command_issue(ahci, cmd);\n\n    ahci_command_verify(ahci, cmd);\n\n    g_free(cmd);\n\n\n\n    cmd = ahci_command_create(CMD_READ_DMA);\n\n    ahci_command_adjust(cmd, 0, ptr, bufsize, 32);\n\n    ahci_command_commit(ahci, cmd, px);\n\n    ahci_command_issue(ahci, cmd);\n\n    ahci_command_verify(ahci, cmd);\n\n    g_free(cmd);\n\n\n\n    /* Read back the guest's receive buffer into local memory */\n\n    bufread(ptr, rx, bufsize);\n\n    guest_free(ahci->parent->alloc, ptr);\n\n\n\n    g_assert_cmphex(memcmp(tx, rx, bufsize), ==, 0);\n\n\n\n    ahci_shutdown(ahci);\n\n\n\n    g_free(rx);\n\n    g_free(tx);\n\n}\n", "idx": 25862}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int w64_read_header(AVFormatContext *s, AVFormatParameters *ap)\n\n{\n\n    int64_t size;\n\n    AVIOContext *pb  = s->pb;\n\n    WAVContext    *wav = s->priv_data;\n\n    AVStream *st;\n\n    uint8_t guid[16];\n\n\n\n    avio_read(pb, guid, 16);\n\n    if (memcmp(guid, guid_riff, 16))\n\n        return -1;\n\n\n\n    if (avio_rl64(pb) < 16 + 8 + 16 + 8 + 16 + 8) /* riff + wave + fmt + sizes */\n\n        return -1;\n\n\n\n    avio_read(pb, guid, 16);\n\n    if (memcmp(guid, guid_wave, 16)) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find wave guid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    size = find_guid(pb, guid_fmt);\n\n    if (size < 0) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find fmt guid\\n\");\n\n        return -1;\n\n    }\n\n\n\n    st = av_new_stream(s, 0);\n\n    if (!st)\n\n        return AVERROR(ENOMEM);\n\n\n\n    /* subtract chunk header size - normal wav file doesn't count it */\n\n    ff_get_wav_header(pb, st->codec, size - 24);\n\n    avio_skip(pb, FFALIGN(size, INT64_C(8)) - size);\n\n\n\n    st->need_parsing = AVSTREAM_PARSE_FULL;\n\n\n\n    av_set_pts_info(st, 64, 1, st->codec->sample_rate);\n\n\n\n    size = find_guid(pb, guid_data);\n\n    if (size < 0) {\n\n        av_log(s, AV_LOG_ERROR, \"could not find data guid\\n\");\n\n        return -1;\n\n    }\n\n    wav->data_end = avio_tell(pb) + size - 24;\n\n    wav->w64      = 1;\n\n\n\n    return 0;\n\n}\n", "idx": 25868}, {"project": "test", "commit_id": "test", "target": 1, "func": "void rgb15tobgr15(const uint8_t *src, uint8_t *dst, long src_size)\n\n{\n\n\tlong i;\n\n\tlong num_pixels = src_size >> 1;\n\n\n\n\tfor(i=0; i<num_pixels; i++)\n\n\t{\n\n\t    unsigned b,g,r;\n\n\t    register uint16_t rgb;\n\n\t    rgb = src[2*i];\n\n\t    r = rgb&0x1F;\n\n\t    g = (rgb&0x3E0)>>5;\n\n\t    b = (rgb&0x7C00)>>10;\n\n\t    dst[2*i] = (b&0x1F) | ((g&0x1F)<<5) | ((r&0x1F)<<10);\n\n\t}\n\n}\n", "idx": 25869}, {"project": "test", "commit_id": "test", "target": 1, "func": "int vnc_job_add_rect(VncJob *job, int x, int y, int w, int h)\n\n{\n\n    VncRectEntry *entry = g_malloc0(sizeof(VncRectEntry));\n\n\n\n    entry->rect.x = x;\n\n    entry->rect.y = y;\n\n    entry->rect.w = w;\n\n    entry->rect.h = h;\n\n\n\n    vnc_lock_queue(queue);\n\n    QLIST_INSERT_HEAD(&job->rectangles, entry, next);\n\n    vnc_unlock_queue(queue);\n\n    return 1;\n\n}\n", "idx": 25872}, {"project": "test", "commit_id": "test", "target": 1, "func": "int ff_ass_split_override_codes(const ASSCodesCallbacks *callbacks, void *priv,\n\n                                const char *buf)\n\n{\n\n    const char *text = NULL;\n\n    char new_line[2];\n\n    int text_len = 0;\n\n\n\n    while (*buf) {\n\n        if (text && callbacks->text &&\n\n            (sscanf(buf, \"\\\\%1[nN]\", new_line) == 1 ||\n\n             !strncmp(buf, \"{\\\\\", 2))) {\n\n            callbacks->text(priv, text, text_len);\n\n            text = NULL;\n\n        }\n\n        if (sscanf(buf, \"\\\\%1[nN]\", new_line) == 1) {\n\n            if (callbacks->new_line)\n\n                callbacks->new_line(priv, new_line[0] == 'N');\n\n            buf += 2;\n\n        } else if (!strncmp(buf, \"{\\\\\", 2)) {\n\n            buf++;\n\n            while (*buf == '\\\\') {\n\n                char style[2], c[2], sep[2], c_num[2] = \"0\", tmp[128] = {0};\n\n                unsigned int color = 0xFFFFFFFF;\n\n                int len, size = -1, an = -1, alpha = -1;\n\n                int x1, y1, x2, y2, t1 = -1, t2 = -1;\n\n                if (sscanf(buf, \"\\\\%1[bisu]%1[01\\\\}]%n\", style, c, &len) > 1) {\n\n                    int close = c[0] == '0' ? 1 : c[0] == '1' ? 0 : -1;\n\n                    len += close != -1;\n\n                    if (callbacks->style)\n\n                        callbacks->style(priv, style[0], close);\n\n                } else if (sscanf(buf, \"\\\\c%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\c&H%X&%1[\\\\}]%n\", &color, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]c%1[\\\\}]%n\", c_num, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]c&H%X&%1[\\\\}]%n\", c_num, &color, sep, &len) > 2) {\n\n                    if (callbacks->color)\n\n                        callbacks->color(priv, color, c_num[0] - '0');\n\n                } else if (sscanf(buf, \"\\\\alpha%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\alpha&H%2X&%1[\\\\}]%n\", &alpha, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]a%1[\\\\}]%n\", c_num, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\%1[1234]a&H%2X&%1[\\\\}]%n\", c_num, &alpha, sep, &len) > 2) {\n\n                    if (callbacks->alpha)\n\n                        callbacks->alpha(priv, alpha, c_num[0] - '0');\n\n                } else if (sscanf(buf, \"\\\\fn%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\fn%127[^\\\\}]%1[\\\\}]%n\", tmp, sep, &len) > 1) {\n\n                    if (callbacks->font_name)\n\n                        callbacks->font_name(priv, tmp[0] ? tmp : NULL);\n\n                } else if (sscanf(buf, \"\\\\fs%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\fs%u%1[\\\\}]%n\", &size, sep, &len) > 1) {\n\n                    if (callbacks->font_size)\n\n                        callbacks->font_size(priv, size);\n\n                } else if (sscanf(buf, \"\\\\a%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\a%2u%1[\\\\}]%n\", &an, sep, &len) > 1 ||\n\n                           sscanf(buf, \"\\\\an%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\an%1u%1[\\\\}]%n\", &an, sep, &len) > 1) {\n\n                    if (an != -1 && buf[2] != 'n')\n\n                        an = (an&3) + (an&4 ? 6 : an&8 ? 3 : 0);\n\n                    if (callbacks->alignment)\n\n                        callbacks->alignment(priv, an);\n\n                } else if (sscanf(buf, \"\\\\r%1[\\\\}]%n\", sep, &len) > 0 ||\n\n                           sscanf(buf, \"\\\\r%127[^\\\\}]%1[\\\\}]%n\", tmp, sep, &len) > 1) {\n\n                    if (callbacks->cancel_overrides)\n\n                        callbacks->cancel_overrides(priv, tmp);\n\n                } else if (sscanf(buf, \"\\\\move(%d,%d,%d,%d)%1[\\\\}]%n\", &x1, &y1, &x2, &y2, sep, &len) > 4 ||\n\n                           sscanf(buf, \"\\\\move(%d,%d,%d,%d,%d,%d)%1[\\\\}]%n\", &x1, &y1, &x2, &y2, &t1, &t2, sep, &len) > 6) {\n\n                    if (callbacks->move)\n\n                        callbacks->move(priv, x1, y1, x2, y2, t1, t2);\n\n                } else if (sscanf(buf, \"\\\\pos(%d,%d)%1[\\\\}]%n\", &x1, &y1, sep, &len) > 2) {\n\n                    if (callbacks->move)\n\n                        callbacks->move(priv, x1, y1, x1, y1, -1, -1);\n\n                } else if (sscanf(buf, \"\\\\org(%d,%d)%1[\\\\}]%n\", &x1, &y1, sep, &len) > 2) {\n\n                    if (callbacks->origin)\n\n                        callbacks->origin(priv, x1, y1);\n\n                } else {\n\n                    len = strcspn(buf+1, \"\\\\}\") + 2;  /* skip unknown code */\n\n                }\n\n                buf += len - 1;\n\n            }\n\n            if (*buf++ != '}')\n\n                return AVERROR_INVALIDDATA;\n\n        } else {\n\n            if (!text) {\n\n                text = buf;\n\n                text_len = 1;\n\n            } else\n\n                text_len++;\n\n            buf++;\n\n        }\n\n    }\n\n    if (text && callbacks->text)\n\n        callbacks->text(priv, text, text_len);\n\n    if (callbacks->end)\n\n        callbacks->end(priv);\n\n    return 0;\n\n}\n", "idx": 26031}, {"project": "test", "commit_id": "test", "target": 1, "func": "long do_sigreturn(CPUSH4State *regs)\n\n{\n\n    struct target_sigframe *frame;\n\n    abi_ulong frame_addr;\n\n    sigset_t blocked;\n\n    target_sigset_t target_set;\n\n    target_ulong r0;\n\n    int i;\n\n    int err = 0;\n\n\n\n#if defined(DEBUG_SIGNAL)\n\n    fprintf(stderr, \"do_sigreturn\\n\");\n\n#endif\n\n    frame_addr = regs->gregs[15];\n\n    if (!lock_user_struct(VERIFY_READ, frame, frame_addr, 1))\n\n   \tgoto badframe;\n\n\n\n    __get_user(target_set.sig[0], &frame->sc.oldmask);\n\n    for(i = 1; i < TARGET_NSIG_WORDS; i++) {\n\n        __get_user(target_set.sig[i], &frame->extramask[i - 1]);\n\n    }\n\n\n\n    if (err)\n\n        goto badframe;\n\n\n\n    target_to_host_sigset_internal(&blocked, &target_set);\n\n    do_sigprocmask(SIG_SETMASK, &blocked, NULL);\n\n\n\n    if (restore_sigcontext(regs, &frame->sc, &r0))\n\n        goto badframe;\n\n\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    return r0;\n\n\n\nbadframe:\n\n    unlock_user_struct(frame, frame_addr, 0);\n\n    force_sig(TARGET_SIGSEGV);\n\n    return 0;\n\n}\n", "idx": 26234}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int decode_5(SANMVideoContext *ctx)\n\n{\n\n#if HAVE_BIGENDIAN\n\n    uint16_t *frm;\n\n    int npixels;\n\n#endif\n\n    uint8_t *dst = (uint8_t*)ctx->frm0;\n\n\n\n    if (rle_decode(ctx, dst, ctx->buf_size))\n\n        return AVERROR_INVALIDDATA;\n\n\n\n#if HAVE_BIGENDIAN\n\n    npixels = ctx->npixels;\n\n    frm = ctx->frm0;\n\n    while (npixels--)\n\n        *frm++ = av_bswap16(*frm);\n\n#endif\n\n\n\n    return 0;\n\n}\n", "idx": 26294}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void aux_bridge_init(Object *obj)\n\n{\n\n    AUXTOI2CState *s = AUXTOI2C(obj);\n\n\n\n    s->i2c_bus = i2c_init_bus(DEVICE(obj), \"aux-i2c\");\n\n}\n", "idx": 26306}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void bdrv_co_drain_bh_cb(void *opaque)\n\n{\n\n    BdrvCoDrainData *data = opaque;\n\n    Coroutine *co = data->co;\n\n\n\n    qemu_bh_delete(data->bh);\n\n    bdrv_drain_poll(data->bs);\n\n    data->done = true;\n\n    qemu_coroutine_enter(co, NULL);\n\n}\n", "idx": 26315}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int qcow2_create2(const char *filename, int64_t total_size,\n                         const char *backing_file, const char *backing_format,\n                         int flags, size_t cluster_size, int prealloc,\n                         QEMUOptionParameter *options, int version,\n                         Error **errp)\n{\n    /* Calculate cluster_bits */\n    int cluster_bits;\n    cluster_bits = ffs(cluster_size) - 1;\n    if (cluster_bits < MIN_CLUSTER_BITS || cluster_bits > MAX_CLUSTER_BITS ||\n        (1 << cluster_bits) != cluster_size)\n    {\n        error_setg(errp, \"Cluster size must be a power of two between %d and \"\n                   \"%dk\", 1 << MIN_CLUSTER_BITS, 1 << (MAX_CLUSTER_BITS - 10));\n        return -EINVAL;\n    /*\n     * Open the image file and write a minimal qcow2 header.\n     *\n     * We keep things simple and start with a zero-sized image. We also\n     * do without refcount blocks or a L1 table for now. We'll fix the\n     * inconsistency later.\n     *\n     * We do need a refcount table because growing the refcount table means\n     * allocating two new refcount blocks - the seconds of which would be at\n     * 2 GB for 64k clusters, and we don't want to have a 2 GB initial file\n     * size for any qcow2 image.\n     */\n    BlockDriverState* bs;\n    QCowHeader header;\n    uint8_t* refcount_table;\n    Error *local_err = NULL;\n    int ret;\n    ret = bdrv_create_file(filename, options, &local_err);\n    if (ret < 0) {\n        return ret;\n    ret = bdrv_file_open(&bs, filename, NULL, BDRV_O_RDWR, &local_err);\n    if (ret < 0) {\n        return ret;\n    /* Write the header */\n    memset(&header, 0, sizeof(header));\n    header.magic = cpu_to_be32(QCOW_MAGIC);\n    header.version = cpu_to_be32(version);\n    header.cluster_bits = cpu_to_be32(cluster_bits);\n    header.size = cpu_to_be64(0);\n    header.l1_table_offset = cpu_to_be64(0);\n    header.l1_size = cpu_to_be32(0);\n    header.refcount_table_offset = cpu_to_be64(cluster_size);\n    header.refcount_table_clusters = cpu_to_be32(1);\n    header.refcount_order = cpu_to_be32(3 + REFCOUNT_SHIFT);\n    header.header_length = cpu_to_be32(sizeof(header));\n    if (flags & BLOCK_FLAG_ENCRYPT) {\n        header.crypt_method = cpu_to_be32(QCOW_CRYPT_AES);\n    } else {\n        header.crypt_method = cpu_to_be32(QCOW_CRYPT_NONE);\n    if (flags & BLOCK_FLAG_LAZY_REFCOUNTS) {\n        header.compatible_features |=\n            cpu_to_be64(QCOW2_COMPAT_LAZY_REFCOUNTS);\n    ret = bdrv_pwrite(bs, 0, &header, sizeof(header));\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not write qcow2 header\");\n    /* Write an empty refcount table */\n    refcount_table = g_malloc0(cluster_size);\n    ret = bdrv_pwrite(bs, cluster_size, refcount_table, cluster_size);\n    g_free(refcount_table);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not write refcount table\");\n    /*\n     * And now open the image and make it consistent first (i.e. increase the\n     * refcount of the cluster that is occupied by the header and the refcount\n     * table)\n     */\n    BlockDriver* drv = bdrv_find_format(\"qcow2\");\n    assert(drv != NULL);\n        BDRV_O_RDWR | BDRV_O_CACHE_WB | BDRV_O_NO_FLUSH, drv, &local_err);\n    if (ret < 0) {\n    ret = qcow2_alloc_clusters(bs, 2 * cluster_size);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not allocate clusters for qcow2 \"\n                         \"header and refcount table\");\n    } else if (ret != 0) {\n        error_report(\"Huh, first cluster in empty image is already in use?\");\n        abort();\n    /* Okay, now that we have a valid image, let's give it the right size */\n    ret = bdrv_truncate(bs, total_size * BDRV_SECTOR_SIZE);\n    if (ret < 0) {\n        error_setg_errno(errp, -ret, \"Could not resize image\");\n    /* Want a backing file? There you go.*/\n    if (backing_file) {\n        ret = bdrv_change_backing_file(bs, backing_file, backing_format);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not assign backing file '%s' \"\n                             \"with format '%s'\", backing_file, backing_format);\n    /* And if we're supposed to preallocate metadata, do that now */\n    if (prealloc) {\n        BDRVQcowState *s = bs->opaque;\n        qemu_co_mutex_lock(&s->lock);\n        ret = preallocate(bs);\n        qemu_co_mutex_unlock(&s->lock);\n        if (ret < 0) {\n            error_setg_errno(errp, -ret, \"Could not preallocate metadata\");\n    ret = 0;\nout:\n    bdrv_unref(bs);\n    return ret;", "idx": 26388}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline void hyscale_fast_c(SwsContext *c, int16_t *dst, int dstWidth,\n\n                                  const uint8_t *src, int srcW, int xInc)\n\n{\n\n    int i;\n\n    unsigned int xpos=0;\n\n    for (i=0;i<dstWidth;i++) {\n\n        register unsigned int xx=xpos>>16;\n\n        register unsigned int xalpha=(xpos&0xFFFF)>>9;\n\n        dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*xalpha;\n\n        xpos+=xInc;\n\n    }\n\n\n\n}", "idx": 26435}, {"project": "test", "commit_id": "test", "target": 1, "func": "static TCGv_i64 gen_addq_msw(TCGv_i64 a, TCGv b)\n\n{\n\n    TCGv_i64 tmp64 = tcg_temp_new_i64();\n\n\n\n    tcg_gen_extu_i32_i64(tmp64, b);\n\n    dead_tmp(b);\n\n    tcg_gen_shli_i64(tmp64, tmp64, 32);\n\n    tcg_gen_add_i64(a, tmp64, a);\n\n\n\n    tcg_temp_free_i64(tmp64);\n\n    return a;\n\n}\n", "idx": 26531}, {"project": "test", "commit_id": "test", "target": 1, "func": "static inline int wv_get_value_integer(WavpackFrameContext *s, uint32_t *crc, int S)\n\n{\n\n    int bit;\n\n\n\n    if(s->extra_bits){\n\n        S <<= s->extra_bits;\n\n\n\n        if(s->got_extra_bits){\n\n            S |= get_bits(&s->gb_extra_bits, s->extra_bits);\n\n            *crc = *crc * 9 + (S&0xffff) * 3 + ((unsigned)S>>16);\n\n        }\n\n    }\n\n    bit = (S & s->and) | s->or;\n\n    return (((S + bit) << s->shift) - bit) << s->post_shift;\n\n}\n", "idx": 26559}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int bt_hid_in(struct bt_hid_device_s *s)\n\n{\n\n    USBPacket p;\n\n\n\n    p.pid = USB_TOKEN_IN;\n\n    p.devep = 1;\n\n    p.data = s->datain.buffer;\n\n    p.len = sizeof(s->datain.buffer);\n\n    s->datain.len = s->usbdev->info->handle_data(s->usbdev, &p);\n\n\n\n    return s->datain.len;\n\n}\n", "idx": 26642}, {"project": "test", "commit_id": "test", "target": 1, "func": "VncJob *vnc_job_new(VncState *vs)\n\n{\n\n    VncJob *job = g_malloc0(sizeof(VncJob));\n\n\n\n    job->vs = vs;\n\n    vnc_lock_queue(queue);\n\n    QLIST_INIT(&job->rectangles);\n\n    vnc_unlock_queue(queue);\n\n    return job;\n\n}\n", "idx": 26738}, {"project": "test", "commit_id": "test", "target": 1, "func": "static uint16_t nvme_create_sq(NvmeCtrl *n, NvmeCmd *cmd)\n\n{\n\n    NvmeSQueue *sq;\n\n    NvmeCreateSq *c = (NvmeCreateSq *)cmd;\n\n\n\n    uint16_t cqid = le16_to_cpu(c->cqid);\n\n    uint16_t sqid = le16_to_cpu(c->sqid);\n\n    uint16_t qsize = le16_to_cpu(c->qsize);\n\n    uint16_t qflags = le16_to_cpu(c->sq_flags);\n\n    uint64_t prp1 = le64_to_cpu(c->prp1);\n\n\n\n    if (!cqid || nvme_check_cqid(n, cqid)) {\n\n        return NVME_INVALID_CQID | NVME_DNR;\n\n    }\n\n    if (!sqid || !nvme_check_sqid(n, sqid)) {\n\n        return NVME_INVALID_QID | NVME_DNR;\n\n    }\n\n    if (!qsize || qsize > NVME_CAP_MQES(n->bar.cap)) {\n\n        return NVME_MAX_QSIZE_EXCEEDED | NVME_DNR;\n\n    }\n\n    if (!prp1 || prp1 & (n->page_size - 1)) {\n\n        return NVME_INVALID_FIELD | NVME_DNR;\n\n    }\n\n    if (!(NVME_SQ_FLAGS_PC(qflags))) {\n\n        return NVME_INVALID_FIELD | NVME_DNR;\n\n    }\n\n    sq = g_malloc0(sizeof(*sq));\n\n    nvme_init_sq(sq, n, prp1, sqid, cqid, qsize + 1);\n\n    return NVME_SUCCESS;\n\n}\n", "idx": 26749}, {"project": "test", "commit_id": "test", "target": 1, "func": "static CharDriverState *qemu_chr_open_pipe(ChardevHostdev *opts)\n\n{\n\n    const char *filename = opts->device;\n\n    CharDriverState *chr;\n\n    WinCharState *s;\n\n\n\n    chr = qemu_chr_alloc();\n\n    s = g_malloc0(sizeof(WinCharState));\n\n    chr->opaque = s;\n\n    chr->chr_write = win_chr_write;\n\n    chr->chr_close = win_chr_close;\n\n\n\n    if (win_chr_pipe_init(chr, filename) < 0) {\n\n        g_free(s);\n\n        g_free(chr);\n\n        return NULL;\n\n    }\n\n    return chr;\n\n}\n", "idx": 26848}, {"project": "test", "commit_id": "test", "target": 1, "func": "void ppc970_irq_init (CPUState *env)\n\n{\n\n    env->irq_inputs = (void **)qemu_allocate_irqs(&ppc970_set_irq, env, 7);\n\n}\n", "idx": 26935}, {"project": "test", "commit_id": "test", "target": 1, "func": "void stq_tce(VIOsPAPRDevice *dev, uint64_t taddr, uint64_t val)\n\n{\n\n    val = tswap64(val);\n\n    spapr_tce_dma_write(dev, taddr, &val, sizeof(val));\n\n}\n", "idx": 26987}, {"project": "test", "commit_id": "test", "target": 1, "func": "void FUNCC(ff_h264_idct_add)(uint8_t *_dst, DCTELEM *_block, int stride)\n\n{\n\n    int i;\n\n    INIT_CLIP\n\n    pixel *dst = (pixel*)_dst;\n\n    dctcoef *block = (dctcoef*)_block;\n\n    stride /= sizeof(pixel);\n\n\n\n    block[0] += 1 << 5;\n\n\n\n    for(i=0; i<4; i++){\n\n        const int z0=  block[i + 4*0]     +  block[i + 4*2];\n\n        const int z1=  block[i + 4*0]     -  block[i + 4*2];\n\n        const int z2= (block[i + 4*1]>>1) -  block[i + 4*3];\n\n        const int z3=  block[i + 4*1]     + (block[i + 4*3]>>1);\n\n\n\n        block[i + 4*0]= z0 + z3;\n\n        block[i + 4*1]= z1 + z2;\n\n        block[i + 4*2]= z1 - z2;\n\n        block[i + 4*3]= z0 - z3;\n\n    }\n\n\n\n    for(i=0; i<4; i++){\n\n        const int z0=  block[0 + 4*i]     +  block[2 + 4*i];\n\n        const int z1=  block[0 + 4*i]     -  block[2 + 4*i];\n\n        const int z2= (block[1 + 4*i]>>1) -  block[3 + 4*i];\n\n        const int z3=  block[1 + 4*i]     + (block[3 + 4*i]>>1);\n\n\n\n        dst[i + 0*stride]= CLIP(dst[i + 0*stride] + ((z0 + z3) >> 6));\n\n        dst[i + 1*stride]= CLIP(dst[i + 1*stride] + ((z1 + z2) >> 6));\n\n        dst[i + 2*stride]= CLIP(dst[i + 2*stride] + ((z1 - z2) >> 6));\n\n        dst[i + 3*stride]= CLIP(dst[i + 3*stride] + ((z0 - z3) >> 6));\n\n    }\n\n}\n", "idx": 27081}, {"project": "test", "commit_id": "test", "target": 1, "func": "static int qmp_tmp105_get_temperature(const char *id)\n\n{\n\n    QDict *response;\n\n    int ret;\n\n\n\n    response = qmp(\"{ 'execute': 'qom-get', 'arguments': { 'path': '%s', \"\n\n                   \"'property': 'temperature' } }\", id);\n\n    g_assert(qdict_haskey(response, \"return\"));\n\n    ret = qdict_get_int(response, \"return\");\n\n    QDECREF(response);\n\n    return ret;\n\n}\n", "idx": 27107}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void pci_hotplug(void)\n\n{\n\n    QVirtioPCIDevice *dev;\n\n    QOSState *qs;\n\n    const char *arch = qtest_get_arch();\n\n\n\n    qs = pci_test_start();\n\n\n\n    /* plug secondary disk */\n\n    qpci_plug_device_test(\"virtio-blk-pci\", \"drv1\", PCI_SLOT_HP,\n\n                          \"'drive': 'drive1'\");\n\n\n\n    dev = virtio_blk_pci_init(qs->pcibus, PCI_SLOT_HP);\n\n    g_assert(dev);\n\n    qvirtio_pci_device_disable(dev);\n\n    g_free(dev);\n\n\n\n    /* unplug secondary disk */\n\n    if (strcmp(arch, \"i386\") == 0 || strcmp(arch, \"x86_64\") == 0) {\n\n        qpci_unplug_acpi_device_test(\"drv1\", PCI_SLOT_HP);\n\n    }\n\n    qtest_shutdown(qs);\n\n}\n", "idx": 27148}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void test_ide_drive_cd_0(void)\n\n{\n\n    char *argv[256];\n\n    int argc, ide_idx;\n\n    Backend i;\n\n\n\n    argc = setup_common(argv, ARRAY_SIZE(argv));\n\n    for (i = 0; i <= backend_empty; i++) {\n\n        ide_idx = backend_empty - i;\n\n        cur_ide[ide_idx] = &hd_chst[i][mbr_blank];\n\n        argc = setup_ide(argc, argv, ARRAY_SIZE(argv),\n\n                         ide_idx, NULL, i, mbr_blank, \"\");\n\n    }\n\n    qtest_start(g_strjoinv(\" \", argv));\n\n    test_cmos();\n\n    qtest_end();\n\n}\n", "idx": 27171}, {"project": "test", "commit_id": "test", "target": 1, "func": "static void filter(MpegAudioContext *s, int ch, short *samples, int incr)\n\n{\n\n    short *p, *q;\n\n    int sum, offset, i, j, norm, n;\n\n    short tmp[64];\n\n    int tmp1[32];\n\n    int *out;\n\n\n\n    //    print_pow1(samples, 1152);\n\n\n\n    offset = s->samples_offset[ch];\n\n    out = &s->sb_samples[ch][0][0][0];\n\n    for(j=0;j<36;j++) {\n\n        /* 32 samples at once */\n\n        for(i=0;i<32;i++) {\n\n            s->samples_buf[ch][offset + (31 - i)] = samples[0];\n\n            samples += incr;\n\n        }\n\n\n\n        /* filter */\n\n        p = s->samples_buf[ch] + offset;\n\n        q = filter_bank;\n\n        /* maxsum = 23169 */\n\n        for(i=0;i<64;i++) {\n\n            sum = p[0*64] * q[0*64];\n\n            sum += p[1*64] * q[1*64];\n\n            sum += p[2*64] * q[2*64];\n\n            sum += p[3*64] * q[3*64];\n\n            sum += p[4*64] * q[4*64];\n\n            sum += p[5*64] * q[5*64];\n\n            sum += p[6*64] * q[6*64];\n\n            sum += p[7*64] * q[7*64];\n\n            tmp[i] = sum >> 14;\n\n            p++;\n\n            q++;\n\n        }\n\n        tmp1[0] = tmp[16];\n\n        for( i=1; i<=16; i++ ) tmp1[i] = tmp[i+16]+tmp[16-i];\n\n        for( i=17; i<=31; i++ ) tmp1[i] = tmp[i+16]-tmp[80-i];\n\n\n\n        /* integer IDCT 32 with normalization. XXX: There may be some\n\n           overflow left */\n\n        norm = 0;\n\n        for(i=0;i<32;i++) {\n\n            norm |= abs(tmp1[i]);\n\n        }\n\n        n = av_log2(norm) - 12;\n\n        if (n > 0) {\n\n            for(i=0;i<32;i++) \n\n                tmp1[i] >>= n;\n\n        } else {\n\n            n = 0;\n\n        }\n\n\n\n        idct32(out, tmp1, s->sblimit, n);\n\n\n\n        /* advance of 32 samples */\n\n        offset -= 32;\n\n        out += 32;\n\n        /* handle the wrap around */\n\n        if (offset < 0) {\n\n            memmove(s->samples_buf[ch] + SAMPLES_BUF_SIZE - (512 - 32), \n\n                    s->samples_buf[ch], (512 - 32) * 2);\n\n            offset = SAMPLES_BUF_SIZE - 512;\n\n        }\n\n    }\n\n    s->samples_offset[ch] = offset;\n\n\n\n    //    print_pow(s->sb_samples, 1152);\n\n}\n", "idx": 27237}]